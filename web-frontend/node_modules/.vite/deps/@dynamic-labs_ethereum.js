"use client";
import {
  Field as Field2,
  FpInvertBatch,
  FpLegendre,
  FpPow,
  _normFnElement,
  bitGet,
  bitLen,
  bitMask,
  bytesToNumberBE,
  createCurve as createCurve2,
  createHash,
  createHasher as createHasher2,
  ensureBytes,
  equalBytes,
  getMinHashLength,
  inRange,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU as mapToCurveSimpleSWU2,
  memoized,
  mod,
  normalizeZ,
  notImplemented,
  numberToBytesBE,
  p256,
  pow2,
  secp256r1,
  weierstrassPoints
} from "./chunk-347VRUTM.js";
import {
  base,
  baseGoerli,
  baseSepolia,
  chains_exports,
  optimism,
  optimismGoerli,
  optimismSepolia
} from "./chunk-CA5PPJIG.js";
import {
  A,
  AccountNotFoundError,
  C,
  E,
  IEvents,
  InvalidAddressError as InvalidAddressError2,
  InvalidInputError,
  Po,
  Qe,
  Qo,
  bases,
  bytesRegex,
  clear,
  createClient,
  createNonceManager,
  createPublicClient,
  createStore,
  createWalletClient,
  custom,
  defineChain,
  del,
  destr,
  detect,
  encode,
  encodePacked,
  esm_exports,
  estimateFeesPerGas,
  f,
  f2,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  formatLog,
  formatTransactionReceipt,
  from,
  get,
  getAction,
  getBigIntRpcId,
  getChainId,
  getCode,
  getContract,
  hashAuthorization,
  hashMessage,
  hashTypedData,
  http,
  i,
  import_pino,
  integerRegex,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  k,
  keccak256 as keccak2562,
  keys,
  namehash,
  o,
  observe,
  parseEther,
  parseSignature,
  parseTransaction,
  parseUnits,
  payloadId,
  poll,
  prepareAuthorization,
  r,
  readContract,
  require_cjs,
  require_cjs2,
  require_cjs3,
  require_events,
  ripemd160,
  ripemd1602,
  safeJsonParse,
  safeJsonStringify,
  serializeErc6492Signature,
  serializeTransaction,
  serializeTypedData,
  set,
  sha256 as sha2562,
  sn,
  toHex as toHex2,
  validate,
  waitForCallsStatus,
  y
} from "./chunk-WH7V7QM4.js";
import "./chunk-XWZ3RPJ2.js";
import {
  stringToBase64urlString
} from "./chunk-TJGQWPPV.js";
import {
  BaseError,
  BaseError2,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  InvalidAddressError,
  TransactionExecutionError,
  UserRejectedRequestError as UserRejectedRequestError2,
  concat,
  concat2,
  decodeAbiParameters,
  decodeErrorResult,
  decodeFunctionData,
  encodeAbiParameters,
  encodeFunctionData,
  erc20Abi,
  formatEther,
  formatGwei,
  formatUnits,
  fromNumber,
  fromString,
  fromString2,
  getAddress,
  hexToBigInt,
  hexToBytes,
  hexToNumber,
  hexToString,
  isAddress,
  isAddressEqual,
  isHex,
  keccak256,
  numberToHex,
  pad,
  padLeft,
  parseAbi,
  parseAccount,
  prettyPrint,
  serializeStateOverride,
  size,
  size3 as size2,
  slice,
  slice3 as slice2,
  stringToBytes,
  stringToHex,
  stringify,
  stringify2,
  toBytes,
  toHex,
  trim
} from "./chunk-2W7IVRND.js";
import "./chunk-H3KY72G7.js";
import {
  BaseError as BaseError3,
  LruMap,
  checksumAddress,
  concat as concat3,
  defineFormatter,
  from as from2,
  fromBoolean,
  fromBytes,
  fromNumber as fromNumber2,
  fromString as fromString3,
  fromString2 as fromString4,
  hexToBigInt as hexToBigInt2,
  hexToNumber as hexToNumber2,
  isHex as isHex2,
  keccak256 as keccak2563,
  numberToHex as numberToHex2,
  padLeft as padLeft2,
  padRight,
  size as size3,
  size2 as size4,
  toHex as toHex3
} from "./chunk-3HK5BZ4Y.js";
import {
  keccak_256
} from "./chunk-6ILRZUVA.js";
import {
  ens_normalize,
  require_browser_ponyfill
} from "./chunk-OSUS26K4.js";
import {
  Field,
  createCurve,
  createHasher,
  mapToCurveSimpleSWU
} from "./chunk-GRJMIR36.js";
import "./chunk-KASMAJTU.js";
import {
  SHA256_IV,
  hmac,
  sha256,
  sha384,
  sha512
} from "./chunk-XK3CLVBG.js";
import {
  Hash,
  abytes,
  add,
  add3H,
  add3L,
  aexists,
  ahash,
  anumber,
  aoutput,
  bytesToHex,
  checkOpts,
  clean,
  concatBytes,
  createOptHasher,
  createView,
  createXOFer,
  fromBig,
  hexToBytes as hexToBytes2,
  kdfInputToBytes,
  randomBytes,
  rotr,
  rotr32H,
  rotr32L,
  rotrBH,
  rotrBL,
  rotrSH,
  rotrSL,
  swap32IfBE,
  swap8IfBE,
  toBytes as toBytes2,
  u32,
  u8,
  utf8ToBytes
} from "./chunk-VS2X32LD.js";
import {
  AuthenticatorTransportProtocol,
  ChainRpcProviders,
  DeferredPromise,
  DynamicError,
  Eip6963ProviderSingleton,
  ErrorCode,
  FALLBACK_UNDEFINED,
  GetAddressCancelledError,
  LogLevel,
  Logger,
  MFAAction,
  MetaMaskError,
  PlatformEventsService,
  PlatformService,
  ProviderChain,
  ProviderLookup,
  RequestChannelNotHandledError,
  StorageService,
  UserRejectedRequestError,
  UserRejectedTransactionError,
  Wallet,
  WalletConnectorBase,
  assertPackageVersion,
  browserSupportsWebAuthn,
  bufferToBase64URLString,
  createEventTimeline,
  eventListenerHandlers,
  findWalletBookWallet,
  formatNumberText,
  getDeepLink,
  getProvidersFromWindow,
  getRpcUrlForChain,
  getTLD,
  handleMobileWalletRedirect,
  isMobile,
  isSameAddress,
  listenToEip6963Events,
  logger,
  parseEvmNetworks,
  parseIntSafe,
  performPlatformSpecificConnectionMethod,
  require_buffer,
  retryableFn,
  sanitizeName,
  startRegistration,
  template,
  walletConnectorEvents
} from "./chunk-QVA33I52.js";
import {
  import_index
} from "./chunk-2UFRZFM3.js";
import "./chunk-I6OM4FBL.js";
import {
  __commonJS,
  __export,
  __glob,
  __publicField,
  __require,
  __toESM
} from "./chunk-CVK6YDBK.js";

// node_modules/blakejs/util.js
var require_util = __commonJS({
  "node_modules/blakejs/util.js"(exports, module) {
    var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
    function normalizeInput(input) {
      let ret;
      if (input instanceof Uint8Array) {
        ret = input;
      } else if (typeof input === "string") {
        const encoder5 = new TextEncoder();
        ret = encoder5.encode(input);
      } else {
        throw new Error(ERROR_MSG_INPUT);
      }
      return ret;
    }
    function toHex14(bytes2) {
      return Array.prototype.map.call(bytes2, function(n5) {
        return (n5 < 16 ? "0" : "") + n5.toString(16);
      }).join("");
    }
    function uint32ToHex(val) {
      return (4294967296 + val).toString(16).substring(1);
    }
    function debugPrint(label, arr, size11) {
      let msg = "\n" + label + " = ";
      for (let i9 = 0; i9 < arr.length; i9 += 2) {
        if (size11 === 32) {
          msg += uint32ToHex(arr[i9]).toUpperCase();
          msg += " ";
          msg += uint32ToHex(arr[i9 + 1]).toUpperCase();
        } else if (size11 === 64) {
          msg += uint32ToHex(arr[i9 + 1]).toUpperCase();
          msg += uint32ToHex(arr[i9]).toUpperCase();
        } else throw new Error("Invalid size " + size11);
        if (i9 % 6 === 4) {
          msg += "\n" + new Array(label.length + 4).join(" ");
        } else if (i9 < arr.length - 2) {
          msg += " ";
        }
      }
      console.log(msg);
    }
    function testSpeed(hashFn, N9, M8) {
      let startMs = (/* @__PURE__ */ new Date()).getTime();
      const input = new Uint8Array(N9);
      for (let i9 = 0; i9 < N9; i9++) {
        input[i9] = i9 % 256;
      }
      const genMs = (/* @__PURE__ */ new Date()).getTime();
      console.log("Generated random input in " + (genMs - startMs) + "ms");
      startMs = genMs;
      for (let i9 = 0; i9 < M8; i9++) {
        const hashHex = hashFn(input);
        const hashMs = (/* @__PURE__ */ new Date()).getTime();
        const ms3 = hashMs - startMs;
        startMs = hashMs;
        console.log("Hashed in " + ms3 + "ms: " + hashHex.substring(0, 20) + "...");
        console.log(
          Math.round(N9 / (1 << 20) / (ms3 / 1e3) * 100) / 100 + " MB PER SECOND"
        );
      }
    }
    module.exports = {
      normalizeInput,
      toHex: toHex14,
      debugPrint,
      testSpeed
    };
  }
});

// node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS({
  "node_modules/blakejs/blake2b.js"(exports, module) {
    var util = require_util();
    function ADD64AA(v10, a6, b6) {
      const o0 = v10[a6] + v10[b6];
      let o1 = v10[a6 + 1] + v10[b6 + 1];
      if (o0 >= 4294967296) {
        o1++;
      }
      v10[a6] = o0;
      v10[a6 + 1] = o1;
    }
    function ADD64AC(v10, a6, b0, b1) {
      let o0 = v10[a6] + b0;
      if (b0 < 0) {
        o0 += 4294967296;
      }
      let o1 = v10[a6 + 1] + b1;
      if (o0 >= 4294967296) {
        o1++;
      }
      v10[a6] = o0;
      v10[a6 + 1] = o1;
    }
    function B2B_GET32(arr, i9) {
      return arr[i9] ^ arr[i9 + 1] << 8 ^ arr[i9 + 2] << 16 ^ arr[i9 + 3] << 24;
    }
    function B2B_G(a6, b6, c9, d7, ix, iy) {
      const x0 = m6[ix];
      const x1 = m6[ix + 1];
      const y0 = m6[iy];
      const y1 = m6[iy + 1];
      ADD64AA(v9, a6, b6);
      ADD64AC(v9, a6, x0, x1);
      let xor0 = v9[d7] ^ v9[a6];
      let xor1 = v9[d7 + 1] ^ v9[a6 + 1];
      v9[d7] = xor1;
      v9[d7 + 1] = xor0;
      ADD64AA(v9, c9, d7);
      xor0 = v9[b6] ^ v9[c9];
      xor1 = v9[b6 + 1] ^ v9[c9 + 1];
      v9[b6] = xor0 >>> 24 ^ xor1 << 8;
      v9[b6 + 1] = xor1 >>> 24 ^ xor0 << 8;
      ADD64AA(v9, a6, b6);
      ADD64AC(v9, a6, y0, y1);
      xor0 = v9[d7] ^ v9[a6];
      xor1 = v9[d7 + 1] ^ v9[a6 + 1];
      v9[d7] = xor0 >>> 16 ^ xor1 << 16;
      v9[d7 + 1] = xor1 >>> 16 ^ xor0 << 16;
      ADD64AA(v9, c9, d7);
      xor0 = v9[b6] ^ v9[c9];
      xor1 = v9[b6 + 1] ^ v9[c9 + 1];
      v9[b6] = xor1 >>> 31 ^ xor0 << 1;
      v9[b6 + 1] = xor0 >>> 31 ^ xor1 << 1;
    }
    var BLAKE2B_IV32 = new Uint32Array([
      4089235720,
      1779033703,
      2227873595,
      3144134277,
      4271175723,
      1013904242,
      1595750129,
      2773480762,
      2917565137,
      1359893119,
      725511199,
      2600822924,
      4215389547,
      528734635,
      327033209,
      1541459225
    ]);
    var SIGMA8 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3
    ];
    var SIGMA82 = new Uint8Array(
      SIGMA8.map(function(x7) {
        return x7 * 2;
      })
    );
    var v9 = new Uint32Array(32);
    var m6 = new Uint32Array(32);
    function blake2bCompress(ctx, last5) {
      let i9 = 0;
      for (i9 = 0; i9 < 16; i9++) {
        v9[i9] = ctx.h[i9];
        v9[i9 + 16] = BLAKE2B_IV32[i9];
      }
      v9[24] = v9[24] ^ ctx.t;
      v9[25] = v9[25] ^ ctx.t / 4294967296;
      if (last5) {
        v9[28] = ~v9[28];
        v9[29] = ~v9[29];
      }
      for (i9 = 0; i9 < 32; i9++) {
        m6[i9] = B2B_GET32(ctx.b, 4 * i9);
      }
      for (i9 = 0; i9 < 12; i9++) {
        B2B_G(0, 8, 16, 24, SIGMA82[i9 * 16 + 0], SIGMA82[i9 * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i9 * 16 + 2], SIGMA82[i9 * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i9 * 16 + 4], SIGMA82[i9 * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i9 * 16 + 6], SIGMA82[i9 * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i9 * 16 + 8], SIGMA82[i9 * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i9 * 16 + 10], SIGMA82[i9 * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i9 * 16 + 12], SIGMA82[i9 * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i9 * 16 + 14], SIGMA82[i9 * 16 + 15]);
      }
      for (i9 = 0; i9 < 16; i9++) {
        ctx.h[i9] = ctx.h[i9] ^ v9[i9] ^ v9[i9 + 16];
      }
    }
    var parameterBlock = new Uint8Array([
      0,
      0,
      0,
      0,
      //  0: outlen, keylen, fanout, depth
      0,
      0,
      0,
      0,
      //  4: leaf length, sequential mode
      0,
      0,
      0,
      0,
      //  8: node offset
      0,
      0,
      0,
      0,
      // 12: node offset
      0,
      0,
      0,
      0,
      // 16: node depth, inner length, rfu
      0,
      0,
      0,
      0,
      // 20: rfu
      0,
      0,
      0,
      0,
      // 24: rfu
      0,
      0,
      0,
      0,
      // 28: rfu
      0,
      0,
      0,
      0,
      // 32: salt
      0,
      0,
      0,
      0,
      // 36: salt
      0,
      0,
      0,
      0,
      // 40: salt
      0,
      0,
      0,
      0,
      // 44: salt
      0,
      0,
      0,
      0,
      // 48: personal
      0,
      0,
      0,
      0,
      // 52: personal
      0,
      0,
      0,
      0,
      // 56: personal
      0,
      0,
      0,
      0
      // 60: personal
    ]);
    function blake2bInit(outlen, key, salt, personal) {
      if (outlen === 0 || outlen > 64) {
        throw new Error("Illegal output length, expected 0 < length <= 64");
      }
      if (key && key.length > 64) {
        throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
      }
      if (salt && salt.length !== 16) {
        throw new Error("Illegal salt, expected Uint8Array with length is 16");
      }
      if (personal && personal.length !== 16) {
        throw new Error("Illegal personal, expected Uint8Array with length is 16");
      }
      const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        // input count
        c: 0,
        // pointer within buffer
        outlen
        // output length in bytes
      };
      parameterBlock.fill(0);
      parameterBlock[0] = outlen;
      if (key) parameterBlock[1] = key.length;
      parameterBlock[2] = 1;
      parameterBlock[3] = 1;
      if (salt) parameterBlock.set(salt, 32);
      if (personal) parameterBlock.set(personal, 48);
      for (let i9 = 0; i9 < 16; i9++) {
        ctx.h[i9] = BLAKE2B_IV32[i9] ^ B2B_GET32(parameterBlock, i9 * 4);
      }
      if (key) {
        blake2bUpdate(ctx, key);
        ctx.c = 128;
      }
      return ctx;
    }
    function blake2bUpdate(ctx, input) {
      for (let i9 = 0; i9 < input.length; i9++) {
        if (ctx.c === 128) {
          ctx.t += ctx.c;
          blake2bCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i9];
      }
    }
    function blake2bFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 128) {
        ctx.b[ctx.c++] = 0;
      }
      blake2bCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i9 = 0; i9 < ctx.outlen; i9++) {
        out[i9] = ctx.h[i9 >> 2] >> 8 * (i9 & 3);
      }
      return out;
    }
    function blake2b2(input, key, outlen, salt, personal) {
      outlen = outlen || 64;
      input = util.normalizeInput(input);
      if (salt) {
        salt = util.normalizeInput(salt);
      }
      if (personal) {
        personal = util.normalizeInput(personal);
      }
      const ctx = blake2bInit(outlen, key, salt, personal);
      blake2bUpdate(ctx, input);
      return blake2bFinal(ctx);
    }
    function blake2bHex(input, key, outlen, salt, personal) {
      const output2 = blake2b2(input, key, outlen, salt, personal);
      return util.toHex(output2);
    }
    module.exports = {
      blake2b: blake2b2,
      blake2bHex,
      blake2bInit,
      blake2bUpdate,
      blake2bFinal
    };
  }
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS({
  "node_modules/blakejs/blake2s.js"(exports, module) {
    var util = require_util();
    function B2S_GET32(v10, i9) {
      return v10[i9] ^ v10[i9 + 1] << 8 ^ v10[i9 + 2] << 16 ^ v10[i9 + 3] << 24;
    }
    function B2S_G(a6, b6, c9, d7, x7, y11) {
      v9[a6] = v9[a6] + v9[b6] + x7;
      v9[d7] = ROTR32(v9[d7] ^ v9[a6], 16);
      v9[c9] = v9[c9] + v9[d7];
      v9[b6] = ROTR32(v9[b6] ^ v9[c9], 12);
      v9[a6] = v9[a6] + v9[b6] + y11;
      v9[d7] = ROTR32(v9[d7] ^ v9[a6], 8);
      v9[c9] = v9[c9] + v9[d7];
      v9[b6] = ROTR32(v9[b6] ^ v9[c9], 7);
    }
    function ROTR32(x7, y11) {
      return x7 >>> y11 ^ x7 << 32 - y11;
    }
    var BLAKE2S_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SIGMA = new Uint8Array([
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      14,
      10,
      4,
      8,
      9,
      15,
      13,
      6,
      1,
      12,
      0,
      2,
      11,
      7,
      5,
      3,
      11,
      8,
      12,
      0,
      5,
      2,
      15,
      13,
      10,
      14,
      3,
      6,
      7,
      1,
      9,
      4,
      7,
      9,
      3,
      1,
      13,
      12,
      11,
      14,
      2,
      6,
      5,
      10,
      4,
      0,
      15,
      8,
      9,
      0,
      5,
      7,
      2,
      4,
      10,
      15,
      14,
      1,
      11,
      12,
      6,
      8,
      3,
      13,
      2,
      12,
      6,
      10,
      0,
      11,
      8,
      3,
      4,
      13,
      7,
      5,
      15,
      14,
      1,
      9,
      12,
      5,
      1,
      15,
      14,
      13,
      4,
      10,
      0,
      7,
      6,
      3,
      9,
      2,
      8,
      11,
      13,
      11,
      7,
      14,
      12,
      1,
      3,
      9,
      5,
      0,
      15,
      4,
      8,
      6,
      2,
      10,
      6,
      15,
      14,
      9,
      11,
      3,
      0,
      8,
      12,
      2,
      13,
      7,
      1,
      4,
      10,
      5,
      10,
      2,
      8,
      4,
      7,
      6,
      1,
      5,
      15,
      11,
      9,
      14,
      3,
      12,
      13,
      0
    ]);
    var v9 = new Uint32Array(16);
    var m6 = new Uint32Array(16);
    function blake2sCompress(ctx, last5) {
      let i9 = 0;
      for (i9 = 0; i9 < 8; i9++) {
        v9[i9] = ctx.h[i9];
        v9[i9 + 8] = BLAKE2S_IV[i9];
      }
      v9[12] ^= ctx.t;
      v9[13] ^= ctx.t / 4294967296;
      if (last5) {
        v9[14] = ~v9[14];
      }
      for (i9 = 0; i9 < 16; i9++) {
        m6[i9] = B2S_GET32(ctx.b, 4 * i9);
      }
      for (i9 = 0; i9 < 10; i9++) {
        B2S_G(0, 4, 8, 12, m6[SIGMA[i9 * 16 + 0]], m6[SIGMA[i9 * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m6[SIGMA[i9 * 16 + 2]], m6[SIGMA[i9 * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m6[SIGMA[i9 * 16 + 4]], m6[SIGMA[i9 * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m6[SIGMA[i9 * 16 + 6]], m6[SIGMA[i9 * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m6[SIGMA[i9 * 16 + 8]], m6[SIGMA[i9 * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m6[SIGMA[i9 * 16 + 10]], m6[SIGMA[i9 * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m6[SIGMA[i9 * 16 + 12]], m6[SIGMA[i9 * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m6[SIGMA[i9 * 16 + 14]], m6[SIGMA[i9 * 16 + 15]]);
      }
      for (i9 = 0; i9 < 8; i9++) {
        ctx.h[i9] ^= v9[i9] ^ v9[i9 + 8];
      }
    }
    function blake2sInit(outlen, key) {
      if (!(outlen > 0 && outlen <= 32)) {
        throw new Error("Incorrect output length, should be in [1, 32]");
      }
      const keylen = key ? key.length : 0;
      if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error("Incorrect key length, should be in [1, 32]");
      }
      const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        // hash state
        b: new Uint8Array(64),
        // input block
        c: 0,
        // pointer within block
        t: 0,
        // input count
        outlen
        // output length in bytes
      };
      ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
      if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64;
      }
      return ctx;
    }
    function blake2sUpdate(ctx, input) {
      for (let i9 = 0; i9 < input.length; i9++) {
        if (ctx.c === 64) {
          ctx.t += ctx.c;
          blake2sCompress(ctx, false);
          ctx.c = 0;
        }
        ctx.b[ctx.c++] = input[i9];
      }
    }
    function blake2sFinal(ctx) {
      ctx.t += ctx.c;
      while (ctx.c < 64) {
        ctx.b[ctx.c++] = 0;
      }
      blake2sCompress(ctx, true);
      const out = new Uint8Array(ctx.outlen);
      for (let i9 = 0; i9 < ctx.outlen; i9++) {
        out[i9] = ctx.h[i9 >> 2] >> 8 * (i9 & 3) & 255;
      }
      return out;
    }
    function blake2s2(input, key, outlen) {
      outlen = outlen || 32;
      input = util.normalizeInput(input);
      const ctx = blake2sInit(outlen, key);
      blake2sUpdate(ctx, input);
      return blake2sFinal(ctx);
    }
    function blake2sHex(input, key, outlen) {
      const output2 = blake2s2(input, key, outlen);
      return util.toHex(output2);
    }
    module.exports = {
      blake2s: blake2s2,
      blake2sHex,
      blake2sInit,
      blake2sUpdate,
      blake2sFinal
    };
  }
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS({
  "node_modules/blakejs/index.js"(exports, module) {
    var b2b = require_blake2b();
    var b2s = require_blake2s();
    module.exports = {
      blake2b: b2b.blake2b,
      blake2bHex: b2b.blake2bHex,
      blake2bInit: b2b.blake2bInit,
      blake2bUpdate: b2b.blake2bUpdate,
      blake2bFinal: b2b.blake2bFinal,
      blake2s: b2s.blake2s,
      blake2sHex: b2s.blake2sHex,
      blake2sInit: b2s.blake2sInit,
      blake2sUpdate: b2s.blake2sUpdate,
      blake2sFinal: b2s.blake2sFinal
    };
  }
});

// node_modules/@turnkey/http/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill2 = __commonJS({
  "node_modules/@turnkey/http/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F8() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F8.prototype = __global__;
      return new F8();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g4 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g4,
          iterable: "Symbol" in g4 && "iterator" in Symbol,
          blob: "FileReader" in g4 && "Blob" in g4 && function() {
            try {
              new Blob();
              return true;
            } catch (e11) {
              return false;
            }
          }(),
          formData: "FormData" in g4,
          arrayBuffer: "ArrayBuffer" in g4
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView3 = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue3(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator4 = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator4[Symbol.iterator] = function() {
              return iterator4;
            };
          }
          return iterator4;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value2, name) {
              this.append(name, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value2) {
          name = normalizeName(name);
          value2 = normalizeValue3(value2);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value2) {
          this.map[normalizeName(name)] = normalizeValue3(value2);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push([name, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match14 = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match14 ? match14[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars2 = new Array(view.length);
          for (var i9 = 0; i9 < view.length; i9++) {
            chars2[i9] = String.fromCharCode(view[i9]);
          }
          return chars2.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView3(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode10);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request3(input, options) {
          if (!(this instanceof Request3)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request3) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g4) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request3.prototype.clone = function() {
          return new Request3(this, { body: this._bodyInit });
        };
        function decode10(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes2) {
            if (bytes2) {
              var split3 = bytes2.split("=");
              var name = split3.shift().replace(/\+/g, " ");
              var value2 = split3.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts2 = line.split(":");
            var key = parts2.shift().trim();
            if (key) {
              var value2 = parts2.join(":").trim();
              try {
                headers.append(key, value2);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request3.prototype);
        function Response2(bodyInit, options) {
          if (!(this instanceof Response2)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response2.prototype);
        Response2.prototype.clone = function() {
          return new Response2(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response2.error = function() {
          var response = new Response2(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response2.redirect = function(url2, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response2(null, { status, headers: { location: url2 } });
        };
        exports2.DOMException = g4.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init4) {
          return new Promise(function(resolve, reject) {
            var request2 = new Request3(input, init4);
            if (request2.signal && request2.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response2(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url2) {
              try {
                return url2 === "" && g4.location.href ? g4.location.href : url2;
              } catch (e11) {
                return url2;
              }
            }
            xhr.open(request2.method, fixUrl(request2.url), true);
            if (request2.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request2.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init4 && typeof init4.headers === "object" && !(init4.headers instanceof Headers2 || g4.Headers && init4.headers instanceof g4.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init4.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue3(init4.headers[name]));
              });
              request2.headers.forEach(function(value2, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value2);
                }
              });
            } else {
              request2.headers.forEach(function(value2, name) {
                xhr.setRequestHeader(name, value2);
              });
            }
            if (request2.signal) {
              request2.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request2.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!g4.fetch) {
          g4.fetch = fetch3;
          g4.Headers = Headers2;
          g4.Request = Request3;
          g4.Response = Response2;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request3;
        exports2.Response = Response2;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
    exports.add = add3;
    exports.fromBig = fromBig4;
    exports.split = split3;
    var U32_MASK643 = BigInt(2 ** 32 - 1);
    var _32n3 = BigInt(32);
    function fromBig4(n5, le5 = false) {
      if (le5)
        return { h: Number(n5 & U32_MASK643), l: Number(n5 >> _32n3 & U32_MASK643) };
      return { h: Number(n5 >> _32n3 & U32_MASK643) | 0, l: Number(n5 & U32_MASK643) | 0 };
    }
    function split3(lst, le5 = false) {
      const len = lst.length;
      let Ah2 = new Uint32Array(len);
      let Al2 = new Uint32Array(len);
      for (let i9 = 0; i9 < len; i9++) {
        const { h: h9, l: l9 } = fromBig4(lst[i9], le5);
        [Ah2[i9], Al2[i9]] = [h9, l9];
      }
      return [Ah2, Al2];
    }
    var toBig = (h9, l9) => BigInt(h9 >>> 0) << _32n3 | BigInt(l9 >>> 0);
    exports.toBig = toBig;
    var shrSH2 = (h9, _l2, s5) => h9 >>> s5;
    exports.shrSH = shrSH2;
    var shrSL2 = (h9, l9, s5) => h9 << 32 - s5 | l9 >>> s5;
    exports.shrSL = shrSL2;
    var rotrSH3 = (h9, l9, s5) => h9 >>> s5 | l9 << 32 - s5;
    exports.rotrSH = rotrSH3;
    var rotrSL3 = (h9, l9, s5) => h9 << 32 - s5 | l9 >>> s5;
    exports.rotrSL = rotrSL3;
    var rotrBH3 = (h9, l9, s5) => h9 << 64 - s5 | l9 >>> s5 - 32;
    exports.rotrBH = rotrBH3;
    var rotrBL3 = (h9, l9, s5) => h9 >>> s5 - 32 | l9 << 64 - s5;
    exports.rotrBL = rotrBL3;
    var rotr32H2 = (_h2, l9) => l9;
    exports.rotr32H = rotr32H2;
    var rotr32L2 = (h9, _l2) => h9;
    exports.rotr32L = rotr32L2;
    var rotlSH2 = (h9, l9, s5) => h9 << s5 | l9 >>> 32 - s5;
    exports.rotlSH = rotlSH2;
    var rotlSL2 = (h9, l9, s5) => l9 << s5 | h9 >>> 32 - s5;
    exports.rotlSL = rotlSL2;
    var rotlBH2 = (h9, l9, s5) => l9 << s5 - 32 | h9 >>> 64 - s5;
    exports.rotlBH = rotlBH2;
    var rotlBL2 = (h9, l9, s5) => h9 << s5 - 32 | l9 >>> 64 - s5;
    exports.rotlBL = rotlBL2;
    function add3(Ah2, Al2, Bh2, Bl2) {
      const l9 = (Al2 >>> 0) + (Bl2 >>> 0);
      return { h: Ah2 + Bh2 + (l9 / 2 ** 32 | 0) | 0, l: l9 | 0 };
    }
    var add3L3 = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
    exports.add3L = add3L3;
    var add3H3 = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H3;
    var add4L2 = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
    exports.add4L = add4L2;
    var add4H2 = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H2;
    var add5L2 = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
    exports.add5L = add5L2;
    var add5H2 = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H2;
    var u64 = {
      fromBig: fromBig4,
      split: split3,
      toBig,
      shrSH: shrSH2,
      shrSL: shrSL2,
      rotrSH: rotrSH3,
      rotrSL: rotrSL3,
      rotrBH: rotrBH3,
      rotrBL: rotrBL3,
      rotr32H: rotr32H2,
      rotr32L: rotr32L2,
      rotlSH: rotlSH2,
      rotlSL: rotlSL2,
      rotlBH: rotlBH2,
      rotlBL: rotlBL2,
      add: add3,
      add3L: add3L3,
      add3H: add3H3,
      add4L: add4L2,
      add4H: add4H2,
      add5H: add5H2,
      add5L: add5L2
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
    exports.isBytes = isBytes10;
    exports.anumber = anumber6;
    exports.abytes = abytes7;
    exports.ahash = ahash4;
    exports.aexists = aexists5;
    exports.aoutput = aoutput5;
    exports.u8 = u83;
    exports.u32 = u324;
    exports.clean = clean4;
    exports.createView = createView5;
    exports.rotr = rotr4;
    exports.rotl = rotl;
    exports.byteSwap = byteSwap2;
    exports.byteSwap32 = byteSwap322;
    exports.bytesToHex = bytesToHex6;
    exports.hexToBytes = hexToBytes6;
    exports.asyncLoop = asyncLoop2;
    exports.utf8ToBytes = utf8ToBytes5;
    exports.bytesToUtf8 = bytesToUtf82;
    exports.toBytes = toBytes15;
    exports.kdfInputToBytes = kdfInputToBytes2;
    exports.concatBytes = concatBytes6;
    exports.checkOpts = checkOpts2;
    exports.createHasher = createHasher6;
    exports.createOptHasher = createOptHasher2;
    exports.createXOFer = createXOFer2;
    exports.randomBytes = randomBytes6;
    var crypto_1 = require_crypto();
    function isBytes10(a6) {
      return a6 instanceof Uint8Array || ArrayBuffer.isView(a6) && a6.constructor.name === "Uint8Array";
    }
    function anumber6(n5) {
      if (!Number.isSafeInteger(n5) || n5 < 0)
        throw new Error("positive integer expected, got " + n5);
    }
    function abytes7(b6, ...lengths) {
      if (!isBytes10(b6))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b6.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b6.length);
    }
    function ahash4(h9) {
      if (typeof h9 !== "function" || typeof h9.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber6(h9.outputLen);
      anumber6(h9.blockLen);
    }
    function aexists5(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput5(out, instance) {
      abytes7(out);
      const min4 = instance.outputLen;
      if (out.length < min4) {
        throw new Error("digestInto() expects output buffer of length at least " + min4);
      }
    }
    function u83(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u324(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean4(...arrays) {
      for (let i9 = 0; i9 < arrays.length; i9++) {
        arrays[i9].fill(0);
      }
    }
    function createView5(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function rotr4(word, shift) {
      return word << 32 - shift | word >>> shift;
    }
    function rotl(word, shift) {
      return word << shift | word >>> 32 - shift >>> 0;
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    function byteSwap2(word) {
      return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    }
    exports.swap8IfBE = exports.isLE ? (n5) => n5 : (n5) => byteSwap2(n5);
    exports.byteSwapIfBE = exports.swap8IfBE;
    function byteSwap322(arr) {
      for (let i9 = 0; i9 < arr.length; i9++) {
        arr[i9] = byteSwap2(arr[i9]);
      }
      return arr;
    }
    exports.swap32IfBE = exports.isLE ? (u10) => u10 : byteSwap322;
    var hasHexBuiltin4 = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes7 = Array.from({ length: 256 }, (_6, i9) => i9.toString(16).padStart(2, "0"));
    function bytesToHex6(bytes2) {
      abytes7(bytes2);
      if (hasHexBuiltin4)
        return bytes2.toHex();
      let hex2 = "";
      for (let i9 = 0; i9 < bytes2.length; i9++) {
        hex2 += hexes7[bytes2[i9]];
      }
      return hex2;
    }
    var asciis3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase163(ch2) {
      if (ch2 >= asciis3._0 && ch2 <= asciis3._9)
        return ch2 - asciis3._0;
      if (ch2 >= asciis3.A && ch2 <= asciis3.F)
        return ch2 - (asciis3.A - 10);
      if (ch2 >= asciis3.a && ch2 <= asciis3.f)
        return ch2 - (asciis3.a - 10);
      return;
    }
    function hexToBytes6(hex2) {
      if (typeof hex2 !== "string")
        throw new Error("hex string expected, got " + typeof hex2);
      if (hasHexBuiltin4)
        return Uint8Array.fromHex(hex2);
      const hl2 = hex2.length;
      const al2 = hl2 / 2;
      if (hl2 % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl2);
      const array = new Uint8Array(al2);
      for (let ai5 = 0, hi5 = 0; ai5 < al2; ai5++, hi5 += 2) {
        const n1 = asciiToBase163(hex2.charCodeAt(hi5));
        const n22 = asciiToBase163(hex2.charCodeAt(hi5 + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex2[hi5] + hex2[hi5 + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi5);
        }
        array[ai5] = n1 * 16 + n22;
      }
      return array;
    }
    var nextTick2 = async () => {
    };
    exports.nextTick = nextTick2;
    async function asyncLoop2(iters, tick, cb) {
      let ts3 = Date.now();
      for (let i9 = 0; i9 < iters; i9++) {
        cb(i9);
        const diff = Date.now() - ts3;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts3 += diff;
      }
    }
    function utf8ToBytes5(str) {
      if (typeof str !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bytesToUtf82(bytes2) {
      return new TextDecoder().decode(bytes2);
    }
    function toBytes15(data) {
      if (typeof data === "string")
        data = utf8ToBytes5(data);
      abytes7(data);
      return data;
    }
    function kdfInputToBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes5(data);
      abytes7(data);
      return data;
    }
    function concatBytes6(...arrays) {
      let sum = 0;
      for (let i9 = 0; i9 < arrays.length; i9++) {
        const a6 = arrays[i9];
        abytes7(a6);
        sum += a6.length;
      }
      const res = new Uint8Array(sum);
      for (let i9 = 0, pad5 = 0; i9 < arrays.length; i9++) {
        const a6 = arrays[i9];
        res.set(a6, pad5);
        pad5 += a6.length;
      }
      return res;
    }
    function checkOpts2(defaults3, opts2) {
      if (opts2 !== void 0 && {}.toString.call(opts2) !== "[object Object]")
        throw new Error("options should be object or undefined");
      const merged = Object.assign(defaults3, opts2);
      return merged;
    }
    var Hash3 = class {
    };
    exports.Hash = Hash3;
    function createHasher6(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes15(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    function createOptHasher2(hashCons) {
      const hashC = (msg, opts2) => hashCons(opts2).update(toBytes15(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts2) => hashCons(opts2);
      return hashC;
    }
    function createXOFer2(hashCons) {
      const hashC = (msg, opts2) => hashCons(opts2).update(toBytes15(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts2) => hashCons(opts2);
      return hashC;
    }
    exports.wrapConstructor = createHasher6;
    exports.wrapConstructorWithOpts = createOptHasher2;
    exports.wrapXOFConstructorWithOpts = createXOFer2;
    function randomBytes6(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === "function") {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
    exports.keccakP = keccakP2;
    var _u64_ts_1 = require_u64();
    var utils_ts_1 = require_utils();
    var _0n11 = BigInt(0);
    var _1n12 = BigInt(1);
    var _2n10 = BigInt(2);
    var _7n2 = BigInt(7);
    var _256n2 = BigInt(256);
    var _0x71n2 = BigInt(113);
    var SHA3_PI2 = [];
    var SHA3_ROTL2 = [];
    var _SHA3_IOTA2 = [];
    for (let round = 0, R6 = _1n12, x7 = 1, y11 = 0; round < 24; round++) {
      [x7, y11] = [y11, (2 * x7 + 3 * y11) % 5];
      SHA3_PI2.push(2 * (5 * y11 + x7));
      SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
      let t6 = _0n11;
      for (let j9 = 0; j9 < 7; j9++) {
        R6 = (R6 << _1n12 ^ (R6 >> _7n2) * _0x71n2) % _256n2;
        if (R6 & _2n10)
          t6 ^= _1n12 << (_1n12 << BigInt(j9)) - _1n12;
      }
      _SHA3_IOTA2.push(t6);
    }
    var IOTAS2 = (0, _u64_ts_1.split)(_SHA3_IOTA2, true);
    var SHA3_IOTA_H2 = IOTAS2[0];
    var SHA3_IOTA_L2 = IOTAS2[1];
    var rotlH2 = (h9, l9, s5) => s5 > 32 ? (0, _u64_ts_1.rotlBH)(h9, l9, s5) : (0, _u64_ts_1.rotlSH)(h9, l9, s5);
    var rotlL2 = (h9, l9, s5) => s5 > 32 ? (0, _u64_ts_1.rotlBL)(h9, l9, s5) : (0, _u64_ts_1.rotlSL)(h9, l9, s5);
    function keccakP2(s5, rounds = 24) {
      const B9 = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x7 = 0; x7 < 10; x7++)
          B9[x7] = s5[x7] ^ s5[x7 + 10] ^ s5[x7 + 20] ^ s5[x7 + 30] ^ s5[x7 + 40];
        for (let x7 = 0; x7 < 10; x7 += 2) {
          const idx1 = (x7 + 8) % 10;
          const idx0 = (x7 + 2) % 10;
          const B0 = B9[idx0];
          const B1 = B9[idx0 + 1];
          const Th2 = rotlH2(B0, B1, 1) ^ B9[idx1];
          const Tl2 = rotlL2(B0, B1, 1) ^ B9[idx1 + 1];
          for (let y11 = 0; y11 < 50; y11 += 10) {
            s5[x7 + y11] ^= Th2;
            s5[x7 + y11 + 1] ^= Tl2;
          }
        }
        let curH = s5[2];
        let curL = s5[3];
        for (let t6 = 0; t6 < 24; t6++) {
          const shift = SHA3_ROTL2[t6];
          const Th2 = rotlH2(curH, curL, shift);
          const Tl2 = rotlL2(curH, curL, shift);
          const PI = SHA3_PI2[t6];
          curH = s5[PI];
          curL = s5[PI + 1];
          s5[PI] = Th2;
          s5[PI + 1] = Tl2;
        }
        for (let y11 = 0; y11 < 50; y11 += 10) {
          for (let x7 = 0; x7 < 10; x7++)
            B9[x7] = s5[y11 + x7];
          for (let x7 = 0; x7 < 10; x7++)
            s5[y11 + x7] ^= ~B9[(x7 + 2) % 10] & B9[(x7 + 4) % 10];
        }
        s5[0] ^= SHA3_IOTA_H2[round];
        s5[1] ^= SHA3_IOTA_L2[round];
      }
      (0, utils_ts_1.clean)(B9);
    }
    var Keccak2 = class _Keccak extends utils_ts_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        (0, utils_ts_1.anumber)(outputLen);
        if (!(0 < blockLen && blockLen < 200))
          throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
      }
      clone() {
        return this._cloneInto();
      }
      keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP2(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i9 = 0; i9 < take; i9++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes2) {
        (0, utils_ts_1.anumber)(bytes2);
        return this.xofInto(new Uint8Array(bytes2));
      }
      digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
      }
      _cloneInto(to6) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to6 || (to6 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to6.state32.set(this.state32);
        to6.pos = this.pos;
        to6.posOut = this.posOut;
        to6.finished = this.finished;
        to6.rounds = rounds;
        to6.suffix = suffix;
        to6.outputLen = outputLen;
        to6.enableXOF = enableXOF;
        to6.destroyed = this.destroyed;
        return to6;
      }
    };
    exports.Keccak = Keccak2;
    var gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak2(blockLen, suffix, outputLen));
    exports.sha3_224 = (() => gen(6, 144, 224 / 8))();
    exports.sha3_256 = (() => gen(6, 136, 256 / 8))();
    exports.sha3_384 = (() => gen(6, 104, 384 / 8))();
    exports.sha3_512 = (() => gen(6, 72, 512 / 8))();
    exports.keccak_224 = (() => gen(1, 144, 224 / 8))();
    exports.keccak_256 = (() => gen(1, 136, 256 / 8))();
    exports.keccak_384 = (() => gen(1, 104, 384 / 8))();
    exports.keccak_512 = (() => gen(1, 72, 512 / 8))();
    var genShake2 = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts2 = {}) => new Keccak2(blockLen, suffix, opts2.dkLen === void 0 ? outputLen : opts2.dkLen, true));
    exports.shake128 = (() => genShake2(31, 168, 128 / 8))();
    exports.shake256 = (() => genShake2(31, 136, 256 / 8))();
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs
var require_util2 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.cjs"(exports, module) {
    var { keccak_256: keccak_2563 } = require_sha3();
    function zeros(bytes2) {
      return Buffer.allocUnsafe(bytes2).fill(0);
    }
    function bitLengthFromBigInt(num3) {
      return num3.toString(2).length;
    }
    function bufferBEFromBigInt(num3, length) {
      let hex2 = num3.toString(16);
      if (hex2.length % 2 !== 0) hex2 = "0" + hex2;
      const byteArray = hex2.match(/.{1,2}/g).map((byte) => parseInt(byte, 16));
      while (byteArray.length < length) {
        byteArray.unshift(0);
      }
      return Buffer.from(byteArray);
    }
    function twosFromBigInt(value2, width) {
      const isNegative = value2 < 0n;
      let result;
      if (isNegative) {
        const mask = (1n << BigInt(width)) - 1n;
        result = (~value2 & mask) + 1n;
      } else {
        result = value2;
      }
      result &= (1n << BigInt(width)) - 1n;
      return result;
    }
    function setLength(msg, length, right13) {
      const buf = zeros(length);
      msg = toBuffer(msg);
      if (right13) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    }
    function setLengthRight(msg, length) {
      return setLength(msg, length, true);
    }
    function toBuffer(v9) {
      if (!Buffer.isBuffer(v9)) {
        if (Array.isArray(v9)) {
          v9 = Buffer.from(v9);
        } else if (typeof v9 === "string") {
          if (isHexString3(v9)) {
            v9 = Buffer.from(padToEven(stripHexPrefix(v9)), "hex");
          } else {
            v9 = Buffer.from(v9);
          }
        } else if (typeof v9 === "number") {
          v9 = intToBuffer(v9);
        } else if (v9 === null || v9 === void 0) {
          v9 = Buffer.allocUnsafe(0);
        } else if (typeof v9 === "bigint") {
          v9 = bufferBEFromBigInt(v9);
        } else if (v9.toArray) {
          v9 = Buffer.from(v9.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v9;
    }
    function bufferToHex(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a6, bits) {
      a6 = toBuffer(a6);
      if (!bits) bits = 256;
      if (bits !== 256) {
        throw new Error("unsupported");
      }
      return Buffer.from(keccak_2563(new Uint8Array(a6)));
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString3(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros,
      setLength,
      setLengthRight,
      isHexString: isHexString3,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak,
      bitLengthFromBigInt,
      bufferBEFromBigInt,
      twosFromBigInt
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.cjs"(exports, module) {
    var util = require_util2();
    function elementaryName(name) {
      if (name.startsWith("int[")) {
        return "int256" + name.slice(3);
      } else if (name === "int") {
        return "int256";
      } else if (name.startsWith("uint[")) {
        return "uint256" + name.slice(4);
      } else if (name === "uint") {
        return "uint256";
      } else if (name.startsWith("fixed[")) {
        return "fixed128x128" + name.slice(5);
      } else if (name === "fixed") {
        return "fixed128x128";
      } else if (name.startsWith("ufixed[")) {
        return "ufixed128x128" + name.slice(6);
      } else if (name === "ufixed") {
        return "ufixed128x128";
      }
      return name;
    }
    function parseTypeN(type7) {
      return Number.parseInt(/^\D+(\d+)$/.exec(type7)[1], 10);
    }
    function parseTypeNxM(type7) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type7);
      return [Number.parseInt(tmp[1], 10), Number.parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type7) {
      var tmp = type7.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : Number.parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type7 = typeof arg;
      if (type7 === "string" || type7 === "number") {
        return BigInt(arg);
      } else if (type7 === "bigint") {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type7, arg) {
      var size11, num3, ret, i9;
      if (type7 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type7 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type7 === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray4(type7)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size11 = parseTypeArray(type7);
        if (size11 !== "dynamic" && size11 !== 0 && arg.length > size11) {
          throw new Error("Elements exceed array size: " + size11);
        }
        ret = [];
        type7 = type7.slice(0, type7.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i9 in arg) {
          ret.push(encodeSingle(type7, arg[i9]));
        }
        if (size11 === "dynamic") {
          var length = encodeSingle("uint256", arg.length);
          ret.unshift(length);
        }
        return Buffer.concat(ret);
      } else if (type7 === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type7.startsWith("bytes")) {
        size11 = parseTypeN(type7);
        if (size11 < 1 || size11 > 32) {
          throw new Error("Invalid bytes<N> width: " + size11);
        }
        return util.setLengthRight(arg, 32);
      } else if (type7.startsWith("uint")) {
        size11 = parseTypeN(type7);
        if (size11 % 8 || size11 < 8 || size11 > 256) {
          throw new Error("Invalid uint<N> width: " + size11);
        }
        num3 = parseNumber(arg);
        const bitLength = util.bitLengthFromBigInt(num3);
        if (bitLength > size11) {
          throw new Error("Supplied uint exceeds width: " + size11 + " vs " + bitLength);
        }
        if (num3 < 0) {
          throw new Error("Supplied uint is negative");
        }
        return util.bufferBEFromBigInt(num3, 32);
      } else if (type7.startsWith("int")) {
        size11 = parseTypeN(type7);
        if (size11 % 8 || size11 < 8 || size11 > 256) {
          throw new Error("Invalid int<N> width: " + size11);
        }
        num3 = parseNumber(arg);
        const bitLength = util.bitLengthFromBigInt(num3);
        if (bitLength > size11) {
          throw new Error("Supplied int exceeds width: " + size11 + " vs " + bitLength);
        }
        const twos = util.twosFromBigInt(num3, 256);
        return util.bufferBEFromBigInt(twos, 32);
      } else if (type7.startsWith("ufixed")) {
        size11 = parseTypeNxM(type7);
        num3 = parseNumber(arg);
        if (num3 < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num3 * BigInt(2) ** BigInt(size11[1]));
      } else if (type7.startsWith("fixed")) {
        size11 = parseTypeNxM(type7);
        return encodeSingle("int256", parseNumber(arg) * BigInt(2) ** BigInt(size11[1]));
      }
      throw new Error("Unsupported or invalid type: " + type7);
    }
    function isDynamic(type7) {
      return type7 === "string" || type7 === "bytes" || parseTypeArray(type7) === "dynamic";
    }
    function isArray4(type7) {
      return type7.lastIndexOf("]") === type7.length - 1;
    }
    function rawEncode(types2, values) {
      var output2 = [];
      var data = [];
      var headLength = 32 * types2.length;
      for (var i9 in types2) {
        var type7 = elementaryName(types2[i9]);
        var value2 = values[i9];
        var cur = encodeSingle(type7, value2);
        if (isDynamic(type7)) {
          output2.push(encodeSingle("uint256", headLength));
          data.push(cur);
          headLength += cur.length;
        } else {
          output2.push(cur);
        }
      }
      return Buffer.concat(output2.concat(data));
    }
    function solidityPack(types2, values) {
      if (types2.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size11, num3;
      var ret = [];
      for (var i9 = 0; i9 < types2.length; i9++) {
        var type7 = elementaryName(types2[i9]);
        var value2 = values[i9];
        if (type7 === "bytes") {
          ret.push(value2);
        } else if (type7 === "string") {
          ret.push(new Buffer(value2, "utf8"));
        } else if (type7 === "bool") {
          ret.push(new Buffer(value2 ? "01" : "00", "hex"));
        } else if (type7 === "address") {
          ret.push(util.setLength(value2, 20));
        } else if (type7.startsWith("bytes")) {
          size11 = parseTypeN(type7);
          if (size11 < 1 || size11 > 32) {
            throw new Error("Invalid bytes<N> width: " + size11);
          }
          ret.push(util.setLengthRight(value2, size11));
        } else if (type7.startsWith("uint")) {
          size11 = parseTypeN(type7);
          if (size11 % 8 || size11 < 8 || size11 > 256) {
            throw new Error("Invalid uint<N> width: " + size11);
          }
          num3 = parseNumber(value2);
          const bitLength = util.bitLengthFromBigInt(num3);
          if (bitLength > size11) {
            throw new Error("Supplied uint exceeds width: " + size11 + " vs " + bitLength);
          }
          ret.push(util.bufferBEFromBigInt(num3, size11 / 8));
        } else if (type7.startsWith("int")) {
          size11 = parseTypeN(type7);
          if (size11 % 8 || size11 < 8 || size11 > 256) {
            throw new Error("Invalid int<N> width: " + size11);
          }
          num3 = parseNumber(value2);
          const bitLength = util.bitLengthFromBigInt(num3);
          if (bitLength > size11) {
            throw new Error("Supplied int exceeds width: " + size11 + " vs " + bitLength);
          }
          const twos = util.twosFromBigInt(num3, size11);
          ret.push(util.bufferBEFromBigInt(twos, size11 / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type7);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types2, values) {
      return util.keccak(solidityPack(types2, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.cjs"(exports, module) {
    var util = require_util2();
    var abi3 = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      /**
       * Encodes an object by encoding and concatenating each of its members
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of an object
       */
      encodeData(primaryType, data, types2, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types2)];
        if (useV4) {
          const encodeField3 = (name, type7, value2) => {
            if (types2[type7] !== void 0) {
              return ["bytes32", value2 == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type7, value2, types2, useV4))];
            }
            if (value2 === void 0)
              throw new Error(`missing value for field ${name} of type ${type7}`);
            if (type7 === "bytes") {
              return ["bytes32", util.keccak(value2)];
            }
            if (type7 === "string") {
              if (typeof value2 === "string") {
                value2 = Buffer.from(value2, "utf8");
              }
              return ["bytes32", util.keccak(value2)];
            }
            if (type7.lastIndexOf("]") === type7.length - 1) {
              const parsedType = type7.slice(0, type7.lastIndexOf("["));
              const typeValuePairs = value2.map((item) => encodeField3(name, parsedType, item));
              return ["bytes32", util.keccak(abi3.rawEncode(
                typeValuePairs.map(([type8]) => type8),
                typeValuePairs.map(([, value3]) => value3)
              ))];
            }
            return [type7, value2];
          };
          for (const field of types2[primaryType]) {
            const [type7, value2] = encodeField3(field.name, field.type, data[field.name]);
            encodedTypes.push(type7);
            encodedValues.push(value2);
          }
        } else {
          for (const field of types2[primaryType]) {
            let value2 = data[field.name];
            if (value2 !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value2 = util.keccak(value2);
                encodedValues.push(value2);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value2 === "string") {
                  value2 = Buffer.from(value2, "utf8");
                }
                value2 = util.keccak(value2);
                encodedValues.push(value2);
              } else if (types2[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value2 = util.keccak(this.encodeData(field.type, value2, types2, useV4));
                encodedValues.push(value2);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value2);
              }
            }
          }
        }
        return abi3.rawEncode(encodedTypes, encodedValues);
      },
      /**
       * Encodes the type of an object by encoding a comma delimited list of its members
       *
       * @param {string} primaryType - Root type to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of the type of an object
       */
      encodeType(primaryType, types2) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types2).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type7 of deps) {
          const children = types2[type7];
          if (!children) {
            throw new Error("No type definition specified: " + type7);
          }
          result += type7 + "(" + types2[type7].map(({ name, type: type8 }) => type8 + " " + name).join(",") + ")";
        }
        return result;
      },
      /**
       * Finds all types within a type definition object
       *
       * @param {string} primaryType - Root type
       * @param {Object} types - Type definitions
       * @param {Array} results - current set of accumulated types
       * @returns {Array} - Set of all types found in the type definition
       */
      findTypeDependencies(primaryType, types2, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types2[primaryType] === void 0) {
          return results;
        }
        results.push(primaryType);
        for (const field of types2[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types2, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results;
      },
      /**
       * Hashes an object
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to hash
       * @param {Object} types - Type definitions
       * @returns {Buffer} - Hash of an object
       */
      hashStruct(primaryType, data, types2, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data, types2, useV4));
      },
      /**
       * Hashes the type of an object
       *
       * @param {string} primaryType - Root type to hash
       * @param {Object} types - Type definitions
       * @returns {string} - Hash of an object
       */
      hashType(primaryType, types2) {
        return util.keccak(this.encodeType(primaryType, types2));
      },
      /**
       * Removes properties from a message object that are not defined per EIP-712
       *
       * @param {Object} data - typed message object
       * @returns {Object} - typed message object with only allowed fields
       */
      sanitizeData(data) {
        const sanitizedData = {};
        for (const key in TYPED_MESSAGE_SCHEMA.properties) {
          data[key] && (sanitizedData[key] = data[key]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      /**
       * Returns the hash of a typed message as per EIP-712 for signing
       *
       * @param {Object} typedData - Types message data to sign
       * @returns {string} - sha3 hash for signing
       */
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts2 = [Buffer.from("1901", "hex")];
        parts2.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts2.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer.concat(parts2));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length) throw error;
      const data = typedData.map(function(e11) {
        return e11.type === "bytes" ? util.toBuffer(e11.value) : e11.value;
      });
      const types2 = typedData.map(function(e11) {
        return e11.type;
      });
      const schema = typedData.map(function(e11) {
        if (!e11.name) throw error;
        return e11.type + " " + e11.name;
      });
      return abi3.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi3.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi3.soliditySHA3(types2, data)
        ]
      );
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s5 = 1e3;
    var m6 = s5 * 60;
    var h9 = m6 * 60;
    var d7 = h9 * 24;
    var w8 = d7 * 7;
    var y11 = d7 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type7 = typeof val;
      if (type7 === "string" && val.length > 0) {
        return parse6(val);
      } else if (type7 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match14 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match14) {
        return;
      }
      var n5 = parseFloat(match14[1]);
      var type7 = (match14[2] || "ms").toLowerCase();
      switch (type7) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n5 * y11;
        case "weeks":
        case "week":
        case "w":
          return n5 * w8;
        case "days":
        case "day":
        case "d":
          return n5 * d7;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n5 * h9;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n5 * m6;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n5 * s5;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n5;
        default:
          return void 0;
      }
    }
    function fmtShort(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d7) {
        return Math.round(ms3 / d7) + "d";
      }
      if (msAbs >= h9) {
        return Math.round(ms3 / h9) + "h";
      }
      if (msAbs >= m6) {
        return Math.round(ms3 / m6) + "m";
      }
      if (msAbs >= s5) {
        return Math.round(ms3 / s5) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d7) {
        return plural(ms3, msAbs, d7, "day");
      }
      if (msAbs >= h9) {
        return plural(ms3, msAbs, h9, "hour");
      }
      if (msAbs >= m6) {
        return plural(ms3, msAbs, m6, "minute");
      }
      if (msAbs >= s5) {
        return plural(ms3, msAbs, s5, "second");
      }
      return ms3 + " ms";
    }
    function plural(ms3, msAbs, n5, name) {
      var isPlural = msAbs >= n5 * 1.5;
      return Math.round(ms3 / n5) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash9 = 0;
        for (let i9 = 0; i9 < namespace.length; i9++) {
          hash9 = (hash9 << 5) - hash9 + namespace.charCodeAt(i9);
          hash9 |= 0;
        }
        return createDebug.colors[Math.abs(hash9) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match14, format9) => {
            if (match14 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format9];
            if (typeof formatter === "function") {
              const val = args[index2];
              match14 = formatter.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match14;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend15;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v9) => {
            enableOverride = v9;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend15(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split3 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns3 of split3) {
          if (ns3[0] === "-") {
            createDebug.skips.push(ns3.slice(1));
          } else {
            createDebug.names.push(ns3);
          }
        }
      }
      function matchesTemplate(search, template2) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template2.length && (template2[templateIndex] === search[searchIndex] || template2[templateIndex] === "*")) {
            if (template2[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template2.length && template2[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template2.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns3 of createDebug.names) {
          if (matchesTemplate(name, ns3)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m6;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m6 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m6[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c9 = "color: " + this.color;
      args.splice(1, 0, c9, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match14) => {
        if (match14 === "%%") {
          return;
        }
        index2++;
        if (match14 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c9);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r8;
      try {
        r8 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r8 && typeof process !== "undefined" && "env" in process) {
        r8 = process.env.DEBUG;
      }
      return r8;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v9) {
      try {
        return JSON.stringify(v9);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/openapi-fetch/dist/cjs/index.cjs
var require_cjs4 = __commonJS({
  "node_modules/openapi-fetch/dist/cjs/index.cjs"(exports, module) {
    "use strict";
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all5) => {
      for (var name in all5)
        __defProp3(target, name, { get: all5[name], enumerable: true });
    };
    var __copyProps = (to6, from40, except, desc) => {
      if (from40 && typeof from40 === "object" || typeof from40 === "function") {
        for (let key of __getOwnPropNames(from40))
          if (!__hasOwnProp.call(to6, key) && key !== except)
            __defProp3(to6, key, { get: () => from40[key], enumerable: !(desc = __getOwnPropDesc(from40, key)) || desc.enumerable });
      }
      return to6;
    };
    var __toCommonJS = (mod4) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod4);
    var index_exports = {};
    __export2(index_exports, {
      createFinalURL: () => createFinalURL,
      createPathBasedClient: () => createPathBasedClient,
      createQuerySerializer: () => createQuerySerializer,
      default: () => createClient3,
      defaultBodySerializer: () => defaultBodySerializer,
      defaultPathSerializer: () => defaultPathSerializer,
      mergeHeaders: () => mergeHeaders,
      randomID: () => randomID,
      removeTrailingSlash: () => removeTrailingSlash,
      serializeArrayParam: () => serializeArrayParam,
      serializeObjectParam: () => serializeObjectParam,
      serializePrimitiveParam: () => serializePrimitiveParam,
      wrapAsPathBasedClient: () => wrapAsPathBasedClient
    });
    module.exports = __toCommonJS(index_exports);
    var PATH_PARAM_RE = /\{[^{}]+\}/g;
    var supportsRequestInitExt = () => {
      var _a14, _b;
      return typeof process === "object" && Number.parseInt((_b = (_a14 = process == null ? void 0 : process.versions) == null ? void 0 : _a14.node) == null ? void 0 : _b.substring(0, 2)) >= 18 && process.versions.undici;
    };
    function randomID() {
      return Math.random().toString(36).slice(2, 11);
    }
    function createClient3(clientOptions) {
      let {
        baseUrl = "",
        Request: CustomRequest = globalThis.Request,
        fetch: baseFetch = globalThis.fetch,
        querySerializer: globalQuerySerializer,
        bodySerializer: globalBodySerializer,
        headers: baseHeaders,
        requestInitExt = void 0,
        ...baseOptions
      } = { ...clientOptions };
      requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;
      baseUrl = removeTrailingSlash(baseUrl);
      const middlewares = [];
      async function coreFetch(schemaPath, fetchOptions) {
        const {
          baseUrl: localBaseUrl,
          fetch: fetch3 = baseFetch,
          Request: Request3 = CustomRequest,
          headers,
          params = {},
          parseAs = "json",
          querySerializer: requestQuerySerializer,
          bodySerializer = globalBodySerializer ?? defaultBodySerializer,
          body,
          ...init4
        } = fetchOptions || {};
        let finalBaseUrl = baseUrl;
        if (localBaseUrl) {
          finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;
        }
        let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
        if (requestQuerySerializer) {
          querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
            ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
            ...requestQuerySerializer
          });
        }
        const serializedBody = body === void 0 ? void 0 : bodySerializer(
          body,
          // Note: we declare mergeHeaders() both here and below because its a bit of a chicken-or-egg situation:
          // bodySerializer() needs all headers so we arent dropping ones set by the user, however,
          // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,
          // setting the content-type at the very beginning to be overwritten.
          // Lastly, based on the way headers work, its not a simplepresent-or-not check becauase null intentionally un-sets headers.
          mergeHeaders(baseHeaders, headers, params.header)
        );
        const finalHeaders = mergeHeaders(
          // with no body, we should not to set Content-Type
          serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression
          serializedBody instanceof FormData ? {} : {
            "Content-Type": "application/json"
          },
          baseHeaders,
          headers,
          params.header
        );
        const requestInit = {
          redirect: "follow",
          ...baseOptions,
          ...init4,
          body: serializedBody,
          headers: finalHeaders
        };
        let id2;
        let options;
        let request2 = new CustomRequest(
          createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),
          requestInit
        );
        let response;
        for (const key in init4) {
          if (!(key in request2)) {
            request2[key] = init4[key];
          }
        }
        if (middlewares.length) {
          id2 = randomID();
          options = Object.freeze({
            baseUrl: finalBaseUrl,
            fetch: fetch3,
            parseAs,
            querySerializer,
            bodySerializer
          });
          for (const m6 of middlewares) {
            if (m6 && typeof m6 === "object" && typeof m6.onRequest === "function") {
              const result = await m6.onRequest({
                request: request2,
                schemaPath,
                params,
                options,
                id: id2
              });
              if (result) {
                if (result instanceof CustomRequest) {
                  request2 = result;
                } else if (result instanceof Response) {
                  response = result;
                  break;
                } else {
                  throw new Error("onRequest: must return new Request() or Response() when modifying the request");
                }
              }
            }
          }
        }
        if (!response) {
          try {
            response = await fetch3(request2, requestInitExt);
          } catch (error2) {
            let errorAfterMiddleware = error2;
            if (middlewares.length) {
              for (let i9 = middlewares.length - 1; i9 >= 0; i9--) {
                const m6 = middlewares[i9];
                if (m6 && typeof m6 === "object" && typeof m6.onError === "function") {
                  const result = await m6.onError({
                    request: request2,
                    error: errorAfterMiddleware,
                    schemaPath,
                    params,
                    options,
                    id: id2
                  });
                  if (result) {
                    if (result instanceof Response) {
                      errorAfterMiddleware = void 0;
                      response = result;
                      break;
                    }
                    if (result instanceof Error) {
                      errorAfterMiddleware = result;
                      continue;
                    }
                    throw new Error("onError: must return new Response() or instance of Error");
                  }
                }
              }
            }
            if (errorAfterMiddleware) {
              throw errorAfterMiddleware;
            }
          }
          if (middlewares.length) {
            for (let i9 = middlewares.length - 1; i9 >= 0; i9--) {
              const m6 = middlewares[i9];
              if (m6 && typeof m6 === "object" && typeof m6.onResponse === "function") {
                const result = await m6.onResponse({
                  request: request2,
                  response,
                  schemaPath,
                  params,
                  options,
                  id: id2
                });
                if (result) {
                  if (!(result instanceof Response)) {
                    throw new Error("onResponse: must return new Response() when modifying the response");
                  }
                  response = result;
                }
              }
            }
          }
        }
        if (response.status === 204 || request2.method === "HEAD" || response.headers.get("Content-Length") === "0") {
          return response.ok ? { data: void 0, response } : { error: void 0, response };
        }
        if (response.ok) {
          if (parseAs === "stream") {
            return { data: response.body, response };
          }
          return { data: await response[parseAs](), response };
        }
        let error = await response.text();
        try {
          error = JSON.parse(error);
        } catch {
        }
        return { error, response };
      }
      return {
        request(method, url2, init4) {
          return coreFetch(url2, { ...init4, method: method.toUpperCase() });
        },
        /** Call a GET endpoint */
        GET(url2, init4) {
          return coreFetch(url2, { ...init4, method: "GET" });
        },
        /** Call a PUT endpoint */
        PUT(url2, init4) {
          return coreFetch(url2, { ...init4, method: "PUT" });
        },
        /** Call a POST endpoint */
        POST(url2, init4) {
          return coreFetch(url2, { ...init4, method: "POST" });
        },
        /** Call a DELETE endpoint */
        DELETE(url2, init4) {
          return coreFetch(url2, { ...init4, method: "DELETE" });
        },
        /** Call a OPTIONS endpoint */
        OPTIONS(url2, init4) {
          return coreFetch(url2, { ...init4, method: "OPTIONS" });
        },
        /** Call a HEAD endpoint */
        HEAD(url2, init4) {
          return coreFetch(url2, { ...init4, method: "HEAD" });
        },
        /** Call a PATCH endpoint */
        PATCH(url2, init4) {
          return coreFetch(url2, { ...init4, method: "PATCH" });
        },
        /** Call a TRACE endpoint */
        TRACE(url2, init4) {
          return coreFetch(url2, { ...init4, method: "TRACE" });
        },
        /** Register middleware */
        use(...middleware) {
          for (const m6 of middleware) {
            if (!m6) {
              continue;
            }
            if (typeof m6 !== "object" || !("onRequest" in m6 || "onResponse" in m6 || "onError" in m6)) {
              throw new Error("Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`");
            }
            middlewares.push(m6);
          }
        },
        /** Unregister middleware */
        eject(...middleware) {
          for (const m6 of middleware) {
            const i9 = middlewares.indexOf(m6);
            if (i9 !== -1) {
              middlewares.splice(i9, 1);
            }
          }
        }
      };
    }
    var PathCallForwarder = class {
      constructor(client, url2) {
        __publicField(this, "GET", (init4) => {
          return this.client.GET(this.url, init4);
        });
        __publicField(this, "PUT", (init4) => {
          return this.client.PUT(this.url, init4);
        });
        __publicField(this, "POST", (init4) => {
          return this.client.POST(this.url, init4);
        });
        __publicField(this, "DELETE", (init4) => {
          return this.client.DELETE(this.url, init4);
        });
        __publicField(this, "OPTIONS", (init4) => {
          return this.client.OPTIONS(this.url, init4);
        });
        __publicField(this, "HEAD", (init4) => {
          return this.client.HEAD(this.url, init4);
        });
        __publicField(this, "PATCH", (init4) => {
          return this.client.PATCH(this.url, init4);
        });
        __publicField(this, "TRACE", (init4) => {
          return this.client.TRACE(this.url, init4);
        });
        this.client = client;
        this.url = url2;
      }
    };
    var PathClientProxyHandler = class {
      constructor() {
        this.client = null;
      }
      // Assume the property is an URL.
      get(coreClient, url2) {
        const forwarder = new PathCallForwarder(coreClient, url2);
        this.client[url2] = forwarder;
        return forwarder;
      }
    };
    function wrapAsPathBasedClient(coreClient) {
      const handler = new PathClientProxyHandler();
      const proxy = new Proxy(coreClient, handler);
      function Client() {
      }
      Client.prototype = proxy;
      const client = new Client();
      handler.client = client;
      return client;
    }
    function createPathBasedClient(clientOptions) {
      return wrapAsPathBasedClient(createClient3(clientOptions));
    }
    function serializePrimitiveParam(name, value2, options) {
      if (value2 === void 0 || value2 === null) {
        return "";
      }
      if (typeof value2 === "object") {
        throw new Error(
          "Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these."
        );
      }
      return `${name}=${(options == null ? void 0 : options.allowReserved) === true ? value2 : encodeURIComponent(value2)}`;
    }
    function serializeObjectParam(name, value2, options) {
      if (!value2 || typeof value2 !== "object") {
        return "";
      }
      const values = [];
      const joiner = {
        simple: ",",
        label: ".",
        matrix: ";"
      }[options.style] || "&";
      if (options.style !== "deepObject" && options.explode === false) {
        for (const k11 in value2) {
          values.push(k11, options.allowReserved === true ? value2[k11] : encodeURIComponent(value2[k11]));
        }
        const final2 = values.join(",");
        switch (options.style) {
          case "form": {
            return `${name}=${final2}`;
          }
          case "label": {
            return `.${final2}`;
          }
          case "matrix": {
            return `;${name}=${final2}`;
          }
          default: {
            return final2;
          }
        }
      }
      for (const k11 in value2) {
        const finalName = options.style === "deepObject" ? `${name}[${k11}]` : k11;
        values.push(serializePrimitiveParam(finalName, value2[k11], options));
      }
      const final = values.join(joiner);
      return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
    }
    function serializeArrayParam(name, value2, options) {
      if (!Array.isArray(value2)) {
        return "";
      }
      if (options.explode === false) {
        const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
        const final = (options.allowReserved === true ? value2 : value2.map((v9) => encodeURIComponent(v9))).join(joiner2);
        switch (options.style) {
          case "simple": {
            return final;
          }
          case "label": {
            return `.${final}`;
          }
          case "matrix": {
            return `;${name}=${final}`;
          }
          default: {
            return `${name}=${final}`;
          }
        }
      }
      const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
      const values = [];
      for (const v9 of value2) {
        if (options.style === "simple" || options.style === "label") {
          values.push(options.allowReserved === true ? v9 : encodeURIComponent(v9));
        } else {
          values.push(serializePrimitiveParam(name, v9, options));
        }
      }
      return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
    }
    function createQuerySerializer(options) {
      return function querySerializer(queryParams) {
        const search = [];
        if (queryParams && typeof queryParams === "object") {
          for (const name in queryParams) {
            const value2 = queryParams[name];
            if (value2 === void 0 || value2 === null) {
              continue;
            }
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                continue;
              }
              search.push(
                serializeArrayParam(name, value2, {
                  style: "form",
                  explode: true,
                  ...options == null ? void 0 : options.array,
                  allowReserved: (options == null ? void 0 : options.allowReserved) || false
                })
              );
              continue;
            }
            if (typeof value2 === "object") {
              search.push(
                serializeObjectParam(name, value2, {
                  style: "deepObject",
                  explode: true,
                  ...options == null ? void 0 : options.object,
                  allowReserved: (options == null ? void 0 : options.allowReserved) || false
                })
              );
              continue;
            }
            search.push(serializePrimitiveParam(name, value2, options));
          }
        }
        return search.join("&");
      };
    }
    function defaultPathSerializer(pathname, pathParams) {
      let nextURL = pathname;
      for (const match14 of pathname.match(PATH_PARAM_RE) ?? []) {
        let name = match14.substring(1, match14.length - 1);
        let explode = false;
        let style = "simple";
        if (name.endsWith("*")) {
          explode = true;
          name = name.substring(0, name.length - 1);
        }
        if (name.startsWith(".")) {
          style = "label";
          name = name.substring(1);
        } else if (name.startsWith(";")) {
          style = "matrix";
          name = name.substring(1);
        }
        if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {
          continue;
        }
        const value2 = pathParams[name];
        if (Array.isArray(value2)) {
          nextURL = nextURL.replace(match14, serializeArrayParam(name, value2, { style, explode }));
          continue;
        }
        if (typeof value2 === "object") {
          nextURL = nextURL.replace(match14, serializeObjectParam(name, value2, { style, explode }));
          continue;
        }
        if (style === "matrix") {
          nextURL = nextURL.replace(match14, `;${serializePrimitiveParam(name, value2)}`);
          continue;
        }
        nextURL = nextURL.replace(match14, style === "label" ? `.${encodeURIComponent(value2)}` : encodeURIComponent(value2));
      }
      return nextURL;
    }
    function defaultBodySerializer(body, headers) {
      if (body instanceof FormData) {
        return body;
      }
      if (headers) {
        const contentType = headers.get instanceof Function ? headers.get("Content-Type") ?? headers.get("content-type") : headers["Content-Type"] ?? headers["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          return new URLSearchParams(body).toString();
        }
      }
      return JSON.stringify(body);
    }
    function createFinalURL(pathname, options) {
      var _a14;
      let finalURL = `${options.baseUrl}${pathname}`;
      if ((_a14 = options.params) == null ? void 0 : _a14.path) {
        finalURL = defaultPathSerializer(finalURL, options.params.path);
      }
      let search = options.querySerializer(options.params.query ?? {});
      if (search.startsWith("?")) {
        search = search.substring(1);
      }
      if (search) {
        finalURL += `?${search}`;
      }
      return finalURL;
    }
    function mergeHeaders(...allHeaders) {
      const finalHeaders = new Headers();
      for (const h9 of allHeaders) {
        if (!h9 || typeof h9 !== "object") {
          continue;
        }
        const iterator4 = h9 instanceof Headers ? h9.entries() : Object.entries(h9);
        for (const [k11, v9] of iterator4) {
          if (v9 === null) {
            finalHeaders.delete(k11);
          } else if (Array.isArray(v9)) {
            for (const v22 of v9) {
              finalHeaders.append(k11, v22);
            }
          } else if (v9 !== void 0) {
            finalHeaders.set(k11, v9);
          }
        }
      }
      return finalHeaders;
    }
    function removeTrailingSlash(url2) {
      if (url2.endsWith("/")) {
        return url2.substring(0, url2.length - 1);
      }
      return url2;
    }
  }
});

// node_modules/@metamask/sdk-analytics/dist/index.js
var require_dist = __commonJS({
  "node_modules/@metamask/sdk-analytics/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp3 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all5) => {
      for (var name in all5)
        __defProp3(target, name, { get: all5[name], enumerable: true });
    };
    var __copyProps = (to6, from40, except, desc) => {
      if (from40 && typeof from40 === "object" || typeof from40 === "function") {
        for (let key of __getOwnPropNames(from40))
          if (!__hasOwnProp.call(to6, key) && key !== except)
            __defProp3(to6, key, { get: () => from40[key], enumerable: !(desc = __getOwnPropDesc(from40, key)) || desc.enumerable });
      }
      return to6;
    };
    var __toESM2 = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod4 || !mod4.__esModule ? __defProp3(target, "default", { value: mod4, enumerable: true }) : target,
      mod4
    ));
    var __toCommonJS = (mod4) => __copyProps(__defProp3({}, "__esModule", { value: true }), mod4);
    var index_exports = {};
    __export2(index_exports, {
      analytics: () => analytics
    });
    module.exports = __toCommonJS(index_exports);
    var import_openapi_fetch = __toESM2(require_cjs4());
    var Sender = class {
      constructor(options) {
        this.batch = [];
        this.maxTimeoutMs = 3e4;
        this.timeoutId = null;
        this.isSending = false;
        this.batchSize = options.batchSize;
        this.baseTimeoutMs = options.baseTimeoutMs;
        this.currentTimeoutMs = options.baseTimeoutMs;
        this.sendFn = options.sendFn;
      }
      enqueue(item) {
        this.batch.push(item);
        this.schedule();
      }
      schedule() {
        if (this.batch.length > 0 && !this.timeoutId) {
          this.timeoutId = setTimeout(() => {
            this.timeoutId = null;
            this.flush();
          }, this.currentTimeoutMs);
        }
      }
      async flush() {
        if (this.isSending || this.batch.length === 0) {
          return;
        }
        this.isSending = true;
        const current = [...this.batch.slice(0, this.batchSize)];
        this.batch = this.batch.slice(this.batchSize);
        try {
          await this.sendFn(current);
          this.currentTimeoutMs = this.baseTimeoutMs;
        } catch (error) {
          console.error("Sender: Failed to send batch", error);
          this.batch = [...current, ...this.batch];
          this.currentTimeoutMs = Math.min(
            this.currentTimeoutMs * 2,
            this.maxTimeoutMs
          );
        } finally {
          this.isSending = false;
          this.schedule();
        }
      }
    };
    var sender_default = Sender;
    var Analytics = class {
      constructor(baseUrl) {
        this.enabled = false;
        this.properties = {};
        const client2 = (0, import_openapi_fetch.default)({ baseUrl });
        const sendFn = async (batch) => {
          const res = await client2.POST("/v1/events", { body: batch });
          if (res.response.status !== 200) {
            throw new Error(res.error);
          }
        };
        this.sender = new sender_default({ batchSize: 100, baseTimeoutMs: 200, sendFn });
      }
      enable() {
        this.enabled = true;
      }
      setGlobalProperty(key, value2) {
        this.properties[key] = value2;
      }
      track(name, properties) {
        if (!this.enabled) {
          return;
        }
        const event = {
          name,
          ...this.properties,
          ...properties
        };
        this.sender.enqueue(event);
      }
    };
    var analytics_default = Analytics;
    var endpoint;
    var _a14;
    if (typeof process !== "undefined" && process.env) {
      endpoint = (_a14 = process.env.METAMASK_ANALYTICS_ENDPOINT) != null ? _a14 : process.env.NEXT_PUBLIC_METAMASK_ANALYTICS_ENDPOINT;
    }
    var METAMASK_ANALYTICS_ENDPOINT = endpoint != null ? endpoint : "https://mm-sdk-analytics.api.cx.metamask.io/";
    var client = new analytics_default(METAMASK_ANALYTICS_ENDPOINT);
    var analytics = client;
  }
});

// node_modules/eventemitter2/lib/eventemitter2.js
var require_eventemitter2 = __commonJS({
  "node_modules/eventemitter2/lib/eventemitter2.js"(exports, module) {
    !function(undefined2) {
      var hasOwnProperty7 = Object.hasOwnProperty;
      var isArray4 = Array.isArray ? Array.isArray : function _isArray(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      var nextTickSupported = typeof process == "object" && typeof process.nextTick == "function";
      var symbolsSupported = typeof Symbol === "function";
      var reflectSupported = typeof Reflect === "object";
      var setImmediateSupported = typeof setImmediate === "function";
      var _setImmediate3 = setImmediateSupported ? setImmediate : setTimeout;
      var ownKeys = symbolsSupported ? reflectSupported && typeof Reflect.ownKeys === "function" ? Reflect.ownKeys : function(obj) {
        var arr = Object.getOwnPropertyNames(obj);
        arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
        return arr;
      } : Object.keys;
      function init4() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          if (conf.maxListeners !== undefined2) {
            this._maxListeners = conf.maxListeners;
          }
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        }
      }
      function logPossibleMemoryLeak(count, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process !== "undefined" && process.emitWarning) {
          var e11 = new Error(errorMsg);
          e11.name = "MaxListenersExceededWarning";
          e11.emitter = this;
          e11.count = count;
          process.emitWarning(e11);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      var toArray5 = function(a6, b6, c9) {
        var n5 = arguments.length;
        switch (n5) {
          case 0:
            return [];
          case 1:
            return [a6];
          case 2:
            return [a6, b6];
          case 3:
            return [a6, b6, c9];
          default:
            var arr = new Array(n5);
            while (n5--) {
              arr[n5] = arguments[n5];
            }
            return arr;
        }
      };
      function toObject(keys5, values) {
        var obj = {};
        var key;
        var len = keys5.length;
        var valuesCount = values ? values.length : 0;
        for (var i9 = 0; i9 < len; i9++) {
          key = keys5[i9];
          obj[key] = i9 < valuesCount ? values[i9] : undefined2;
        }
        return obj;
      }
      function TargetObserver(emitter, target, options) {
        this._emitter = emitter;
        this._target = target;
        this._listeners = {};
        this._listenersCount = 0;
        var on5, off;
        if (options.on || options.off) {
          on5 = options.on;
          off = options.off;
        }
        if (target.addEventListener) {
          on5 = target.addEventListener;
          off = target.removeEventListener;
        } else if (target.addListener) {
          on5 = target.addListener;
          off = target.removeListener;
        } else if (target.on) {
          on5 = target.on;
          off = target.off;
        }
        if (!on5 && !off) {
          throw Error("target does not implement any known event API");
        }
        if (typeof on5 !== "function") {
          throw TypeError("on method must be a function");
        }
        if (typeof off !== "function") {
          throw TypeError("off method must be a function");
        }
        this._on = on5;
        this._off = off;
        var _observers = emitter._observers;
        if (_observers) {
          _observers.push(this);
        } else {
          emitter._observers = [this];
        }
      }
      Object.assign(TargetObserver.prototype, {
        subscribe: function(event, localEvent, reducer) {
          var observer = this;
          var target = this._target;
          var emitter = this._emitter;
          var listeners = this._listeners;
          var handler = function() {
            var args = toArray5.apply(null, arguments);
            var eventObj = {
              data: args,
              name: localEvent,
              original: event
            };
            if (reducer) {
              var result = reducer.call(target, eventObj);
              if (result !== false) {
                emitter.emit.apply(emitter, [eventObj.name].concat(args));
              }
              return;
            }
            emitter.emit.apply(emitter, [localEvent].concat(args));
          };
          if (listeners[event]) {
            throw Error("Event '" + event + "' is already listening");
          }
          this._listenersCount++;
          if (emitter._newListener && emitter._removeListener && !observer._onNewListener) {
            this._onNewListener = function(_event) {
              if (_event === localEvent && listeners[event] === null) {
                listeners[event] = handler;
                observer._on.call(target, event, handler);
              }
            };
            emitter.on("newListener", this._onNewListener);
            this._onRemoveListener = function(_event) {
              if (_event === localEvent && !emitter.hasListeners(_event) && listeners[event]) {
                listeners[event] = null;
                observer._off.call(target, event, handler);
              }
            };
            listeners[event] = null;
            emitter.on("removeListener", this._onRemoveListener);
          } else {
            listeners[event] = handler;
            observer._on.call(target, event, handler);
          }
        },
        unsubscribe: function(event) {
          var observer = this;
          var listeners = this._listeners;
          var emitter = this._emitter;
          var handler;
          var events;
          var off = this._off;
          var target = this._target;
          var i9;
          if (event && typeof event !== "string") {
            throw TypeError("event must be a string");
          }
          function clearRefs() {
            if (observer._onNewListener) {
              emitter.off("newListener", observer._onNewListener);
              emitter.off("removeListener", observer._onRemoveListener);
              observer._onNewListener = null;
              observer._onRemoveListener = null;
            }
            var index2 = findTargetIndex.call(emitter, observer);
            emitter._observers.splice(index2, 1);
          }
          if (event) {
            handler = listeners[event];
            if (!handler) return;
            off.call(target, event, handler);
            delete listeners[event];
            if (!--this._listenersCount) {
              clearRefs();
            }
          } else {
            events = ownKeys(listeners);
            i9 = events.length;
            while (i9-- > 0) {
              event = events[i9];
              off.call(target, event, listeners[event]);
            }
            this._listeners = {};
            this._listenersCount = 0;
            clearRefs();
          }
        }
      });
      function resolveOptions(options, schema, reducers, allowUnknown) {
        var computedOptions = Object.assign({}, schema);
        if (!options) return computedOptions;
        if (typeof options !== "object") {
          throw TypeError("options must be an object");
        }
        var keys5 = Object.keys(options);
        var length = keys5.length;
        var option, value2;
        var reducer;
        function reject(reason) {
          throw Error('Invalid "' + option + '" option value' + (reason ? ". Reason: " + reason : ""));
        }
        for (var i9 = 0; i9 < length; i9++) {
          option = keys5[i9];
          if (!allowUnknown && !hasOwnProperty7.call(schema, option)) {
            throw Error('Unknown "' + option + '" option');
          }
          value2 = options[option];
          if (value2 !== undefined2) {
            reducer = reducers[option];
            computedOptions[option] = reducer ? reducer(value2, reject) : value2;
          }
        }
        return computedOptions;
      }
      function constructorReducer(value2, reject) {
        if (typeof value2 !== "function" || !value2.hasOwnProperty("prototype")) {
          reject("value must be a constructor");
        }
        return value2;
      }
      function makeTypeReducer(types2) {
        var message = "value must be type of " + types2.join("|");
        var len = types2.length;
        var firstType = types2[0];
        var secondType = types2[1];
        if (len === 1) {
          return function(v9, reject) {
            if (typeof v9 === firstType) {
              return v9;
            }
            reject(message);
          };
        }
        if (len === 2) {
          return function(v9, reject) {
            var kind = typeof v9;
            if (kind === firstType || kind === secondType) return v9;
            reject(message);
          };
        }
        return function(v9, reject) {
          var kind = typeof v9;
          var i9 = len;
          while (i9-- > 0) {
            if (kind === types2[i9]) return v9;
          }
          reject(message);
        };
      }
      var functionReducer = makeTypeReducer(["function"]);
      var objectFunctionReducer = makeTypeReducer(["object", "function"]);
      function makeCancelablePromise(Promise2, executor, options) {
        var isCancelable;
        var callbacks;
        var timer = 0;
        var subscriptionClosed;
        var promise = new Promise2(function(resolve, reject, onCancel) {
          options = resolveOptions(options, {
            timeout: 0,
            overload: false
          }, {
            timeout: function(value2, reject2) {
              value2 *= 1;
              if (typeof value2 !== "number" || value2 < 0 || !Number.isFinite(value2)) {
                reject2("timeout must be a positive number");
              }
              return value2;
            }
          });
          isCancelable = !options.overload && typeof Promise2.prototype.cancel === "function" && typeof onCancel === "function";
          function cleanup() {
            if (callbacks) {
              callbacks = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = 0;
            }
          }
          var _resolve = function(value2) {
            cleanup();
            resolve(value2);
          };
          var _reject = function(err) {
            cleanup();
            reject(err);
          };
          if (isCancelable) {
            executor(_resolve, _reject, onCancel);
          } else {
            callbacks = [function(reason) {
              _reject(reason || Error("canceled"));
            }];
            executor(_resolve, _reject, function(cb) {
              if (subscriptionClosed) {
                throw Error("Unable to subscribe on cancel event asynchronously");
              }
              if (typeof cb !== "function") {
                throw TypeError("onCancel callback must be a function");
              }
              callbacks.push(cb);
            });
            subscriptionClosed = true;
          }
          if (options.timeout > 0) {
            timer = setTimeout(function() {
              var reason = Error("timeout");
              reason.code = "ETIMEDOUT";
              timer = 0;
              promise.cancel(reason);
              reject(reason);
            }, options.timeout);
          }
        });
        if (!isCancelable) {
          promise.cancel = function(reason) {
            if (!callbacks) {
              return;
            }
            var length = callbacks.length;
            for (var i9 = 1; i9 < length; i9++) {
              callbacks[i9](reason);
            }
            callbacks[0](reason);
            callbacks = null;
          };
        }
        return promise;
      }
      function findTargetIndex(observer) {
        var observers = this._observers;
        if (!observers) {
          return -1;
        }
        var len = observers.length;
        for (var i9 = 0; i9 < len; i9++) {
          if (observers[i9]._target === observer) return i9;
        }
        return -1;
      }
      function searchListenerTree(handlers, type7, tree, i9, typeLength) {
        if (!tree) {
          return null;
        }
        if (i9 === 0) {
          var kind = typeof type7;
          if (kind === "string") {
            var ns3, n5, l9 = 0, j9 = 0, delimiter = this.delimiter, dl2 = delimiter.length;
            if ((n5 = type7.indexOf(delimiter)) !== -1) {
              ns3 = new Array(5);
              do {
                ns3[l9++] = type7.slice(j9, n5);
                j9 = n5 + dl2;
              } while ((n5 = type7.indexOf(delimiter, j9)) !== -1);
              ns3[l9++] = type7.slice(j9);
              type7 = ns3;
              typeLength = l9;
            } else {
              type7 = [type7];
              typeLength = 1;
            }
          } else if (kind === "object") {
            typeLength = type7.length;
          } else {
            type7 = [type7];
            typeLength = 1;
          }
        }
        var listeners = null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type7[i9], nextType = type7[i9 + 1], branches, _listeners;
        if (i9 === typeLength) {
          if (tree._listeners) {
            if (typeof tree._listeners === "function") {
              handlers && handlers.push(tree._listeners);
              listeners = [tree];
            } else {
              handlers && handlers.push.apply(handlers, tree._listeners);
              listeners = [tree];
            }
          }
        } else {
          if (currentType === "*") {
            branches = ownKeys(tree);
            n5 = branches.length;
            while (n5-- > 0) {
              branch = branches[n5];
              if (branch !== "_listeners") {
                _listeners = searchListenerTree(handlers, type7, tree[branch], i9 + 1, typeLength);
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i9 + 1 === typeLength || i9 + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = searchListenerTree(handlers, type7, tree, typeLength, typeLength);
            }
            branches = ownKeys(tree);
            n5 = branches.length;
            while (n5-- > 0) {
              branch = branches[n5];
              if (branch !== "_listeners") {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    _listeners = searchListenerTree(handlers, type7, tree[branch], typeLength, typeLength);
                    if (_listeners) {
                      if (listeners) {
                        listeners.push.apply(listeners, _listeners);
                      } else {
                        listeners = _listeners;
                      }
                    }
                  }
                  _listeners = searchListenerTree(handlers, type7, tree[branch], i9, typeLength);
                } else if (branch === nextType) {
                  _listeners = searchListenerTree(handlers, type7, tree[branch], i9 + 2, typeLength);
                } else {
                  _listeners = searchListenerTree(handlers, type7, tree[branch], i9, typeLength);
                }
                if (_listeners) {
                  if (listeners) {
                    listeners.push.apply(listeners, _listeners);
                  } else {
                    listeners = _listeners;
                  }
                }
              }
            }
            return listeners;
          } else if (tree[currentType]) {
            listeners = searchListenerTree(handlers, type7, tree[currentType], i9 + 1, typeLength);
          }
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type7, xTree, i9 + 1, typeLength);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i9 < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type7, xxTree, typeLength, typeLength);
            }
            branches = ownKeys(xxTree);
            n5 = branches.length;
            while (n5-- > 0) {
              branch = branches[n5];
              if (branch !== "_listeners") {
                if (branch === nextType) {
                  searchListenerTree(handlers, type7, xxTree[branch], i9 + 2, typeLength);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type7, xxTree[branch], i9 + 1, typeLength);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type7, { "**": isolatedBranch }, i9 + 1, typeLength);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type7, xxTree, typeLength, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type7, xxTree["*"], typeLength, typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type7, listener, prepend3) {
        var len = 0, j9 = 0, i9, delimiter = this.delimiter, dl2 = delimiter.length, ns3;
        if (typeof type7 === "string") {
          if ((i9 = type7.indexOf(delimiter)) !== -1) {
            ns3 = new Array(5);
            do {
              ns3[len++] = type7.slice(j9, i9);
              j9 = i9 + dl2;
            } while ((i9 = type7.indexOf(delimiter, j9)) !== -1);
            ns3[len++] = type7.slice(j9);
          } else {
            ns3 = [type7];
            len = 1;
          }
        } else {
          ns3 = type7;
          len = type7.length;
        }
        if (len > 1) {
          for (i9 = 0; i9 + 1 < len; i9++) {
            if (ns3[i9] === "**" && ns3[i9 + 1] === "**") {
              return;
            }
          }
        }
        var tree = this.listenerTree, name;
        for (i9 = 0; i9 < len; i9++) {
          name = ns3[i9];
          tree = tree[name] || (tree[name] = {});
          if (i9 === len - 1) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              if (prepend3) {
                tree._listeners.unshift(listener);
              } else {
                tree._listeners.push(listener);
              }
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
        }
        return true;
      }
      function collectTreeEvents(tree, events, root, asArray) {
        var branches = ownKeys(tree);
        var i9 = branches.length;
        var branch, branchName, path2;
        var hasListeners = tree["_listeners"];
        var isArrayPath;
        while (i9-- > 0) {
          branchName = branches[i9];
          branch = tree[branchName];
          if (branchName === "_listeners") {
            path2 = root;
          } else {
            path2 = root ? root.concat(branchName) : [branchName];
          }
          isArrayPath = asArray || typeof branchName === "symbol";
          hasListeners && events.push(isArrayPath ? path2 : path2.join(this.delimiter));
          if (typeof branch === "object") {
            collectTreeEvents.call(this, branch, events, path2, isArrayPath);
          }
        }
        return events;
      }
      function recursivelyGarbageCollect(root) {
        var keys5 = ownKeys(root);
        var i9 = keys5.length;
        var obj, key, flag;
        while (i9-- > 0) {
          key = keys5[i9];
          obj = root[key];
          if (obj) {
            flag = true;
            if (key !== "_listeners" && !recursivelyGarbageCollect(obj)) {
              delete root[key];
            }
          }
        }
        return flag;
      }
      function Listener(emitter, event, listener) {
        this.emitter = emitter;
        this.event = event;
        this.listener = listener;
      }
      Listener.prototype.off = function() {
        this.emitter.off(this.event, this.listener);
        return this;
      };
      function setupListener(event, listener, options) {
        if (options === true) {
          promisify = true;
        } else if (options === false) {
          async = true;
        } else {
          if (!options || typeof options !== "object") {
            throw TypeError("options should be an object or true");
          }
          var async = options.async;
          var promisify = options.promisify;
          var nextTick2 = options.nextTick;
          var objectify = options.objectify;
        }
        if (async || nextTick2 || promisify) {
          var _listener = listener;
          var _origin = listener._origin || listener;
          if (nextTick2 && !nextTickSupported) {
            throw Error("process.nextTick is not supported");
          }
          if (promisify === undefined2) {
            promisify = listener.constructor.name === "AsyncFunction";
          }
          listener = function() {
            var args = arguments;
            var context = this;
            var event2 = this.event;
            return promisify ? nextTick2 ? Promise.resolve() : new Promise(function(resolve) {
              _setImmediate3(resolve);
            }).then(function() {
              context.event = event2;
              return _listener.apply(context, args);
            }) : (nextTick2 ? process.nextTick : _setImmediate3)(function() {
              context.event = event2;
              _listener.apply(context, args);
            });
          };
          listener._async = true;
          listener._origin = _origin;
        }
        return [listener, objectify ? new Listener(this, event, listener) : this];
      }
      function EventEmitter2(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter2.EventEmitter2 = EventEmitter2;
      EventEmitter2.prototype.listenTo = function(target, events, options) {
        if (typeof target !== "object") {
          throw TypeError("target musts be an object");
        }
        var emitter = this;
        options = resolveOptions(options, {
          on: undefined2,
          off: undefined2,
          reducers: undefined2
        }, {
          on: functionReducer,
          off: functionReducer,
          reducers: objectFunctionReducer
        });
        function listen(events2) {
          if (typeof events2 !== "object") {
            throw TypeError("events must be an object");
          }
          var reducers = options.reducers;
          var index2 = findTargetIndex.call(emitter, target);
          var observer;
          if (index2 === -1) {
            observer = new TargetObserver(emitter, target, options);
          } else {
            observer = emitter._observers[index2];
          }
          var keys5 = ownKeys(events2);
          var len = keys5.length;
          var event;
          var isSingleReducer = typeof reducers === "function";
          for (var i9 = 0; i9 < len; i9++) {
            event = keys5[i9];
            observer.subscribe(
              event,
              events2[event] || event,
              isSingleReducer ? reducers : reducers && reducers[event]
            );
          }
        }
        isArray4(events) ? listen(toObject(events)) : typeof events === "string" ? listen(toObject(events.split(/\s+/))) : listen(events);
        return this;
      };
      EventEmitter2.prototype.stopListeningTo = function(target, event) {
        var observers = this._observers;
        if (!observers) {
          return false;
        }
        var i9 = observers.length;
        var observer;
        var matched = false;
        if (target && typeof target !== "object") {
          throw TypeError("target should be an object");
        }
        while (i9-- > 0) {
          observer = observers[i9];
          if (!target || observer._target === target) {
            observer.unsubscribe(event);
            matched = true;
          }
        }
        return matched;
      };
      EventEmitter2.prototype.delimiter = ".";
      EventEmitter2.prototype.setMaxListeners = function(n5) {
        if (n5 !== undefined2) {
          this._maxListeners = n5;
          if (!this._conf) this._conf = {};
          this._conf.maxListeners = n5;
        }
      };
      EventEmitter2.prototype.getMaxListeners = function() {
        return this._maxListeners;
      };
      EventEmitter2.prototype.event = "";
      EventEmitter2.prototype.once = function(event, fn4, options) {
        return this._once(event, fn4, false, options);
      };
      EventEmitter2.prototype.prependOnceListener = function(event, fn4, options) {
        return this._once(event, fn4, true, options);
      };
      EventEmitter2.prototype._once = function(event, fn4, prepend3, options) {
        return this._many(event, 1, fn4, prepend3, options);
      };
      EventEmitter2.prototype.many = function(event, ttl, fn4, options) {
        return this._many(event, ttl, fn4, false, options);
      };
      EventEmitter2.prototype.prependMany = function(event, ttl, fn4, options) {
        return this._many(event, ttl, fn4, true, options);
      };
      EventEmitter2.prototype._many = function(event, ttl, fn4, prepend3, options) {
        var self2 = this;
        if (typeof fn4 !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event, listener);
          }
          return fn4.apply(this, arguments);
        }
        listener._origin = fn4;
        return this._on(event, listener, prepend3, options);
      };
      EventEmitter2.prototype.emit = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init4.call(this);
        var type7 = arguments[0], ns3, wildcard = this.wildcard;
        var args, l9, i9, j9, containsSymbol;
        if (type7 === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        if (wildcard) {
          ns3 = type7;
          if (type7 !== "newListener" && type7 !== "removeListener") {
            if (typeof type7 === "object") {
              l9 = type7.length;
              if (symbolsSupported) {
                for (i9 = 0; i9 < l9; i9++) {
                  if (typeof type7[i9] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type7 = type7.join(this.delimiter);
              }
            }
          }
        }
        var al2 = arguments.length;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          for (i9 = 0, l9 = handler.length; i9 < l9; i9++) {
            this.event = type7;
            switch (al2) {
              case 1:
                handler[i9].call(this, type7);
                break;
              case 2:
                handler[i9].call(this, type7, arguments[1]);
                break;
              case 3:
                handler[i9].call(this, type7, arguments[1], arguments[2]);
                break;
              default:
                handler[i9].apply(this, arguments);
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns3, this.listenerTree, 0, l9);
        } else {
          handler = this._events[type7];
          if (typeof handler === "function") {
            this.event = type7;
            switch (al2) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al2 - 1);
                for (j9 = 1; j9 < al2; j9++) args[j9 - 1] = arguments[j9];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al2 > 3) {
            args = new Array(al2 - 1);
            for (j9 = 1; j9 < al2; j9++) args[j9 - 1] = arguments[j9];
          }
          for (i9 = 0, l9 = handler.length; i9 < l9; i9++) {
            this.event = type7;
            switch (al2) {
              case 1:
                handler[i9].call(this);
                break;
              case 2:
                handler[i9].call(this, arguments[1]);
                break;
              case 3:
                handler[i9].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i9].apply(this, args);
            }
          }
          return true;
        } else if (!this.ignoreErrors && !this._all && type7 === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter2.prototype.emitAsync = function() {
        if (!this._events && !this._all) {
          return false;
        }
        this._events || init4.call(this);
        var type7 = arguments[0], wildcard = this.wildcard, ns3, containsSymbol;
        var args, l9, i9, j9;
        if (type7 === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        if (wildcard) {
          ns3 = type7;
          if (type7 !== "newListener" && type7 !== "removeListener") {
            if (typeof type7 === "object") {
              l9 = type7.length;
              if (symbolsSupported) {
                for (i9 = 0; i9 < l9; i9++) {
                  if (typeof type7[i9] === "symbol") {
                    containsSymbol = true;
                    break;
                  }
                }
              }
              if (!containsSymbol) {
                type7 = type7.join(this.delimiter);
              }
            }
          }
        }
        var promises = [];
        var al2 = arguments.length;
        var handler;
        if (this._all) {
          for (i9 = 0, l9 = this._all.length; i9 < l9; i9++) {
            this.event = type7;
            switch (al2) {
              case 1:
                promises.push(this._all[i9].call(this, type7));
                break;
              case 2:
                promises.push(this._all[i9].call(this, type7, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i9].call(this, type7, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i9].apply(this, arguments));
            }
          }
        }
        if (wildcard) {
          handler = [];
          searchListenerTree.call(this, handler, ns3, this.listenerTree, 0);
        } else {
          handler = this._events[type7];
        }
        if (typeof handler === "function") {
          this.event = type7;
          switch (al2) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al2 - 1);
              for (j9 = 1; j9 < al2; j9++) args[j9 - 1] = arguments[j9];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al2 > 3) {
            args = new Array(al2 - 1);
            for (j9 = 1; j9 < al2; j9++) args[j9 - 1] = arguments[j9];
          }
          for (i9 = 0, l9 = handler.length; i9 < l9; i9++) {
            this.event = type7;
            switch (al2) {
              case 1:
                promises.push(handler[i9].call(this));
                break;
              case 2:
                promises.push(handler[i9].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i9].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i9].apply(this, args));
            }
          }
        } else if (!this.ignoreErrors && !this._all && type7 === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter2.prototype.on = function(type7, listener, options) {
        return this._on(type7, listener, false, options);
      };
      EventEmitter2.prototype.prependListener = function(type7, listener, options) {
        return this._on(type7, listener, true, options);
      };
      EventEmitter2.prototype.onAny = function(fn4) {
        return this._onAny(fn4, false);
      };
      EventEmitter2.prototype.prependAny = function(fn4) {
        return this._onAny(fn4, true);
      };
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prototype._onAny = function(fn4, prepend3) {
        if (typeof fn4 !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend3) {
          this._all.unshift(fn4);
        } else {
          this._all.push(fn4);
        }
        return this;
      };
      EventEmitter2.prototype._on = function(type7, listener, prepend3, options) {
        if (typeof type7 === "function") {
          this._onAny(type7, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init4.call(this);
        var returnValue = this, temp;
        if (options !== undefined2) {
          temp = setupListener.call(this, type7, listener, options);
          listener = temp[0];
          returnValue = temp[1];
        }
        if (this._newListener) {
          this.emit("newListener", type7, listener);
        }
        if (this.wildcard) {
          growListenerTree.call(this, type7, listener, prepend3);
          return returnValue;
        }
        if (!this._events[type7]) {
          this._events[type7] = listener;
        } else {
          if (typeof this._events[type7] === "function") {
            this._events[type7] = [this._events[type7]];
          }
          if (prepend3) {
            this._events[type7].unshift(listener);
          } else {
            this._events[type7].push(listener);
          }
          if (!this._events[type7].warned && this._maxListeners > 0 && this._events[type7].length > this._maxListeners) {
            this._events[type7].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type7].length, type7);
          }
        }
        return returnValue;
      };
      EventEmitter2.prototype.off = function(type7, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns3 = typeof type7 === "string" ? type7.split(this.delimiter) : type7.slice();
          leafs = searchListenerTree.call(this, null, ns3, this.listenerTree, 0);
          if (!leafs) return this;
        } else {
          if (!this._events[type7]) return this;
          handlers = this._events[type7];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray4(handlers)) {
            var position = -1;
            for (var i9 = 0, length = handlers.length; i9 < length; i9++) {
              if (handlers[i9] === listener || handlers[i9].listener && handlers[i9].listener === listener || handlers[i9]._origin && handlers[i9]._origin === listener) {
                position = i9;
                break;
              }
            }
            if (position < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position, 1);
            } else {
              this._events[type7].splice(position, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type7];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type7, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type7];
            }
            if (this._removeListener)
              this.emit("removeListener", type7, listener);
          }
        }
        this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter2.prototype.offAny = function(fn4) {
        var i9 = 0, l9 = 0, fns;
        if (fn4 && this._all && this._all.length > 0) {
          fns = this._all;
          for (i9 = 0, l9 = fns.length; i9 < l9; i9++) {
            if (fn4 === fns[i9]) {
              fns.splice(i9, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn4);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i9 = 0, l9 = fns.length; i9 < l9; i9++)
              this.emit("removeListenerAny", fns[i9]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter2.prototype.removeListener = EventEmitter2.prototype.off;
      EventEmitter2.prototype.removeAllListeners = function(type7) {
        if (type7 === undefined2) {
          !this._events || init4.call(this);
          return this;
        }
        if (this.wildcard) {
          var leafs = searchListenerTree.call(this, null, type7, this.listenerTree, 0), leaf, i9;
          if (!leafs) return this;
          for (i9 = 0; i9 < leafs.length; i9++) {
            leaf = leafs[i9];
            leaf._listeners = null;
          }
          this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
        } else if (this._events) {
          this._events[type7] = null;
        }
        return this;
      };
      EventEmitter2.prototype.listeners = function(type7) {
        var _events = this._events;
        var keys5, listeners, allListeners;
        var i9;
        var listenerTree;
        if (type7 === undefined2) {
          if (this.wildcard) {
            throw Error("event name required for wildcard emitter");
          }
          if (!_events) {
            return [];
          }
          keys5 = ownKeys(_events);
          i9 = keys5.length;
          allListeners = [];
          while (i9-- > 0) {
            listeners = _events[keys5[i9]];
            if (typeof listeners === "function") {
              allListeners.push(listeners);
            } else {
              allListeners.push.apply(allListeners, listeners);
            }
          }
          return allListeners;
        } else {
          if (this.wildcard) {
            listenerTree = this.listenerTree;
            if (!listenerTree) return [];
            var handlers = [];
            var ns3 = typeof type7 === "string" ? type7.split(this.delimiter) : type7.slice();
            searchListenerTree.call(this, handlers, ns3, listenerTree, 0);
            return handlers;
          }
          if (!_events) {
            return [];
          }
          listeners = _events[type7];
          if (!listeners) {
            return [];
          }
          return typeof listeners === "function" ? [listeners] : listeners;
        }
      };
      EventEmitter2.prototype.eventNames = function(nsAsArray) {
        var _events = this._events;
        return this.wildcard ? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : _events ? ownKeys(_events) : [];
      };
      EventEmitter2.prototype.listenerCount = function(type7) {
        return this.listeners(type7).length;
      };
      EventEmitter2.prototype.hasListeners = function(type7) {
        if (this.wildcard) {
          var handlers = [];
          var ns3 = typeof type7 === "string" ? type7.split(this.delimiter) : type7.slice();
          searchListenerTree.call(this, handlers, ns3, this.listenerTree, 0);
          return handlers.length > 0;
        }
        var _events = this._events;
        var _all = this._all;
        return !!(_all && _all.length || _events && (type7 === undefined2 ? ownKeys(_events).length : _events[type7]));
      };
      EventEmitter2.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      EventEmitter2.prototype.waitFor = function(event, options) {
        var self2 = this;
        var type7 = typeof options;
        if (type7 === "number") {
          options = { timeout: options };
        } else if (type7 === "function") {
          options = { filter: options };
        }
        options = resolveOptions(options, {
          timeout: 0,
          filter: undefined2,
          handleError: false,
          Promise,
          overload: false
        }, {
          filter: functionReducer,
          Promise: constructorReducer
        });
        return makeCancelablePromise(options.Promise, function(resolve, reject, onCancel) {
          function listener() {
            var filter10 = options.filter;
            if (filter10 && !filter10.apply(self2, arguments)) {
              return;
            }
            self2.off(event, listener);
            if (options.handleError) {
              var err = arguments[0];
              err ? reject(err) : resolve(toArray5.apply(null, arguments).slice(1));
            } else {
              resolve(toArray5.apply(null, arguments));
            }
          }
          onCancel(function() {
            self2.off(event, listener);
          });
          self2._on(event, listener, false);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      };
      function once(emitter, name, options) {
        options = resolveOptions(options, {
          Promise,
          timeout: 0,
          overload: false
        }, {
          Promise: constructorReducer
        });
        var _Promise = options.Promise;
        return makeCancelablePromise(_Promise, function(resolve, reject, onCancel) {
          var handler;
          if (typeof emitter.addEventListener === "function") {
            handler = function() {
              resolve(toArray5.apply(null, arguments));
            };
            onCancel(function() {
              emitter.removeEventListener(name, handler);
            });
            emitter.addEventListener(
              name,
              handler,
              { once: true }
            );
            return;
          }
          var eventListener = function() {
            errorListener && emitter.removeListener("error", errorListener);
            resolve(toArray5.apply(null, arguments));
          };
          var errorListener;
          if (name !== "error") {
            errorListener = function(err) {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          onCancel(function() {
            errorListener && emitter.removeListener("error", errorListener);
            emitter.removeListener(name, eventListener);
          });
          emitter.once(name, eventListener);
        }, {
          timeout: options.timeout,
          overload: options.overload
        });
      }
      var prototype5 = EventEmitter2.prototype;
      Object.defineProperties(EventEmitter2, {
        defaultMaxListeners: {
          get: function() {
            return prototype5._maxListeners;
          },
          set: function(n5) {
            if (typeof n5 !== "number" || n5 < 0 || Number.isNaN(n5)) {
              throw TypeError("n must be a non-negative number");
            }
            prototype5._maxListeners = n5;
          },
          enumerable: true
        },
        once: {
          value: once,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(prototype5, {
        _maxListeners: {
          value: defaultMaxListeners,
          writable: true,
          configurable: true
        },
        _observers: { value: null, writable: true, configurable: true }
      });
      if (typeof define === "function" && define.amd) {
        define(function() {
          return EventEmitter2;
        });
      } else if (typeof exports === "object") {
        module.exports = EventEmitter2;
      } else {
        var _global3 = new Function("", "return this")();
        _global3.EventEmitter2 = EventEmitter2;
      }
    }();
  }
});

// node_modules/@dynamic-labs/ethereum/src/polyfills.js
var import_buffer = __toESM(require_buffer(), 1);
if (typeof window !== "undefined") {
  window.global = globalThis;
  Object.assign(window, { Buffer: import_buffer.Buffer });
}

// node_modules/@dynamic-labs/ethereum/package.js
var version = "4.43.0";

// node_modules/@dynamic-labs/ethereum-core/package.js
var version2 = "4.43.0";

// node_modules/@dynamic-labs/ethereum-core/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var secp256k1_ENDO = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  basises: [
    [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
    [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
  ]
};
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
function sqrtMod(y11) {
  const P7 = secp256k1_CURVE.p;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y11 * y11 * y11 % P7;
  const b32 = b22 * b22 * y11 % P7;
  const b6 = pow2(b32, _3n6, P7) * b32 % P7;
  const b9 = pow2(b6, _3n6, P7) * b32 % P7;
  const b11 = pow2(b9, _2n, P7) * b22 % P7;
  const b222 = pow2(b11, _11n, P7) * b11 % P7;
  const b44 = pow2(b222, _22n, P7) * b222 % P7;
  const b88 = pow2(b44, _44n, P7) * b44 % P7;
  const b176 = pow2(b88, _88n, P7) * b88 % P7;
  const b220 = pow2(b176, _44n, P7) * b44 % P7;
  const b223 = pow2(b220, _3n6, P7) * b32 % P7;
  const t1 = pow2(b223, _23n, P7) * b222 % P7;
  const t22 = pow2(t1, _6n, P7) * b22 % P7;
  const root = pow2(t22, _2n, P7);
  if (!Fpk1.eql(Fpk1.sqr(root), y11))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field2(secp256k1_CURVE.p, { sqrt: sqrtMod });
var secp256k1 = createCurve2({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(utf8ToBytes(tag));
    tagP = concatBytes(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes(tagP, ...messages));
}
var pointToBytes = (point) => point.toBytes(true).slice(1);
var Pointk1 = (() => secp256k1.Point)();
var hasEven = (y11) => y11 % _2n === _0n;
function schnorrGetExtPubKey(priv) {
  const { Fn: Fn4, BASE } = Pointk1;
  const d_ = _normFnElement(Fn4, priv);
  const p9 = BASE.multiply(d_);
  const scalar = hasEven(p9.y) ? d_ : Fn4.neg(d_);
  return { scalar, bytes: pointToBytes(p9) };
}
function lift_x(x7) {
  const Fp4 = Fpk1;
  if (!Fp4.isValidNot0(x7))
    throw new Error("invalid x: Fail if x  p");
  const xx = Fp4.create(x7 * x7);
  const c9 = Fp4.create(xx * x7 + BigInt(7));
  let y11 = Fp4.sqrt(c9);
  if (!hasEven(y11))
    y11 = Fp4.neg(y11);
  const p9 = Pointk1.fromAffine({ x: x7, y: y11 });
  p9.assertValidity();
  return p9;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(secretKey) {
  return schnorrGetExtPubKey(secretKey).bytes;
}
function schnorrSign(message, secretKey, auxRand = randomBytes(32)) {
  const { Fn: Fn4 } = Pointk1;
  const m6 = ensureBytes("message", message);
  const { bytes: px, scalar: d7 } = schnorrGetExtPubKey(secretKey);
  const a6 = ensureBytes("auxRand", auxRand, 32);
  const t6 = Fn4.toBytes(d7 ^ num(taggedHash("BIP0340/aux", a6)));
  const rand = taggedHash("BIP0340/nonce", t6, px, m6);
  const { bytes: rx, scalar: k11 } = schnorrGetExtPubKey(rand);
  const e11 = challenge(rx, px, m6);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(Fn4.toBytes(Fn4.create(k11 + e11 * d7)), 32);
  if (!schnorrVerify(sig, m6, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const { Fn: Fn4, BASE } = Pointk1;
  const sig = ensureBytes("signature", signature, 64);
  const m6 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P7 = lift_x(num(pub));
    const r8 = num(sig.subarray(0, 32));
    if (!inRange(r8, _1n, secp256k1_CURVE.p))
      return false;
    const s5 = num(sig.subarray(32, 64));
    if (!inRange(s5, _1n, secp256k1_CURVE.n))
      return false;
    const e11 = challenge(Fn4.toBytes(r8), pointToBytes(P7), m6);
    const R6 = BASE.multiplyUnsafe(s5).add(P7.multiplyUnsafe(Fn4.neg(e11)));
    const { x: x7, y: y11 } = R6.toAffine();
    if (R6.is0() || !hasEven(y11) || x7 !== r8)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => {
  const size11 = 32;
  const seedLength = 48;
  const randomSecretKey = (seed = randomBytes(seedLength)) => {
    return mapHashToField(seed, secp256k1_CURVE.n);
  };
  secp256k1.utils.randomSecretKey;
  function keygen(seed) {
    const secretKey = randomSecretKey(seed);
    return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
  }
  return {
    keygen,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    Point: Pointk1,
    utils: {
      randomSecretKey,
      randomPrivateKey: randomSecretKey,
      taggedHash,
      // TODO: remove
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      mod
    },
    lengths: {
      secretKey: size11,
      publicKey: size11,
      publicKeyHasPrefix: false,
      signature: size11 * 2,
      seed: seedLength
    }
  };
})();
var isoMap = (() => isogenyMap(Fpk1, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i9) => i9.map((j9) => BigInt(j9)))))();
var mapSWU = (() => mapToCurveSimpleSWU2(Fpk1, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk1.create(BigInt("-11"))
}))();
var secp256k1_hasher = (() => createHasher2(secp256k1.Point, (scalars) => {
  const { x: x7, y: y11 } = mapSWU(Fpk1.create(scalars[0]));
  return isoMap(x7, y11);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk1.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => secp256k1_hasher.hashToCurve)();
var encodeToCurve = (() => secp256k1_hasher.encodeToCurve)();

// node_modules/@scure/base/lib/esm/index.js
function isBytes(a6) {
  return a6 instanceof Uint8Array || ArrayBuffer.isView(a6) && a6.constructor.name === "Uint8Array";
}
function abytes2(b6, ...lengths) {
  if (!isBytes(b6))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b6.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b6.length);
}
function isArrayOf(isString4, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString4) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n5) {
  if (!Number.isSafeInteger(n5))
    throw new Error(`invalid integer: ${n5}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id2 = (a6) => a6;
  const wrap = (a6, b6) => (c9) => a6(b6(c9));
  const encode20 = args.map((x7) => x7.encode).reduceRight(wrap, id2);
  const decode10 = args.map((x7) => x7.decode).reduce(wrap, id2);
  return { encode: encode20, decode: decode10 };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l9, i9) => [l9, i9]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i9) => {
        if (!Number.isSafeInteger(i9) || i9 < 0 || i9 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i9}". Allowed: ${letters}`);
        return lettersA[i9];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i9 = indexes.get(letter);
        if (i9 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i9;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from40) => {
      astrArr("join.decode", from40);
      return from40.join(separator);
    },
    decode: (to6) => {
      astr("join.decode", to6);
      return to6.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last5 = end - 1;
        const byte = last5 * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn4) {
  afn(fn4);
  return { encode: (from40) => from40, decode: (to6) => fn4(to6) };
}
function convertRadix(data, from40, to6) {
  if (from40 < 2)
    throw new Error(`convertRadix: invalid from=${from40}, base cannot be less than 2`);
  if (to6 < 2)
    throw new Error(`convertRadix: invalid to=${to6}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d7) => {
    anumber2(d7);
    if (d7 < 0 || d7 >= from40)
      throw new Error(`invalid integer: ${d7}`);
    return d7;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i9 = pos; i9 < dlen; i9++) {
      const digit = digits[i9];
      const fromCarry = from40 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from40 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to6;
      carry = digitBase % to6;
      const rounded = Math.floor(div);
      digits[i9] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to6 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i9;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i9 = 0; i9 < data.length - 1 && data[i9] === 0; i9++)
    res.push(0);
  return res.reverse();
}
var gcd = (a6, b6) => b6 === 0 ? a6 : gcd(b6, a6 % b6);
var radix2carry = (from40, to6) => from40 + (to6 - gcd(from40, to6));
var powers = (() => {
  let res = [];
  for (let i9 = 0; i9 < 40; i9++)
    res.push(2 ** i9);
  return res;
})();
function convertRadix2(data, from40, to6, padding2) {
  aArr(data);
  if (from40 <= 0 || from40 > 32)
    throw new Error(`convertRadix2: wrong from=${from40}`);
  if (to6 <= 0 || to6 > 32)
    throw new Error(`convertRadix2: wrong to=${to6}`);
  if (radix2carry(from40, to6) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from40} to=${to6} carryBits=${radix2carry(from40, to6)}`);
  }
  let carry = 0;
  let pos = 0;
  const max4 = powers[from40];
  const mask = powers[to6] - 1;
  const res = [];
  for (const n5 of data) {
    anumber2(n5);
    if (n5 >= max4)
      throw new Error(`convertRadix2: invalid data word=${n5} from=${from40}`);
    carry = carry << from40 | n5;
    if (pos + from40 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from40}`);
    pos += from40;
    for (; pos >= to6; pos -= to6)
      res.push((carry >> pos - to6 & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to6 - pos & mask;
  if (!padding2 && pos >= from40)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num3) {
  anumber2(num3);
  const _256 = 2 ** 8;
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), _256, num3);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num3, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn4) {
  afn(fn4);
  return function(...args) {
    try {
      return fn4.apply(null, args);
    } catch (e11) {
    }
  };
}
function checksum(len, fn4) {
  anumber2(len);
  afn(fn4);
  return {
    encode(data) {
      if (!isBytes(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn4(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn4(payload).slice(0, len);
      for (let i9 = 0; i9 < len; i9++)
        if (newChecksum[i9] !== oldChecksum[i9])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils = {
  alphabet,
  chain,
  checksum,
  convertRadix,
  convertRadix2,
  radix,
  radix2,
  join,
  padding
};
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s5) => s5.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s5, isUrl) => {
  astr("base64", s5);
  const re5 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet2 = isUrl ? "base64url" : "base64";
  if (s5.length > 0 && !re5.test(s5))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s5, { alphabet: alphabet2, lastChunkHandling: "strict" });
};
var base64 = hasBase64Builtin ? {
  encode(b6) {
    abytes2(b6);
    return b6.toBase64();
  },
  decode(s5) {
    return decodeBase64Builtin(s5, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b6) {
    abytes2(b6);
    return b6.toBase64({ alphabet: "base64url" });
  },
  decode(s5) {
    return decodeBase64Builtin(s5, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2568) => chain(checksum(4, (data) => sha2568(sha2568(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b6 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i9 = 0; i9 < POLYMOD_GENERATORS.length; i9++) {
    if ((b6 >> i9 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i9];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i9 = 0; i9 < len; i9++) {
    const c9 = prefix.charCodeAt(i9);
    if (c9 < 33 || c9 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c9 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i9 = 0; i9 < len; i9++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i9) & 31;
  for (let v9 of words)
    chk = bech32Polymod(chk) ^ v9;
  for (let i9 = 0; i9 < 6; i9++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode20(prefix, words, limit2 = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode10(str, limit2 = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit2 !== false && slen > limit2)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode10);
  function decodeToBytes(str) {
    const { prefix, words } = decode10(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes2) {
    return encode20(prefix, toWords(bytes2));
  }
  return {
    encode: encode20,
    decode: decode10,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s5) {
    astr("hex", s5);
    return Uint8Array.fromHex(s5);
  }
};
var hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s5) => {
  if (typeof s5 !== "string" || s5.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s5} with length ${s5.length}`);
  return s5.toLowerCase();
}));

// node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
function bytesToNumber(bytes2) {
  abytes(bytes2);
  const h9 = bytes2.length === 0 ? "0" : bytesToHex(bytes2);
  return BigInt("0x" + h9);
}
function numberToBytes(num3) {
  if (typeof num3 !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes2(num3.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha256(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n5) => {
  if (!Number.isSafeInteger(n5) || n5 < 0 || n5 > 2 ** 32 - 1) {
    throw new Error("invalid number, should be from 0 to 2**32-1, got " + n5);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n5, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    abytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
    }
    const I8 = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I8.slice(32),
      privateKey: I8.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version11 = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version11 !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return _HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path2) {
    if (!/^[mM]'?/.test(path2)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path2)) {
      return this;
    }
    const parts2 = path2.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c9 of parts2) {
      const m6 = /^(\d+)('?)$/.exec(c9);
      const m1 = m6 && m6[1];
      if (!m6 || m6.length !== 3 || typeof m1 !== "string")
        throw new Error("invalid child index: " + c9);
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m6[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index2) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index2);
    if (index2 >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I8 = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I8.slice(0, 32));
    const chainCode = I8.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: index2
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
        if (added.equals(Point.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index2 + 1);
    }
  }
  sign(hash9) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    abytes(hash9, 32);
    return secp256k1.sign(hash9, this.privKey).toCompactRawBytes();
  }
  verify(hash9, signature) {
    abytes(hash9, 32);
    abytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k1.verify(sig, hash9, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version11, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    abytes(key, 33);
    return concatBytes(toU32(version11), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash9, _password, _salt, _opts) {
  ahash(hash9);
  const opts2 = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c9, dkLen, asyncTick } = opts2;
  anumber(c9);
  anumber(dkLen);
  anumber(asyncTick);
  if (c9 < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash9, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c9, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u10) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u10);
  return DK;
}
function pbkdf2(hash9, password, salt, opts2) {
  const { c: c9, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash9, password, salt, opts2);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u10 = new Uint8Array(PRF.outputLen);
  for (let ti4 = 1, pos = 0; pos < dkLen; ti4++, pos += PRF.outputLen) {
    const Ti4 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti4, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u10);
    Ti4.set(u10.subarray(0, Ti4.length));
    for (let ui5 = 1; ui5 < c9; ui5++) {
      PRF._cloneInto(prfW).update(u10).digestInto(u10);
      for (let i9 = 0; i9 < Ti4.length; i9++)
        Ti4[i9] ^= u10[i9];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u10);
}

// node_modules/@scure/bip39/esm/index.js
var isJapanese = (wordlist11) => wordlist11[0] === "";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function aentropy(ent) {
  abytes(ent, 16, 20, 24, 28, 32);
}
function generateMnemonic(wordlist11, strength = 128) {
  anumber(strength);
  if (strength % 32 !== 0 || strength > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes(strength / 8), wordlist11);
}
var calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist11) {
  if (!Array.isArray(wordlist11) || wordlist11.length !== 2048 || typeof wordlist11[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist11.forEach((i9) => {
    if (typeof i9 !== "string")
      throw new Error("wordlist: non-string element: " + i9);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist11));
}
function mnemonicToEntropy(mnemonic, wordlist11) {
  const { words } = normalize2(mnemonic);
  const entropy = getCoder(wordlist11).decode(words);
  aentropy(entropy);
  return entropy;
}
function entropyToMnemonic(entropy, wordlist11) {
  aentropy(entropy);
  const words = getCoder(wordlist11).encode(entropy);
  return words.join(isJapanese(wordlist11) ? "" : " ");
}
function validateMnemonic(mnemonic, wordlist11) {
  try {
    mnemonicToEntropy(mnemonic, wordlist11);
  } catch (e11) {
    return false;
  }
  return true;
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/viem/_esm/accounts/toAccount.js
function toAccount(source) {
  if (typeof source === "string") {
    if (!isAddress(source, { strict: false }))
      throw new InvalidAddressError({ address: source });
    return {
      address: source,
      type: "json-rpc"
    };
  }
  if (!isAddress(source.address, { strict: false }))
    throw new InvalidAddressError({ address: source.address });
  return {
    address: source.address,
    nonceManager: source.nonceManager,
    sign: source.sign,
    signAuthorization: source.signAuthorization,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: "custom",
    type: "local"
  };
}

// node_modules/@scure/bip39/esm/wordlists/czech.js
var wordlist = `abdikace
abeceda
adresa
agrese
akce
aktovka
alej
alkohol
amputace
ananas
andulka
anekdota
anketa
antika
anulovat
archa
arogance
asfalt
asistent
aspirace
astma
astronom
atlas
atletika
atol
autobus
azyl
babka
bachor
bacil
baculka
badatel
bageta
bagr
bahno
bakterie
balada
baletka
balkon
balonek
balvan
balza
bambus
bankomat
barbar
baret
barman
baroko
barva
baterka
batoh
bavlna
bazalka
bazilika
bazuka
bedna
beran
beseda
bestie
beton
bezinka
bezmoc
beztak
bicykl
bidlo
biftek
bikiny
bilance
biograf
biolog
bitva
bizon
blahobyt
blatouch
blecha
bledule
blesk
blikat
blizna
blokovat
bloudit
blud
bobek
bobr
bodlina
bodnout
bohatost
bojkot
bojovat
bokorys
bolest
borec
borovice
bota
boubel
bouchat
bouda
boule
bourat
boxer
bradavka
brambora
branka
bratr
brepta
briketa
brko
brloh
bronz
broskev
brunetka
brusinka
brzda
brzy
bublina
bubnovat
buchta
buditel
budka
budova
bufet
bujarost
bukvice
buldok
bulva
bunda
bunkr
burza
butik
buvol
buzola
bydlet
bylina
bytovka
bzukot
capart
carevna
cedr
cedule
cejch
cejn
cela
celer
celkem
celnice
cenina
cennost
cenovka
centrum
cenzor
cestopis
cetka
chalupa
chapadlo
charita
chata
chechtat
chemie
chichot
chirurg
chlad
chleba
chlubit
chmel
chmura
chobot
chochol
chodba
cholera
chomout
chopit
choroba
chov
chrapot
chrlit
chrt
chrup
chtivost
chudina
chutnat
chvat
chvilka
chvost
chyba
chystat
chytit
cibule
cigareta
cihelna
cihla
cinkot
cirkus
cisterna
citace
citrus
cizinec
cizost
clona
cokoliv
couvat
ctitel
ctnost
cudnost
cuketa
cukr
cupot
cvaknout
cval
cvik
cvrkot
cyklista
daleko
dareba
datel
datum
dcera
debata
dechovka
decibel
deficit
deflace
dekl
dekret
demokrat
deprese
derby
deska
detektiv
dikobraz
diktovat
dioda
diplom
disk
displej
divadlo
divoch
dlaha
dlouho
dluhopis
dnes
dobro
dobytek
docent
dochutit
dodnes
dohled
dohoda
dohra
dojem
dojnice
doklad
dokola
doktor
dokument
dolar
doleva
dolina
doma
dominant
domluvit
domov
donutit
dopad
dopis
doplnit
doposud
doprovod
dopustit
dorazit
dorost
dort
dosah
doslov
dostatek
dosud
dosyta
dotaz
dotek
dotknout
doufat
doutnat
dovozce
dozadu
doznat
dozorce
drahota
drak
dramatik
dravec
draze
drdol
drobnost
drogerie
drozd
drsnost
drtit
drzost
duben
duchovno
dudek
duha
duhovka
dusit
dusno
dutost
dvojice
dvorec
dynamit
ekolog
ekonomie
elektron
elipsa
email
emise
emoce
empatie
epizoda
epocha
epopej
epos
esej
esence
eskorta
eskymo
etiketa
euforie
evoluce
exekuce
exkurze
expedice
exploze
export
extrakt
facka
fajfka
fakulta
fanatik
fantazie
farmacie
favorit
fazole
federace
fejeton
fenka
fialka
figurant
filozof
filtr
finance
finta
fixace
fjord
flanel
flirt
flotila
fond
fosfor
fotbal
fotka
foton
frakce
freska
fronta
fukar
funkce
fyzika
galeje
garant
genetika
geolog
gilotina
glazura
glejt
golem
golfista
gotika
graf
gramofon
granule
grep
gril
grog
groteska
guma
hadice
hadr
hala
halenka
hanba
hanopis
harfa
harpuna
havran
hebkost
hejkal
hejno
hejtman
hektar
helma
hematom
herec
herna
heslo
hezky
historik
hladovka
hlasivky
hlava
hledat
hlen
hlodavec
hloh
hloupost
hltat
hlubina
hluchota
hmat
hmota
hmyz
hnis
hnojivo
hnout
hoblina
hoboj
hoch
hodiny
hodlat
hodnota
hodovat
hojnost
hokej
holinka
holka
holub
homole
honitba
honorace
horal
horda
horizont
horko
horlivec
hormon
hornina
horoskop
horstvo
hospoda
hostina
hotovost
houba
houf
houpat
houska
hovor
hradba
hranice
hravost
hrazda
hrbolek
hrdina
hrdlo
hrdost
hrnek
hrobka
hromada
hrot
hrouda
hrozen
hrstka
hrubost
hryzat
hubenost
hubnout
hudba
hukot
humr
husita
hustota
hvozd
hybnost
hydrant
hygiena
hymna
hysterik
idylka
ihned
ikona
iluze
imunita
infekce
inflace
inkaso
inovace
inspekce
internet
invalida
investor
inzerce
ironie
jablko
jachta
jahoda
jakmile
jakost
jalovec
jantar
jarmark
jaro
jasan
jasno
jatka
javor
jazyk
jedinec
jedle
jednatel
jehlan
jekot
jelen
jelito
jemnost
jenom
jepice
jeseter
jevit
jezdec
jezero
jinak
jindy
jinoch
jiskra
jistota
jitrnice
jizva
jmenovat
jogurt
jurta
kabaret
kabel
kabinet
kachna
kadet
kadidlo
kahan
kajak
kajuta
kakao
kaktus
kalamita
kalhoty
kalibr
kalnost
kamera
kamkoliv
kamna
kanibal
kanoe
kantor
kapalina
kapela
kapitola
kapka
kaple
kapota
kapr
kapusta
kapybara
karamel
karotka
karton
kasa
katalog
katedra
kauce
kauza
kavalec
kazajka
kazeta
kazivost
kdekoliv
kdesi
kedluben
kemp
keramika
kino
klacek
kladivo
klam
klapot
klasika
klaun
klec
klenba
klepat
klesnout
klid
klima
klisna
klobouk
klokan
klopa
kloub
klubovna
klusat
kluzkost
kmen
kmitat
kmotr
kniha
knot
koalice
koberec
kobka
kobliha
kobyla
kocour
kohout
kojenec
kokos
koktejl
kolaps
koleda
kolize
kolo
komando
kometa
komik
komnata
komora
kompas
komunita
konat
koncept
kondice
konec
konfese
kongres
konina
konkurs
kontakt
konzerva
kopanec
kopie
kopnout
koprovka
korbel
korektor
kormidlo
koroptev
korpus
koruna
koryto
korzet
kosatec
kostka
kotel
kotleta
kotoul
koukat
koupelna
kousek
kouzlo
kovboj
koza
kozoroh
krabice
krach
krajina
kralovat
krasopis
kravata
kredit
krejcar
kresba
kreveta
kriket
kritik
krize
krkavec
krmelec
krmivo
krocan
krok
kronika
kropit
kroupa
krovka
krtek
kruhadlo
krupice
krutost
krvinka
krychle
krypta
krystal
kryt
kudlanka
kufr
kujnost
kukla
kulajda
kulich
kulka
kulomet
kultura
kuna
kupodivu
kurt
kurzor
kutil
kvalita
kvasinka
kvestor
kynolog
kyselina
kytara
kytice
kytka
kytovec
kyvadlo
labrador
lachtan
ladnost
laik
lakomec
lamela
lampa
lanovka
lasice
laso
lastura
latinka
lavina
lebka
leckdy
leden
lednice
ledovka
ledvina
legenda
legie
legrace
lehce
lehkost
lehnout
lektvar
lenochod
lentilka
lepenka
lepidlo
letadlo
letec
letmo
letokruh
levhart
levitace
levobok
libra
lichotka
lidojed
lidskost
lihovina
lijavec
lilek
limetka
linie
linka
linoleum
listopad
litina
litovat
lobista
lodivod
logika
logoped
lokalita
loket
lomcovat
lopata
lopuch
lord
losos
lotr
loudal
louh
louka
louskat
lovec
lstivost
lucerna
lucifer
lump
lusk
lustrace
lvice
lyra
lyrika
lysina
madam
madlo
magistr
mahagon
majetek
majitel
majorita
makak
makovice
makrela
malba
malina
malovat
malvice
maminka
mandle
manko
marnost
masakr
maskot
masopust
matice
matrika
maturita
mazanec
mazivo
mazlit
mazurka
mdloba
mechanik
meditace
medovina
melasa
meloun
mentolka
metla
metoda
metr
mezera
migrace
mihnout
mihule
mikina
mikrofon
milenec
milimetr
milost
mimika
mincovna
minibar
minomet
minulost
miska
mistr
mixovat
mladost
mlha
mlhovina
mlok
mlsat
mluvit
mnich
mnohem
mobil
mocnost
modelka
modlitba
mohyla
mokro
molekula
momentka
monarcha
monokl
monstrum
montovat
monzun
mosaz
moskyt
most
motivace
motorka
motyka
moucha
moudrost
mozaika
mozek
mozol
mramor
mravenec
mrkev
mrtvola
mrzet
mrzutost
mstitel
mudrc
muflon
mulat
mumie
munice
muset
mutace
muzeum
muzikant
myslivec
mzda
nabourat
nachytat
nadace
nadbytek
nadhoz
nadobro
nadpis
nahlas
nahnat
nahodile
nahradit
naivita
najednou
najisto
najmout
naklonit
nakonec
nakrmit
nalevo
namazat
namluvit
nanometr
naoko
naopak
naostro
napadat
napevno
naplnit
napnout
naposled
naprosto
narodit
naruby
narychlo
nasadit
nasekat
naslepo
nastat
natolik
navenek
navrch
navzdory
nazvat
nebe
nechat
necky
nedaleko
nedbat
neduh
negace
nehet
nehoda
nejen
nejprve
neklid
nelibost
nemilost
nemoc
neochota
neonka
nepokoj
nerost
nerv
nesmysl
nesoulad
netvor
neuron
nevina
nezvykle
nicota
nijak
nikam
nikdy
nikl
nikterak
nitro
nocleh
nohavice
nominace
nora
norek
nositel
nosnost
nouze
noviny
novota
nozdra
nuda
nudle
nuget
nutit
nutnost
nutrie
nymfa
obal
obarvit
obava
obdiv
obec
obehnat
obejmout
obezita
obhajoba
obilnice
objasnit
objekt
obklopit
oblast
oblek
obliba
obloha
obluda
obnos
obohatit
obojek
obout
obrazec
obrna
obruba
obrys
obsah
obsluha
obstarat
obuv
obvaz
obvinit
obvod
obvykle
obyvatel
obzor
ocas
ocel
ocenit
ochladit
ochota
ochrana
ocitnout
odboj
odbyt
odchod
odcizit
odebrat
odeslat
odevzdat
odezva
odhadce
odhodit
odjet
odjinud
odkaz
odkoupit
odliv
odluka
odmlka
odolnost
odpad
odpis
odplout
odpor
odpustit
odpykat
odrazka
odsoudit
odstup
odsun
odtok
odtud
odvaha
odveta
odvolat
odvracet
odznak
ofina
ofsajd
ohlas
ohnisko
ohrada
ohrozit
ohryzek
okap
okenice
oklika
okno
okouzlit
okovy
okrasa
okres
okrsek
okruh
okupant
okurka
okusit
olejnina
olizovat
omak
omeleta
omezit
omladina
omlouvat
omluva
omyl
onehdy
opakovat
opasek
operace
opice
opilost
opisovat
opora
opozice
opravdu
oproti
orbital
orchestr
orgie
orlice
orloj
ortel
osada
oschnout
osika
osivo
oslava
oslepit
oslnit
oslovit
osnova
osoba
osolit
ospalec
osten
ostraha
ostuda
ostych
osvojit
oteplit
otisk
otop
otrhat
otrlost
otrok
otruby
otvor
ovanout
ovar
oves
ovlivnit
ovoce
oxid
ozdoba
pachatel
pacient
padouch
pahorek
pakt
palanda
palec
palivo
paluba
pamflet
pamlsek
panenka
panika
panna
panovat
panstvo
pantofle
paprika
parketa
parodie
parta
paruka
paryba
paseka
pasivita
pastelka
patent
patrona
pavouk
pazneht
pazourek
pecka
pedagog
pejsek
peklo
peloton
penalta
pendrek
penze
periskop
pero
pestrost
petarda
petice
petrolej
pevnina
pexeso
pianista
piha
pijavice
pikle
piknik
pilina
pilnost
pilulka
pinzeta
pipeta
pisatel
pistole
pitevna
pivnice
pivovar
placenta
plakat
plamen
planeta
plastika
platit
plavidlo
plaz
plech
plemeno
plenta
ples
pletivo
plevel
plivat
plnit
plno
plocha
plodina
plomba
plout
pluk
plyn
pobavit
pobyt
pochod
pocit
poctivec
podat
podcenit
podepsat
podhled
podivit
podklad
podmanit
podnik
podoba
podpora
podraz
podstata
podvod
podzim
poezie
pohanka
pohnutka
pohovor
pohroma
pohyb
pointa
pojistka
pojmout
pokazit
pokles
pokoj
pokrok
pokuta
pokyn
poledne
polibek
polknout
poloha
polynom
pomalu
pominout
pomlka
pomoc
pomsta
pomyslet
ponechat
ponorka
ponurost
popadat
popel
popisek
poplach
poprosit
popsat
popud
poradce
porce
porod
porucha
poryv
posadit
posed
posila
poskok
poslanec
posoudit
pospolu
postava
posudek
posyp
potah
potkan
potlesk
potomek
potrava
potupa
potvora
poukaz
pouto
pouzdro
povaha
povidla
povlak
povoz
povrch
povstat
povyk
povzdech
pozdrav
pozemek
poznatek
pozor
pozvat
pracovat
prahory
praktika
prales
praotec
praporek
prase
pravda
princip
prkno
probudit
procento
prodej
profese
prohra
projekt
prolomit
promile
pronikat
propad
prorok
prosba
proton
proutek
provaz
prskavka
prsten
prudkost
prut
prvek
prvohory
psanec
psovod
pstruh
ptactvo
puberta
puch
pudl
pukavec
puklina
pukrle
pult
pumpa
punc
pupen
pusa
pusinka
pustina
putovat
putyka
pyramida
pysk
pytel
racek
rachot
radiace
radnice
radon
raft
ragby
raketa
rakovina
rameno
rampouch
rande
rarach
rarita
rasovna
rastr
ratolest
razance
razidlo
reagovat
reakce
recept
redaktor
referent
reflex
rejnok
reklama
rekord
rekrut
rektor
reputace
revize
revma
revolver
rezerva
riskovat
riziko
robotika
rodokmen
rohovka
rokle
rokoko
romaneto
ropovod
ropucha
rorejs
rosol
rostlina
rotmistr
rotoped
rotunda
roubenka
roucho
roup
roura
rovina
rovnice
rozbor
rozchod
rozdat
rozeznat
rozhodce
rozinka
rozjezd
rozkaz
rozloha
rozmar
rozpad
rozruch
rozsah
roztok
rozum
rozvod
rubrika
ruchadlo
rukavice
rukopis
ryba
rybolov
rychlost
rydlo
rypadlo
rytina
ryzost
sadista
sahat
sako
samec
samizdat
samota
sanitka
sardinka
sasanka
satelit
sazba
sazenice
sbor
schovat
sebranka
secese
sedadlo
sediment
sedlo
sehnat
sejmout
sekera
sekta
sekunda
sekvoje
semeno
seno
servis
sesadit
seshora
seskok
seslat
sestra
sesuv
sesypat
setba
setina
setkat
setnout
setrvat
sever
seznam
shoda
shrnout
sifon
silnice
sirka
sirotek
sirup
situace
skafandr
skalisko
skanzen
skaut
skeptik
skica
skladba
sklenice
sklo
skluz
skoba
skokan
skoro
skripta
skrz
skupina
skvost
skvrna
slabika
sladidlo
slanina
slast
slavnost
sledovat
slepec
sleva
slezina
slib
slina
sliznice
slon
sloupek
slovo
sluch
sluha
slunce
slupka
slza
smaragd
smetana
smilstvo
smlouva
smog
smrad
smrk
smrtka
smutek
smysl
snad
snaha
snob
sobota
socha
sodovka
sokol
sopka
sotva
souboj
soucit
soudce
souhlas
soulad
soumrak
souprava
soused
soutok
souviset
spalovna
spasitel
spis
splav
spodek
spojenec
spolu
sponzor
spornost
spousta
sprcha
spustit
sranda
sraz
srdce
srna
srnec
srovnat
srpen
srst
srub
stanice
starosta
statika
stavba
stehno
stezka
stodola
stolek
stopa
storno
stoupat
strach
stres
strhnout
strom
struna
studna
stupnice
stvol
styk
subjekt
subtropy
suchar
sudost
sukno
sundat
sunout
surikata
surovina
svah
svalstvo
svetr
svatba
svazek
svisle
svitek
svoboda
svodidlo
svorka
svrab
sykavka
sykot
synek
synovec
sypat
sypkost
syrovost
sysel
sytost
tabletka
tabule
tahoun
tajemno
tajfun
tajga
tajit
tajnost
taktika
tamhle
tampon
tancovat
tanec
tanker
tapeta
tavenina
tazatel
technika
tehdy
tekutina
telefon
temnota
tendence
tenista
tenor
teplota
tepna
teprve
terapie
termoska
textil
ticho
tiskopis
titulek
tkadlec
tkanina
tlapka
tleskat
tlukot
tlupa
tmel
toaleta
topinka
topol
torzo
touha
toulec
tradice
traktor
tramp
trasa
traverza
trefit
trest
trezor
trhavina
trhlina
trochu
trojice
troska
trouba
trpce
trpitel
trpkost
trubec
truchlit
truhlice
trus
trvat
tudy
tuhnout
tuhost
tundra
turista
turnaj
tuzemsko
tvaroh
tvorba
tvrdost
tvrz
tygr
tykev
ubohost
uboze
ubrat
ubrousek
ubrus
ubytovna
ucho
uctivost
udivit
uhradit
ujednat
ujistit
ujmout
ukazatel
uklidnit
uklonit
ukotvit
ukrojit
ulice
ulita
ulovit
umyvadlo
unavit
uniforma
uniknout
upadnout
uplatnit
uplynout
upoutat
upravit
uran
urazit
usednout
usilovat
usmrtit
usnadnit
usnout
usoudit
ustlat
ustrnout
utahovat
utkat
utlumit
utonout
utopenec
utrousit
uvalit
uvolnit
uvozovka
uzdravit
uzel
uzenina
uzlina
uznat
vagon
valcha
valoun
vana
vandal
vanilka
varan
varhany
varovat
vcelku
vchod
vdova
vedro
vegetace
vejce
velbloud
veletrh
velitel
velmoc
velryba
venkov
veranda
verze
veselka
veskrze
vesnice
vespodu
vesta
veterina
veverka
vibrace
vichr
videohra
vidina
vidle
vila
vinice
viset
vitalita
vize
vizitka
vjezd
vklad
vkus
vlajka
vlak
vlasec
vlevo
vlhkost
vliv
vlnovka
vloupat
vnucovat
vnuk
voda
vodivost
vodoznak
vodstvo
vojensky
vojna
vojsko
volant
volba
volit
volno
voskovka
vozidlo
vozovna
vpravo
vrabec
vracet
vrah
vrata
vrba
vrcholek
vrhat
vrstva
vrtule
vsadit
vstoupit
vstup
vtip
vybavit
vybrat
vychovat
vydat
vydra
vyfotit
vyhledat
vyhnout
vyhodit
vyhradit
vyhubit
vyjasnit
vyjet
vyjmout
vyklopit
vykonat
vylekat
vymazat
vymezit
vymizet
vymyslet
vynechat
vynikat
vynutit
vypadat
vyplatit
vypravit
vypustit
vyrazit
vyrovnat
vyrvat
vyslovit
vysoko
vystavit
vysunout
vysypat
vytasit
vytesat
vytratit
vyvinout
vyvolat
vyvrhel
vyzdobit
vyznat
vzadu
vzbudit
vzchopit
vzdor
vzduch
vzdychat
vzestup
vzhledem
vzkaz
vzlykat
vznik
vzorek
vzpoura
vztah
vztek
xylofon
zabrat
zabydlet
zachovat
zadarmo
zadusit
zafoukat
zahltit
zahodit
zahrada
zahynout
zajatec
zajet
zajistit
zaklepat
zakoupit
zalepit
zamezit
zamotat
zamyslet
zanechat
zanikat
zaplatit
zapojit
zapsat
zarazit
zastavit
zasunout
zatajit
zatemnit
zatknout
zaujmout
zavalit
zavelet
zavinit
zavolat
zavrtat
zazvonit
zbavit
zbrusu
zbudovat
zbytek
zdaleka
zdarma
zdatnost
zdivo
zdobit
zdroj
zdvih
zdymadlo
zelenina
zeman
zemina
zeptat
zezadu
zezdola
zhatit
zhltnout
zhluboka
zhotovit
zhruba
zima
zimnice
zjemnit
zklamat
zkoumat
zkratka
zkumavka
zlato
zlehka
zloba
zlom
zlost
zlozvyk
zmapovat
zmar
zmatek
zmije
zmizet
zmocnit
zmodrat
zmrzlina
zmutovat
znak
znalost
znamenat
znovu
zobrazit
zotavit
zoubek
zoufale
zplodit
zpomalit
zprava
zprostit
zprudka
zprvu
zrada
zranit
zrcadlo
zrnitost
zrno
zrovna
zrychlit
zrzavost
zticha
ztratit
zubovina
zubr
zvednout
zvenku
zvesela
zvon
zvrat
zvukovod
zvyk`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/english.js
var wordlist2 = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/french.js
var wordlist3 = `abaisser
abandon
abdiquer
abeille
abolir
aborder
aboutir
aboyer
abrasif
abreuver
abriter
abroger
abrupt
absence
absolu
absurde
abusif
abyssal
academie
acajou
acarien
accabler
accepter
acclamer
accolade
accroche
accuser
acerbe
achat
acheter
aciduler
acier
acompte
acquerir
acronyme
acteur
actif
actuel
adepte
adequat
adhesif
adjectif
adjuger
admettre
admirer
adopter
adorer
adoucir
adresse
adroit
adulte
adverbe
aerer
aeronef
affaire
affecter
affiche
affreux
affubler
agacer
agencer
agile
agiter
agrafer
agreable
agrume
aider
aiguille
ailier
aimable
aisance
ajouter
ajuster
alarmer
alchimie
alerte
algebre
algue
aliener
aliment
alleger
alliage
allouer
allumer
alourdir
alpaga
altesse
alveole
amateur
ambigu
ambre
amenager
amertume
amidon
amiral
amorcer
amour
amovible
amphibie
ampleur
amusant
analyse
anaphore
anarchie
anatomie
ancien
aneantir
angle
angoisse
anguleux
animal
annexer
annonce
annuel
anodin
anomalie
anonyme
anormal
antenne
antidote
anxieux
apaiser
aperitif
aplanir
apologie
appareil
appeler
apporter
appuyer
aquarium
aqueduc
arbitre
arbuste
ardeur
ardoise
argent
arlequin
armature
armement
armoire
armure
arpenter
arracher
arriver
arroser
arsenic
arteriel
article
aspect
asphalte
aspirer
assaut
asservir
assiette
associer
assurer
asticot
astre
astuce
atelier
atome
atrium
atroce
attaque
attentif
attirer
attraper
aubaine
auberge
audace
audible
augurer
aurore
automne
autruche
avaler
avancer
avarice
avenir
averse
aveugle
aviateur
avide
avion
aviser
avoine
avouer
avril
axial
axiome
badge
bafouer
bagage
baguette
baignade
balancer
balcon
baleine
balisage
bambin
bancaire
bandage
banlieue
banniere
banquier
barbier
baril
baron
barque
barrage
bassin
bastion
bataille
bateau
batterie
baudrier
bavarder
belette
belier
belote
benefice
berceau
berger
berline
bermuda
besace
besogne
betail
beurre
biberon
bicycle
bidule
bijou
bilan
bilingue
billard
binaire
biologie
biopsie
biotype
biscuit
bison
bistouri
bitume
bizarre
blafard
blague
blanchir
blessant
blinder
blond
bloquer
blouson
bobard
bobine
boire
boiser
bolide
bonbon
bondir
bonheur
bonifier
bonus
bordure
borne
botte
boucle
boueux
bougie
boulon
bouquin
bourse
boussole
boutique
boxeur
branche
brasier
brave
brebis
breche
breuvage
bricoler
brigade
brillant
brioche
brique
brochure
broder
bronzer
brousse
broyeur
brume
brusque
brutal
bruyant
buffle
buisson
bulletin
bureau
burin
bustier
butiner
butoir
buvable
buvette
cabanon
cabine
cachette
cadeau
cadre
cafeine
caillou
caisson
calculer
calepin
calibre
calmer
calomnie
calvaire
camarade
camera
camion
campagne
canal
caneton
canon
cantine
canular
capable
caporal
caprice
capsule
capter
capuche
carabine
carbone
caresser
caribou
carnage
carotte
carreau
carton
cascade
casier
casque
cassure
causer
caution
cavalier
caverne
caviar
cedille
ceinture
celeste
cellule
cendrier
censurer
central
cercle
cerebral
cerise
cerner
cerveau
cesser
chagrin
chaise
chaleur
chambre
chance
chapitre
charbon
chasseur
chaton
chausson
chavirer
chemise
chenille
chequier
chercher
cheval
chien
chiffre
chignon
chimere
chiot
chlorure
chocolat
choisir
chose
chouette
chrome
chute
cigare
cigogne
cimenter
cinema
cintrer
circuler
cirer
cirque
citerne
citoyen
citron
civil
clairon
clameur
claquer
classe
clavier
client
cligner
climat
clivage
cloche
clonage
cloporte
cobalt
cobra
cocasse
cocotier
coder
codifier
coffre
cogner
cohesion
coiffer
coincer
colere
colibri
colline
colmater
colonel
combat
comedie
commande
compact
concert
conduire
confier
congeler
connoter
consonne
contact
convexe
copain
copie
corail
corbeau
cordage
corniche
corpus
correct
cortege
cosmique
costume
coton
coude
coupure
courage
couteau
couvrir
coyote
crabe
crainte
cravate
crayon
creature
crediter
cremeux
creuser
crevette
cribler
crier
cristal
critere
croire
croquer
crotale
crucial
cruel
crypter
cubique
cueillir
cuillere
cuisine
cuivre
culminer
cultiver
cumuler
cupide
curatif
curseur
cyanure
cycle
cylindre
cynique
daigner
damier
danger
danseur
dauphin
debattre
debiter
deborder
debrider
debutant
decaler
decembre
dechirer
decider
declarer
decorer
decrire
decupler
dedale
deductif
deesse
defensif
defiler
defrayer
degager
degivrer
deglutir
degrafer
dejeuner
delice
deloger
demander
demeurer
demolir
denicher
denouer
dentelle
denuder
depart
depenser
dephaser
deplacer
deposer
deranger
derober
desastre
descente
desert
designer
desobeir
dessiner
destrier
detacher
detester
detourer
detresse
devancer
devenir
deviner
devoir
diable
dialogue
diamant
dicter
differer
digerer
digital
digne
diluer
dimanche
diminuer
dioxyde
directif
diriger
discuter
disposer
dissiper
distance
divertir
diviser
docile
docteur
dogme
doigt
domaine
domicile
dompter
donateur
donjon
donner
dopamine
dortoir
dorure
dosage
doseur
dossier
dotation
douanier
double
douceur
douter
doyen
dragon
draper
dresser
dribbler
droiture
duperie
duplexe
durable
durcir
dynastie
eblouir
ecarter
echarpe
echelle
eclairer
eclipse
eclore
ecluse
ecole
economie
ecorce
ecouter
ecraser
ecremer
ecrivain
ecrou
ecume
ecureuil
edifier
eduquer
effacer
effectif
effigie
effort
effrayer
effusion
egaliser
egarer
ejecter
elaborer
elargir
electron
elegant
elephant
eleve
eligible
elitisme
eloge
elucider
eluder
emballer
embellir
embryon
emeraude
emission
emmener
emotion
emouvoir
empereur
employer
emporter
emprise
emulsion
encadrer
enchere
enclave
encoche
endiguer
endosser
endroit
enduire
energie
enfance
enfermer
enfouir
engager
engin
englober
enigme
enjamber
enjeu
enlever
ennemi
ennuyeux
enrichir
enrobage
enseigne
entasser
entendre
entier
entourer
entraver
enumerer
envahir
enviable
envoyer
enzyme
eolien
epaissir
epargne
epatant
epaule
epicerie
epidemie
epier
epilogue
epine
episode
epitaphe
epoque
epreuve
eprouver
epuisant
equerre
equipe
eriger
erosion
erreur
eruption
escalier
espadon
espece
espiegle
espoir
esprit
esquiver
essayer
essence
essieu
essorer
estime
estomac
estrade
etagere
etaler
etanche
etatique
eteindre
etendoir
eternel
ethanol
ethique
ethnie
etirer
etoffer
etoile
etonnant
etourdir
etrange
etroit
etude
euphorie
evaluer
evasion
eventail
evidence
eviter
evolutif
evoquer
exact
exagerer
exaucer
exceller
excitant
exclusif
excuse
executer
exemple
exercer
exhaler
exhorter
exigence
exiler
exister
exotique
expedier
explorer
exposer
exprimer
exquis
extensif
extraire
exulter
fable
fabuleux
facette
facile
facture
faiblir
falaise
fameux
famille
farceur
farfelu
farine
farouche
fasciner
fatal
fatigue
faucon
fautif
faveur
favori
febrile
feconder
federer
felin
femme
femur
fendoir
feodal
fermer
feroce
ferveur
festival
feuille
feutre
fevrier
fiasco
ficeler
fictif
fidele
figure
filature
filetage
filiere
filleul
filmer
filou
filtrer
financer
finir
fiole
firme
fissure
fixer
flairer
flamme
flasque
flatteur
fleau
fleche
fleur
flexion
flocon
flore
fluctuer
fluide
fluvial
folie
fonderie
fongible
fontaine
forcer
forgeron
formuler
fortune
fossile
foudre
fougere
fouiller
foulure
fourmi
fragile
fraise
franchir
frapper
frayeur
fregate
freiner
frelon
fremir
frenesie
frere
friable
friction
frisson
frivole
froid
fromage
frontal
frotter
fruit
fugitif
fuite
fureur
furieux
furtif
fusion
futur
gagner
galaxie
galerie
gambader
garantir
gardien
garnir
garrigue
gazelle
gazon
geant
gelatine
gelule
gendarme
general
genie
genou
gentil
geologie
geometre
geranium
germe
gestuel
geyser
gibier
gicler
girafe
givre
glace
glaive
glisser
globe
gloire
glorieux
golfeur
gomme
gonfler
gorge
gorille
goudron
gouffre
goulot
goupille
gourmand
goutte
graduel
graffiti
graine
grand
grappin
gratuit
gravir
grenat
griffure
griller
grimper
grogner
gronder
grotte
groupe
gruger
grutier
gruyere
guepard
guerrier
guide
guimauve
guitare
gustatif
gymnaste
gyrostat
habitude
hachoir
halte
hameau
hangar
hanneton
haricot
harmonie
harpon
hasard
helium
hematome
herbe
herisson
hermine
heron
hesiter
heureux
hiberner
hibou
hilarant
histoire
hiver
homard
hommage
homogene
honneur
honorer
honteux
horde
horizon
horloge
hormone
horrible
houleux
housse
hublot
huileux
humain
humble
humide
humour
hurler
hydromel
hygiene
hymne
hypnose
idylle
ignorer
iguane
illicite
illusion
image
imbiber
imiter
immense
immobile
immuable
impact
imperial
implorer
imposer
imprimer
imputer
incarner
incendie
incident
incliner
incolore
indexer
indice
inductif
inedit
ineptie
inexact
infini
infliger
informer
infusion
ingerer
inhaler
inhiber
injecter
injure
innocent
inoculer
inonder
inscrire
insecte
insigne
insolite
inspirer
instinct
insulter
intact
intense
intime
intrigue
intuitif
inutile
invasion
inventer
inviter
invoquer
ironique
irradier
irreel
irriter
isoler
ivoire
ivresse
jaguar
jaillir
jambe
janvier
jardin
jauger
jaune
javelot
jetable
jeton
jeudi
jeunesse
joindre
joncher
jongler
joueur
jouissif
journal
jovial
joyau
joyeux
jubiler
jugement
junior
jupon
juriste
justice
juteux
juvenile
kayak
kimono
kiosque
label
labial
labourer
lacerer
lactose
lagune
laine
laisser
laitier
lambeau
lamelle
lampe
lanceur
langage
lanterne
lapin
largeur
larme
laurier
lavabo
lavoir
lecture
legal
leger
legume
lessive
lettre
levier
lexique
lezard
liasse
liberer
libre
licence
licorne
liege
lievre
ligature
ligoter
ligue
limer
limite
limonade
limpide
lineaire
lingot
lionceau
liquide
lisiere
lister
lithium
litige
littoral
livreur
logique
lointain
loisir
lombric
loterie
louer
lourd
loutre
louve
loyal
lubie
lucide
lucratif
lueur
lugubre
luisant
lumiere
lunaire
lundi
luron
lutter
luxueux
machine
magasin
magenta
magique
maigre
maillon
maintien
mairie
maison
majorer
malaxer
malefice
malheur
malice
mallette
mammouth
mandater
maniable
manquant
manteau
manuel
marathon
marbre
marchand
mardi
maritime
marqueur
marron
marteler
mascotte
massif
materiel
matiere
matraque
maudire
maussade
mauve
maximal
mechant
meconnu
medaille
medecin
mediter
meduse
meilleur
melange
melodie
membre
memoire
menacer
mener
menhir
mensonge
mentor
mercredi
merite
merle
messager
mesure
metal
meteore
methode
metier
meuble
miauler
microbe
miette
mignon
migrer
milieu
million
mimique
mince
mineral
minimal
minorer
minute
miracle
miroiter
missile
mixte
mobile
moderne
moelleux
mondial
moniteur
monnaie
monotone
monstre
montagne
monument
moqueur
morceau
morsure
mortier
moteur
motif
mouche
moufle
moulin
mousson
mouton
mouvant
multiple
munition
muraille
murene
murmure
muscle
museum
musicien
mutation
muter
mutuel
myriade
myrtille
mystere
mythique
nageur
nappe
narquois
narrer
natation
nation
nature
naufrage
nautique
navire
nebuleux
nectar
nefaste
negation
negliger
negocier
neige
nerveux
nettoyer
neurone
neutron
neveu
niche
nickel
nitrate
niveau
noble
nocif
nocturne
noirceur
noisette
nomade
nombreux
nommer
normatif
notable
notifier
notoire
nourrir
nouveau
novateur
novembre
novice
nuage
nuancer
nuire
nuisible
numero
nuptial
nuque
nutritif
obeir
objectif
obliger
obscur
observer
obstacle
obtenir
obturer
occasion
occuper
ocean
octobre
octroyer
octupler
oculaire
odeur
odorant
offenser
officier
offrir
ogive
oiseau
oisillon
olfactif
olivier
ombrage
omettre
onctueux
onduler
onereux
onirique
opale
opaque
operer
opinion
opportun
opprimer
opter
optique
orageux
orange
orbite
ordonner
oreille
organe
orgueil
orifice
ornement
orque
ortie
osciller
osmose
ossature
otarie
ouragan
ourson
outil
outrager
ouvrage
ovation
oxyde
oxygene
ozone
paisible
palace
palmares
palourde
palper
panache
panda
pangolin
paniquer
panneau
panorama
pantalon
papaye
papier
papoter
papyrus
paradoxe
parcelle
paresse
parfumer
parler
parole
parrain
parsemer
partager
parure
parvenir
passion
pasteque
paternel
patience
patron
pavillon
pavoiser
payer
paysage
peigne
peintre
pelage
pelican
pelle
pelouse
peluche
pendule
penetrer
penible
pensif
penurie
pepite
peplum
perdrix
perforer
periode
permuter
perplexe
persil
perte
peser
petale
petit
petrir
peuple
pharaon
phobie
phoque
photon
phrase
physique
piano
pictural
piece
pierre
pieuvre
pilote
pinceau
pipette
piquer
pirogue
piscine
piston
pivoter
pixel
pizza
placard
plafond
plaisir
planer
plaque
plastron
plateau
pleurer
plexus
pliage
plomb
plonger
pluie
plumage
pochette
poesie
poete
pointe
poirier
poisson
poivre
polaire
policier
pollen
polygone
pommade
pompier
ponctuel
ponderer
poney
portique
position
posseder
posture
potager
poteau
potion
pouce
poulain
poumon
pourpre
poussin
pouvoir
prairie
pratique
precieux
predire
prefixe
prelude
prenom
presence
pretexte
prevoir
primitif
prince
prison
priver
probleme
proceder
prodige
profond
progres
proie
projeter
prologue
promener
propre
prospere
proteger
prouesse
proverbe
prudence
pruneau
psychose
public
puceron
puiser
pulpe
pulsar
punaise
punitif
pupitre
purifier
puzzle
pyramide
quasar
querelle
question
quietude
quitter
quotient
racine
raconter
radieux
ragondin
raideur
raisin
ralentir
rallonge
ramasser
rapide
rasage
ratisser
ravager
ravin
rayonner
reactif
reagir
realiser
reanimer
recevoir
reciter
reclamer
recolter
recruter
reculer
recycler
rediger
redouter
refaire
reflexe
reformer
refrain
refuge
regalien
region
reglage
regulier
reiterer
rejeter
rejouer
relatif
relever
relief
remarque
remede
remise
remonter
remplir
remuer
renard
renfort
renifler
renoncer
rentrer
renvoi
replier
reporter
reprise
reptile
requin
reserve
resineux
resoudre
respect
rester
resultat
retablir
retenir
reticule
retomber
retracer
reunion
reussir
revanche
revivre
revolte
revulsif
richesse
rideau
rieur
rigide
rigoler
rincer
riposter
risible
risque
rituel
rival
riviere
rocheux
romance
rompre
ronce
rondin
roseau
rosier
rotatif
rotor
rotule
rouge
rouille
rouleau
routine
royaume
ruban
rubis
ruche
ruelle
rugueux
ruiner
ruisseau
ruser
rustique
rythme
sabler
saboter
sabre
sacoche
safari
sagesse
saisir
salade
salive
salon
saluer
samedi
sanction
sanglier
sarcasme
sardine
saturer
saugrenu
saumon
sauter
sauvage
savant
savonner
scalpel
scandale
scelerat
scenario
sceptre
schema
science
scinder
score
scrutin
sculpter
seance
secable
secher
secouer
secreter
sedatif
seduire
seigneur
sejour
selectif
semaine
sembler
semence
seminal
senateur
sensible
sentence
separer
sequence
serein
sergent
serieux
serrure
serum
service
sesame
sevir
sevrage
sextuple
sideral
siecle
sieger
siffler
sigle
signal
silence
silicium
simple
sincere
sinistre
siphon
sirop
sismique
situer
skier
social
socle
sodium
soigneux
soldat
soleil
solitude
soluble
sombre
sommeil
somnoler
sonde
songeur
sonnette
sonore
sorcier
sortir
sosie
sottise
soucieux
soudure
souffle
soulever
soupape
source
soutirer
souvenir
spacieux
spatial
special
sphere
spiral
stable
station
sternum
stimulus
stipuler
strict
studieux
stupeur
styliste
sublime
substrat
subtil
subvenir
succes
sucre
suffixe
suggerer
suiveur
sulfate
superbe
supplier
surface
suricate
surmener
surprise
sursaut
survie
suspect
syllabe
symbole
symetrie
synapse
syntaxe
systeme
tabac
tablier
tactile
tailler
talent
talisman
talonner
tambour
tamiser
tangible
tapis
taquiner
tarder
tarif
tartine
tasse
tatami
tatouage
taupe
taureau
taxer
temoin
temporel
tenaille
tendre
teneur
tenir
tension
terminer
terne
terrible
tetine
texte
theme
theorie
therapie
thorax
tibia
tiede
timide
tirelire
tiroir
tissu
titane
titre
tituber
toboggan
tolerant
tomate
tonique
tonneau
toponyme
torche
tordre
tornade
torpille
torrent
torse
tortue
totem
toucher
tournage
tousser
toxine
traction
trafic
tragique
trahir
train
trancher
travail
trefle
tremper
tresor
treuil
triage
tribunal
tricoter
trilogie
triomphe
tripler
triturer
trivial
trombone
tronc
tropical
troupeau
tuile
tulipe
tumulte
tunnel
turbine
tuteur
tutoyer
tuyau
tympan
typhon
typique
tyran
ubuesque
ultime
ultrason
unanime
unifier
union
unique
unitaire
univers
uranium
urbain
urticant
usage
usine
usuel
usure
utile
utopie
vacarme
vaccin
vagabond
vague
vaillant
vaincre
vaisseau
valable
valise
vallon
valve
vampire
vanille
vapeur
varier
vaseux
vassal
vaste
vecteur
vedette
vegetal
vehicule
veinard
veloce
vendredi
venerer
venger
venimeux
ventouse
verdure
verin
vernir
verrou
verser
vertu
veston
veteran
vetuste
vexant
vexer
viaduc
viande
victoire
vidange
video
vignette
vigueur
vilain
village
vinaigre
violon
vipere
virement
virtuose
virus
visage
viseur
vision
visqueux
visuel
vital
vitesse
viticole
vitrine
vivace
vivipare
vocation
voguer
voile
voisin
voiture
volaille
volcan
voltiger
volume
vorace
vortex
voter
vouloir
voyage
voyelle
wagon
xenon
yacht
zebre
zenith
zeste
zoologie`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/italian.js
var wordlist4 = `abaco
abbaglio
abbinato
abete
abisso
abolire
abrasivo
abrogato
accadere
accenno
accusato
acetone
achille
acido
acqua
acre
acrilico
acrobata
acuto
adagio
addebito
addome
adeguato
aderire
adipe
adottare
adulare
affabile
affetto
affisso
affranto
aforisma
afoso
africano
agave
agente
agevole
aggancio
agire
agitare
agonismo
agricolo
agrumeto
aguzzo
alabarda
alato
albatro
alberato
albo
albume
alce
alcolico
alettone
alfa
algebra
aliante
alibi
alimento
allagato
allegro
allievo
allodola
allusivo
almeno
alogeno
alpaca
alpestre
altalena
alterno
alticcio
altrove
alunno
alveolo
alzare
amalgama
amanita
amarena
ambito
ambrato
ameba
america
ametista
amico
ammasso
ammenda
ammirare
ammonito
amore
ampio
ampliare
amuleto
anacardo
anagrafe
analista
anarchia
anatra
anca
ancella
ancora
andare
andrea
anello
angelo
angolare
angusto
anima
annegare
annidato
anno
annuncio
anonimo
anticipo
anzi
apatico
apertura
apode
apparire
appetito
appoggio
approdo
appunto
aprile
arabica
arachide
aragosta
araldica
arancio
aratura
arazzo
arbitro
archivio
ardito
arenile
argento
argine
arguto
aria
armonia
arnese
arredato
arringa
arrosto
arsenico
arso
artefice
arzillo
asciutto
ascolto
asepsi
asettico
asfalto
asino
asola
aspirato
aspro
assaggio
asse
assoluto
assurdo
asta
astenuto
astice
astratto
atavico
ateismo
atomico
atono
attesa
attivare
attorno
attrito
attuale
ausilio
austria
autista
autonomo
autunno
avanzato
avere
avvenire
avviso
avvolgere
azione
azoto
azzimo
azzurro
babele
baccano
bacino
baco
badessa
badilata
bagnato
baita
balcone
baldo
balena
ballata
balzano
bambino
bandire
baraonda
barbaro
barca
baritono
barlume
barocco
basilico
basso
batosta
battuto
baule
bava
bavosa
becco
beffa
belgio
belva
benda
benevole
benigno
benzina
bere
berlina
beta
bibita
bici
bidone
bifido
biga
bilancia
bimbo
binocolo
biologo
bipede
bipolare
birbante
birra
biscotto
bisesto
bisnonno
bisonte
bisturi
bizzarro
blando
blatta
bollito
bonifico
bordo
bosco
botanico
bottino
bozzolo
braccio
bradipo
brama
branca
bravura
bretella
brevetto
brezza
briglia
brillante
brindare
broccolo
brodo
bronzina
brullo
bruno
bubbone
buca
budino
buffone
buio
bulbo
buono
burlone
burrasca
bussola
busta
cadetto
caduco
calamaro
calcolo
calesse
calibro
calmo
caloria
cambusa
camerata
camicia
cammino
camola
campale
canapa
candela
cane
canino
canotto
cantina
capace
capello
capitolo
capogiro
cappero
capra
capsula
carapace
carcassa
cardo
carisma
carovana
carretto
cartolina
casaccio
cascata
caserma
caso
cassone
castello
casuale
catasta
catena
catrame
cauto
cavillo
cedibile
cedrata
cefalo
celebre
cellulare
cena
cenone
centesimo
ceramica
cercare
certo
cerume
cervello
cesoia
cespo
ceto
chela
chiaro
chicca
chiedere
chimera
china
chirurgo
chitarra
ciao
ciclismo
cifrare
cigno
cilindro
ciottolo
circa
cirrosi
citrico
cittadino
ciuffo
civetta
civile
classico
clinica
cloro
cocco
codardo
codice
coerente
cognome
collare
colmato
colore
colposo
coltivato
colza
coma
cometa
commando
comodo
computer
comune
conciso
condurre
conferma
congelare
coniuge
connesso
conoscere
consumo
continuo
convegno
coperto
copione
coppia
copricapo
corazza
cordata
coricato
cornice
corolla
corpo
corredo
corsia
cortese
cosmico
costante
cottura
covato
cratere
cravatta
creato
credere
cremoso
crescita
creta
criceto
crinale
crisi
critico
croce
cronaca
crostata
cruciale
crusca
cucire
cuculo
cugino
cullato
cupola
curatore
cursore
curvo
cuscino
custode
dado
daino
dalmata
damerino
daniela
dannoso
danzare
datato
davanti
davvero
debutto
decennio
deciso
declino
decollo
decreto
dedicato
definito
deforme
degno
delegare
delfino
delirio
delta
demenza
denotato
dentro
deposito
derapata
derivare
deroga
descritto
deserto
desiderio
desumere
detersivo
devoto
diametro
dicembre
diedro
difeso
diffuso
digerire
digitale
diluvio
dinamico
dinnanzi
dipinto
diploma
dipolo
diradare
dire
dirotto
dirupo
disagio
discreto
disfare
disgelo
disposto
distanza
disumano
dito
divano
divelto
dividere
divorato
doblone
docente
doganale
dogma
dolce
domato
domenica
dominare
dondolo
dono
dormire
dote
dottore
dovuto
dozzina
drago
druido
dubbio
dubitare
ducale
duna
duomo
duplice
duraturo
ebano
eccesso
ecco
eclissi
economia
edera
edicola
edile
editoria
educare
egemonia
egli
egoismo
egregio
elaborato
elargire
elegante
elencato
eletto
elevare
elfico
elica
elmo
elsa
eluso
emanato
emblema
emesso
emiro
emotivo
emozione
empirico
emulo
endemico
enduro
energia
enfasi
enoteca
entrare
enzima
epatite
epilogo
episodio
epocale
eppure
equatore
erario
erba
erboso
erede
eremita
erigere
ermetico
eroe
erosivo
errante
esagono
esame
esanime
esaudire
esca
esempio
esercito
esibito
esigente
esistere
esito
esofago
esortato
esoso
espanso
espresso
essenza
esso
esteso
estimare
estonia
estroso
esultare
etilico
etnico
etrusco
etto
euclideo
europa
evaso
evidenza
evitato
evoluto
evviva
fabbrica
faccenda
fachiro
falco
famiglia
fanale
fanfara
fango
fantasma
fare
farfalla
farinoso
farmaco
fascia
fastoso
fasullo
faticare
fato
favoloso
febbre
fecola
fede
fegato
felpa
feltro
femmina
fendere
fenomeno
fermento
ferro
fertile
fessura
festivo
fetta
feudo
fiaba
fiducia
fifa
figurato
filo
finanza
finestra
finire
fiore
fiscale
fisico
fiume
flacone
flamenco
flebo
flemma
florido
fluente
fluoro
fobico
focaccia
focoso
foderato
foglio
folata
folclore
folgore
fondente
fonetico
fonia
fontana
forbito
forchetta
foresta
formica
fornaio
foro
fortezza
forzare
fosfato
fosso
fracasso
frana
frassino
fratello
freccetta
frenata
fresco
frigo
frollino
fronde
frugale
frutta
fucilata
fucsia
fuggente
fulmine
fulvo
fumante
fumetto
fumoso
fune
funzione
fuoco
furbo
furgone
furore
fuso
futile
gabbiano
gaffe
galateo
gallina
galoppo
gambero
gamma
garanzia
garbo
garofano
garzone
gasdotto
gasolio
gastrico
gatto
gaudio
gazebo
gazzella
geco
gelatina
gelso
gemello
gemmato
gene
genitore
gennaio
genotipo
gergo
ghepardo
ghiaccio
ghisa
giallo
gilda
ginepro
giocare
gioiello
giorno
giove
girato
girone
gittata
giudizio
giurato
giusto
globulo
glutine
gnomo
gobba
golf
gomito
gommone
gonfio
gonna
governo
gracile
grado
grafico
grammo
grande
grattare
gravoso
grazia
greca
gregge
grifone
grigio
grinza
grotta
gruppo
guadagno
guaio
guanto
guardare
gufo
guidare
ibernato
icona
identico
idillio
idolo
idra
idrico
idrogeno
igiene
ignaro
ignorato
ilare
illeso
illogico
illudere
imballo
imbevuto
imbocco
imbuto
immane
immerso
immolato
impacco
impeto
impiego
importo
impronta
inalare
inarcare
inattivo
incanto
incendio
inchino
incisivo
incluso
incontro
incrocio
incubo
indagine
india
indole
inedito
infatti
infilare
inflitto
ingaggio
ingegno
inglese
ingordo
ingrosso
innesco
inodore
inoltrare
inondato
insano
insetto
insieme
insonnia
insulina
intasato
intero
intonaco
intuito
inumidire
invalido
invece
invito
iperbole
ipnotico
ipotesi
ippica
iride
irlanda
ironico
irrigato
irrorare
isolato
isotopo
isterico
istituto
istrice
italia
iterare
labbro
labirinto
lacca
lacerato
lacrima
lacuna
laddove
lago
lampo
lancetta
lanterna
lardoso
larga
laringe
lastra
latenza
latino
lattuga
lavagna
lavoro
legale
leggero
lembo
lentezza
lenza
leone
lepre
lesivo
lessato
lesto
letterale
leva
levigato
libero
lido
lievito
lilla
limatura
limitare
limpido
lineare
lingua
liquido
lira
lirica
lisca
lite
litigio
livrea
locanda
lode
logica
lombare
londra
longevo
loquace
lorenzo
loto
lotteria
luce
lucidato
lumaca
luminoso
lungo
lupo
luppolo
lusinga
lusso
lutto
macabro
macchina
macero
macinato
madama
magico
maglia
magnete
magro
maiolica
malafede
malgrado
malinteso
malsano
malto
malumore
mana
mancia
mandorla
mangiare
manifesto
mannaro
manovra
mansarda
mantide
manubrio
mappa
maratona
marcire
maretta
marmo
marsupio
maschera
massaia
mastino
materasso
matricola
mattone
maturo
mazurca
meandro
meccanico
mecenate
medesimo
meditare
mega
melassa
melis
melodia
meninge
meno
mensola
mercurio
merenda
merlo
meschino
mese
messere
mestolo
metallo
metodo
mettere
miagolare
mica
micelio
michele
microbo
midollo
miele
migliore
milano
milite
mimosa
minerale
mini
minore
mirino
mirtillo
miscela
missiva
misto
misurare
mitezza
mitigare
mitra
mittente
mnemonico
modello
modifica
modulo
mogano
mogio
mole
molosso
monastero
monco
mondina
monetario
monile
monotono
monsone
montato
monviso
mora
mordere
morsicato
mostro
motivato
motosega
motto
movenza
movimento
mozzo
mucca
mucosa
muffa
mughetto
mugnaio
mulatto
mulinello
multiplo
mummia
munto
muovere
murale
musa
muscolo
musica
mutevole
muto
nababbo
nafta
nanometro
narciso
narice
narrato
nascere
nastrare
naturale
nautica
naviglio
nebulosa
necrosi
negativo
negozio
nemmeno
neofita
neretto
nervo
nessuno
nettuno
neutrale
neve
nevrotico
nicchia
ninfa
nitido
nobile
nocivo
nodo
nome
nomina
nordico
normale
norvegese
nostrano
notare
notizia
notturno
novella
nucleo
nulla
numero
nuovo
nutrire
nuvola
nuziale
oasi
obbedire
obbligo
obelisco
oblio
obolo
obsoleto
occasione
occhio
occidente
occorrere
occultare
ocra
oculato
odierno
odorare
offerta
offrire
offuscato
oggetto
oggi
ognuno
olandese
olfatto
oliato
oliva
ologramma
oltre
omaggio
ombelico
ombra
omega
omissione
ondoso
onere
onice
onnivoro
onorevole
onta
operato
opinione
opposto
oracolo
orafo
ordine
orecchino
orefice
orfano
organico
origine
orizzonte
orma
ormeggio
ornativo
orologio
orrendo
orribile
ortensia
ortica
orzata
orzo
osare
oscurare
osmosi
ospedale
ospite
ossa
ossidare
ostacolo
oste
otite
otre
ottagono
ottimo
ottobre
ovale
ovest
ovino
oviparo
ovocito
ovunque
ovviare
ozio
pacchetto
pace
pacifico
padella
padrone
paese
paga
pagina
palazzina
palesare
pallido
palo
palude
pandoro
pannello
paolo
paonazzo
paprica
parabola
parcella
parere
pargolo
pari
parlato
parola
partire
parvenza
parziale
passivo
pasticca
patacca
patologia
pattume
pavone
peccato
pedalare
pedonale
peggio
peloso
penare
pendice
penisola
pennuto
penombra
pensare
pentola
pepe
pepita
perbene
percorso
perdonato
perforare
pergamena
periodo
permesso
perno
perplesso
persuaso
pertugio
pervaso
pesatore
pesista
peso
pestifero
petalo
pettine
petulante
pezzo
piacere
pianta
piattino
piccino
picozza
piega
pietra
piffero
pigiama
pigolio
pigro
pila
pilifero
pillola
pilota
pimpante
pineta
pinna
pinolo
pioggia
piombo
piramide
piretico
pirite
pirolisi
pitone
pizzico
placebo
planare
plasma
platano
plenario
pochezza
poderoso
podismo
poesia
poggiare
polenta
poligono
pollice
polmonite
polpetta
polso
poltrona
polvere
pomice
pomodoro
ponte
popoloso
porfido
poroso
porpora
porre
portata
posa
positivo
possesso
postulato
potassio
potere
pranzo
prassi
pratica
precluso
predica
prefisso
pregiato
prelievo
premere
prenotare
preparato
presenza
pretesto
prevalso
prima
principe
privato
problema
procura
produrre
profumo
progetto
prolunga
promessa
pronome
proposta
proroga
proteso
prova
prudente
prugna
prurito
psiche
pubblico
pudica
pugilato
pugno
pulce
pulito
pulsante
puntare
pupazzo
pupilla
puro
quadro
qualcosa
quasi
querela
quota
raccolto
raddoppio
radicale
radunato
raffica
ragazzo
ragione
ragno
ramarro
ramingo
ramo
randagio
rantolare
rapato
rapina
rappreso
rasatura
raschiato
rasente
rassegna
rastrello
rata
ravveduto
reale
recepire
recinto
recluta
recondito
recupero
reddito
redimere
regalato
registro
regola
regresso
relazione
remare
remoto
renna
replica
reprimere
reputare
resa
residente
responso
restauro
rete
retina
retorica
rettifica
revocato
riassunto
ribadire
ribelle
ribrezzo
ricarica
ricco
ricevere
riciclato
ricordo
ricreduto
ridicolo
ridurre
rifasare
riflesso
riforma
rifugio
rigare
rigettato
righello
rilassato
rilevato
rimanere
rimbalzo
rimedio
rimorchio
rinascita
rincaro
rinforzo
rinnovo
rinomato
rinsavito
rintocco
rinuncia
rinvenire
riparato
ripetuto
ripieno
riportare
ripresa
ripulire
risata
rischio
riserva
risibile
riso
rispetto
ristoro
risultato
risvolto
ritardo
ritegno
ritmico
ritrovo
riunione
riva
riverso
rivincita
rivolto
rizoma
roba
robotico
robusto
roccia
roco
rodaggio
rodere
roditore
rogito
rollio
romantico
rompere
ronzio
rosolare
rospo
rotante
rotondo
rotula
rovescio
rubizzo
rubrica
ruga
rullino
rumine
rumoroso
ruolo
rupe
russare
rustico
sabato
sabbiare
sabotato
sagoma
salasso
saldatura
salgemma
salivare
salmone
salone
saltare
saluto
salvo
sapere
sapido
saporito
saraceno
sarcasmo
sarto
sassoso
satellite
satira
satollo
saturno
savana
savio
saziato
sbadiglio
sbalzo
sbancato
sbarra
sbattere
sbavare
sbendare
sbirciare
sbloccato
sbocciato
sbrinare
sbruffone
sbuffare
scabroso
scadenza
scala
scambiare
scandalo
scapola
scarso
scatenare
scavato
scelto
scenico
scettro
scheda
schiena
sciarpa
scienza
scindere
scippo
sciroppo
scivolo
sclerare
scodella
scolpito
scomparto
sconforto
scoprire
scorta
scossone
scozzese
scriba
scrollare
scrutinio
scuderia
scultore
scuola
scuro
scusare
sdebitare
sdoganare
seccatura
secondo
sedano
seggiola
segnalato
segregato
seguito
selciato
selettivo
sella
selvaggio
semaforo
sembrare
seme
seminato
sempre
senso
sentire
sepolto
sequenza
serata
serbato
sereno
serio
serpente
serraglio
servire
sestina
setola
settimana
sfacelo
sfaldare
sfamato
sfarzoso
sfaticato
sfera
sfida
sfilato
sfinge
sfocato
sfoderare
sfogo
sfoltire
sforzato
sfratto
sfruttato
sfuggito
sfumare
sfuso
sgabello
sgarbato
sgonfiare
sgorbio
sgrassato
sguardo
sibilo
siccome
sierra
sigla
signore
silenzio
sillaba
simbolo
simpatico
simulato
sinfonia
singolo
sinistro
sino
sintesi
sinusoide
sipario
sisma
sistole
situato
slitta
slogatura
sloveno
smarrito
smemorato
smentito
smeraldo
smilzo
smontare
smottato
smussato
snellire
snervato
snodo
sobbalzo
sobrio
soccorso
sociale
sodale
soffitto
sogno
soldato
solenne
solido
sollazzo
solo
solubile
solvente
somatico
somma
sonda
sonetto
sonnifero
sopire
soppeso
sopra
sorgere
sorpasso
sorriso
sorso
sorteggio
sorvolato
sospiro
sosta
sottile
spada
spalla
spargere
spatola
spavento
spazzola
specie
spedire
spegnere
spelatura
speranza
spessore
spettrale
spezzato
spia
spigoloso
spillato
spinoso
spirale
splendido
sportivo
sposo
spranga
sprecare
spronato
spruzzo
spuntino
squillo
sradicare
srotolato
stabile
stacco
staffa
stagnare
stampato
stantio
starnuto
stasera
statuto
stelo
steppa
sterzo
stiletto
stima
stirpe
stivale
stizzoso
stonato
storico
strappo
stregato
stridulo
strozzare
strutto
stuccare
stufo
stupendo
subentro
succoso
sudore
suggerito
sugo
sultano
suonare
superbo
supporto
surgelato
surrogato
sussurro
sutura
svagare
svedese
sveglio
svelare
svenuto
svezia
sviluppo
svista
svizzera
svolta
svuotare
tabacco
tabulato
tacciare
taciturno
tale
talismano
tampone
tannino
tara
tardivo
targato
tariffa
tarpare
tartaruga
tasto
tattico
taverna
tavolata
tazza
teca
tecnico
telefono
temerario
tempo
temuto
tendone
tenero
tensione
tentacolo
teorema
terme
terrazzo
terzetto
tesi
tesserato
testato
tetro
tettoia
tifare
tigella
timbro
tinto
tipico
tipografo
tiraggio
tiro
titanio
titolo
titubante
tizio
tizzone
toccare
tollerare
tolto
tombola
tomo
tonfo
tonsilla
topazio
topologia
toppa
torba
tornare
torrone
tortora
toscano
tossire
tostatura
totano
trabocco
trachea
trafila
tragedia
tralcio
tramonto
transito
trapano
trarre
trasloco
trattato
trave
treccia
tremolio
trespolo
tributo
tricheco
trifoglio
trillo
trincea
trio
tristezza
triturato
trivella
tromba
trono
troppo
trottola
trovare
truccato
tubatura
tuffato
tulipano
tumulto
tunisia
turbare
turchino
tuta
tutela
ubicato
uccello
uccisore
udire
uditivo
uffa
ufficio
uguale
ulisse
ultimato
umano
umile
umorismo
uncinetto
ungere
ungherese
unicorno
unificato
unisono
unitario
unte
uovo
upupa
uragano
urgenza
urlo
usanza
usato
uscito
usignolo
usuraio
utensile
utilizzo
utopia
vacante
vaccinato
vagabondo
vagliato
valanga
valgo
valico
valletta
valoroso
valutare
valvola
vampata
vangare
vanitoso
vano
vantaggio
vanvera
vapore
varano
varcato
variante
vasca
vedetta
vedova
veduto
vegetale
veicolo
velcro
velina
velluto
veloce
venato
vendemmia
vento
verace
verbale
vergogna
verifica
vero
verruca
verticale
vescica
vessillo
vestale
veterano
vetrina
vetusto
viandante
vibrante
vicenda
vichingo
vicinanza
vidimare
vigilia
vigneto
vigore
vile
villano
vimini
vincitore
viola
vipera
virgola
virologo
virulento
viscoso
visione
vispo
vissuto
visura
vita
vitello
vittima
vivanda
vivido
viziare
voce
voga
volatile
volere
volpe
voragine
vulcano
zampogna
zanna
zappato
zattera
zavorra
zefiro
zelante
zelo
zenzero
zerbino
zibetto
zinco
zircone
zitto
zolla
zotico
zucchero
zufolo
zulu
zuppa`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/japanese.js
var wordlist5 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/korean.js
var wordlist6 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/portuguese.js
var wordlist7 = `abacate
abaixo
abalar
abater
abduzir
abelha
aberto
abismo
abotoar
abranger
abreviar
abrigar
abrupto
absinto
absoluto
absurdo
abutre
acabado
acalmar
acampar
acanhar
acaso
aceitar
acelerar
acenar
acervo
acessar
acetona
achatar
acidez
acima
acionado
acirrar
aclamar
aclive
acolhida
acomodar
acoplar
acordar
acumular
acusador
adaptar
adega
adentro
adepto
adequar
aderente
adesivo
adeus
adiante
aditivo
adjetivo
adjunto
admirar
adorar
adquirir
adubo
adverso
advogado
aeronave
afastar
aferir
afetivo
afinador
afivelar
aflito
afluente
afrontar
agachar
agarrar
agasalho
agenciar
agilizar
agiota
agitado
agora
agradar
agreste
agrupar
aguardar
agulha
ajoelhar
ajudar
ajustar
alameda
alarme
alastrar
alavanca
albergue
albino
alcatra
aldeia
alecrim
alegria
alertar
alface
alfinete
algum
alheio
aliar
alicate
alienar
alinhar
aliviar
almofada
alocar
alpiste
alterar
altitude
alucinar
alugar
aluno
alusivo
alvo
amaciar
amador
amarelo
amassar
ambas
ambiente
ameixa
amenizar
amido
amistoso
amizade
amolador
amontoar
amoroso
amostra
amparar
ampliar
ampola
anagrama
analisar
anarquia
anatomia
andaime
anel
anexo
angular
animar
anjo
anomalia
anotado
ansioso
anterior
anuidade
anunciar
anzol
apagador
apalpar
apanhado
apego
apelido
apertada
apesar
apetite
apito
aplauso
aplicada
apoio
apontar
aposta
aprendiz
aprovar
aquecer
arame
aranha
arara
arcada
ardente
areia
arejar
arenito
aresta
argiloso
argola
arma
arquivo
arraial
arrebate
arriscar
arroba
arrumar
arsenal
arterial
artigo
arvoredo
asfaltar
asilado
aspirar
assador
assinar
assoalho
assunto
astral
atacado
atadura
atalho
atarefar
atear
atender
aterro
ateu
atingir
atirador
ativo
atoleiro
atracar
atrevido
atriz
atual
atum
auditor
aumentar
aura
aurora
autismo
autoria
autuar
avaliar
avante
avaria
avental
avesso
aviador
avisar
avulso
axila
azarar
azedo
azeite
azulejo
babar
babosa
bacalhau
bacharel
bacia
bagagem
baiano
bailar
baioneta
bairro
baixista
bajular
baleia
baliza
balsa
banal
bandeira
banho
banir
banquete
barato
barbado
baronesa
barraca
barulho
baseado
bastante
batata
batedor
batida
batom
batucar
baunilha
beber
beijo
beirada
beisebol
beldade
beleza
belga
beliscar
bendito
bengala
benzer
berimbau
berlinda
berro
besouro
bexiga
bezerro
bico
bicudo
bienal
bifocal
bifurcar
bigorna
bilhete
bimestre
bimotor
biologia
biombo
biosfera
bipolar
birrento
biscoito
bisneto
bispo
bissexto
bitola
bizarro
blindado
bloco
bloquear
boato
bobagem
bocado
bocejo
bochecha
boicotar
bolada
boletim
bolha
bolo
bombeiro
bonde
boneco
bonita
borbulha
borda
boreal
borracha
bovino
boxeador
branco
brasa
braveza
breu
briga
brilho
brincar
broa
brochura
bronzear
broto
bruxo
bucha
budismo
bufar
bule
buraco
busca
busto
buzina
cabana
cabelo
cabide
cabo
cabrito
cacau
cacetada
cachorro
cacique
cadastro
cadeado
cafezal
caiaque
caipira
caixote
cajado
caju
calafrio
calcular
caldeira
calibrar
calmante
calota
camada
cambista
camisa
camomila
campanha
camuflar
canavial
cancelar
caneta
canguru
canhoto
canivete
canoa
cansado
cantar
canudo
capacho
capela
capinar
capotar
capricho
captador
capuz
caracol
carbono
cardeal
careca
carimbar
carneiro
carpete
carreira
cartaz
carvalho
casaco
casca
casebre
castelo
casulo
catarata
cativar
caule
causador
cautelar
cavalo
caverna
cebola
cedilha
cegonha
celebrar
celular
cenoura
censo
centeio
cercar
cerrado
certeiro
cerveja
cetim
cevada
chacota
chaleira
chamado
chapada
charme
chatice
chave
chefe
chegada
cheiro
cheque
chicote
chifre
chinelo
chocalho
chover
chumbo
chutar
chuva
cicatriz
ciclone
cidade
cidreira
ciente
cigana
cimento
cinto
cinza
ciranda
circuito
cirurgia
citar
clareza
clero
clicar
clone
clube
coado
coagir
cobaia
cobertor
cobrar
cocada
coelho
coentro
coeso
cogumelo
coibir
coifa
coiote
colar
coleira
colher
colidir
colmeia
colono
coluna
comando
combinar
comentar
comitiva
comover
complexo
comum
concha
condor
conectar
confuso
congelar
conhecer
conjugar
consumir
contrato
convite
cooperar
copeiro
copiador
copo
coquetel
coragem
cordial
corneta
coronha
corporal
correio
cortejo
coruja
corvo
cosseno
costela
cotonete
couro
couve
covil
cozinha
cratera
cravo
creche
credor
creme
crer
crespo
criada
criminal
crioulo
crise
criticar
crosta
crua
cruzeiro
cubano
cueca
cuidado
cujo
culatra
culminar
culpar
cultura
cumprir
cunhado
cupido
curativo
curral
cursar
curto
cuspir
custear
cutelo
damasco
datar
debater
debitar
deboche
debulhar
decalque
decimal
declive
decote
decretar
dedal
dedicado
deduzir
defesa
defumar
degelo
degrau
degustar
deitado
deixar
delator
delegado
delinear
delonga
demanda
demitir
demolido
dentista
depenado
depilar
depois
depressa
depurar
deriva
derramar
desafio
desbotar
descanso
desenho
desfiado
desgaste
desigual
deslize
desmamar
desova
despesa
destaque
desviar
detalhar
detentor
detonar
detrito
deusa
dever
devido
devotado
dezena
diagrama
dialeto
didata
difuso
digitar
dilatado
diluente
diminuir
dinastia
dinheiro
diocese
direto
discreta
disfarce
disparo
disquete
dissipar
distante
ditador
diurno
diverso
divisor
divulgar
dizer
dobrador
dolorido
domador
dominado
donativo
donzela
dormente
dorsal
dosagem
dourado
doutor
drenagem
drible
drogaria
duelar
duende
dueto
duplo
duquesa
durante
duvidoso
eclodir
ecoar
ecologia
edificar
edital
educado
efeito
efetivar
ejetar
elaborar
eleger
eleitor
elenco
elevador
eliminar
elogiar
embargo
embolado
embrulho
embutido
emenda
emergir
emissor
empatia
empenho
empinado
empolgar
emprego
empurrar
emulador
encaixe
encenado
enchente
encontro
endeusar
endossar
enfaixar
enfeite
enfim
engajado
engenho
englobar
engomado
engraxar
enguia
enjoar
enlatar
enquanto
enraizar
enrolado
enrugar
ensaio
enseada
ensino
ensopado
entanto
enteado
entidade
entortar
entrada
entulho
envergar
enviado
envolver
enxame
enxerto
enxofre
enxuto
epiderme
equipar
ereto
erguido
errata
erva
ervilha
esbanjar
esbelto
escama
escola
escrita
escuta
esfinge
esfolar
esfregar
esfumado
esgrima
esmalte
espanto
espelho
espiga
esponja
espreita
espumar
esquerda
estaca
esteira
esticar
estofado
estrela
estudo
esvaziar
etanol
etiqueta
euforia
europeu
evacuar
evaporar
evasivo
eventual
evidente
evoluir
exagero
exalar
examinar
exato
exausto
excesso
excitar
exclamar
executar
exemplo
exibir
exigente
exonerar
expandir
expelir
expirar
explanar
exposto
expresso
expulsar
externo
extinto
extrato
fabricar
fabuloso
faceta
facial
fada
fadiga
faixa
falar
falta
familiar
fandango
fanfarra
fantoche
fardado
farelo
farinha
farofa
farpa
fartura
fatia
fator
favorita
faxina
fazenda
fechado
feijoada
feirante
felino
feminino
fenda
feno
fera
feriado
ferrugem
ferver
festejar
fetal
feudal
fiapo
fibrose
ficar
ficheiro
figurado
fileira
filho
filme
filtrar
firmeza
fisgada
fissura
fita
fivela
fixador
fixo
flacidez
flamingo
flanela
flechada
flora
flutuar
fluxo
focal
focinho
fofocar
fogo
foguete
foice
folgado
folheto
forjar
formiga
forno
forte
fosco
fossa
fragata
fralda
frango
frasco
fraterno
freira
frente
fretar
frieza
friso
fritura
fronha
frustrar
fruteira
fugir
fulano
fuligem
fundar
fungo
funil
furador
furioso
futebol
gabarito
gabinete
gado
gaiato
gaiola
gaivota
galega
galho
galinha
galocha
ganhar
garagem
garfo
gargalo
garimpo
garoupa
garrafa
gasoduto
gasto
gata
gatilho
gaveta
gazela
gelado
geleia
gelo
gemada
gemer
gemido
generoso
gengiva
genial
genoma
genro
geologia
gerador
germinar
gesso
gestor
ginasta
gincana
gingado
girafa
girino
glacial
glicose
global
glorioso
goela
goiaba
golfe
golpear
gordura
gorjeta
gorro
gostoso
goteira
governar
gracejo
gradual
grafite
gralha
grampo
granada
gratuito
graveto
graxa
grego
grelhar
greve
grilo
grisalho
gritaria
grosso
grotesco
grudado
grunhido
gruta
guache
guarani
guaxinim
guerrear
guiar
guincho
guisado
gula
guloso
guru
habitar
harmonia
haste
haver
hectare
herdar
heresia
hesitar
hiato
hibernar
hidratar
hiena
hino
hipismo
hipnose
hipoteca
hoje
holofote
homem
honesto
honrado
hormonal
hospedar
humorado
iate
ideia
idoso
ignorado
igreja
iguana
ileso
ilha
iludido
iluminar
ilustrar
imagem
imediato
imenso
imersivo
iminente
imitador
imortal
impacto
impedir
implante
impor
imprensa
impune
imunizar
inalador
inapto
inativo
incenso
inchar
incidir
incluir
incolor
indeciso
indireto
indutor
ineficaz
inerente
infantil
infestar
infinito
inflamar
informal
infrator
ingerir
inibido
inicial
inimigo
injetar
inocente
inodoro
inovador
inox
inquieto
inscrito
inseto
insistir
inspetor
instalar
insulto
intacto
integral
intimar
intocado
intriga
invasor
inverno
invicto
invocar
iogurte
iraniano
ironizar
irreal
irritado
isca
isento
isolado
isqueiro
italiano
janeiro
jangada
janta
jararaca
jardim
jarro
jasmim
jato
javali
jazida
jejum
joaninha
joelhada
jogador
joia
jornal
jorrar
jovem
juba
judeu
judoca
juiz
julgador
julho
jurado
jurista
juro
justa
labareda
laboral
lacre
lactante
ladrilho
lagarta
lagoa
laje
lamber
lamentar
laminar
lampejo
lanche
lapidar
lapso
laranja
lareira
largura
lasanha
lastro
lateral
latido
lavanda
lavoura
lavrador
laxante
lazer
lealdade
lebre
legado
legendar
legista
leigo
leiloar
leitura
lembrete
leme
lenhador
lentilha
leoa
lesma
leste
letivo
letreiro
levar
leveza
levitar
liberal
libido
liderar
ligar
ligeiro
limitar
limoeiro
limpador
linda
linear
linhagem
liquidez
listagem
lisura
litoral
livro
lixa
lixeira
locador
locutor
lojista
lombo
lona
longe
lontra
lorde
lotado
loteria
loucura
lousa
louvar
luar
lucidez
lucro
luneta
lustre
lutador
luva
macaco
macete
machado
macio
madeira
madrinha
magnata
magreza
maior
mais
malandro
malha
malote
maluco
mamilo
mamoeiro
mamute
manada
mancha
mandato
manequim
manhoso
manivela
manobrar
mansa
manter
manusear
mapeado
maquinar
marcador
maresia
marfim
margem
marinho
marmita
maroto
marquise
marreco
martelo
marujo
mascote
masmorra
massagem
mastigar
matagal
materno
matinal
matutar
maxilar
medalha
medida
medusa
megafone
meiga
melancia
melhor
membro
memorial
menino
menos
mensagem
mental
merecer
mergulho
mesada
mesclar
mesmo
mesquita
mestre
metade
meteoro
metragem
mexer
mexicano
micro
migalha
migrar
milagre
milenar
milhar
mimado
minerar
minhoca
ministro
minoria
miolo
mirante
mirtilo
misturar
mocidade
moderno
modular
moeda
moer
moinho
moita
moldura
moleza
molho
molinete
molusco
montanha
moqueca
morango
morcego
mordomo
morena
mosaico
mosquete
mostarda
motel
motim
moto
motriz
muda
muito
mulata
mulher
multar
mundial
munido
muralha
murcho
muscular
museu
musical
nacional
nadador
naja
namoro
narina
narrado
nascer
nativa
natureza
navalha
navegar
navio
neblina
nebuloso
negativa
negociar
negrito
nervoso
neta
neural
nevasca
nevoeiro
ninar
ninho
nitidez
nivelar
nobreza
noite
noiva
nomear
nominal
nordeste
nortear
notar
noticiar
noturno
novelo
novilho
novo
nublado
nudez
numeral
nupcial
nutrir
nuvem
obcecado
obedecer
objetivo
obrigado
obscuro
obstetra
obter
obturar
ocidente
ocioso
ocorrer
oculista
ocupado
ofegante
ofensiva
oferenda
oficina
ofuscado
ogiva
olaria
oleoso
olhar
oliveira
ombro
omelete
omisso
omitir
ondulado
oneroso
ontem
opcional
operador
oponente
oportuno
oposto
orar
orbitar
ordem
ordinal
orfanato
orgasmo
orgulho
oriental
origem
oriundo
orla
ortodoxo
orvalho
oscilar
ossada
osso
ostentar
otimismo
ousadia
outono
outubro
ouvido
ovelha
ovular
oxidar
oxigenar
pacato
paciente
pacote
pactuar
padaria
padrinho
pagar
pagode
painel
pairar
paisagem
palavra
palestra
palheta
palito
palmada
palpitar
pancada
panela
panfleto
panqueca
pantanal
papagaio
papelada
papiro
parafina
parcial
pardal
parede
partida
pasmo
passado
pastel
patamar
patente
patinar
patrono
paulada
pausar
peculiar
pedalar
pedestre
pediatra
pedra
pegada
peitoral
peixe
pele
pelicano
penca
pendurar
peneira
penhasco
pensador
pente
perceber
perfeito
pergunta
perito
permitir
perna
perplexo
persiana
pertence
peruca
pescado
pesquisa
pessoa
petiscar
piada
picado
piedade
pigmento
pilastra
pilhado
pilotar
pimenta
pincel
pinguim
pinha
pinote
pintar
pioneiro
pipoca
piquete
piranha
pires
pirueta
piscar
pistola
pitanga
pivete
planta
plaqueta
platina
plebeu
plumagem
pluvial
pneu
poda
poeira
poetisa
polegada
policiar
poluente
polvilho
pomar
pomba
ponderar
pontaria
populoso
porta
possuir
postal
pote
poupar
pouso
povoar
praia
prancha
prato
praxe
prece
predador
prefeito
premiar
prensar
preparar
presilha
pretexto
prevenir
prezar
primata
princesa
prisma
privado
processo
produto
profeta
proibido
projeto
prometer
propagar
prosa
protetor
provador
publicar
pudim
pular
pulmonar
pulseira
punhal
punir
pupilo
pureza
puxador
quadra
quantia
quarto
quase
quebrar
queda
queijo
quente
querido
quimono
quina
quiosque
rabanada
rabisco
rachar
racionar
radial
raiar
rainha
raio
raiva
rajada
ralado
ramal
ranger
ranhura
rapadura
rapel
rapidez
raposa
raquete
raridade
rasante
rascunho
rasgar
raspador
rasteira
rasurar
ratazana
ratoeira
realeza
reanimar
reaver
rebaixar
rebelde
rebolar
recado
recente
recheio
recibo
recordar
recrutar
recuar
rede
redimir
redonda
reduzida
reenvio
refinar
refletir
refogar
refresco
refugiar
regalia
regime
regra
reinado
reitor
rejeitar
relativo
remador
remendo
remorso
renovado
reparo
repelir
repleto
repolho
represa
repudiar
requerer
resenha
resfriar
resgatar
residir
resolver
respeito
ressaca
restante
resumir
retalho
reter
retirar
retomada
retratar
revelar
revisor
revolta
riacho
rica
rigidez
rigoroso
rimar
ringue
risada
risco
risonho
robalo
rochedo
rodada
rodeio
rodovia
roedor
roleta
romano
roncar
rosado
roseira
rosto
rota
roteiro
rotina
rotular
rouco
roupa
roxo
rubro
rugido
rugoso
ruivo
rumo
rupestre
russo
sabor
saciar
sacola
sacudir
sadio
safira
saga
sagrada
saibro
salada
saleiro
salgado
saliva
salpicar
salsicha
saltar
salvador
sambar
samurai
sanar
sanfona
sangue
sanidade
sapato
sarda
sargento
sarjeta
saturar
saudade
saxofone
sazonal
secar
secular
seda
sedento
sediado
sedoso
sedutor
segmento
segredo
segundo
seiva
seleto
selvagem
semanal
semente
senador
senhor
sensual
sentado
separado
sereia
seringa
serra
servo
setembro
setor
sigilo
silhueta
silicone
simetria
simpatia
simular
sinal
sincero
singular
sinopse
sintonia
sirene
siri
situado
soberano
sobra
socorro
sogro
soja
solda
soletrar
solteiro
sombrio
sonata
sondar
sonegar
sonhador
sono
soprano
soquete
sorrir
sorteio
sossego
sotaque
soterrar
sovado
sozinho
suavizar
subida
submerso
subsolo
subtrair
sucata
sucesso
suco
sudeste
sufixo
sugador
sugerir
sujeito
sulfato
sumir
suor
superior
suplicar
suposto
suprimir
surdina
surfista
surpresa
surreal
surtir
suspiro
sustento
tabela
tablete
tabuada
tacho
tagarela
talher
talo
talvez
tamanho
tamborim
tampa
tangente
tanto
tapar
tapioca
tardio
tarefa
tarja
tarraxa
tatuagem
taurino
taxativo
taxista
teatral
tecer
tecido
teclado
tedioso
teia
teimar
telefone
telhado
tempero
tenente
tensor
tentar
termal
terno
terreno
tese
tesoura
testado
teto
textura
texugo
tiara
tigela
tijolo
timbrar
timidez
tingido
tinteiro
tiragem
titular
toalha
tocha
tolerar
tolice
tomada
tomilho
tonel
tontura
topete
tora
torcido
torneio
torque
torrada
torto
tostar
touca
toupeira
toxina
trabalho
tracejar
tradutor
trafegar
trajeto
trama
trancar
trapo
traseiro
tratador
travar
treino
tremer
trepidar
trevo
triagem
tribo
triciclo
tridente
trilogia
trindade
triplo
triturar
triunfal
trocar
trombeta
trova
trunfo
truque
tubular
tucano
tudo
tulipa
tupi
turbo
turma
turquesa
tutelar
tutorial
uivar
umbigo
unha
unidade
uniforme
urologia
urso
urtiga
urubu
usado
usina
usufruir
vacina
vadiar
vagaroso
vaidoso
vala
valente
validade
valores
vantagem
vaqueiro
varanda
vareta
varrer
vascular
vasilha
vassoura
vazar
vazio
veado
vedar
vegetar
veicular
veleiro
velhice
veludo
vencedor
vendaval
venerar
ventre
verbal
verdade
vereador
vergonha
vermelho
verniz
versar
vertente
vespa
vestido
vetorial
viaduto
viagem
viajar
viatura
vibrador
videira
vidraria
viela
viga
vigente
vigiar
vigorar
vilarejo
vinco
vinheta
vinil
violeta
virada
virtude
visitar
visto
vitral
viveiro
vizinho
voador
voar
vogal
volante
voleibol
voltagem
volumoso
vontade
vulto
vuvuzela
xadrez
xarope
xeque
xeretar
xerife
xingar
zangado
zarpar
zebu
zelador
zombar
zoologia
zumbido`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/simplified-chinese.js
var wordlist8 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/spanish.js
var wordlist9 = `abaco
abdomen
abeja
abierto
abogado
abono
aborto
abrazo
abrir
abuelo
abuso
acabar
academia
acceso
accion
aceite
acelga
acento
aceptar
acido
aclarar
acne
acoger
acoso
activo
acto
actriz
actuar
acudir
acuerdo
acusar
adicto
admitir
adoptar
adorno
aduana
adulto
aereo
afectar
aficion
afinar
afirmar
agil
agitar
agonia
agosto
agotar
agregar
agrio
agua
agudo
aguila
aguja
ahogo
ahorro
aire
aislar
ajedrez
ajeno
ajuste
alacran
alambre
alarma
alba
album
alcalde
aldea
alegre
alejar
alerta
aleta
alfiler
alga
algodon
aliado
aliento
alivio
alma
almeja
almibar
altar
alteza
altivo
alto
altura
alumno
alzar
amable
amante
amapola
amargo
amasar
ambar
ambito
ameno
amigo
amistad
amor
amparo
amplio
ancho
anciano
ancla
andar
anden
anemia
angulo
anillo
animo
anis
anotar
antena
antiguo
antojo
anual
anular
anuncio
anadir
anejo
ano
apagar
aparato
apetito
apio
aplicar
apodo
aporte
apoyo
aprender
aprobar
apuesta
apuro
arado
arana
arar
arbitro
arbol
arbusto
archivo
arco
arder
ardilla
arduo
area
arido
aries
armonia
arnes
aroma
arpa
arpon
arreglo
arroz
arruga
arte
artista
asa
asado
asalto
ascenso
asegurar
aseo
asesor
asiento
asilo
asistir
asno
asombro
aspero
astilla
astro
astuto
asumir
asunto
atajo
ataque
atar
atento
ateo
atico
atleta
atomo
atraer
atroz
atun
audaz
audio
auge
aula
aumento
ausente
autor
aval
avance
avaro
ave
avellana
avena
avestruz
avion
aviso
ayer
ayuda
ayuno
azafran
azar
azote
azucar
azufre
azul
baba
babor
bache
bahia
baile
bajar
balanza
balcon
balde
bambu
banco
banda
bano
barba
barco
barniz
barro
bascula
baston
basura
batalla
bateria
batir
batuta
baul
bazar
bebe
bebida
bello
besar
beso
bestia
bicho
bien
bingo
blanco
bloque
blusa
boa
bobina
bobo
boca
bocina
boda
bodega
boina
bola
bolero
bolsa
bomba
bondad
bonito
bono
bonsai
borde
borrar
bosque
bote
botin
boveda
bozal
bravo
brazo
brecha
breve
brillo
brinco
brisa
broca
broma
bronce
brote
bruja
brusco
bruto
buceo
bucle
bueno
buey
bufanda
bufon
buho
buitre
bulto
burbuja
burla
burro
buscar
butaca
buzon
caballo
cabeza
cabina
cabra
cacao
cadaver
cadena
caer
cafe
caida
caiman
caja
cajon
cal
calamar
calcio
caldo
calidad
calle
calma
calor
calvo
cama
cambio
camello
camino
campo
cancer
candil
canela
canguro
canica
canto
cana
canon
caoba
caos
capaz
capitan
capote
captar
capucha
cara
carbon
carcel
careta
carga
carino
carne
carpeta
carro
carta
casa
casco
casero
caspa
castor
catorce
catre
caudal
causa
cazo
cebolla
ceder
cedro
celda
celebre
celoso
celula
cemento
ceniza
centro
cerca
cerdo
cereza
cero
cerrar
certeza
cesped
cetro
chacal
chaleco
champu
chancla
chapa
charla
chico
chiste
chivo
choque
choza
chuleta
chupar
ciclon
ciego
cielo
cien
cierto
cifra
cigarro
cima
cinco
cine
cinta
cipres
circo
ciruela
cisne
cita
ciudad
clamor
clan
claro
clase
clave
cliente
clima
clinica
cobre
coccion
cochino
cocina
coco
codigo
codo
cofre
coger
cohete
cojin
cojo
cola
colcha
colegio
colgar
colina
collar
colmo
columna
combate
comer
comida
comodo
compra
conde
conejo
conga
conocer
consejo
contar
copa
copia
corazon
corbata
corcho
cordon
corona
correr
coser
cosmos
costa
craneo
crater
crear
crecer
creido
crema
cria
crimen
cripta
crisis
cromo
cronica
croqueta
crudo
cruz
cuadro
cuarto
cuatro
cubo
cubrir
cuchara
cuello
cuento
cuerda
cuesta
cueva
cuidar
culebra
culpa
culto
cumbre
cumplir
cuna
cuneta
cuota
cupon
cupula
curar
curioso
curso
curva
cutis
dama
danza
dar
dardo
datil
deber
debil
decada
decir
dedo
defensa
definir
dejar
delfin
delgado
delito
demora
denso
dental
deporte
derecho
derrota
desayuno
deseo
desfile
desnudo
destino
desvio
detalle
detener
deuda
dia
diablo
diadema
diamante
diana
diario
dibujo
dictar
diente
dieta
diez
dificil
digno
dilema
diluir
dinero
directo
dirigir
disco
diseno
disfraz
diva
divino
doble
doce
dolor
domingo
don
donar
dorado
dormir
dorso
dos
dosis
dragon
droga
ducha
duda
duelo
dueno
dulce
duo
duque
durar
dureza
duro
ebano
ebrio
echar
eco
ecuador
edad
edicion
edificio
editor
educar
efecto
eficaz
eje
ejemplo
elefante
elegir
elemento
elevar
elipse
elite
elixir
elogio
eludir
embudo
emitir
emocion
empate
empeno
empleo
empresa
enano
encargo
enchufe
encia
enemigo
enero
enfado
enfermo
engano
enigma
enlace
enorme
enredo
ensayo
ensenar
entero
entrar
envase
envio
epoca
equipo
erizo
escala
escena
escolar
escribir
escudo
esencia
esfera
esfuerzo
espada
espejo
espia
esposa
espuma
esqui
estar
este
estilo
estufa
etapa
eterno
etica
etnia
evadir
evaluar
evento
evitar
exacto
examen
exceso
excusa
exento
exigir
exilio
existir
exito
experto
explicar
exponer
extremo
fabrica
fabula
fachada
facil
factor
faena
faja
falda
fallo
falso
faltar
fama
familia
famoso
faraon
farmacia
farol
farsa
fase
fatiga
fauna
favor
fax
febrero
fecha
feliz
feo
feria
feroz
fertil
fervor
festin
fiable
fianza
fiar
fibra
ficcion
ficha
fideo
fiebre
fiel
fiera
fiesta
figura
fijar
fijo
fila
filete
filial
filtro
fin
finca
fingir
finito
firma
flaco
flauta
flecha
flor
flota
fluir
flujo
fluor
fobia
foca
fogata
fogon
folio
folleto
fondo
forma
forro
fortuna
forzar
fosa
foto
fracaso
fragil
franja
frase
fraude
freir
freno
fresa
frio
frito
fruta
fuego
fuente
fuerza
fuga
fumar
funcion
funda
furgon
furia
fusil
futbol
futuro
gacela
gafas
gaita
gajo
gala
galeria
gallo
gamba
ganar
gancho
ganga
ganso
garaje
garza
gasolina
gastar
gato
gavilan
gemelo
gemir
gen
genero
genio
gente
geranio
gerente
germen
gesto
gigante
gimnasio
girar
giro
glaciar
globo
gloria
gol
golfo
goloso
golpe
goma
gordo
gorila
gorra
gota
goteo
gozar
grada
grafico
grano
grasa
gratis
grave
grieta
grillo
gripe
gris
grito
grosor
grua
grueso
grumo
grupo
guante
guapo
guardia
guerra
guia
guino
guion
guiso
guitarra
gusano
gustar
haber
habil
hablar
hacer
hacha
hada
hallar
hamaca
harina
haz
hazana
hebilla
hebra
hecho
helado
helio
hembra
herir
hermano
heroe
hervir
hielo
hierro
higado
higiene
hijo
himno
historia
hocico
hogar
hoguera
hoja
hombre
hongo
honor
honra
hora
hormiga
horno
hostil
hoyo
hueco
huelga
huerta
hueso
huevo
huida
huir
humano
humedo
humilde
humo
hundir
huracan
hurto
icono
ideal
idioma
idolo
iglesia
iglu
igual
ilegal
ilusion
imagen
iman
imitar
impar
imperio
imponer
impulso
incapaz
indice
inerte
infiel
informe
ingenio
inicio
inmenso
inmune
innato
insecto
instante
interes
intimo
intuir
inutil
invierno
ira
iris
ironia
isla
islote
jabali
jabon
jamon
jarabe
jardin
jarra
jaula
jazmin
jefe
jeringa
jinete
jornada
joroba
joven
joya
juerga
jueves
juez
jugador
jugo
juguete
juicio
junco
jungla
junio
juntar
jupiter
jurar
justo
juvenil
juzgar
kilo
koala
labio
lacio
lacra
lado
ladron
lagarto
lagrima
laguna
laico
lamer
lamina
lampara
lana
lancha
langosta
lanza
lapiz
largo
larva
lastima
lata
latex
latir
laurel
lavar
lazo
leal
leccion
leche
lector
leer
legion
legumbre
lejano
lengua
lento
lena
leon
leopardo
lesion
letal
letra
leve
leyenda
libertad
libro
licor
lider
lidiar
lienzo
liga
ligero
lima
limite
limon
limpio
lince
lindo
linea
lingote
lino
linterna
liquido
liso
lista
litera
litio
litro
llaga
llama
llanto
llave
llegar
llenar
llevar
llorar
llover
lluvia
lobo
locion
loco
locura
logica
logro
lombriz
lomo
lonja
lote
lucha
lucir
lugar
lujo
luna
lunes
lupa
lustro
luto
luz
maceta
macho
madera
madre
maduro
maestro
mafia
magia
mago
maiz
maldad
maleta
malla
malo
mama
mambo
mamut
manco
mando
manejar
manga
maniqui
manjar
mano
manso
manta
manana
mapa
maquina
mar
marco
marea
marfil
margen
marido
marmol
marron
martes
marzo
masa
mascara
masivo
matar
materia
matiz
matriz
maximo
mayor
mazorca
mecha
medalla
medio
medula
mejilla
mejor
melena
melon
memoria
menor
mensaje
mente
menu
mercado
merengue
merito
mes
meson
meta
meter
metodo
metro
mezcla
miedo
miel
miembro
miga
mil
milagro
militar
millon
mimo
mina
minero
minimo
minuto
miope
mirar
misa
miseria
misil
mismo
mitad
mito
mochila
mocion
moda
modelo
moho
mojar
molde
moler
molino
momento
momia
monarca
moneda
monja
monto
mono
morada
morder
moreno
morir
morro
morsa
mortal
mosca
mostrar
motivo
mover
movil
mozo
mucho
mudar
mueble
muela
muerte
muestra
mugre
mujer
mula
muleta
multa
mundo
muneca
mural
muro
musculo
museo
musgo
musica
muslo
nacar
nacion
nadar
naipe
naranja
nariz
narrar
nasal
natal
nativo
natural
nausea
naval
nave
navidad
necio
nectar
negar
negocio
negro
neon
nervio
neto
neutro
nevar
nevera
nicho
nido
niebla
nieto
ninez
nino
nitido
nivel
nobleza
noche
nomina
noria
norma
norte
nota
noticia
novato
novela
novio
nube
nuca
nucleo
nudillo
nudo
nuera
nueve
nuez
nulo
numero
nutria
oasis
obeso
obispo
objeto
obra
obrero
observar
obtener
obvio
oca
ocaso
oceano
ochenta
ocho
ocio
ocre
octavo
octubre
oculto
ocupar
ocurrir
odiar
odio
odisea
oeste
ofensa
oferta
oficio
ofrecer
ogro
oido
oir
ojo
ola
oleada
olfato
olivo
olla
olmo
olor
olvido
ombligo
onda
onza
opaco
opcion
opera
opinar
oponer
optar
optica
opuesto
oracion
orador
oral
orbita
orca
orden
oreja
organo
orgia
orgullo
oriente
origen
orilla
oro
orquesta
oruga
osadia
oscuro
osezno
oso
ostra
otono
otro
oveja
ovulo
oxido
oxigeno
oyente
ozono
pacto
padre
paella
pagina
pago
pais
pajaro
palabra
palco
paleta
palido
palma
paloma
palpar
pan
panal
panico
pantera
panuelo
papa
papel
papilla
paquete
parar
parcela
pared
parir
paro
parpado
parque
parrafo
parte
pasar
paseo
pasion
paso
pasta
pata
patio
patria
pausa
pauta
pavo
payaso
peaton
pecado
pecera
pecho
pedal
pedir
pegar
peine
pelar
peldano
pelea
peligro
pellejo
pelo
peluca
pena
pensar
penon
peon
peor
pepino
pequeno
pera
percha
perder
pereza
perfil
perico
perla
permiso
perro
persona
pesa
pesca
pesimo
pestana
petalo
petroleo
pez
pezuna
picar
pichon
pie
piedra
pierna
pieza
pijama
pilar
piloto
pimienta
pino
pintor
pinza
pina
piojo
pipa
pirata
pisar
piscina
piso
pista
piton
pizca
placa
plan
plata
playa
plaza
pleito
pleno
plomo
pluma
plural
pobre
poco
poder
podio
poema
poesia
poeta
polen
policia
pollo
polvo
pomada
pomelo
pomo
pompa
poner
porcion
portal
posada
poseer
posible
poste
potencia
potro
pozo
prado
precoz
pregunta
premio
prensa
preso
previo
primo
principe
prision
privar
proa
probar
proceso
producto
proeza
profesor
programa
prole
promesa
pronto
propio
proximo
prueba
publico
puchero
pudor
pueblo
puerta
puesto
pulga
pulir
pulmon
pulpo
pulso
puma
punto
punal
puno
pupa
pupila
pure
quedar
queja
quemar
querer
queso
quieto
quimica
quince
quitar
rabano
rabia
rabo
racion
radical
raiz
rama
rampa
rancho
rango
rapaz
rapido
rapto
rasgo
raspa
rato
rayo
raza
razon
reaccion
realidad
rebano
rebote
recaer
receta
rechazo
recoger
recreo
recto
recurso
red
redondo
reducir
reflejo
reforma
refran
refugio
regalo
regir
regla
regreso
rehen
reino
reir
reja
relato
relevo
relieve
relleno
reloj
remar
remedio
remo
rencor
rendir
renta
reparto
repetir
reposo
reptil
res
rescate
resina
respeto
resto
resumen
retiro
retorno
retrato
reunir
reves
revista
rey
rezar
rico
riego
rienda
riesgo
rifa
rigido
rigor
rincon
rinon
rio
riqueza
risa
ritmo
rito
rizo
roble
roce
rociar
rodar
rodeo
rodilla
roer
rojizo
rojo
romero
romper
ron
ronco
ronda
ropa
ropero
rosa
rosca
rostro
rotar
rubi
rubor
rudo
rueda
rugir
ruido
ruina
ruleta
rulo
rumbo
rumor
ruptura
ruta
rutina
sabado
saber
sabio
sable
sacar
sagaz
sagrado
sala
saldo
salero
salir
salmon
salon
salsa
salto
salud
salvar
samba
sancion
sandia
sanear
sangre
sanidad
sano
santo
sapo
saque
sardina
sarten
sastre
satan
sauna
saxofon
seccion
seco
secreto
secta
sed
seguir
seis
sello
selva
semana
semilla
senda
sensor
senal
senor
separar
sepia
sequia
ser
serie
sermon
servir
sesenta
sesion
seta
setenta
severo
sexo
sexto
sidra
siesta
siete
siglo
signo
silaba
silbar
silencio
silla
simbolo
simio
sirena
sistema
sitio
situar
sobre
socio
sodio
sol
solapa
soldado
soledad
solido
soltar
solucion
sombra
sondeo
sonido
sonoro
sonrisa
sopa
soplar
soporte
sordo
sorpresa
sorteo
sosten
sotano
suave
subir
suceso
sudor
suegra
suelo
sueno
suerte
sufrir
sujeto
sultan
sumar
superar
suplir
suponer
supremo
sur
surco
sureno
surgir
susto
sutil
tabaco
tabique
tabla
tabu
taco
tacto
tajo
talar
talco
talento
talla
talon
tamano
tambor
tango
tanque
tapa
tapete
tapia
tapon
taquilla
tarde
tarea
tarifa
tarjeta
tarot
tarro
tarta
tatuaje
tauro
taza
tazon
teatro
techo
tecla
tecnica
tejado
tejer
tejido
tela
telefono
tema
temor
templo
tenaz
tender
tener
tenis
tenso
teoria
terapia
terco
termino
ternura
terror
tesis
tesoro
testigo
tetera
texto
tez
tibio
tiburon
tiempo
tienda
tierra
tieso
tigre
tijera
tilde
timbre
timido
timo
tinta
tio
tipico
tipo
tira
tiron
titan
titere
titulo
tiza
toalla
tobillo
tocar
tocino
todo
toga
toldo
tomar
tono
tonto
topar
tope
toque
torax
torero
tormenta
torneo
toro
torpedo
torre
torso
tortuga
tos
tosco
toser
toxico
trabajo
tractor
traer
trafico
trago
traje
tramo
trance
trato
trauma
trazar
trebol
tregua
treinta
tren
trepar
tres
tribu
trigo
tripa
triste
triunfo
trofeo
trompa
tronco
tropa
trote
trozo
truco
trueno
trufa
tuberia
tubo
tuerto
tumba
tumor
tunel
tunica
turbina
turismo
turno
tutor
ubicar
ulcera
umbral
unidad
unir
universo
uno
untar
una
urbano
urbe
urgente
urna
usar
usuario
util
utopia
uva
vaca
vacio
vacuna
vagar
vago
vaina
vajilla
vale
valido
valle
valor
valvula
vampiro
vara
variar
varon
vaso
vecino
vector
vehiculo
veinte
vejez
vela
velero
veloz
vena
vencer
venda
veneno
vengar
venir
venta
venus
ver
verano
verbo
verde
vereda
verja
verso
verter
via
viaje
vibrar
vicio
victima
vida
video
vidrio
viejo
viernes
vigor
vil
villa
vinagre
vino
vinedo
violin
viral
virgo
virtud
visor
vispera
vista
vitamina
viudo
vivaz
vivero
vivir
vivo
volcan
volumen
volver
voraz
votar
voto
voz
vuelo
vulgar
yacer
yate
yegua
yema
yerno
yeso
yodo
yoga
yogur
zafiro
zanja
zapato
zarza
zona
zorro
zumo
zurdo`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/traditional-chinese.js
var wordlist10 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@dynamic-labs/ethereum-core/src/utils/logger.js
var logger2 = new Logger("ethereum-core");

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/estimateL1Fee/opStack/abi.js
var gasPriceOracleAbiAddress = "0x420000000000000000000000000000000000000F";
var gasPriceOracleAbi = [
  {
    inputs: [{ internalType: "bytes", name: "_data", type: "bytes" }],
    name: "getL1Fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/estimateL1Fee/opStack/estimateL1Fee.js
var estimateL1Fee = (publicClient, transaction) => __awaiter(void 0, void 0, void 0, function* () {
  const serializedTransaction = serializeTransaction(Object.assign(Object.assign({ chainId: publicClient.chain.id }, transaction), { type: transaction.type ? transaction.type : "eip1559" }));
  return publicClient.readContract({
    abi: gasPriceOracleAbi,
    address: gasPriceOracleAbiAddress,
    args: [serializedTransaction],
    functionName: "getL1Fee"
  });
});
var opStackSupportedChains = [
  optimism.id,
  optimismGoerli.id,
  optimismSepolia.id,
  base.id,
  baseGoerli.id,
  baseSepolia.id
];

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/chainsMap/chainsMap.js
var chainsMap = Object.values(chains_exports).reduce((acc, chain6) => {
  acc[chain6.id] = chain6;
  return acc;
}, {});

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/erc20/abi.js
var erc20Abi2 = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/Eip1559FeeFeed.js
var Eip1559FeeFeed = class {
  constructor({ publicClient, initialGasLimit, initialMaxFeePerGas }) {
    this.fee = {
      gas: BigInt(0)
    };
    this.publicClient = publicClient;
    this.initialGasLimit = initialGasLimit;
    this.initialMaxFeePerGas = initialMaxFeePerGas;
  }
  fetchFee() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const l1Fee = yield this.estimateL1Fee();
        if (this.initialGasLimit && this.initialMaxFeePerGas) {
          this.fee.gas = this.initialGasLimit * this.initialMaxFeePerGas + l1Fee;
          return;
        }
        const gasLimit = yield this.estimateGas();
        if (this.initialMaxFeePerGas) {
          this.fee.gas = gasLimit * this.initialMaxFeePerGas + l1Fee;
          return;
        }
        const estimatedFeesPerGas = yield this.publicClient.estimateFeesPerGas();
        if (!estimatedFeesPerGas || !estimatedFeesPerGas.maxFeePerGas) {
          return;
        }
        this.fee.gas = gasLimit * estimatedFeesPerGas.maxFeePerGas + l1Fee;
        this.maxFeePerGas = estimatedFeesPerGas.maxFeePerGas;
        this.maxPriorityFeePerGas = estimatedFeesPerGas.maxPriorityFeePerGas;
      } catch (error) {
        logger2.debug(error);
        return void 0;
      }
    });
  }
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/estimateL1Fee/estimateL1Fee.js
var estimateL1Fee2 = (publicClient, transaction) => __awaiter(void 0, void 0, void 0, function* () {
  const { chain: chain6 } = publicClient;
  if (!chain6) {
    throw new Error("Chain is not defined");
  }
  const publicClientWithChain = publicClient;
  if (opStackSupportedChains.includes(chain6.id)) {
    return estimateL1Fee(publicClientWithChain, transaction);
  }
  throw new Error("Chain is not supported");
});
var estimateL1FeeSupportedChains = [...opStackSupportedChains];
var isL1FeeSupportedByChain = (chainId) => estimateL1FeeSupportedChains.includes(chainId);

// node_modules/@dynamic-labs/ethereum-core/src/utils/validateAddressFormat/validateAddressFormat.js
var validateAddressFormat = (address) => /^0x[0-9a-fA-F]{40}$/.test(address);

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/parseEther/parseEther.js
var parseEther2 = (input) => parseEther(input, "wei");

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/formatEther/formatEther.js
var formatEther2 = (value2, { precision } = {}) => formatNumberText(formatEther(value2), { precision });

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/getTransactionRecipient.js
var getTransactionRecipient = (data, to6) => {
  if (data === null || data === void 0 ? void 0 : data.startsWith("0xa9059cbb")) {
    return decodeAbiParameters([
      { name: "x", type: "address" },
      { name: "x", type: "uint256" }
    ], "0x" + (data === null || data === void 0 ? void 0 : data.slice(10)))[0];
  }
  if (!data || data === "0x") {
    return to6 !== null && to6 !== void 0 ? to6 : void 0;
  }
  return void 0;
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/ViemUiTransaction/ViemUiTransaction.js
var ViemUiTransaction = class extends Eip1559FeeFeed {
  constructor({ transaction, onSubmit, publicClient, account: account2 }) {
    super({
      initialGasLimit: transaction.gas,
      initialMaxFeePerGas: transaction.maxFeePerGas,
      publicClient
    });
    this.chain = "EVM";
    this.validateAddressFormat = validateAddressFormat;
    this.parse = parseEther2;
    this.parseNonNativeToken = (amount, decimals) => parseUnits(amount, decimals);
    this.format = formatEther2;
    this.formatNonNativeToken = (value2, decimals) => formatUnits(value2, decimals);
    this.transaction = transaction;
    this.onSubmit = onSubmit;
    this.publicClient = publicClient;
    this.address = account2;
  }
  get to() {
    return this.transaction.to || void 0;
  }
  set to(toAddress) {
    this.transaction.to = toAddress;
  }
  get from() {
    return this.address;
  }
  get value() {
    return this.transaction.value;
  }
  set value(value2) {
    this.transaction.value = value2;
  }
  get nonNativeValue() {
    return this.transaction.nonNativeValue;
  }
  set nonNativeValue(value2) {
    this.transaction.nonNativeValue = value2;
  }
  get nonNativeAddress() {
    return this.transaction.nonNativeAddress;
  }
  set nonNativeAddress(value2) {
    this.transaction.nonNativeAddress = value2;
  }
  get nonNativeDecimal() {
    return this.transaction.nonNativeDecimal;
  }
  set nonNativeDecimal(value2) {
    this.transaction.nonNativeDecimal = value2;
  }
  get data() {
    return this.transaction.data;
  }
  submit() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.onSubmit(this.transaction).catch((error) => {
        if (error instanceof UserRejectedTransactionError) {
          throw new TransactionExecutionError(new BaseError(error.message), this.transaction);
        }
        throw error;
      });
    });
  }
  getBalance() {
    return this.publicClient.getBalance({ address: this.address });
  }
  estimateGas() {
    return __awaiter(this, void 0, void 0, function* () {
      const hexResult = yield this.publicClient.transport.request({
        method: "eth_estimateGas",
        params: [
          {
            data: this.data,
            to: this.to,
            value: this.convertBigIntToHex(this.value)
          }
        ]
      });
      return hexToBigInt(hexResult);
    });
  }
  convertBigIntToHex(value2) {
    return value2 ? toHex(value2) : void 0;
  }
  getTransactionRecipient() {
    var _a14;
    return getTransactionRecipient(this.transaction.data, (_a14 = this.transaction.to) !== null && _a14 !== void 0 ? _a14 : void 0);
  }
  estimateL1Fee() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a14;
      if (!isL1FeeSupportedByChain(((_a14 = this.publicClient.chain) === null || _a14 === void 0 ? void 0 : _a14.id) || 0)) {
        return BigInt(0);
      }
      return estimateL1Fee2(this.publicClient, {
        data: this.transaction.data,
        to: this.transaction.to,
        value: this.transaction.value
      });
    });
  }
  set maxFeePerGas(value2) {
    this.transaction.maxFeePerGas = value2;
  }
  set maxPriorityFeePerGas(value2) {
    this.transaction.maxPriorityFeePerGas = value2;
  }
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/createViemUiTransaction/createViemUiTransaction.js
var createViemUiTransaction = (_a14) => __awaiter(void 0, [_a14], void 0, function* ({ from: from40, publicClient, walletClient }) {
  return new ViemUiTransaction({
    account: from40,
    onSubmit: (transaction) => __awaiter(void 0, void 0, void 0, function* () {
      if (transaction.nonNativeAddress) {
        return walletClient.writeContract({
          abi: erc20Abi2,
          account: from40,
          address: transaction.nonNativeAddress,
          args: [transaction.to, transaction.nonNativeValue],
          functionName: "transfer",
          maxFeePerGas: transaction.maxFeePerGas,
          maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
        });
      }
      return walletClient.sendTransaction({
        account: from40,
        data: "0x",
        maxFeePerGas: transaction.maxFeePerGas,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
        to: transaction.to,
        value: transaction.value
      });
    }),
    publicClient,
    transaction: {}
  });
});

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/getOrMapViemChain/getOrMapViemChain.js
var getChain = (chainId) => {
  for (const chain6 of Object.values(chains_exports)) {
    if ("id" in chain6) {
      if (chain6.id === chainId) {
        return chain6;
      }
    }
  }
  throw new Error(`Chain with id ${chainId} not found`);
};
var mapChain = (network) => {
  var _a14;
  return {
    blockExplorers: ((_a14 = network.blockExplorerUrls) === null || _a14 === void 0 ? void 0 : _a14[0]) ? {
      default: {
        name: network.blockExplorerUrls[0],
        url: network.blockExplorerUrls[0]
      }
    } : void 0,
    id: network.chainId,
    name: network.vanityName || network.name || network.chainName,
    nativeCurrency: network.nativeCurrency,
    rpcUrls: {
      default: { http: network.rpcUrls },
      public: { http: network.rpcUrls }
    }
  };
};
var getOrMapViemChain = (network) => {
  let viemChain;
  try {
    viemChain = getChain(network.chainId);
  } catch (_a14) {
    logger2.debug(`Chain with id ${network.chainId} not found in viem's chains`);
  }
  const mappedChain = mapChain(network);
  if (!viemChain) {
    return mappedChain;
  }
  return Object.assign(Object.assign({}, viemChain), mappedChain);
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/hasAtomicStatusCapability/hasAtomicStatusCapability.js
var hasAtomicStatusCapability = (capabilities, chainId) => {
  if (!(capabilities === null || capabilities === void 0 ? void 0 : capabilities[chainId])) {
    return false;
  }
  const chainCapabilities = capabilities[chainId];
  const hasAtomicStatus = Boolean(chainCapabilities["atomic"] && (chainCapabilities["atomic"].status === "ready" || chainCapabilities["atomic"].status === "supported"));
  const hasAtomicBatchSupport = Boolean(chainCapabilities["atomicBatch"] && chainCapabilities["atomicBatch"].supported === true);
  logger2.debug("[hasAtomicStatusCapability]", {
    chainCapabilities,
    hasAtomicBatchSupport,
    hasAtomicStatus
  });
  return hasAtomicStatus || hasAtomicBatchSupport;
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/hasPaymasterServiceCapability/hasPaymasterServiceCapability.js
var hasPaymasterServiceCapability = (capabilities, chainId) => {
  var _a14;
  if (!(capabilities === null || capabilities === void 0 ? void 0 : capabilities[chainId])) {
    return false;
  }
  const chainCapabilities = capabilities[chainId];
  return Boolean((_a14 = chainCapabilities["paymasterService"]) === null || _a14 === void 0 ? void 0 : _a14.supported);
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/findEvmNetwork/findEvmNetwork.js
var findEvmNetwork = ({ chainId, name, networks }) => {
  if (!chainId && !name) {
    return void 0;
  }
  if (chainId && name) {
    return networks.find((network) => network.chainId === chainId && network.name === name);
  } else if (chainId) {
    return networks.find((network) => network.chainId === chainId);
  } else {
    return networks.find((network) => network.name === name);
  }
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/L2ResolverAbi/L2ResolverAbi.js
var L2ResolverAbi = [
  {
    inputs: [
      {
        internalType: "contract ENS",
        name: "ens_",
        type: "address"
      },
      {
        internalType: "address",
        name: "registrarController_",
        type: "address"
      },
      {
        internalType: "address",
        name: "reverseRegistrar_",
        type: "address"
      },
      {
        internalType: "address",
        name: "owner_",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "AlreadyInitialized",
    type: "error"
  },
  {
    inputs: [],
    name: "CantSetSelfAsDelegate",
    type: "error"
  },
  {
    inputs: [],
    name: "CantSetSelfAsOperator",
    type: "error"
  },
  {
    inputs: [],
    name: "NewOwnerIsZeroAddress",
    type: "error"
  },
  {
    inputs: [],
    name: "NoHandoverRequest",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "contentType",
        type: "uint256"
      }
    ],
    name: "ABIChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "AddrChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "newAddress",
        type: "bytes"
      }
    ],
    name: "AddressChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "delegate",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "Approved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "hash",
        type: "bytes"
      }
    ],
    name: "ContenthashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "record",
        type: "bytes"
      }
    ],
    name: "DNSRecordChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "DNSRecordDeleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "lastzonehash",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "zonehash",
        type: "bytes"
      }
    ],
    name: "DNSZonehashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      },
      {
        indexed: false,
        internalType: "address",
        name: "implementer",
        type: "address"
      }
    ],
    name: "InterfaceChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    name: "NameChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "OwnershipHandoverCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "OwnershipHandoverRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "oldOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    name: "PubkeyChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRegistrarController",
        type: "address"
      }
    ],
    name: "RegistrarControllerUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newReverseRegistrar",
        type: "address"
      }
    ],
    name: "ReverseRegistrarUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "string",
        name: "indexedKey",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "key",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "value",
        type: "string"
      }
    ],
    name: "TextChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "newVersion",
        type: "uint64"
      }
    ],
    name: "VersionChanged",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "contentTypes",
        type: "uint256"
      }
    ],
    name: "ABI",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "delegate",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "cancelOwnershipHandover",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "clearRecords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "completeOwnershipHandover",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "contenthash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      },
      {
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "dnsRecord",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ens",
    outputs: [
      {
        internalType: "contract ENS",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      }
    ],
    name: "hasDNSRecords",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "interfaceImplementer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "delegate",
        type: "address"
      }
    ],
    name: "isApprovedFor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "nodehash",
        type: "bytes32"
      },
      {
        internalType: "bytes[]",
        name: "data",
        type: "bytes[]"
      }
    ],
    name: "multicallWithNodeCheck",
    outputs: [
      {
        internalType: "bytes[]",
        name: "results",
        type: "bytes[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "result",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "pendingOwner",
        type: "address"
      }
    ],
    name: "ownershipHandoverExpiresAt",
    outputs: [
      {
        internalType: "uint256",
        name: "result",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "pubkey",
    outputs: [
      {
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "recordVersions",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "registrarController",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "requestOwnershipHandover",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "resolve",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "reverseRegistrar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "contentType",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "setABI",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "a",
        type: "bytes"
      }
    ],
    name: "setAddr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "setAddr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "hash",
        type: "bytes"
      }
    ],
    name: "setContenthash",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "setDNSRecords",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      },
      {
        internalType: "address",
        name: "implementer",
        type: "address"
      }
    ],
    name: "setInterface",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "newName",
        type: "string"
      }
    ],
    name: "setName",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    name: "setPubkey",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "registrarController_",
        type: "address"
      }
    ],
    name: "setRegistrarController",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "reverseRegistrar_",
        type: "address"
      }
    ],
    name: "setReverseRegistrar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "key",
        type: "string"
      },
      {
        internalType: "string",
        name: "value",
        type: "string"
      }
    ],
    name: "setText",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "hash",
        type: "bytes"
      }
    ],
    name: "setZonehash",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "text",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "zonehash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@dynamic-labs/ethereum-core/src/utils/getNameservice/getNameservice.js
var getNameservice = (_a14) => __awaiter(void 0, [_a14], void 0, function* ({ rpcProvider, address }) {
  const nsData = {
    avatar: void 0,
    name: void 0
  };
  const network = yield rpcProvider.getChainId();
  if (!network) {
    return nsData;
  }
  const convertReverseNodeToBytes = (address2, chainId) => {
    const addressFormatted = address2.toLocaleLowerCase();
    const addressNode = keccak256(addressFormatted.substring(2));
    const chainCoinType = convertChainIdToCoinType(chainId);
    const baseReverseNode = namehash(`${chainCoinType.toLocaleUpperCase()}.reverse`);
    const addressReverseNode = keccak256(encodePacked(["bytes32", "bytes32"], [baseReverseNode, addressNode]));
    return addressReverseNode;
  };
  const convertChainIdToCoinType = (chainId) => {
    const cointype = (2147483648 | chainId) >>> 0;
    return cointype.toString(16).toLocaleUpperCase();
  };
  if (network === 8453) {
    const addressReverseNode = convertReverseNodeToBytes(address, 8453);
    try {
      const baseName = yield rpcProvider.readContract({
        abi: L2ResolverAbi,
        address: "0xC6d566A56A1aFf6508b41f6c90ff131615583BCD",
        args: [addressReverseNode],
        functionName: "name"
      });
      if (baseName) {
        nsData.name = baseName;
        return nsData;
      }
    } catch (_error) {
      return nsData;
    }
  } else {
    nsData.name = yield rpcProvider.getEnsName({
      address
    });
    nsData.avatar = nsData.name ? yield rpcProvider.getEnsAvatar({
      name: nsData.name
    }) : void 0;
  }
  return nsData;
});

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/isTransactionExecutionError/isTransactionExecutionError.js
var isTransactionExecutionError = (error) => error !== void 0 && error !== null && typeof error === "object" && "walk" in error && typeof error["walk"] === "function";

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/interceptTransport/interceptTransport.js
var interceptTransport = ({ getAccounts, onPersonalSign, onSendTransaction, onSignTypedData, onGetCapabilities, onSendCalls, transport }) => (props) => {
  const provider = transport(props);
  return custom({
    request: (args) => __awaiter(void 0, void 0, void 0, function* () {
      var _a14;
      const { method, params } = args;
      if (getAccounts && method === "eth_accounts") {
        return getAccounts({ provider });
      }
      if (onPersonalSign && method === "personal_sign") {
        const [message] = params;
        return onPersonalSign({ args, message, provider }).catch((error) => {
          if (error instanceof UserRejectedRequestError) {
            throw new UserRejectedRequestError2(error);
          }
          throw error;
        });
      }
      if (onSendTransaction && method === "eth_sendTransaction") {
        const [transaction] = params;
        return onSendTransaction({ args, provider, transaction }).catch((error) => {
          if (isTransactionExecutionError(error) && error.walk() instanceof UserRejectedTransactionError) {
            throw new UserRejectedRequestError2(error.walk());
          }
          if (error instanceof UserRejectedTransactionError) {
            throw new UserRejectedRequestError2(error);
          }
          if (error instanceof UserRejectedRequestError) {
            throw new UserRejectedRequestError2(error);
          }
          throw error;
        });
      }
      if (onSignTypedData && method === "eth_signTypedData_v4") {
        const [, message] = (_a14 = params) !== null && _a14 !== void 0 ? _a14 : [];
        return onSignTypedData({ args, message, provider }).catch((error) => {
          if (error instanceof UserRejectedRequestError) {
            throw new UserRejectedRequestError2(error);
          }
          throw error;
        });
      }
      if (onGetCapabilities && method === "wallet_getCapabilities") {
        return onGetCapabilities({ provider });
      }
      if (onSendCalls && method === "wallet_sendCalls") {
        const [callParams] = params;
        return onSendCalls({ callParams, provider });
      }
      return provider.request(args);
    })
  })(props);
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/parseAddress/parseAddress.js
var parseAddress = (address) => {
  try {
    return getAddress(address);
  } catch (error) {
    return address;
  }
};

// node_modules/@dynamic-labs/ethereum-core/src/wallet/EthereumWallet.js
var EthereumWallet = class extends Wallet {
  constructor(props) {
    super(Object.assign(Object.assign({}, props), { address: parseAddress(props.address) }));
  }
  /**
   * Sends the native balance of the wallet to the given address.
   * @param amount - The amount of balance to send (in ETH).
   * @param toAddress - The address to send the balance to.
   * @param token - The token to send (optional)  for example, an ERC20 token.
   *   @param token.address - The address of the token contract.
   *   @param token.decimals - The decimals of the token (defaults to 18).
   * @returns The transaction hash of the sent transaction.
   */
  sendBalance(_a14) {
    return __awaiter(this, arguments, void 0, function* ({ amount, toAddress, token }) {
      const provider = yield this.getWalletClient();
      if (token && token.address) {
        const erc20Contract = getContract({
          abi: erc20Abi2,
          address: token.address,
          client: provider
        });
        const transfer = yield erc20Contract.write["transfer"]([
          toAddress,
          parseUnits(amount, token.decimals || 18)
        ]);
        return transfer;
      }
      const transaction = {
        account: this.address,
        chain: getChain(yield provider.getChainId()),
        // required for zksync until this PR is merged:https://github.com/matter-labs/zksync-sso/pull/91
        data: "0x",
        to: toAddress,
        value: amount ? parseEther(amount) : void 0
      };
      const transactionHash = yield provider.sendTransaction(transaction);
      return transactionHash;
    });
  }
  /**
   * Retrieves the public client.
   * @returns A promise that resolves to the public client,
   * or throws if the client cannot be retrieved.
   */
  getPublicClient() {
    return __awaiter(this, void 0, void 0, function* () {
      const client = yield this._connector.getPublicClient();
      if (!client) {
        throw new Error("Unable to retrieve PublicClient");
      }
      return client;
    });
  }
  /**
   * Retrieves the wallet client.
   * @param chainId - (optional) Chain id to be used by the wallet client.
   * @returns A promise that resolves to the wallet client,
   * or throws if the client cannot be retrieved.
   */
  getWalletClient(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
      if ("setActiveAccount" in this._connector) {
        this._connector.setActiveAccount(this.address);
      }
      const walletClient = yield this._connector.getWalletClient(chainId);
      if (!walletClient) {
        throw new Error("Unable to retrieve WalletClient");
      }
      return createWalletClient({
        account: this.address,
        chain: walletClient.chain,
        transport: interceptTransport({
          onPersonalSign: (_a14) => __awaiter(this, [_a14], void 0, function* ({ provider, args }) {
            yield this.sync();
            return provider.request(args);
          }),
          onSendTransaction: (_b) => __awaiter(this, [_b], void 0, function* ({ provider, args }) {
            yield this.sync();
            return provider.request(args);
          }),
          onSignTypedData: (_c3) => __awaiter(this, [_c3], void 0, function* ({ provider, args }) {
            yield this.sync();
            return provider.request(args);
          }),
          transport: custom(walletClient.transport, this.getTransportConfig())
        })
      });
    });
  }
  getTransportConfig() {
    return this._connector.providersConfig.httpTransportConfig;
  }
  isSignAuthorizationSupported() {
    return this._connector.isSignAuthorizationSupported();
  }
  isPaymasterServiceSupported(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const supported = yield this._connector.isPaymasterServiceSupported(chainId);
        return supported;
      } catch (error) {
        logger2.error("[EthereumWallet] isPaymasterServiceSupported", {
          chainId,
          error
        });
        return false;
      }
    });
  }
  isAtomicSupported(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const supported = yield this._connector.isAtomicSupported(chainId);
        return supported;
      } catch (error) {
        logger2.error("[EthereumWallet] isAtomicSupported", {
          chainId,
          error
        });
        return false;
      }
    });
  }
  sendCalls(callParams, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a14, _b, _c3;
      const chainId = (_a14 = callParams.chain) === null || _a14 === void 0 ? void 0 : _a14.id;
      const walletClient = yield this.getWalletClient(chainId === null || chainId === void 0 ? void 0 : chainId.toString());
      const atomicStatusSupported = yield this.isAtomicSupported(chainId);
      if (!atomicStatusSupported) {
        logger2.debug("[EthereumWallet] atomic is not supported wallet or chain", {
          chainId,
          wallet: {
            address: this.address,
            key: this.key
          },
          wcChainId: (_b = walletClient.chain) === null || _b === void 0 ? void 0 : _b.id
        });
        throw new Error("Atomic is not supported for this wallet and chain");
      }
      const paymasterServiceSupported = yield this.isPaymasterServiceSupported(chainId);
      const chainIdToUse = chainId !== null && chainId !== void 0 ? chainId : (_c3 = walletClient.chain) === null || _c3 === void 0 ? void 0 : _c3.id;
      if (paymasterServiceSupported && (options === null || options === void 0 ? void 0 : options.paymasterURL)) {
        callParams.capabilities = {
          paymasterService: {
            [chainIdToUse]: {
              url: options === null || options === void 0 ? void 0 : options.paymasterURL
            }
          }
        };
      }
      logger2.logVerboseTroubleshootingMessage("[EthereumWallet] sendCalls", {
        atomicStatusSupported,
        callOptions: options,
        callParams,
        chainIdToUse,
        paymasterServiceSupported
      });
      const result = yield walletClient.sendCalls(callParams);
      logger2.logVerboseTroubleshootingMessage("[EthereumWallet] sendCalls", {
        result
      });
      return result;
    });
  }
};

// node_modules/@dynamic-labs/ethereum-core/src/connector/EthereumWalletConnector.js
var EthereumWalletConnector = class extends WalletConnectorBase {
  constructor(props) {
    var _a14, _b, _c3;
    super(props);
    this.supportedChains = ["EVM", "ETH"];
    this.connectedChain = "EVM";
    this.ChainWallet = EthereumWallet;
    this.evmNetworkRpcMap = () => this.evmNetworks.reduce((acc, network) => {
      var _a15;
      [acc[network.chainId]] = ((_a15 = network === null || network === void 0 ? void 0 : network.privateCustomerRpcUrls) === null || _a15 === void 0 ? void 0 : _a15.length) ? network.privateCustomerRpcUrls : network.rpcUrls;
      return acc;
    }, {});
    this.walletUiUtils = props.walletUiUtils;
    this.evmNetworks = parseEvmNetworks(props.evmNetworks);
    this.providersConfig = (_a14 = props.providersConfig) !== null && _a14 !== void 0 ? _a14 : {};
    this.chainRpcProviders = props.chainRpcProviders;
    (_b = this.chainRpcProviders) === null || _b === void 0 ? void 0 : _b.registerEvmProviders((_c3 = this.providersConfig) !== null && _c3 !== void 0 ? _c3 : {});
  }
  getPublicClient() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a14, _b;
      const networkId = (_a14 = yield this.getNetwork()) !== null && _a14 !== void 0 ? _a14 : 1;
      if (this.evmNetworks.length === 0) {
        return void 0;
      }
      const configurations = {
        cosmos: [],
        evm: this.evmNetworks,
        solana: [],
        starknet: void 0
      };
      if (!this.chainRpcProviders)
        return void 0;
      const providers = this.chainRpcProviders.getProviders(configurations);
      return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
    });
  }
  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getWalletClient();
      if (!this.supportsNetworkSwitching || !provider) {
        return Promise.resolve(void 0);
      }
      const chainId = yield retryableFn(provider.getChainId, {
        fallbackValue: FALLBACK_UNDEFINED,
        /**
         * The timeout is set to 1 second because the getChainId method
         * takes around 500ms to resolve on Brave. If the timeout is not set
         * it will use 100ms by default and the method will fail.
         * QNTM-815
         */
        timeoutMs: 1e3
      });
      this.setActiveChain(chainsMap[chainId]);
      return chainId;
    });
  }
  getNameService(address) {
    return __awaiter(this, void 0, void 0, function* () {
      const rpcProvider = yield this.getPublicClient();
      if (!rpcProvider) {
        return;
      }
      return getNameservice({ address, rpcProvider });
    });
  }
  isTestnet() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a14, _b;
      const chain6 = (_a14 = yield this.getPublicClient()) === null || _a14 === void 0 ? void 0 : _a14.chain;
      const evmNetwork = this.evmNetworks.find((n5) => n5.chainId === (chain6 === null || chain6 === void 0 ? void 0 : chain6.id));
      logger.logVerboseTroubleshootingMessage("[EthereumWalletConnector] isTestnet", {
        evmNetwork,
        viemChain: chain6
      });
      if ((evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.isTestnet) !== void 0) {
        return evmNetwork.isTestnet;
      }
      return (_b = chain6 === null || chain6 === void 0 ? void 0 : chain6.testnet) !== null && _b !== void 0 ? _b : false;
    });
  }
  parseAddress(address) {
    try {
      return getAddress(address);
    } catch (err) {
      logger.debug(`Failed to parse EVM address into EIP55 format: error getting checksum, returning default ${address}`, err);
    }
    return address;
  }
  getSigner() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getWalletClient();
    });
  }
  getBalance(address) {
    return __awaiter(this, void 0, void 0, function* () {
      const client = yield this.getPublicClient();
      const result = yield client === null || client === void 0 ? void 0 : client.getBalance({
        address
      });
      if (!result && result !== BigInt(0))
        return;
      return formatEther(result);
    });
  }
  supportsNetworkSwitching() {
    return true;
  }
  switchNetwork(_a14) {
    return __awaiter(this, arguments, void 0, function* ({ networkName, networkChainId }) {
      const network = findEvmNetwork({
        chainId: networkChainId,
        name: networkName,
        networks: this.evmNetworks
      });
      if (!network) {
        throw new DynamicError(`Could not find network mapping for chain ${networkName ? networkName : networkChainId}`);
      }
      if (!this.supportsNetworkSwitching()) {
        throw new DynamicError("Network switching is not supported");
      }
      logger.logVerboseTroubleshootingMessage("[EthereumWalletConnector] switchNetwork", { network, networkChainId, networkName });
      const provider = this.getWalletClient();
      logger.logVerboseTroubleshootingMessage("[EthereumWalletConnector] switchNetwork - got provider", { provider });
      if (!provider) {
        throw new DynamicError("Provider not found");
      }
      return this.providerSwitchNetwork({ network, provider });
    });
  }
  chooseAccountsToConnect() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a14, _b, _c3;
      const provider = this.getWalletClient();
      if (!provider)
        return [];
      try {
        const result = yield provider.requestPermissions({ eth_accounts: {} });
        logger.debug("chooseAccountsToConnect - requestPermissions result", result);
        const addresses = (_c3 = (_b = (_a14 = result === null || result === void 0 ? void 0 : result.find((r8) => r8.parentCapability === "eth_accounts")) === null || _a14 === void 0 ? void 0 : _a14.caveats) === null || _b === void 0 ? void 0 : _b[0]) === null || _c3 === void 0 ? void 0 : _c3.value;
        if (typeof addresses === "string") {
          return [addresses];
        }
        if (Array.isArray(addresses)) {
          return addresses;
        }
        return [];
      } catch (error) {
        logger.debug("chooseAccountsToConnect - error", error);
        if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {
          throw new UserRejectedRequestError();
        }
      }
      return [];
    });
  }
  getConnectedAccounts() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.getWalletClient();
      if (!provider)
        return [];
      const addresses = yield retryableFn(provider.getAddresses, {
        fallbackValue: [],
        timeoutMs: 500
      });
      if (addresses.length) {
        this.setActiveAccount(addresses[0]);
      }
      return addresses;
    });
  }
  providerSwitchNetwork(_a14) {
    return __awaiter(this, arguments, void 0, function* ({ network, provider }) {
      var _b, _c3, _d2, _e6, _f3;
      const { chainId } = network;
      const currentNetworkId = yield this.getNetwork();
      if (currentNetworkId && currentNetworkId === chainId) {
        return;
      }
      try {
        if (!this.supportsNetworkSwitching()) {
          throw new DynamicError("Network switching is not supported");
        }
        const viemChain = getOrMapViemChain(network);
        yield provider.switchChain({ id: viemChain.id });
        if (this.key === "magiceden") {
          const newChainId = yield provider.getChainId();
          this.emit("chainChange", { chain: newChainId.toString() });
        } else {
          this.setActiveChain(viemChain);
          this.emit("chainChange", { chain: viemChain.id.toString() });
        }
      } catch (error) {
        if ((_b = error.details) === null || _b === void 0 ? void 0 : _b.includes('"wallet_switchEthereumChain" not implemented')) {
          throw new DynamicError("Network switching is not available at this time. The user should manually switch network in their wallet");
        }
        if (error.code === 4902 || ((_c3 = error.message) === null || _c3 === void 0 ? void 0 : _c3.includes("Unrecognized chain")) || // https://github.com/MetaMask/metamask-mobile/issues/3312#issuecomment-1065923294
        ((_e6 = (_d2 = error.data) === null || _d2 === void 0 ? void 0 : _d2.orginalError) === null || _e6 === void 0 ? void 0 : _e6.code) === 4902) {
          return this.providerAddNetwork({ network, provider });
        } else if (((_f3 = error.message) === null || _f3 === void 0 ? void 0 : _f3.includes("rejected")) || typeof error === "string" && error.includes("rejected")) {
          throw new DynamicError("User rejected the wallet's request to switch network");
        } else {
          throw error;
        }
      }
    });
  }
  providerAddNetwork(_a14) {
    return __awaiter(this, arguments, void 0, function* ({ network, provider }) {
      var _b;
      try {
        if (isMobile()) {
          yield this.walletUiUtils.addNetwork({
            handler: () => provider.addChain({ chain: getOrMapViemChain(network) }),
            network,
            walletConnector: this
          });
        } else {
          yield provider.addChain({ chain: getOrMapViemChain(network) });
        }
      } catch (error) {
        if (((_b = error.message) === null || _b === void 0 ? void 0 : _b.includes("rejected")) || typeof error === "string" && error.includes("rejected")) {
          throw new DynamicError("User rejected the wallet's request to add network");
        } else {
          throw error;
        }
      }
    });
  }
  setActiveAccount(account2) {
    this.activeAccount = account2 ? toAccount(account2) : void 0;
  }
  getActiveAccount() {
    return this.activeAccount;
  }
  setActiveChain(chain6) {
    this.activeChain = chain6;
  }
  getActiveChain() {
    return this.activeChain;
  }
  createUiTransaction(from40) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from40);
      const walletClient = yield this.getWalletClient();
      const publicClient = yield this.getPublicClient();
      if (!publicClient || !walletClient) {
        throw new DynamicError("No public client available");
      }
      return createViemUiTransaction({
        from: from40,
        publicClient,
        walletClient
      });
    });
  }
  confirmTransactionStatus(txHash) {
    return __awaiter(this, void 0, void 0, function* () {
      const publicClient = yield this.getPublicClient();
      if (!publicClient) {
        throw new DynamicError("No public client available");
      }
      const confirmations = 3;
      return publicClient.waitForTransactionReceipt({
        confirmations,
        hash: txHash
      });
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a14, _b;
      const currentNetwork = yield this.getNetwork();
      return (_b = (_a14 = this.evmNetworks.find((network) => network.chainId.toString() === (currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.toString()))) === null || _a14 === void 0 ? void 0 : _a14.blockExplorerUrls) !== null && _b !== void 0 ? _b : [];
    });
  }
  getEnabledNetworks() {
    return this.evmNetworks;
  }
  isAtomicSupported(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
      const walletClient = yield this.getWalletClient();
      if (!walletClient) {
        return false;
      }
      const capabilities = yield walletClient.getCapabilities();
      const chainIdToCheck = chainId !== null && chainId !== void 0 ? chainId : yield walletClient.getChainId();
      logger.debug("[EthereumWalletConnector] isAtomicSupported", {
        capabilities,
        chainId: chainIdToCheck
      });
      return hasAtomicStatusCapability(capabilities, chainIdToCheck);
    });
  }
  isPaymasterServiceSupported(chainId) {
    return __awaiter(this, void 0, void 0, function* () {
      const walletClient = yield this.getWalletClient();
      if (!walletClient) {
        return false;
      }
      const capabilities = yield walletClient.getCapabilities();
      const chainIdToCheck = chainId !== null && chainId !== void 0 ? chainId : yield walletClient.getChainId();
      logger.debug("[EthereumWalletConnector] isPaymasterServiceSupported", {
        capabilities,
        chainId: chainIdToCheck
      });
      return hasPaymasterServiceCapability(capabilities, chainIdToCheck);
    });
  }
  /**
   * Whether the wallet supports sign authorization for eip-7702.
   *
   * @returns {boolean} Whether the wallet supports sign authorization
   */
  isSignAuthorizationSupported() {
    return false;
  }
};

// node_modules/@dynamic-labs/ethereum-core/src/connector/createConnector/createConnector.js
var createConnector = (customConnectorFn) => (props) => {
  const delegate = customConnectorFn(props);
  return [
    class extends EthereumWalletConnector {
      constructor(props2) {
        super(Object.assign(Object.assign({}, props2), { metadata: delegate.metadata }));
        this.name = delegate.metadata.name;
        this.overrideKey = `${delegate.metadata.name}evm`;
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          yield delegate.connect();
        });
      }
      endSession() {
        const _super = Object.create(null, {
          endSession: { get: () => super.endSession }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (delegate.disconnect) {
            yield delegate.disconnect();
          }
          return _super.endSession.call(this);
        });
      }
      getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.getAddress();
        });
      }
      getConnectedAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.getConnectedAccounts();
        });
      }
      getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.getNetwork();
        });
      }
      getPublicClient() {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.getPublicClient();
        });
      }
      getWalletClient(chainId) {
        return delegate.getWalletClient(chainId);
      }
      isInstalledOnBrowser() {
        return delegate.isInstalledOnBrowser();
      }
      signMessage(messageToSign) {
        return __awaiter(this, void 0, void 0, function* () {
          return delegate.signMessage(messageToSign);
        });
      }
      filter() {
        if (delegate.filter) {
          return delegate.filter();
        }
        return super.filter();
      }
      init() {
        const _super = Object.create(null, {
          init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (delegate.init) {
            return delegate.init();
          }
          return _super.init.call(this);
        });
      }
      supportsNetworkSwitching() {
        if (delegate.supportsNetworkSwitching) {
          return delegate.supportsNetworkSwitching();
        }
        return super.supportsNetworkSwitching();
      }
      switchNetwork(_a14) {
        const _super = Object.create(null, {
          switchNetwork: { get: () => super.switchNetwork }
        });
        return __awaiter(this, arguments, void 0, function* ({ networkName, networkChainId }) {
          if (delegate.switchNetwork) {
            return delegate.switchNetwork({ networkChainId, networkName });
          }
          return _super.switchNetwork.call(this, { networkChainId, networkName });
        });
      }
    }
  ];
};

// node_modules/@dynamic-labs/ethereum-core/src/rpc/RpcProvidersEthereum/RpcProvidersEthereum.js
ChainRpcProviders.getEvmProviderByChainId = (rpcProviders, chainId) => {
  var _a14;
  const provider = (_a14 = rpcProviders["evm"]) === null || _a14 === void 0 ? void 0 : _a14.find((provider2) => provider2.chainId === chainId);
  return provider;
};
ChainRpcProviders.registerEvmProviders = (providersConfig) => {
  if (!providersConfig) {
    throw new Error("providersConfig is required");
  }
  ChainRpcProviders.registerChainProviders(ProviderChain.EVM, (config2) => {
    const rpcProviders = {};
    if (config2 === null || config2 === void 0 ? void 0 : config2["evm"]) {
      rpcProviders.evm = parseEvmNetworks(config2["evm"]).map((network) => {
        var _a14;
        const rpcUrl = ((_a14 = network.privateCustomerRpcUrls) === null || _a14 === void 0 ? void 0 : _a14[0]) || network.rpcUrls[0];
        const provider = createPublicClient({
          chain: getOrMapViemChain(network),
          transport: http(rpcUrl, providersConfig === null || providersConfig === void 0 ? void 0 : providersConfig.httpTransportConfig)
        });
        return {
          chainId: network.chainId,
          chainName: network.name,
          provider
        };
      });
    }
    return rpcProviders.evm;
  });
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/unFormatTransaction/unFormatTransaction.js
var unFormatTransaction = (transactionRequest) => Object.assign(Object.assign({}, transactionRequest), { authorizationList: typeof transactionRequest.authorizationList !== "undefined" ? transactionRequest.authorizationList.map((authorization) => Object.assign(Object.assign({}, authorization), { chainId: hexToBigInt(authorization.chainId), nonce: hexToBigInt(authorization.nonce), yParity: hexToNumber(authorization.yParity, { size: 1 }) })) : void 0, gas: typeof transactionRequest.gas !== "undefined" ? hexToBigInt(transactionRequest.gas) : void 0, gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? hexToBigInt(transactionRequest.gasPrice) : void 0, maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? hexToBigInt(transactionRequest.maxFeePerGas) : void 0, maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? hexToBigInt(transactionRequest.maxPriorityFeePerGas) : void 0, nonce: typeof transactionRequest.nonce !== "undefined" ? hexToBigInt(transactionRequest.nonce) : void 0, value: typeof transactionRequest.value !== "undefined" ? hexToBigInt(transactionRequest.value) : void 0 });

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/createAccountWithUiConfirmation/createAccountWithUiConfirmation.js
var createAccountWithUiConfirmation = ({ address, account: account2, provider, walletConnector, walletUiUtils }) => toAccount({
  address,
  signAuthorization: (...args) => __awaiter(void 0, void 0, void 0, function* () {
    const accountInstance = yield account2();
    if (!accountInstance.signAuthorization) {
      throw new Error("signAuthorization not found");
    }
    return accountInstance.signAuthorization(...args);
  }),
  signMessage: (...args) => __awaiter(void 0, void 0, void 0, function* () {
    return walletUiUtils.signMessage({
      handler: () => __awaiter(void 0, void 0, void 0, function* () {
        return (yield account2()).signMessage(...args);
      }),
      message: (() => {
        var _a14;
        const msg = (_a14 = args[0]) === null || _a14 === void 0 ? void 0 : _a14.message;
        return msg && !(typeof msg === "string" && Array.isArray(msg)) ? JSON.stringify(msg) : msg === null || msg === void 0 ? void 0 : msg.toString();
      })(),
      walletConnector
    });
  }),
  signTransaction: (...args) => __awaiter(void 0, void 0, void 0, function* () {
    const uiTransaction = new ViemUiTransaction({
      account: address,
      onSubmit: (transaction) => __awaiter(void 0, void 0, void 0, function* () {
        return (yield account2()).signTransaction(transaction);
      }),
      publicClient: provider,
      transaction: args[0]
    });
    return walletUiUtils.sendTransaction(walletConnector, uiTransaction);
  }),
  signTypedData: (...args) => walletUiUtils.signMessage({
    handler: () => __awaiter(void 0, void 0, void 0, function* () {
      return (yield account2()).signTypedData(...args);
    }),
    message: JSON.stringify(args[0], (_6, value2) => typeof value2 === "bigint" ? value2.toString() : value2),
    walletConnector
  })
});

// node_modules/@dynamic-labs/ethereum-core/src/utils/viem/createWalletClientWithUiConfirmation/createWalletClientWithUiConfirmation.js
var createWalletClientWithUiConfirmation = ({ address, account: account2, chain: chain6, transport, walletConnector, walletUiUtils }) => {
  let client = null;
  const provider = createPublicClient({
    chain: chain6,
    transport
  });
  const gatedAccount = createAccountWithUiConfirmation({
    account: account2,
    address,
    provider,
    walletConnector,
    walletUiUtils
  });
  const customTransport = interceptTransport({
    getAccounts: () => __awaiter(void 0, void 0, void 0, function* () {
      return [address];
    }),
    onPersonalSign: (_a14) => __awaiter(void 0, [_a14], void 0, function* ({ message }) {
      if (!client)
        throw new Error("Client not initialized");
      return client.signMessage({
        message: {
          raw: message
        }
      });
    }),
    onSendTransaction: (_b) => __awaiter(void 0, [_b], void 0, function* ({ transaction }) {
      if (!client)
        throw new Error("Client not initialized");
      const unFormattedTransaction = unFormatTransaction(transaction);
      return client.sendTransaction(unFormattedTransaction);
    }),
    onSignTypedData: (_c3) => __awaiter(void 0, [_c3], void 0, function* ({ message }) {
      if (!client)
        throw new Error("Client not initialized");
      return client.signTypedData(JSON.parse(message));
    }),
    transport
  });
  client = createWalletClient({
    account: gatedAccount,
    chain: chain6,
    transport: customTransport
  });
  return client;
};

// node_modules/@dynamic-labs/ethereum-core/src/utils/normalizeRpcError/normalizeRpcError.js
var normalizeRpcError = (err) => {
  if (err.code === 4001) {
    throw err;
  }
  let mappedError = null;
  try {
    mappedError = mapRpcError(err);
  } catch (e11) {
  }
  if (mappedError) {
    throw mappedError;
  }
  throw err;
};
var mapRpcError = (err) => {
  if (typeof err.message === "string" && (err.message.includes("User rejected the request") || err.message.includes("user reject this request") || err.message === "Request rejected")) {
    return new UserRejectedRequestError2(err);
  }
  return null;
};

// node_modules/@dynamic-labs/ethereum-core/src/wallet/isEthereumWallet/isEthereumWallet.js
var isEthereumWallet = (wallet) => wallet.chain === "EVM";

// node_modules/@dynamic-labs/ethereum-core/src/index.js
assertPackageVersion("@dynamic-labs/ethereum-core", version2);

// node_modules/@dynamic-labs/ethereum/_virtual/_tslib.js
function __rest2(s5, e11) {
  var t6 = {};
  for (var p9 in s5) if (Object.prototype.hasOwnProperty.call(s5, p9) && e11.indexOf(p9) < 0)
    t6[p9] = s5[p9];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i9 = 0, p9 = Object.getOwnPropertySymbols(s5); i9 < p9.length; i9++) {
      if (e11.indexOf(p9[i9]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p9[i9]))
        t6[p9[i9]] = s5[p9[i9]];
    }
  return t6;
}
function __awaiter2(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/ethereum/src/ethProviderHelper.js
var EthProviderHelper = class {
  constructor(connector) {
    this.walletBookWallet = findWalletBookWallet(connector.walletBook, connector.key);
    this.connector = connector;
  }
  getInstalledProvider() {
    const eip6963Provider = this.getEip6963Provider();
    if (eip6963Provider) {
      return eip6963Provider;
    }
    const injectedProvider = this.getInjectedProvider();
    return injectedProvider;
  }
  getInjectedProvider() {
    const config2 = this.getInjectedConfig();
    if (!config2 || !config2.extensionLocators || !config2.extensionLocators.length)
      return void 0;
    const provider = this.installedProviderLookup(config2.extensionLocators);
    return provider;
  }
  getEip6963Provider() {
    const { rdns } = this.connector.metadata;
    if (!rdns) {
      return void 0;
    }
    return this.eip6963ProviderLookup(rdns);
  }
  getInjectedConfig() {
    var _a14;
    const injectedConfig = (_a14 = this.walletBookWallet) === null || _a14 === void 0 ? void 0 : _a14.injectedConfig;
    return injectedConfig === null || injectedConfig === void 0 ? void 0 : injectedConfig.find((c9) => c9.chain === "evm");
  }
  installedProviders() {
    const config2 = this.getInjectedConfig();
    if (!config2)
      return [];
    const providers = [];
    if (config2.windowLocations) {
      for (const windowLocation of config2.windowLocations) {
        const foundProviders = getProvidersFromWindow(windowLocation);
        if (foundProviders && foundProviders.length)
          providers.push(...foundProviders);
      }
    }
    if (window.ethereum) {
      if (!window.ethereum.providers || !window.ethereum.providers.length) {
        providers.push(window.ethereum);
      } else {
        window.ethereum.providers.forEach((p9) => providers.push(p9));
      }
    }
    return providers;
  }
  installedProviderLookup(extensionLocators) {
    const allInstalledProviders = this.installedProviders();
    return ProviderLookup(allInstalledProviders, extensionLocators);
  }
  eip6963ProviderLookup(rdns) {
    var _a14;
    const { providers } = Eip6963ProviderSingleton.get();
    return (_a14 = providers.find((provider) => {
      var _a15;
      return ((_a15 = provider === null || provider === void 0 ? void 0 : provider.info) === null || _a15 === void 0 ? void 0 : _a15.rdns) === rdns;
    })) === null || _a14 === void 0 ? void 0 : _a14.provider;
  }
  isInstalledHelper() {
    return this.findProvider() !== void 0;
  }
  findProvider() {
    const provider = this.connector.findProvider();
    return provider;
  }
  findWalletClient(chainId) {
    const provider = this.findProvider();
    if (!provider) {
      return void 0;
    }
    return createWalletClient({
      account: this.connector.getActiveAccount(),
      chain: chainId ? chainsMap[chainId] : this.connector.getActiveChain(),
      transport: custom({
        request: (args) => provider.request(args).catch(normalizeRpcError)
      }, this.connector.providersConfig.httpTransportConfig)
    });
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      const client = this.findWalletClient();
      if (!client) {
        return Promise.resolve(void 0);
      }
      return this.getAddressWithProvider(client);
    });
  }
  getAddressWithProvider(client) {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        const [lowercaseAddress] = yield client.requestAddresses();
        const publicAddress = getAddress(lowercaseAddress);
        this.connector.setActiveAccount(publicAddress);
        return publicAddress;
      } catch (err) {
        logger.error(err);
        return Promise.reject(err);
      }
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const walletAddress = yield this.getAddress();
      if (!walletAddress) {
        return Promise.resolve(void 0);
      }
      const client = this.findWalletClient();
      if (!client) {
        return Promise.resolve(void 0);
      }
      const signedMessage = yield client.signMessage({
        account: walletAddress,
        message: messageToSign
      });
      return signedMessage;
    });
  }
  _setupEventListeners(walletConnector) {
    const web3Provider = this.findProvider();
    if (!web3Provider) {
      logger.warn("Provider not found", {
        connector: walletConnector
      });
      return {
        tearDownEventListeners: () => {
        }
      };
    }
    if (!web3Provider.on) {
      logger.warn("Provider does not support event listeners", {
        connector: walletConnector,
        provider: web3Provider
      });
      return {
        tearDownEventListeners: () => {
        }
      };
    }
    const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(walletConnector);
    web3Provider.on("accountsChanged", handleAccountChange);
    web3Provider.on("chainChanged", handleChainChange);
    web3Provider.on("disconnect", handleDisconnect);
    const tearDownEventListeners = () => {
      const web3Provider2 = this.findProvider();
      if (!web3Provider2) {
        return;
      }
      if (handleAccountChange) {
        web3Provider2.removeListener("accountsChanged", handleAccountChange);
      }
      if (handleChainChange) {
        web3Provider2.removeListener("chainChanged", handleChainChange);
      }
      if (handleDisconnect) {
        web3Provider2.removeListener("disconnect", handleDisconnect);
      }
    };
    return {
      tearDownEventListeners
    };
  }
};

// node_modules/@dynamic-labs/ethereum/src/utils/logger.js
var logger3 = new Logger("@dynamic-labs/ethereum");

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_events6 = __toESM(require_events());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress2(publicKey) {
  const address = keccak2563(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash: hash9, signature }) {
  const hashHex = isHex2(hash9) ? hash9 : toHex3(hash9);
  const { secp256k1: secp256k15 } = await import("./secp256k1-I7FSZ6OS.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r8, s: s5, v: v9, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v9);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k15.Signature(hexToBigInt2(r8), hexToBigInt2(s5)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex2(signature) ? signature : toHex3(signature);
    if (size3(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber2(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k15.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash9, signature }) {
  return publicKeyToAddress2(await recoverPublicKey({ hash: hash9, signature }));
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber2(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber2(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex2(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber2(count);
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog2(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt2(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog2(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber2(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt2);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackTransactionErrorMagicIdentifier = numberToHex2(0, {
  size: 32
});

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager2(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey2 = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey2({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey2({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey2({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey2({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager2 = createNonceManager2({
  source: jsonRpc()
});

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Hash.js
function keccak2564(value2, options = {}) {
  const { as: as17 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes2 = keccak_256(from2(value2));
  if (as17 === "Bytes")
    return bytes2;
  return fromBytes(bytes2);
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size11) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size11;
  }
  get(key) {
    const value2 = super.get(key);
    if (super.has(key) && value2 !== void 0) {
      this.delete(key);
      super.set(key, value2);
    }
    return value2;
  }
  set(key, value2) {
    super.set(key, value2);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum2 = caches.checksum;

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value2, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value2))
    throw new InvalidAddressError4({
      address: value2,
      cause: new InvalidInputError2()
    });
  if (strict) {
    if (value2.toLowerCase() === value2)
      return;
    if (checksum3(value2) !== value2)
      throw new InvalidAddressError4({
        address: value2,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum3(address) {
  if (checksum2.has(address))
    return checksum2.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash9 = keccak2564(fromString3(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i9 = 0; i9 < 40; i9 += 2) {
    if (hash9[i9 >> 1] >> 4 >= 8 && characters[i9]) {
      characters[i9] = characters[i9].toUpperCase();
    }
    if ((hash9[i9 >> 1] & 15) >= 8 && characters[i9 + 1]) {
      characters[i9 + 1] = characters[i9 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum2.set(address, result);
  return result;
}
var InvalidAddressError4 = class extends BaseError3 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError2 = class extends BaseError3 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError3 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value2) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value2;
    this.position++;
  },
  pushUint16(value2) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value2);
    this.position += 2;
  },
  pushUint24(value2) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value2 >> 8);
    this.dataView.setUint8(this.position + 2, value2 & ~4294967040);
    this.position += 3;
  },
  pushUint32(value2) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value2);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectByte();
    this.position++;
    return value2;
  },
  readBytes(length, size11) {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectBytes(length);
    this.position += size11 ?? length;
    return value2;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint8();
    this.position += 1;
    return value2;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint16();
    this.position += 2;
    return value2;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint24();
    this.position += 3;
    return value2;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint32();
    this.position += 4;
    return value2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError3 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError3 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError3 {
  constructor({ count, limit: limit2 }) {
    super(`Recursive read limit of \`${limit2}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked3(types2, values) {
  if (types2.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types2.length,
      givenLength: values.length
    });
  const data = [];
  for (let i9 = 0; i9 < types2.length; i9++) {
    const type7 = types2[i9];
    const value2 = values[i9];
    data.push(encodePacked3.encode(type7, value2));
  }
  return concat3(...data);
}
(function(encodePacked5) {
  function encode20(type7, value2, isArray4 = false) {
    if (type7 === "address") {
      const address = value2;
      assert(address);
      return padLeft2(address.toLowerCase(), isArray4 ? 32 : 0);
    }
    if (type7 === "string")
      return fromString4(value2);
    if (type7 === "bytes")
      return value2;
    if (type7 === "bool")
      return padLeft2(fromBoolean(value2), isArray4 ? 32 : 1);
    const intMatch = type7.match(integerRegex3);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size11 = Number.parseInt(bits) / 8;
      return fromNumber2(value2, {
        size: isArray4 ? 32 : size11,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type7.match(bytesRegex3);
    if (bytesMatch) {
      const [_type, size11] = bytesMatch;
      if (Number.parseInt(size11) !== (value2.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size11),
          value: value2
        });
      return padRight(value2, isArray4 ? 32 : 0);
    }
    const arrayMatch = type7.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value2)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i9 = 0; i9 < value2.length; i9++) {
        data.push(encode20(childType, value2[i9], true));
      }
      if (data.length === 0)
        return "0x";
      return concat3(...data);
    }
    throw new InvalidTypeError(type7);
  }
  encodePacked5.encode = encode20;
})(encodePacked3 || (encodePacked3 = {}));
var BytesSizeMismatchError2 = class extends BaseError3 {
  constructor({ expectedSize, value: value2 }) {
    super(`Size of bytes "${value2}" (bytes${size4(value2)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError3 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError3 {
  constructor(type7) {
    super(`Type \`${type7}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/base-x/src/esm/index.js
function base2(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j9 = 0; j9 < BASE_MAP.length; j9++) {
    BASE_MAP[j9] = 255;
  }
  for (let i9 = 0; i9 < ALPHABET2.length; i9++) {
    const x7 = ALPHABET2.charAt(i9);
    const xc3 = x7.charCodeAt(0);
    if (BASE_MAP[xc3] !== 255) {
      throw new TypeError(x7 + " is ambiguous");
    }
    BASE_MAP[xc3] = i9;
  }
  const BASE = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE);
  function encode20(source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size11 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size11);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i9 = 0;
      for (let it1 = size11 - 1; (carry !== 0 || i9 < length) && it1 !== -1; it1--, i9++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i9;
      pbegin++;
    }
    let it22 = size11 - length;
    while (it22 !== size11 && b58[it22] === 0) {
      it22++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it22 < size11; ++it22) {
      str += ALPHABET2.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size11 = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size11);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i9 = 0;
      for (let it32 = size11 - 1; (carry !== 0 || i9 < length) && it32 !== -1; it32--, i9++) {
        carry += BASE * b256[it32] >>> 0;
        b256[it32] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i9;
      psz++;
    }
    let it4 = size11 - length;
    while (it4 !== size11 && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size11 - it4));
    let j9 = zeroes;
    while (it4 !== size11) {
      vch[j9++] = b256[it4++];
    }
    return vch;
  }
  function decode10(string3) {
    const buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE + " character");
  }
  return {
    encode: encode20,
    decodeUnsafe,
    decode: decode10
  };
}
var esm_default = base2;

// node_modules/@walletconnect/utils/node_modules/bs58/src/esm/index.js
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var esm_default2 = esm_default(ALPHABET);

// node_modules/@msgpack/msgpack/dist.esm/utils/utf8.mjs
function utf8Count(str) {
  const strLength = str.length;
  let byteLength2 = 0;
  let pos = 0;
  while (pos < strLength) {
    let value2 = str.charCodeAt(pos++);
    if ((value2 & 4294967168) === 0) {
      byteLength2++;
      continue;
    } else if ((value2 & 4294965248) === 0) {
      byteLength2 += 2;
    } else {
      if (value2 >= 55296 && value2 <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value2 = ((value2 & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value2 & 4294901760) === 0) {
        byteLength2 += 3;
      } else {
        byteLength2 += 4;
      }
    }
  }
  return byteLength2;
}
function utf8EncodeJs(str, output2, outputOffset) {
  const strLength = str.length;
  let offset = outputOffset;
  let pos = 0;
  while (pos < strLength) {
    let value2 = str.charCodeAt(pos++);
    if ((value2 & 4294967168) === 0) {
      output2[offset++] = value2;
      continue;
    } else if ((value2 & 4294965248) === 0) {
      output2[offset++] = value2 >> 6 & 31 | 192;
    } else {
      if (value2 >= 55296 && value2 <= 56319) {
        if (pos < strLength) {
          const extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value2 = ((value2 & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value2 & 4294901760) === 0) {
        output2[offset++] = value2 >> 12 & 15 | 224;
        output2[offset++] = value2 >> 6 & 63 | 128;
      } else {
        output2[offset++] = value2 >> 18 & 7 | 240;
        output2[offset++] = value2 >> 12 & 63 | 128;
        output2[offset++] = value2 >> 6 & 63 | 128;
      }
    }
    output2[offset++] = value2 & 63 | 128;
  }
}
var sharedTextEncoder = new TextEncoder();
var TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output2, outputOffset) {
  sharedTextEncoder.encodeInto(str, output2.subarray(outputOffset));
}
function utf8Encode(str, output2, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output2, outputOffset);
  } else {
    utf8EncodeJs(str, output2, outputOffset);
  }
}
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes2, inputOffset, byteLength2) {
  let offset = inputOffset;
  const end = offset + byteLength2;
  const units = [];
  let result = "";
  while (offset < end) {
    const byte1 = bytes2[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = bytes2[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = bytes2[offset++] & 63;
      const byte3 = bytes2[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = bytes2[offset++] & 63;
      const byte3 = bytes2[offset++] & 63;
      const byte4 = bytes2[offset++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode(...units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode(...units);
  }
  return result;
}
var sharedTextDecoder = new TextDecoder();
var TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes2, inputOffset, byteLength2) {
  const stringBytes = bytes2.subarray(inputOffset, inputOffset + byteLength2);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes2, inputOffset, byteLength2) {
  if (byteLength2 > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes2, inputOffset, byteLength2);
  } else {
    return utf8DecodeJs(bytes2, inputOffset, byteLength2);
  }
}

// node_modules/@msgpack/msgpack/dist.esm/ExtData.mjs
var ExtData = class {
  constructor(type7, data) {
    this.type = type7;
    this.data = data;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/DecodeError.mjs
var DecodeError = class _DecodeError extends Error {
  constructor(message) {
    super(message);
    const proto = Object.create(_DecodeError.prototype);
    Object.setPrototypeOf(this, proto);
    Object.defineProperty(this, "name", {
      configurable: true,
      enumerable: false,
      value: _DecodeError.name
    });
  }
};

// node_modules/@msgpack/msgpack/dist.esm/utils/int.mjs
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value2) {
  const high = value2 / 4294967296;
  const low = value2;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value2) {
  const high = Math.floor(value2 / 4294967296);
  const low = value2;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
  const high = view.getInt32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}
function getUint64(view, offset) {
  const high = view.getUint32(offset);
  const low = view.getUint32(offset + 4);
  return high * 4294967296 + low;
}

// node_modules/@msgpack/msgpack/dist.esm/timestamp.mjs
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp({ sec, nsec }) {
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      const rv = new Uint8Array(4);
      const view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      const secHigh = sec / 4294967296;
      const secLow = sec & 4294967295;
      const rv = new Uint8Array(8);
      const view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    const rv = new Uint8Array(12);
    const view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  const msec = date.getTime();
  const sec = Math.floor(msec / 1e3);
  const nsec = (msec - sec * 1e3) * 1e6;
  const nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object2) {
  if (object2 instanceof Date) {
    const timeSpec = encodeDateToTimeSpec(object2);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      const sec = view.getUint32(0);
      const nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      const nsec30AndSecHigh2 = view.getUint32(0);
      const secLow32 = view.getUint32(4);
      const sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      const nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      const sec = getInt64(view, 4);
      const nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);
  }
}
function decodeTimestampExtension(data) {
  const timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};

// node_modules/@msgpack/msgpack/dist.esm/ExtensionCodec.mjs
var ExtensionCodec = class {
  constructor() {
    this.builtInEncoders = [];
    this.builtInDecoders = [];
    this.encoders = [];
    this.decoders = [];
    this.register(timestampExtension);
  }
  register({ type: type7, encode: encode20, decode: decode10 }) {
    if (type7 >= 0) {
      this.encoders[type7] = encode20;
      this.decoders[type7] = decode10;
    } else {
      const index2 = -1 - type7;
      this.builtInEncoders[index2] = encode20;
      this.builtInDecoders[index2] = decode10;
    }
  }
  tryToEncode(object2, context) {
    for (let i9 = 0; i9 < this.builtInEncoders.length; i9++) {
      const encodeExt = this.builtInEncoders[i9];
      if (encodeExt != null) {
        const data = encodeExt(object2, context);
        if (data != null) {
          const type7 = -1 - i9;
          return new ExtData(type7, data);
        }
      }
    }
    for (let i9 = 0; i9 < this.encoders.length; i9++) {
      const encodeExt = this.encoders[i9];
      if (encodeExt != null) {
        const data = encodeExt(object2, context);
        if (data != null) {
          const type7 = i9;
          return new ExtData(type7, data);
        }
      }
    }
    if (object2 instanceof ExtData) {
      return object2;
    }
    return null;
  }
  decode(data, type7, context) {
    const decodeExt = type7 < 0 ? this.builtInDecoders[-1 - type7] : this.decoders[type7];
    if (decodeExt) {
      return decodeExt(data, type7, context);
    } else {
      return new ExtData(type7, data);
    }
  }
};
ExtensionCodec.defaultCodec = new ExtensionCodec();

// node_modules/@msgpack/msgpack/dist.esm/utils/typedArrays.mjs
function isArrayBufferLike(buffer2) {
  return buffer2 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && buffer2 instanceof SharedArrayBuffer;
}
function ensureUint8Array(buffer2) {
  if (buffer2 instanceof Uint8Array) {
    return buffer2;
  } else if (ArrayBuffer.isView(buffer2)) {
    return new Uint8Array(buffer2.buffer, buffer2.byteOffset, buffer2.byteLength);
  } else if (isArrayBufferLike(buffer2)) {
    return new Uint8Array(buffer2);
  } else {
    return Uint8Array.from(buffer2);
  }
}

// node_modules/@msgpack/msgpack/dist.esm/Encoder.mjs
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = class _Encoder {
  constructor(options) {
    this.entered = false;
    this.extensionCodec = (options == null ? void 0 : options.extensionCodec) ?? ExtensionCodec.defaultCodec;
    this.context = options == null ? void 0 : options.context;
    this.useBigInt64 = (options == null ? void 0 : options.useBigInt64) ?? false;
    this.maxDepth = (options == null ? void 0 : options.maxDepth) ?? DEFAULT_MAX_DEPTH;
    this.initialBufferSize = (options == null ? void 0 : options.initialBufferSize) ?? DEFAULT_INITIAL_BUFFER_SIZE;
    this.sortKeys = (options == null ? void 0 : options.sortKeys) ?? false;
    this.forceFloat32 = (options == null ? void 0 : options.forceFloat32) ?? false;
    this.ignoreUndefined = (options == null ? void 0 : options.ignoreUndefined) ?? false;
    this.forceIntegerToFloat = (options == null ? void 0 : options.forceIntegerToFloat) ?? false;
    this.pos = 0;
    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
    this.bytes = new Uint8Array(this.view.buffer);
  }
  clone() {
    return new _Encoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat
    });
  }
  reinitializeState() {
    this.pos = 0;
  }
  /**
   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
   *
   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
   */
  encodeSharedRef(object2) {
    if (this.entered) {
      const instance = this.clone();
      return instance.encodeSharedRef(object2);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.doEncode(object2, 1);
      return this.bytes.subarray(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  /**
   * @returns Encodes the object and returns a copy of the encoder's internal buffer.
   */
  encode(object2) {
    if (this.entered) {
      const instance = this.clone();
      return instance.encode(object2);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.doEncode(object2, 1);
      return this.bytes.slice(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  doEncode(object2, depth) {
    if (depth > this.maxDepth) {
      throw new Error(`Too deep objects in depth ${depth}`);
    }
    if (object2 == null) {
      this.encodeNil();
    } else if (typeof object2 === "boolean") {
      this.encodeBoolean(object2);
    } else if (typeof object2 === "number") {
      if (!this.forceIntegerToFloat) {
        this.encodeNumber(object2);
      } else {
        this.encodeNumberAsFloat(object2);
      }
    } else if (typeof object2 === "string") {
      this.encodeString(object2);
    } else if (this.useBigInt64 && typeof object2 === "bigint") {
      this.encodeBigInt64(object2);
    } else {
      this.encodeObject(object2, depth);
    }
  }
  ensureBufferSizeToWrite(sizeToWrite) {
    const requiredSize = this.pos + sizeToWrite;
    if (this.view.byteLength < requiredSize) {
      this.resizeBuffer(requiredSize * 2);
    }
  }
  resizeBuffer(newSize) {
    const newBuffer = new ArrayBuffer(newSize);
    const newBytes = new Uint8Array(newBuffer);
    const newView = new DataView(newBuffer);
    newBytes.set(this.bytes);
    this.view = newView;
    this.bytes = newBytes;
  }
  encodeNil() {
    this.writeU8(192);
  }
  encodeBoolean(object2) {
    if (object2 === false) {
      this.writeU8(194);
    } else {
      this.writeU8(195);
    }
  }
  encodeNumber(object2) {
    if (!this.forceIntegerToFloat && Number.isSafeInteger(object2)) {
      if (object2 >= 0) {
        if (object2 < 128) {
          this.writeU8(object2);
        } else if (object2 < 256) {
          this.writeU8(204);
          this.writeU8(object2);
        } else if (object2 < 65536) {
          this.writeU8(205);
          this.writeU16(object2);
        } else if (object2 < 4294967296) {
          this.writeU8(206);
          this.writeU32(object2);
        } else if (!this.useBigInt64) {
          this.writeU8(207);
          this.writeU64(object2);
        } else {
          this.encodeNumberAsFloat(object2);
        }
      } else {
        if (object2 >= -32) {
          this.writeU8(224 | object2 + 32);
        } else if (object2 >= -128) {
          this.writeU8(208);
          this.writeI8(object2);
        } else if (object2 >= -32768) {
          this.writeU8(209);
          this.writeI16(object2);
        } else if (object2 >= -2147483648) {
          this.writeU8(210);
          this.writeI32(object2);
        } else if (!this.useBigInt64) {
          this.writeU8(211);
          this.writeI64(object2);
        } else {
          this.encodeNumberAsFloat(object2);
        }
      }
    } else {
      this.encodeNumberAsFloat(object2);
    }
  }
  encodeNumberAsFloat(object2) {
    if (this.forceFloat32) {
      this.writeU8(202);
      this.writeF32(object2);
    } else {
      this.writeU8(203);
      this.writeF64(object2);
    }
  }
  encodeBigInt64(object2) {
    if (object2 >= BigInt(0)) {
      this.writeU8(207);
      this.writeBigUint64(object2);
    } else {
      this.writeU8(211);
      this.writeBigInt64(object2);
    }
  }
  writeStringHeader(byteLength2) {
    if (byteLength2 < 32) {
      this.writeU8(160 + byteLength2);
    } else if (byteLength2 < 256) {
      this.writeU8(217);
      this.writeU8(byteLength2);
    } else if (byteLength2 < 65536) {
      this.writeU8(218);
      this.writeU16(byteLength2);
    } else if (byteLength2 < 4294967296) {
      this.writeU8(219);
      this.writeU32(byteLength2);
    } else {
      throw new Error(`Too long string: ${byteLength2} bytes in UTF-8`);
    }
  }
  encodeString(object2) {
    const maxHeaderSize = 1 + 4;
    const byteLength2 = utf8Count(object2);
    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength2);
    this.writeStringHeader(byteLength2);
    utf8Encode(object2, this.bytes, this.pos);
    this.pos += byteLength2;
  }
  encodeObject(object2, depth) {
    const ext = this.extensionCodec.tryToEncode(object2, this.context);
    if (ext != null) {
      this.encodeExtension(ext);
    } else if (Array.isArray(object2)) {
      this.encodeArray(object2, depth);
    } else if (ArrayBuffer.isView(object2)) {
      this.encodeBinary(object2);
    } else if (typeof object2 === "object") {
      this.encodeMap(object2, depth);
    } else {
      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object2)}`);
    }
  }
  encodeBinary(object2) {
    const size11 = object2.byteLength;
    if (size11 < 256) {
      this.writeU8(196);
      this.writeU8(size11);
    } else if (size11 < 65536) {
      this.writeU8(197);
      this.writeU16(size11);
    } else if (size11 < 4294967296) {
      this.writeU8(198);
      this.writeU32(size11);
    } else {
      throw new Error(`Too large binary: ${size11}`);
    }
    const bytes2 = ensureUint8Array(object2);
    this.writeU8a(bytes2);
  }
  encodeArray(object2, depth) {
    const size11 = object2.length;
    if (size11 < 16) {
      this.writeU8(144 + size11);
    } else if (size11 < 65536) {
      this.writeU8(220);
      this.writeU16(size11);
    } else if (size11 < 4294967296) {
      this.writeU8(221);
      this.writeU32(size11);
    } else {
      throw new Error(`Too large array: ${size11}`);
    }
    for (const item of object2) {
      this.doEncode(item, depth + 1);
    }
  }
  countWithoutUndefined(object2, keys5) {
    let count = 0;
    for (const key of keys5) {
      if (object2[key] !== void 0) {
        count++;
      }
    }
    return count;
  }
  encodeMap(object2, depth) {
    const keys5 = Object.keys(object2);
    if (this.sortKeys) {
      keys5.sort();
    }
    const size11 = this.ignoreUndefined ? this.countWithoutUndefined(object2, keys5) : keys5.length;
    if (size11 < 16) {
      this.writeU8(128 + size11);
    } else if (size11 < 65536) {
      this.writeU8(222);
      this.writeU16(size11);
    } else if (size11 < 4294967296) {
      this.writeU8(223);
      this.writeU32(size11);
    } else {
      throw new Error(`Too large map object: ${size11}`);
    }
    for (const key of keys5) {
      const value2 = object2[key];
      if (!(this.ignoreUndefined && value2 === void 0)) {
        this.encodeString(key);
        this.doEncode(value2, depth + 1);
      }
    }
  }
  encodeExtension(ext) {
    if (typeof ext.data === "function") {
      const data = ext.data(this.pos + 6);
      const size12 = data.length;
      if (size12 >= 4294967296) {
        throw new Error(`Too large extension object: ${size12}`);
      }
      this.writeU8(201);
      this.writeU32(size12);
      this.writeI8(ext.type);
      this.writeU8a(data);
      return;
    }
    const size11 = ext.data.length;
    if (size11 === 1) {
      this.writeU8(212);
    } else if (size11 === 2) {
      this.writeU8(213);
    } else if (size11 === 4) {
      this.writeU8(214);
    } else if (size11 === 8) {
      this.writeU8(215);
    } else if (size11 === 16) {
      this.writeU8(216);
    } else if (size11 < 256) {
      this.writeU8(199);
      this.writeU8(size11);
    } else if (size11 < 65536) {
      this.writeU8(200);
      this.writeU16(size11);
    } else if (size11 < 4294967296) {
      this.writeU8(201);
      this.writeU32(size11);
    } else {
      throw new Error(`Too large extension object: ${size11}`);
    }
    this.writeI8(ext.type);
    this.writeU8a(ext.data);
  }
  writeU8(value2) {
    this.ensureBufferSizeToWrite(1);
    this.view.setUint8(this.pos, value2);
    this.pos++;
  }
  writeU8a(values) {
    const size11 = values.length;
    this.ensureBufferSizeToWrite(size11);
    this.bytes.set(values, this.pos);
    this.pos += size11;
  }
  writeI8(value2) {
    this.ensureBufferSizeToWrite(1);
    this.view.setInt8(this.pos, value2);
    this.pos++;
  }
  writeU16(value2) {
    this.ensureBufferSizeToWrite(2);
    this.view.setUint16(this.pos, value2);
    this.pos += 2;
  }
  writeI16(value2) {
    this.ensureBufferSizeToWrite(2);
    this.view.setInt16(this.pos, value2);
    this.pos += 2;
  }
  writeU32(value2) {
    this.ensureBufferSizeToWrite(4);
    this.view.setUint32(this.pos, value2);
    this.pos += 4;
  }
  writeI32(value2) {
    this.ensureBufferSizeToWrite(4);
    this.view.setInt32(this.pos, value2);
    this.pos += 4;
  }
  writeF32(value2) {
    this.ensureBufferSizeToWrite(4);
    this.view.setFloat32(this.pos, value2);
    this.pos += 4;
  }
  writeF64(value2) {
    this.ensureBufferSizeToWrite(8);
    this.view.setFloat64(this.pos, value2);
    this.pos += 8;
  }
  writeU64(value2) {
    this.ensureBufferSizeToWrite(8);
    setUint64(this.view, this.pos, value2);
    this.pos += 8;
  }
  writeI64(value2) {
    this.ensureBufferSizeToWrite(8);
    setInt64(this.view, this.pos, value2);
    this.pos += 8;
  }
  writeBigUint64(value2) {
    this.ensureBufferSizeToWrite(8);
    this.view.setBigUint64(this.pos, value2);
    this.pos += 8;
  }
  writeBigInt64(value2) {
    this.ensureBufferSizeToWrite(8);
    this.view.setBigInt64(this.pos, value2);
    this.pos += 8;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/encode.mjs
function encode5(value2, options) {
  const encoder5 = new Encoder(options);
  return encoder5.encodeSharedRef(value2);
}

// node_modules/@msgpack/msgpack/dist.esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return `${byte < 0 ? "-" : ""}0x${Math.abs(byte).toString(16).padStart(2, "0")}`;
}

// node_modules/@msgpack/msgpack/dist.esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = class {
  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {
    this.hit = 0;
    this.miss = 0;
    this.maxKeyLength = maxKeyLength;
    this.maxLengthPerKey = maxLengthPerKey;
    this.caches = [];
    for (let i9 = 0; i9 < this.maxKeyLength; i9++) {
      this.caches.push([]);
    }
  }
  canBeCached(byteLength2) {
    return byteLength2 > 0 && byteLength2 <= this.maxKeyLength;
  }
  find(bytes2, inputOffset, byteLength2) {
    const records = this.caches[byteLength2 - 1];
    FIND_CHUNK: for (const record2 of records) {
      const recordBytes = record2.bytes;
      for (let j9 = 0; j9 < byteLength2; j9++) {
        if (recordBytes[j9] !== bytes2[inputOffset + j9]) {
          continue FIND_CHUNK;
        }
      }
      return record2.str;
    }
    return null;
  }
  store(bytes2, value2) {
    const records = this.caches[bytes2.length - 1];
    const record2 = { bytes: bytes2, str: value2 };
    if (records.length >= this.maxLengthPerKey) {
      records[Math.random() * records.length | 0] = record2;
    } else {
      records.push(record2);
    }
  }
  decode(bytes2, inputOffset, byteLength2) {
    const cachedValue = this.find(bytes2, inputOffset, byteLength2);
    if (cachedValue != null) {
      this.hit++;
      return cachedValue;
    }
    this.miss++;
    const str = utf8DecodeJs(bytes2, inputOffset, byteLength2);
    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes2, inputOffset, inputOffset + byteLength2);
    this.store(slicedCopyOfBytes, str);
    return str;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/Decoder.mjs
var STATE_ARRAY = "array";
var STATE_MAP_KEY = "map_key";
var STATE_MAP_VALUE = "map_value";
var mapKeyConverter = (key) => {
  if (typeof key === "string" || typeof key === "number") {
    return key;
  }
  throw new DecodeError("The type of key must be string or number but " + typeof key);
};
var StackPool = class {
  constructor() {
    this.stack = [];
    this.stackHeadPosition = -1;
  }
  get length() {
    return this.stackHeadPosition + 1;
  }
  top() {
    return this.stack[this.stackHeadPosition];
  }
  pushArrayState(size11) {
    const state = this.getUninitializedStateFromPool();
    state.type = STATE_ARRAY;
    state.position = 0;
    state.size = size11;
    state.array = new Array(size11);
  }
  pushMapState(size11) {
    const state = this.getUninitializedStateFromPool();
    state.type = STATE_MAP_KEY;
    state.readCount = 0;
    state.size = size11;
    state.map = {};
  }
  getUninitializedStateFromPool() {
    this.stackHeadPosition++;
    if (this.stackHeadPosition === this.stack.length) {
      const partialState = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null
      };
      this.stack.push(partialState);
    }
    return this.stack[this.stackHeadPosition];
  }
  release(state) {
    const topStackState = this.stack[this.stackHeadPosition];
    if (topStackState !== state) {
      throw new Error("Invalid stack state. Released state is not on top of the stack.");
    }
    if (state.type === STATE_ARRAY) {
      const partialState = state;
      partialState.size = 0;
      partialState.array = void 0;
      partialState.position = 0;
      partialState.type = void 0;
    }
    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
      const partialState = state;
      partialState.size = 0;
      partialState.map = void 0;
      partialState.readCount = 0;
      partialState.type = void 0;
    }
    this.stackHeadPosition--;
  }
  reset() {
    this.stack.length = 0;
    this.stackHeadPosition = -1;
  }
};
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
  EMPTY_VIEW.getInt8(0);
} catch (e11) {
  if (!(e11 instanceof RangeError)) {
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
  }
}
var MORE_DATA = new RangeError("Insufficient data");
var sharedCachedKeyDecoder = new CachedKeyDecoder();
var Decoder = class _Decoder {
  constructor(options) {
    this.totalPos = 0;
    this.pos = 0;
    this.view = EMPTY_VIEW;
    this.bytes = EMPTY_BYTES;
    this.headByte = HEAD_BYTE_REQUIRED;
    this.stack = new StackPool();
    this.entered = false;
    this.extensionCodec = (options == null ? void 0 : options.extensionCodec) ?? ExtensionCodec.defaultCodec;
    this.context = options == null ? void 0 : options.context;
    this.useBigInt64 = (options == null ? void 0 : options.useBigInt64) ?? false;
    this.rawStrings = (options == null ? void 0 : options.rawStrings) ?? false;
    this.maxStrLength = (options == null ? void 0 : options.maxStrLength) ?? UINT32_MAX;
    this.maxBinLength = (options == null ? void 0 : options.maxBinLength) ?? UINT32_MAX;
    this.maxArrayLength = (options == null ? void 0 : options.maxArrayLength) ?? UINT32_MAX;
    this.maxMapLength = (options == null ? void 0 : options.maxMapLength) ?? UINT32_MAX;
    this.maxExtLength = (options == null ? void 0 : options.maxExtLength) ?? UINT32_MAX;
    this.keyDecoder = (options == null ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
    this.mapKeyConverter = (options == null ? void 0 : options.mapKeyConverter) ?? mapKeyConverter;
  }
  clone() {
    return new _Decoder({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder
    });
  }
  reinitializeState() {
    this.totalPos = 0;
    this.headByte = HEAD_BYTE_REQUIRED;
    this.stack.reset();
  }
  setBuffer(buffer2) {
    const bytes2 = ensureUint8Array(buffer2);
    this.bytes = bytes2;
    this.view = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    this.pos = 0;
  }
  appendBuffer(buffer2) {
    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
      this.setBuffer(buffer2);
    } else {
      const remainingData = this.bytes.subarray(this.pos);
      const newData = ensureUint8Array(buffer2);
      const newBuffer = new Uint8Array(remainingData.length + newData.length);
      newBuffer.set(remainingData);
      newBuffer.set(newData, remainingData.length);
      this.setBuffer(newBuffer);
    }
  }
  hasRemaining(size11) {
    return this.view.byteLength - this.pos >= size11;
  }
  createExtraByteError(posToShow) {
    const { view, pos } = this;
    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);
  }
  /**
   * @throws {@link DecodeError}
   * @throws {@link RangeError}
   */
  decode(buffer2) {
    if (this.entered) {
      const instance = this.clone();
      return instance.decode(buffer2);
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.setBuffer(buffer2);
      const object2 = this.doDecodeSync();
      if (this.hasRemaining(1)) {
        throw this.createExtraByteError(this.pos);
      }
      return object2;
    } finally {
      this.entered = false;
    }
  }
  *decodeMulti(buffer2) {
    if (this.entered) {
      const instance = this.clone();
      yield* instance.decodeMulti(buffer2);
      return;
    }
    try {
      this.entered = true;
      this.reinitializeState();
      this.setBuffer(buffer2);
      while (this.hasRemaining(1)) {
        yield this.doDecodeSync();
      }
    } finally {
      this.entered = false;
    }
  }
  async decodeAsync(stream) {
    if (this.entered) {
      const instance = this.clone();
      return instance.decodeAsync(stream);
    }
    try {
      this.entered = true;
      let decoded = false;
      let object2;
      for await (const buffer2 of stream) {
        if (decoded) {
          this.entered = false;
          throw this.createExtraByteError(this.totalPos);
        }
        this.appendBuffer(buffer2);
        try {
          object2 = this.doDecodeSync();
          decoded = true;
        } catch (e11) {
          if (!(e11 instanceof RangeError)) {
            throw e11;
          }
        }
        this.totalPos += this.pos;
      }
      if (decoded) {
        if (this.hasRemaining(1)) {
          throw this.createExtraByteError(this.totalPos);
        }
        return object2;
      }
      const { headByte, pos, totalPos } = this;
      throw new RangeError(`Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`);
    } finally {
      this.entered = false;
    }
  }
  decodeArrayStream(stream) {
    return this.decodeMultiAsync(stream, true);
  }
  decodeStream(stream) {
    return this.decodeMultiAsync(stream, false);
  }
  async *decodeMultiAsync(stream, isArray4) {
    if (this.entered) {
      const instance = this.clone();
      yield* instance.decodeMultiAsync(stream, isArray4);
      return;
    }
    try {
      this.entered = true;
      let isArrayHeaderRequired = isArray4;
      let arrayItemsLeft = -1;
      for await (const buffer2 of stream) {
        if (isArray4 && arrayItemsLeft === 0) {
          throw this.createExtraByteError(this.totalPos);
        }
        this.appendBuffer(buffer2);
        if (isArrayHeaderRequired) {
          arrayItemsLeft = this.readArraySize();
          isArrayHeaderRequired = false;
          this.complete();
        }
        try {
          while (true) {
            yield this.doDecodeSync();
            if (--arrayItemsLeft === 0) {
              break;
            }
          }
        } catch (e11) {
          if (!(e11 instanceof RangeError)) {
            throw e11;
          }
        }
        this.totalPos += this.pos;
      }
    } finally {
      this.entered = false;
    }
  }
  doDecodeSync() {
    DECODE: while (true) {
      const headByte = this.readHeadByte();
      let object2;
      if (headByte >= 224) {
        object2 = headByte - 256;
      } else if (headByte < 192) {
        if (headByte < 128) {
          object2 = headByte;
        } else if (headByte < 144) {
          const size11 = headByte - 128;
          if (size11 !== 0) {
            this.pushMapState(size11);
            this.complete();
            continue DECODE;
          } else {
            object2 = {};
          }
        } else if (headByte < 160) {
          const size11 = headByte - 144;
          if (size11 !== 0) {
            this.pushArrayState(size11);
            this.complete();
            continue DECODE;
          } else {
            object2 = [];
          }
        } else {
          const byteLength2 = headByte - 160;
          object2 = this.decodeString(byteLength2, 0);
        }
      } else if (headByte === 192) {
        object2 = null;
      } else if (headByte === 194) {
        object2 = false;
      } else if (headByte === 195) {
        object2 = true;
      } else if (headByte === 202) {
        object2 = this.readF32();
      } else if (headByte === 203) {
        object2 = this.readF64();
      } else if (headByte === 204) {
        object2 = this.readU8();
      } else if (headByte === 205) {
        object2 = this.readU16();
      } else if (headByte === 206) {
        object2 = this.readU32();
      } else if (headByte === 207) {
        if (this.useBigInt64) {
          object2 = this.readU64AsBigInt();
        } else {
          object2 = this.readU64();
        }
      } else if (headByte === 208) {
        object2 = this.readI8();
      } else if (headByte === 209) {
        object2 = this.readI16();
      } else if (headByte === 210) {
        object2 = this.readI32();
      } else if (headByte === 211) {
        if (this.useBigInt64) {
          object2 = this.readI64AsBigInt();
        } else {
          object2 = this.readI64();
        }
      } else if (headByte === 217) {
        const byteLength2 = this.lookU8();
        object2 = this.decodeString(byteLength2, 1);
      } else if (headByte === 218) {
        const byteLength2 = this.lookU16();
        object2 = this.decodeString(byteLength2, 2);
      } else if (headByte === 219) {
        const byteLength2 = this.lookU32();
        object2 = this.decodeString(byteLength2, 4);
      } else if (headByte === 220) {
        const size11 = this.readU16();
        if (size11 !== 0) {
          this.pushArrayState(size11);
          this.complete();
          continue DECODE;
        } else {
          object2 = [];
        }
      } else if (headByte === 221) {
        const size11 = this.readU32();
        if (size11 !== 0) {
          this.pushArrayState(size11);
          this.complete();
          continue DECODE;
        } else {
          object2 = [];
        }
      } else if (headByte === 222) {
        const size11 = this.readU16();
        if (size11 !== 0) {
          this.pushMapState(size11);
          this.complete();
          continue DECODE;
        } else {
          object2 = {};
        }
      } else if (headByte === 223) {
        const size11 = this.readU32();
        if (size11 !== 0) {
          this.pushMapState(size11);
          this.complete();
          continue DECODE;
        } else {
          object2 = {};
        }
      } else if (headByte === 196) {
        const size11 = this.lookU8();
        object2 = this.decodeBinary(size11, 1);
      } else if (headByte === 197) {
        const size11 = this.lookU16();
        object2 = this.decodeBinary(size11, 2);
      } else if (headByte === 198) {
        const size11 = this.lookU32();
        object2 = this.decodeBinary(size11, 4);
      } else if (headByte === 212) {
        object2 = this.decodeExtension(1, 0);
      } else if (headByte === 213) {
        object2 = this.decodeExtension(2, 0);
      } else if (headByte === 214) {
        object2 = this.decodeExtension(4, 0);
      } else if (headByte === 215) {
        object2 = this.decodeExtension(8, 0);
      } else if (headByte === 216) {
        object2 = this.decodeExtension(16, 0);
      } else if (headByte === 199) {
        const size11 = this.lookU8();
        object2 = this.decodeExtension(size11, 1);
      } else if (headByte === 200) {
        const size11 = this.lookU16();
        object2 = this.decodeExtension(size11, 2);
      } else if (headByte === 201) {
        const size11 = this.lookU32();
        object2 = this.decodeExtension(size11, 4);
      } else {
        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);
      }
      this.complete();
      const stack = this.stack;
      while (stack.length > 0) {
        const state = stack.top();
        if (state.type === STATE_ARRAY) {
          state.array[state.position] = object2;
          state.position++;
          if (state.position === state.size) {
            object2 = state.array;
            stack.release(state);
          } else {
            continue DECODE;
          }
        } else if (state.type === STATE_MAP_KEY) {
          if (object2 === "__proto__") {
            throw new DecodeError("The key __proto__ is not allowed");
          }
          state.key = this.mapKeyConverter(object2);
          state.type = STATE_MAP_VALUE;
          continue DECODE;
        } else {
          state.map[state.key] = object2;
          state.readCount++;
          if (state.readCount === state.size) {
            object2 = state.map;
            stack.release(state);
          } else {
            state.key = null;
            state.type = STATE_MAP_KEY;
            continue DECODE;
          }
        }
      }
      return object2;
    }
  }
  readHeadByte() {
    if (this.headByte === HEAD_BYTE_REQUIRED) {
      this.headByte = this.readU8();
    }
    return this.headByte;
  }
  complete() {
    this.headByte = HEAD_BYTE_REQUIRED;
  }
  readArraySize() {
    const headByte = this.readHeadByte();
    switch (headByte) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (headByte < 160) {
          return headByte - 144;
        } else {
          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);
        }
      }
    }
  }
  pushMapState(size11) {
    if (size11 > this.maxMapLength) {
      throw new DecodeError(`Max length exceeded: map length (${size11}) > maxMapLengthLength (${this.maxMapLength})`);
    }
    this.stack.pushMapState(size11);
  }
  pushArrayState(size11) {
    if (size11 > this.maxArrayLength) {
      throw new DecodeError(`Max length exceeded: array length (${size11}) > maxArrayLength (${this.maxArrayLength})`);
    }
    this.stack.pushArrayState(size11);
  }
  decodeString(byteLength2, headerOffset) {
    if (!this.rawStrings || this.stateIsMapKey()) {
      return this.decodeUtf8String(byteLength2, headerOffset);
    }
    return this.decodeBinary(byteLength2, headerOffset);
  }
  /**
   * @throws {@link RangeError}
   */
  decodeUtf8String(byteLength2, headerOffset) {
    var _a14;
    if (byteLength2 > this.maxStrLength) {
      throw new DecodeError(`Max length exceeded: UTF-8 byte length (${byteLength2}) > maxStrLength (${this.maxStrLength})`);
    }
    if (this.bytes.byteLength < this.pos + headerOffset + byteLength2) {
      throw MORE_DATA;
    }
    const offset = this.pos + headerOffset;
    let object2;
    if (this.stateIsMapKey() && ((_a14 = this.keyDecoder) == null ? void 0 : _a14.canBeCached(byteLength2))) {
      object2 = this.keyDecoder.decode(this.bytes, offset, byteLength2);
    } else {
      object2 = utf8Decode(this.bytes, offset, byteLength2);
    }
    this.pos += headerOffset + byteLength2;
    return object2;
  }
  stateIsMapKey() {
    if (this.stack.length > 0) {
      const state = this.stack.top();
      return state.type === STATE_MAP_KEY;
    }
    return false;
  }
  /**
   * @throws {@link RangeError}
   */
  decodeBinary(byteLength2, headOffset) {
    if (byteLength2 > this.maxBinLength) {
      throw new DecodeError(`Max length exceeded: bin length (${byteLength2}) > maxBinLength (${this.maxBinLength})`);
    }
    if (!this.hasRemaining(byteLength2 + headOffset)) {
      throw MORE_DATA;
    }
    const offset = this.pos + headOffset;
    const object2 = this.bytes.subarray(offset, offset + byteLength2);
    this.pos += headOffset + byteLength2;
    return object2;
  }
  decodeExtension(size11, headOffset) {
    if (size11 > this.maxExtLength) {
      throw new DecodeError(`Max length exceeded: ext length (${size11}) > maxExtLength (${this.maxExtLength})`);
    }
    const extType = this.view.getInt8(this.pos + headOffset);
    const data = this.decodeBinary(
      size11,
      headOffset + 1
      /* extType */
    );
    return this.extensionCodec.decode(data, extType, this.context);
  }
  lookU8() {
    return this.view.getUint8(this.pos);
  }
  lookU16() {
    return this.view.getUint16(this.pos);
  }
  lookU32() {
    return this.view.getUint32(this.pos);
  }
  readU8() {
    const value2 = this.view.getUint8(this.pos);
    this.pos++;
    return value2;
  }
  readI8() {
    const value2 = this.view.getInt8(this.pos);
    this.pos++;
    return value2;
  }
  readU16() {
    const value2 = this.view.getUint16(this.pos);
    this.pos += 2;
    return value2;
  }
  readI16() {
    const value2 = this.view.getInt16(this.pos);
    this.pos += 2;
    return value2;
  }
  readU32() {
    const value2 = this.view.getUint32(this.pos);
    this.pos += 4;
    return value2;
  }
  readI32() {
    const value2 = this.view.getInt32(this.pos);
    this.pos += 4;
    return value2;
  }
  readU64() {
    const value2 = getUint64(this.view, this.pos);
    this.pos += 8;
    return value2;
  }
  readI64() {
    const value2 = getInt64(this.view, this.pos);
    this.pos += 8;
    return value2;
  }
  readU64AsBigInt() {
    const value2 = this.view.getBigUint64(this.pos);
    this.pos += 8;
    return value2;
  }
  readI64AsBigInt() {
    const value2 = this.view.getBigInt64(this.pos);
    this.pos += 8;
    return value2;
  }
  readF32() {
    const value2 = this.view.getFloat32(this.pos);
    this.pos += 4;
    return value2;
  }
  readF64() {
    const value2 = this.view.getFloat64(this.pos);
    this.pos += 8;
    return value2;
  }
};

// node_modules/@msgpack/msgpack/dist.esm/decode.mjs
function decode2(buffer2, options) {
  const decoder4 = new Decoder(options);
  return decoder4.decode(buffer2);
}

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size11 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size11));
  }
  return new Uint8Array(size11);
}

// node_modules/uint8arrays/esm/src/concat.js
function concat5(arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name, prefix, encode20, decode10) {
  return {
    name,
    prefix,
    encoder: {
      name,
      prefix,
      encode: encode20
    },
    decoder: { decode: decode10 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder4 = new TextDecoder("utf8");
  return "u" + decoder4.decode(buf);
}, (str) => {
  const encoder5 = new TextEncoder();
  return encoder5.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string3 = "a";
  for (let i9 = 0; i9 < buf.length; i9++) {
    string3 += String.fromCharCode(buf[i9]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i9 = 0; i9 < str.length; i9++) {
    buf[i9] = str.charCodeAt(i9);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/uint8arrays/esm/src/from-string.js
function fromString5(string3, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string3, "utf-8"));
  }
  return base4.decoder.decode(`${base4.prefix}${string3}`);
}

// node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base4.encoder.encode(array).substring(1);
}

// node_modules/@walletconnect/utils/dist/index.es.js
var import_blakejs = __toESM(require_blakejs());
var xe = ":";
function Fe(t6) {
  const [e11, n5] = t6.split(xe);
  return { namespace: e11, reference: n5 };
}
function _s(t6, e11 = []) {
  const n5 = [];
  return Object.keys(t6).forEach((r8) => {
    if (e11.length && !e11.includes(r8)) return;
    const o6 = t6[r8];
    n5.push(...o6.accounts);
  }), n5;
}
function ve(t6, e11) {
  return t6.includes(":") ? [t6] : e11.chains || [];
}
var $s = Object.defineProperty;
var Cs = Object.defineProperties;
var Ls = Object.getOwnPropertyDescriptors;
var Jn = Object.getOwnPropertySymbols;
var js = Object.prototype.hasOwnProperty;
var ks = Object.prototype.propertyIsEnumerable;
var Ze = (t6, e11, n5) => e11 in t6 ? $s(t6, e11, { enumerable: true, configurable: true, writable: true, value: n5 }) : t6[e11] = n5;
var Qn = (t6, e11) => {
  for (var n5 in e11 || (e11 = {})) js.call(e11, n5) && Ze(t6, n5, e11[n5]);
  if (Jn) for (var n5 of Jn(e11)) ks.call(e11, n5) && Ze(t6, n5, e11[n5]);
  return t6;
};
var Ps = (t6, e11) => Cs(t6, Ls(e11));
var tr = (t6, e11, n5) => Ze(t6, typeof e11 != "symbol" ? e11 + "" : e11, n5);
var er = "ReactNative";
var J = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var rr = "js";
function Ye() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Bt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === er;
}
function Ms() {
  return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function Vs() {
  return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function zt() {
  return !Ye() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function Pt() {
  return Bt() ? J.reactNative : Ye() ? J.node : zt() ? J.browser : J.unknown;
}
function qs() {
  var t6;
  try {
    return Bt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t6 = global.Application) == null ? void 0 : t6.applicationId : void 0;
  } catch {
    return;
  }
}
function or(t6, e11) {
  const n5 = new URLSearchParams(t6);
  for (const r8 of Object.keys(e11).sort()) if (e11.hasOwnProperty(r8)) {
    const o6 = e11[r8];
    o6 !== void 0 && n5.set(r8, o6);
  }
  return n5.toString();
}
function Ks(t6) {
  var e11, n5;
  const r8 = sr();
  try {
    return t6 != null && t6.url && r8.url && new URL(t6.url).host !== new URL(r8.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t6.url} differs from the actual page url:${r8.url}. This is probably unintended and can lead to issues.`), t6.url = r8.url), (e11 = t6 == null ? void 0 : t6.icons) != null && e11.length && t6.icons.length > 0 && (t6.icons = t6.icons.filter((o6) => o6 !== "")), Ps(Qn(Qn({}, r8), t6), { url: (t6 == null ? void 0 : t6.url) || r8.url, name: (t6 == null ? void 0 : t6.name) || r8.name, description: (t6 == null ? void 0 : t6.description) || r8.description, icons: (n5 = t6 == null ? void 0 : t6.icons) != null && n5.length && t6.icons.length > 0 ? t6.icons : r8.icons });
  } catch (o6) {
    return console.warn("Error populating app metadata", o6), t6 || r8;
  }
}
function sr() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ir() {
  if (Pt() === J.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n5, Version: r8 } = global.Platform;
    return [n5, r8].join("-");
  }
  const t6 = detect();
  if (t6 === null) return "unknown";
  const e11 = t6.os ? t6.os.replace(" ", "").toLowerCase() : "unknown";
  return t6.type === "browser" ? [e11, t6.name, t6.version].join("-") : [e11, t6.version].join("-");
}
function fr() {
  var t6;
  const e11 = Pt();
  return e11 === J.browser ? [e11, ((t6 = (0, import_window_getters.getLocation)()) == null ? void 0 : t6.host) || "unknown"].join(":") : e11;
}
function cr(t6, e11, n5) {
  const r8 = ir(), o6 = fr();
  return [[t6, e11].join("-"), [rr, n5].join("-"), r8, o6].join("/");
}
function zs({ protocol: t6, version: e11, relayUrl: n5, sdkVersion: r8, auth: o6, projectId: s5, useOnCloseEvent: i9, bundleId: f16, packageName: a6 }) {
  const l9 = n5.split("?"), c9 = cr(t6, e11, r8), u10 = { auth: o6, ua: c9, projectId: s5, useOnCloseEvent: i9 || void 0, packageName: a6 || void 0, bundleId: f16 || void 0 }, h9 = or(l9[1] || "", u10);
  return l9[0] + "?" + h9;
}
function It(t6, e11) {
  return t6.filter((n5) => e11.includes(n5)).length === t6.length;
}
function Ys(t6) {
  return Object.fromEntries(t6.entries());
}
function Xs(t6) {
  return new Map(Object.entries(t6));
}
function ei(t6 = import_time.FIVE_MINUTES, e11) {
  const n5 = (0, import_time.toMiliseconds)(t6 || import_time.FIVE_MINUTES);
  let r8, o6, s5, i9;
  return { resolve: (f16) => {
    s5 && r8 && (clearTimeout(s5), r8(f16), i9 = Promise.resolve(f16));
  }, reject: (f16) => {
    s5 && o6 && (clearTimeout(s5), o6(f16));
  }, done: () => new Promise((f16, a6) => {
    if (i9) return f16(i9);
    s5 = setTimeout(() => {
      const l9 = new Error(e11);
      i9 = Promise.reject(l9), a6(l9);
    }, n5), r8 = f16, o6 = a6;
  }) };
}
function ni(t6, e11, n5) {
  return new Promise(async (r8, o6) => {
    const s5 = setTimeout(() => o6(new Error(n5)), e11);
    try {
      const i9 = await t6;
      r8(i9);
    } catch (i9) {
      o6(i9);
    }
    clearTimeout(s5);
  });
}
function Xe(t6, e11) {
  if (typeof e11 == "string" && e11.startsWith(`${t6}:`)) return e11;
  if (t6.toLowerCase() === "topic") {
    if (typeof e11 != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e11}`;
  } else if (t6.toLowerCase() === "id") {
    if (typeof e11 != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e11}`;
  }
  throw new Error(`Unknown expirer target type: ${t6}`);
}
function ri(t6) {
  return Xe("topic", t6);
}
function oi(t6) {
  return Xe("id", t6);
}
function si(t6) {
  const [e11, n5] = t6.split(":"), r8 = { id: void 0, topic: void 0 };
  if (e11 === "topic" && typeof n5 == "string") r8.topic = n5;
  else if (e11 === "id" && Number.isInteger(Number(n5))) r8.id = Number(n5);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e11}:${n5}`);
  return r8;
}
function ii(t6, e11) {
  return (0, import_time.fromMiliseconds)((e11 || Date.now()) + (0, import_time.toMiliseconds)(t6));
}
function fi(t6) {
  return Date.now() >= (0, import_time.toMiliseconds)(t6);
}
function ci(t6, e11) {
  return `${t6}${e11 ? `:${e11}` : ""}`;
}
function ct(t6 = [], e11 = []) {
  return [.../* @__PURE__ */ new Set([...t6, ...e11])];
}
async function ai({ id: t6, topic: e11, wcDeepLink: n5 }) {
  var r8;
  try {
    if (!n5) return;
    const o6 = typeof n5 == "string" ? JSON.parse(n5) : n5, s5 = o6 == null ? void 0 : o6.href;
    if (typeof s5 != "string") return;
    const i9 = dr(s5, t6, e11), f16 = Pt();
    if (f16 === J.browser) {
      if (!((r8 = (0, import_window_getters.getDocument)()) != null && r8.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      hr(i9);
    } else f16 === J.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(i9);
  } catch (o6) {
    console.error(o6);
  }
}
function dr(t6, e11, n5) {
  const r8 = `requestId=${e11}&sessionTopic=${n5}`;
  t6.endsWith("/") && (t6 = t6.slice(0, -1));
  let o6 = `${t6}`;
  if (t6.startsWith("https://t.me")) {
    const s5 = t6.includes("?") ? "&startapp=" : "?startapp=";
    o6 = `${o6}${s5}${br(r8, true)}`;
  } else o6 = `${o6}/wc?${r8}`;
  return o6;
}
function hr(t6) {
  let e11 = "_self";
  gr() ? e11 = "_top" : (pr() || t6.startsWith("https://") || t6.startsWith("http://")) && (e11 = "_blank"), window.open(t6, e11, "noreferrer noopener");
}
async function ui(t6, e11) {
  let n5 = "";
  try {
    if (zt() && (n5 = localStorage.getItem(e11), n5)) return n5;
    n5 = await t6.getItem(e11);
  } catch (r8) {
    console.error(r8);
  }
  return n5;
}
function li(t6, e11) {
  if (!t6.includes(e11)) return null;
  const n5 = t6.split(/([&,?,=])/), r8 = n5.indexOf(e11);
  return n5[r8 + 2];
}
function di() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t6) => {
    const e11 = Math.random() * 16 | 0;
    return (t6 === "x" ? e11 : e11 & 3 | 8).toString(16);
  });
}
function hi() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function pr() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function gr() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function br(t6, e11 = false) {
  const n5 = Buffer.from(t6).toString("base64");
  return e11 ? n5.replace(/[=]/g, "") : n5;
}
function Qe2(t6) {
  return Buffer.from(t6, "base64").toString("utf-8");
}
function pi(t6) {
  return new Promise((e11) => setTimeout(e11, t6));
}
var gi = class {
  constructor({ limit: e11 }) {
    tr(this, "limit"), tr(this, "set"), this.limit = e11, this.set = /* @__PURE__ */ new Set();
  }
  add(e11) {
    if (!this.set.has(e11)) {
      if (this.set.size >= this.limit) {
        const n5 = this.set.values().next().value;
        n5 && this.set.delete(n5);
      }
      this.set.add(e11);
    }
  }
  has(e11) {
    return this.set.has(e11);
  }
};
var Be = BigInt(2 ** 32 - 1);
var yr = BigInt(32);
function mr(t6, e11 = false) {
  return e11 ? { h: Number(t6 & Be), l: Number(t6 >> yr & Be) } : { h: Number(t6 >> yr & Be) | 0, l: Number(t6 & Be) | 0 };
}
function wr(t6, e11 = false) {
  const n5 = t6.length;
  let r8 = new Uint32Array(n5), o6 = new Uint32Array(n5);
  for (let s5 = 0; s5 < n5; s5++) {
    const { h: i9, l: f16 } = mr(t6[s5], e11);
    [r8[s5], o6[s5]] = [i9, f16];
  }
  return [r8, o6];
}
var xr = (t6, e11, n5) => t6 >>> n5;
var vr = (t6, e11, n5) => t6 << 32 - n5 | e11 >>> n5;
var At = (t6, e11, n5) => t6 >>> n5 | e11 << 32 - n5;
var St = (t6, e11, n5) => t6 << 32 - n5 | e11 >>> n5;
var se = (t6, e11, n5) => t6 << 64 - n5 | e11 >>> n5 - 32;
var ie = (t6, e11, n5) => t6 >>> n5 - 32 | e11 << 64 - n5;
var bi = (t6, e11) => e11;
var yi = (t6, e11) => t6;
var mi = (t6, e11, n5) => t6 << n5 | e11 >>> 32 - n5;
var wi = (t6, e11, n5) => e11 << n5 | t6 >>> 32 - n5;
var xi = (t6, e11, n5) => e11 << n5 - 32 | t6 >>> 64 - n5;
var vi = (t6, e11, n5) => t6 << n5 - 32 | e11 >>> 64 - n5;
function dt(t6, e11, n5, r8) {
  const o6 = (e11 >>> 0) + (r8 >>> 0);
  return { h: t6 + n5 + (o6 / 2 ** 32 | 0) | 0, l: o6 | 0 };
}
var tn = (t6, e11, n5) => (t6 >>> 0) + (e11 >>> 0) + (n5 >>> 0);
var en = (t6, e11, n5, r8) => e11 + n5 + r8 + (t6 / 2 ** 32 | 0) | 0;
var Ei = (t6, e11, n5, r8) => (t6 >>> 0) + (e11 >>> 0) + (n5 >>> 0) + (r8 >>> 0);
var Bi = (t6, e11, n5, r8, o6) => e11 + n5 + r8 + o6 + (t6 / 2 ** 32 | 0) | 0;
var Ii = (t6, e11, n5, r8, o6) => (t6 >>> 0) + (e11 >>> 0) + (n5 >>> 0) + (r8 >>> 0) + (o6 >>> 0);
var Ai = (t6, e11, n5, r8, o6, s5) => e11 + n5 + r8 + o6 + s5 + (t6 / 2 ** 32 | 0) | 0;
var Gt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn(t6) {
  return t6 instanceof Uint8Array || ArrayBuffer.isView(t6) && t6.constructor.name === "Uint8Array";
}
function mt(t6) {
  if (!Number.isSafeInteger(t6) || t6 < 0) throw new Error("positive integer expected, got " + t6);
}
function at(t6, ...e11) {
  if (!nn(t6)) throw new Error("Uint8Array expected");
  if (e11.length > 0 && !e11.includes(t6.length)) throw new Error("Uint8Array expected of length " + e11 + ", got length=" + t6.length);
}
function rn(t6) {
  if (typeof t6 != "function" || typeof t6.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  mt(t6.outputLen), mt(t6.blockLen);
}
function Nt(t6, e11 = true) {
  if (t6.destroyed) throw new Error("Hash instance has been destroyed");
  if (e11 && t6.finished) throw new Error("Hash#digest() has already been called");
}
function on(t6, e11) {
  at(t6);
  const n5 = e11.outputLen;
  if (t6.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function fe(t6) {
  return new Uint32Array(t6.buffer, t6.byteOffset, Math.floor(t6.byteLength / 4));
}
function ut(...t6) {
  for (let e11 = 0; e11 < t6.length; e11++) t6[e11].fill(0);
}
function sn2(t6) {
  return new DataView(t6.buffer, t6.byteOffset, t6.byteLength);
}
function gt(t6, e11) {
  return t6 << 32 - e11 | t6 >>> e11;
}
var Er = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Br(t6) {
  return t6 << 24 & 4278190080 | t6 << 8 & 16711680 | t6 >>> 8 & 65280 | t6 >>> 24 & 255;
}
var wt = Er ? (t6) => t6 : (t6) => Br(t6);
function Si(t6) {
  for (let e11 = 0; e11 < t6.length; e11++) t6[e11] = Br(t6[e11]);
  return t6;
}
var Ot = Er ? (t6) => t6 : Si;
var Ir = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var Ni = Array.from({ length: 256 }, (t6, e11) => e11.toString(16).padStart(2, "0"));
function ce(t6) {
  if (at(t6), Ir) return t6.toHex();
  let e11 = "";
  for (let n5 = 0; n5 < t6.length; n5++) e11 += Ni[t6[n5]];
  return e11;
}
var xt = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Ar(t6) {
  if (t6 >= xt._0 && t6 <= xt._9) return t6 - xt._0;
  if (t6 >= xt.A && t6 <= xt.F) return t6 - (xt.A - 10);
  if (t6 >= xt.a && t6 <= xt.f) return t6 - (xt.a - 10);
}
function fn(t6) {
  if (typeof t6 != "string") throw new Error("hex string expected, got " + typeof t6);
  if (Ir) return Uint8Array.fromHex(t6);
  const e11 = t6.length, n5 = e11 / 2;
  if (e11 % 2) throw new Error("hex string expected, got unpadded hex of length " + e11);
  const r8 = new Uint8Array(n5);
  for (let o6 = 0, s5 = 0; o6 < n5; o6++, s5 += 2) {
    const i9 = Ar(t6.charCodeAt(s5)), f16 = Ar(t6.charCodeAt(s5 + 1));
    if (i9 === void 0 || f16 === void 0) {
      const a6 = t6[s5] + t6[s5 + 1];
      throw new Error('hex string expected, got non-hex character "' + a6 + '" at index ' + s5);
    }
    r8[o6] = i9 * 16 + f16;
  }
  return r8;
}
function Oi(t6) {
  if (typeof t6 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t6));
}
function ht(t6) {
  return typeof t6 == "string" && (t6 = Oi(t6)), at(t6), t6;
}
function Ht(...t6) {
  let e11 = 0;
  for (let r8 = 0; r8 < t6.length; r8++) {
    const o6 = t6[r8];
    at(o6), e11 += o6.length;
  }
  const n5 = new Uint8Array(e11);
  for (let r8 = 0, o6 = 0; r8 < t6.length; r8++) {
    const s5 = t6[r8];
    n5.set(s5, o6), o6 += s5.length;
  }
  return n5;
}
var Ie = class {
};
function ae(t6) {
  const e11 = (r8) => t6().update(ht(r8)).digest(), n5 = t6();
  return e11.outputLen = n5.outputLen, e11.blockLen = n5.blockLen, e11.create = () => t6(), e11;
}
function Ui(t6) {
  const e11 = (r8, o6) => t6(o6).update(ht(r8)).digest(), n5 = t6({});
  return e11.outputLen = n5.outputLen, e11.blockLen = n5.blockLen, e11.create = (r8) => t6(r8), e11;
}
function Zt(t6 = 32) {
  if (Gt && typeof Gt.getRandomValues == "function") return Gt.getRandomValues(new Uint8Array(t6));
  if (Gt && typeof Gt.randomBytes == "function") return Uint8Array.from(Gt.randomBytes(t6));
  throw new Error("crypto.getRandomValues must be defined");
}
var _i = BigInt(0);
var ue = BigInt(1);
var Ti = BigInt(2);
var Ri = BigInt(7);
var $i = BigInt(256);
var Ci = BigInt(113);
var Sr = [];
var Nr = [];
var Or = [];
for (let t6 = 0, e11 = ue, n5 = 1, r8 = 0; t6 < 24; t6++) {
  [n5, r8] = [r8, (2 * n5 + 3 * r8) % 5], Sr.push(2 * (5 * r8 + n5)), Nr.push((t6 + 1) * (t6 + 2) / 2 % 64);
  let o6 = _i;
  for (let s5 = 0; s5 < 7; s5++) e11 = (e11 << ue ^ (e11 >> Ri) * Ci) % $i, e11 & Ti && (o6 ^= ue << (ue << BigInt(s5)) - ue);
  Or.push(o6);
}
var Ur = wr(Or, true);
var Li = Ur[0];
var ji = Ur[1];
var _r = (t6, e11, n5) => n5 > 32 ? xi(t6, e11, n5) : mi(t6, e11, n5);
var Tr = (t6, e11, n5) => n5 > 32 ? vi(t6, e11, n5) : wi(t6, e11, n5);
function ki(t6, e11 = 24) {
  const n5 = new Uint32Array(10);
  for (let r8 = 24 - e11; r8 < 24; r8++) {
    for (let i9 = 0; i9 < 10; i9++) n5[i9] = t6[i9] ^ t6[i9 + 10] ^ t6[i9 + 20] ^ t6[i9 + 30] ^ t6[i9 + 40];
    for (let i9 = 0; i9 < 10; i9 += 2) {
      const f16 = (i9 + 8) % 10, a6 = (i9 + 2) % 10, l9 = n5[a6], c9 = n5[a6 + 1], u10 = _r(l9, c9, 1) ^ n5[f16], h9 = Tr(l9, c9, 1) ^ n5[f16 + 1];
      for (let g4 = 0; g4 < 50; g4 += 10) t6[i9 + g4] ^= u10, t6[i9 + g4 + 1] ^= h9;
    }
    let o6 = t6[2], s5 = t6[3];
    for (let i9 = 0; i9 < 24; i9++) {
      const f16 = Nr[i9], a6 = _r(o6, s5, f16), l9 = Tr(o6, s5, f16), c9 = Sr[i9];
      o6 = t6[c9], s5 = t6[c9 + 1], t6[c9] = a6, t6[c9 + 1] = l9;
    }
    for (let i9 = 0; i9 < 50; i9 += 10) {
      for (let f16 = 0; f16 < 10; f16++) n5[f16] = t6[i9 + f16];
      for (let f16 = 0; f16 < 10; f16++) t6[i9 + f16] ^= ~n5[(f16 + 2) % 10] & n5[(f16 + 4) % 10];
    }
    t6[0] ^= Li[r8], t6[1] ^= ji[r8];
  }
  ut(n5);
}
var qn = class _qn extends Ie {
  constructor(e11, n5, r8, o6 = false, s5 = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e11, this.suffix = n5, this.outputLen = r8, this.enableXOF = o6, this.rounds = s5, mt(r8), !(0 < e11 && e11 < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = fe(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    Ot(this.state32), ki(this.state32, this.rounds), Ot(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e11) {
    Nt(this), e11 = ht(e11), at(e11);
    const { blockLen: n5, state: r8 } = this, o6 = e11.length;
    for (let s5 = 0; s5 < o6; ) {
      const i9 = Math.min(n5 - this.pos, o6 - s5);
      for (let f16 = 0; f16 < i9; f16++) r8[this.pos++] ^= e11[s5++];
      this.pos === n5 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e11, suffix: n5, pos: r8, blockLen: o6 } = this;
    e11[r8] ^= n5, (n5 & 128) !== 0 && r8 === o6 - 1 && this.keccak(), e11[o6 - 1] ^= 128, this.keccak();
  }
  writeInto(e11) {
    Nt(this, false), at(e11), this.finish();
    const n5 = this.state, { blockLen: r8 } = this;
    for (let o6 = 0, s5 = e11.length; o6 < s5; ) {
      this.posOut >= r8 && this.keccak();
      const i9 = Math.min(r8 - this.posOut, s5 - o6);
      e11.set(n5.subarray(this.posOut, this.posOut + i9), o6), this.posOut += i9, o6 += i9;
    }
    return e11;
  }
  xofInto(e11) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e11);
  }
  xof(e11) {
    return mt(e11), this.xofInto(new Uint8Array(e11));
  }
  digestInto(e11) {
    if (on(e11, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e11), this.destroy(), e11;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, ut(this.state);
  }
  _cloneInto(e11) {
    const { blockLen: n5, suffix: r8, outputLen: o6, rounds: s5, enableXOF: i9 } = this;
    return e11 || (e11 = new _qn(n5, r8, o6, i9, s5)), e11.state32.set(this.state32), e11.pos = this.pos, e11.posOut = this.posOut, e11.finished = this.finished, e11.rounds = s5, e11.suffix = r8, e11.outputLen = o6, e11.enableXOF = i9, e11.destroyed = this.destroyed, e11;
  }
};
var Pi = (t6, e11, n5) => ae(() => new qn(e11, t6, n5));
var Hi = Pi(1, 136, 256 / 8);
function Di(t6, e11, n5, r8) {
  if (typeof t6.setBigUint64 == "function") return t6.setBigUint64(e11, n5, r8);
  const o6 = BigInt(32), s5 = BigInt(4294967295), i9 = Number(n5 >> o6 & s5), f16 = Number(n5 & s5), a6 = r8 ? 4 : 0, l9 = r8 ? 0 : 4;
  t6.setUint32(e11 + a6, i9, r8), t6.setUint32(e11 + l9, f16, r8);
}
function Mi(t6, e11, n5) {
  return t6 & e11 ^ ~t6 & n5;
}
function Vi(t6, e11, n5) {
  return t6 & e11 ^ t6 & n5 ^ e11 & n5;
}
var Rr = class extends Ie {
  constructor(e11, n5, r8, o6) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e11, this.outputLen = n5, this.padOffset = r8, this.isLE = o6, this.buffer = new Uint8Array(e11), this.view = sn2(this.buffer);
  }
  update(e11) {
    Nt(this), e11 = ht(e11), at(e11);
    const { view: n5, buffer: r8, blockLen: o6 } = this, s5 = e11.length;
    for (let i9 = 0; i9 < s5; ) {
      const f16 = Math.min(o6 - this.pos, s5 - i9);
      if (f16 === o6) {
        const a6 = sn2(e11);
        for (; o6 <= s5 - i9; i9 += o6) this.process(a6, i9);
        continue;
      }
      r8.set(e11.subarray(i9, i9 + f16), this.pos), this.pos += f16, i9 += f16, this.pos === o6 && (this.process(n5, 0), this.pos = 0);
    }
    return this.length += e11.length, this.roundClean(), this;
  }
  digestInto(e11) {
    Nt(this), on(e11, this), this.finished = true;
    const { buffer: n5, view: r8, blockLen: o6, isLE: s5 } = this;
    let { pos: i9 } = this;
    n5[i9++] = 128, ut(this.buffer.subarray(i9)), this.padOffset > o6 - i9 && (this.process(r8, 0), i9 = 0);
    for (let u10 = i9; u10 < o6; u10++) n5[u10] = 0;
    Di(r8, o6 - 8, BigInt(this.length * 8), s5), this.process(r8, 0);
    const f16 = sn2(e11), a6 = this.outputLen;
    if (a6 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l9 = a6 / 4, c9 = this.get();
    if (l9 > c9.length) throw new Error("_sha2: outputLen bigger than state");
    for (let u10 = 0; u10 < l9; u10++) f16.setUint32(4 * u10, c9[u10], s5);
  }
  digest() {
    const { buffer: e11, outputLen: n5 } = this;
    this.digestInto(e11);
    const r8 = e11.slice(0, n5);
    return this.destroy(), r8;
  }
  _cloneInto(e11) {
    e11 || (e11 = new this.constructor()), e11.set(...this.get());
    const { blockLen: n5, buffer: r8, length: o6, finished: s5, destroyed: i9, pos: f16 } = this;
    return e11.destroyed = i9, e11.finished = s5, e11.length = o6, e11.pos = f16, o6 % n5 && e11.buffer.set(r8), e11;
  }
  clone() {
    return this._cloneInto();
  }
};
var Ut = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var W = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Y = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var qi = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var _t = new Uint32Array(64);
var Ki = class extends Rr {
  constructor(e11 = 32) {
    super(64, e11, 8, false), this.A = Ut[0] | 0, this.B = Ut[1] | 0, this.C = Ut[2] | 0, this.D = Ut[3] | 0, this.E = Ut[4] | 0, this.F = Ut[5] | 0, this.G = Ut[6] | 0, this.H = Ut[7] | 0;
  }
  get() {
    const { A: e11, B: n5, C: r8, D: o6, E: s5, F: i9, G: f16, H: a6 } = this;
    return [e11, n5, r8, o6, s5, i9, f16, a6];
  }
  set(e11, n5, r8, o6, s5, i9, f16, a6) {
    this.A = e11 | 0, this.B = n5 | 0, this.C = r8 | 0, this.D = o6 | 0, this.E = s5 | 0, this.F = i9 | 0, this.G = f16 | 0, this.H = a6 | 0;
  }
  process(e11, n5) {
    for (let u10 = 0; u10 < 16; u10++, n5 += 4) _t[u10] = e11.getUint32(n5, false);
    for (let u10 = 16; u10 < 64; u10++) {
      const h9 = _t[u10 - 15], g4 = _t[u10 - 2], w8 = gt(h9, 7) ^ gt(h9, 18) ^ h9 >>> 3, y11 = gt(g4, 17) ^ gt(g4, 19) ^ g4 >>> 10;
      _t[u10] = y11 + _t[u10 - 7] + w8 + _t[u10 - 16] | 0;
    }
    let { A: r8, B: o6, C: s5, D: i9, E: f16, F: a6, G: l9, H: c9 } = this;
    for (let u10 = 0; u10 < 64; u10++) {
      const h9 = gt(f16, 6) ^ gt(f16, 11) ^ gt(f16, 25), g4 = c9 + h9 + Mi(f16, a6, l9) + qi[u10] + _t[u10] | 0, y11 = (gt(r8, 2) ^ gt(r8, 13) ^ gt(r8, 22)) + Vi(r8, o6, s5) | 0;
      c9 = l9, l9 = a6, a6 = f16, f16 = i9 + g4 | 0, i9 = s5, s5 = o6, o6 = r8, r8 = g4 + y11 | 0;
    }
    r8 = r8 + this.A | 0, o6 = o6 + this.B | 0, s5 = s5 + this.C | 0, i9 = i9 + this.D | 0, f16 = f16 + this.E | 0, a6 = a6 + this.F | 0, l9 = l9 + this.G | 0, c9 = c9 + this.H | 0, this.set(r8, o6, s5, i9, f16, a6, l9, c9);
  }
  roundClean() {
    ut(_t);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), ut(this.buffer);
  }
};
var $r = wr(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((t6) => BigInt(t6)));
var Fi = $r[0];
var zi = $r[1];
var Tt = new Uint32Array(80);
var Rt = new Uint32Array(80);
var cn = class extends Rr {
  constructor(e11 = 64) {
    super(128, e11, 16, false), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
  }
  get() {
    const { Ah: e11, Al: n5, Bh: r8, Bl: o6, Ch: s5, Cl: i9, Dh: f16, Dl: a6, Eh: l9, El: c9, Fh: u10, Fl: h9, Gh: g4, Gl: w8, Hh: y11, Hl: x7 } = this;
    return [e11, n5, r8, o6, s5, i9, f16, a6, l9, c9, u10, h9, g4, w8, y11, x7];
  }
  set(e11, n5, r8, o6, s5, i9, f16, a6, l9, c9, u10, h9, g4, w8, y11, x7) {
    this.Ah = e11 | 0, this.Al = n5 | 0, this.Bh = r8 | 0, this.Bl = o6 | 0, this.Ch = s5 | 0, this.Cl = i9 | 0, this.Dh = f16 | 0, this.Dl = a6 | 0, this.Eh = l9 | 0, this.El = c9 | 0, this.Fh = u10 | 0, this.Fl = h9 | 0, this.Gh = g4 | 0, this.Gl = w8 | 0, this.Hh = y11 | 0, this.Hl = x7 | 0;
  }
  process(e11, n5) {
    for (let L7 = 0; L7 < 16; L7++, n5 += 4) Tt[L7] = e11.getUint32(n5), Rt[L7] = e11.getUint32(n5 += 4);
    for (let L7 = 16; L7 < 80; L7++) {
      const V8 = Tt[L7 - 15] | 0, _6 = Rt[L7 - 15] | 0, k11 = At(V8, _6, 1) ^ At(V8, _6, 8) ^ xr(V8, _6, 7), j9 = St(V8, _6, 1) ^ St(V8, _6, 8) ^ vr(V8, _6, 7), $8 = Tt[L7 - 2] | 0, d7 = Rt[L7 - 2] | 0, m6 = At($8, d7, 19) ^ se($8, d7, 61) ^ xr($8, d7, 6), p9 = St($8, d7, 19) ^ ie($8, d7, 61) ^ vr($8, d7, 6), b6 = Ei(j9, p9, Rt[L7 - 7], Rt[L7 - 16]), v9 = Bi(b6, k11, m6, Tt[L7 - 7], Tt[L7 - 16]);
      Tt[L7] = v9 | 0, Rt[L7] = b6 | 0;
    }
    let { Ah: r8, Al: o6, Bh: s5, Bl: i9, Ch: f16, Cl: a6, Dh: l9, Dl: c9, Eh: u10, El: h9, Fh: g4, Fl: w8, Gh: y11, Gl: x7, Hh: R6, Hl: M8 } = this;
    for (let L7 = 0; L7 < 80; L7++) {
      const V8 = At(u10, h9, 14) ^ At(u10, h9, 18) ^ se(u10, h9, 41), _6 = St(u10, h9, 14) ^ St(u10, h9, 18) ^ ie(u10, h9, 41), k11 = u10 & g4 ^ ~u10 & y11, j9 = h9 & w8 ^ ~h9 & x7, $8 = Ii(M8, _6, j9, zi[L7], Rt[L7]), d7 = Ai($8, R6, V8, k11, Fi[L7], Tt[L7]), m6 = $8 | 0, p9 = At(r8, o6, 28) ^ se(r8, o6, 34) ^ se(r8, o6, 39), b6 = St(r8, o6, 28) ^ ie(r8, o6, 34) ^ ie(r8, o6, 39), v9 = r8 & s5 ^ r8 & f16 ^ s5 & f16, B9 = o6 & i9 ^ o6 & a6 ^ i9 & a6;
      R6 = y11 | 0, M8 = x7 | 0, y11 = g4 | 0, x7 = w8 | 0, g4 = u10 | 0, w8 = h9 | 0, { h: u10, l: h9 } = dt(l9 | 0, c9 | 0, d7 | 0, m6 | 0), l9 = f16 | 0, c9 = a6 | 0, f16 = s5 | 0, a6 = i9 | 0, s5 = r8 | 0, i9 = o6 | 0;
      const E8 = tn(m6, b6, B9);
      r8 = en(E8, d7, p9, v9), o6 = E8 | 0;
    }
    ({ h: r8, l: o6 } = dt(this.Ah | 0, this.Al | 0, r8 | 0, o6 | 0)), { h: s5, l: i9 } = dt(this.Bh | 0, this.Bl | 0, s5 | 0, i9 | 0), { h: f16, l: a6 } = dt(this.Ch | 0, this.Cl | 0, f16 | 0, a6 | 0), { h: l9, l: c9 } = dt(this.Dh | 0, this.Dl | 0, l9 | 0, c9 | 0), { h: u10, l: h9 } = dt(this.Eh | 0, this.El | 0, u10 | 0, h9 | 0), { h: g4, l: w8 } = dt(this.Fh | 0, this.Fl | 0, g4 | 0, w8 | 0), { h: y11, l: x7 } = dt(this.Gh | 0, this.Gl | 0, y11 | 0, x7 | 0), { h: R6, l: M8 } = dt(this.Hh | 0, this.Hl | 0, R6 | 0, M8 | 0), this.set(r8, o6, s5, i9, f16, a6, l9, c9, u10, h9, g4, w8, y11, x7, R6, M8);
  }
  roundClean() {
    ut(Tt, Rt);
  }
  destroy() {
    ut(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var Gi = class extends cn {
  constructor() {
    super(48), this.Ah = W[0] | 0, this.Al = W[1] | 0, this.Bh = W[2] | 0, this.Bl = W[3] | 0, this.Ch = W[4] | 0, this.Cl = W[5] | 0, this.Dh = W[6] | 0, this.Dl = W[7] | 0, this.Eh = W[8] | 0, this.El = W[9] | 0, this.Fh = W[10] | 0, this.Fl = W[11] | 0, this.Gh = W[12] | 0, this.Gl = W[13] | 0, this.Hh = W[14] | 0, this.Hl = W[15] | 0;
  }
};
var X = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var Zi = class extends cn {
  constructor() {
    super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
  }
};
var Ae = ae(() => new Ki());
var Wi = ae(() => new cn());
var Yi = ae(() => new Gi());
var Xi = ae(() => new Zi());
var Ji = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var F = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var N = new Uint32Array(32);
function $t(t6, e11, n5, r8, o6, s5) {
  const i9 = o6[s5], f16 = o6[s5 + 1];
  let a6 = N[2 * t6], l9 = N[2 * t6 + 1], c9 = N[2 * e11], u10 = N[2 * e11 + 1], h9 = N[2 * n5], g4 = N[2 * n5 + 1], w8 = N[2 * r8], y11 = N[2 * r8 + 1], x7 = tn(a6, c9, i9);
  l9 = en(x7, l9, u10, f16), a6 = x7 | 0, { Dh: y11, Dl: w8 } = { Dh: y11 ^ l9, Dl: w8 ^ a6 }, { Dh: y11, Dl: w8 } = { Dh: bi(y11, w8), Dl: yi(y11) }, { h: g4, l: h9 } = dt(g4, h9, y11, w8), { Bh: u10, Bl: c9 } = { Bh: u10 ^ g4, Bl: c9 ^ h9 }, { Bh: u10, Bl: c9 } = { Bh: At(u10, c9, 24), Bl: St(u10, c9, 24) }, N[2 * t6] = a6, N[2 * t6 + 1] = l9, N[2 * e11] = c9, N[2 * e11 + 1] = u10, N[2 * n5] = h9, N[2 * n5 + 1] = g4, N[2 * r8] = w8, N[2 * r8 + 1] = y11;
}
function Ct(t6, e11, n5, r8, o6, s5) {
  const i9 = o6[s5], f16 = o6[s5 + 1];
  let a6 = N[2 * t6], l9 = N[2 * t6 + 1], c9 = N[2 * e11], u10 = N[2 * e11 + 1], h9 = N[2 * n5], g4 = N[2 * n5 + 1], w8 = N[2 * r8], y11 = N[2 * r8 + 1], x7 = tn(a6, c9, i9);
  l9 = en(x7, l9, u10, f16), a6 = x7 | 0, { Dh: y11, Dl: w8 } = { Dh: y11 ^ l9, Dl: w8 ^ a6 }, { Dh: y11, Dl: w8 } = { Dh: At(y11, w8, 16), Dl: St(y11, w8, 16) }, { h: g4, l: h9 } = dt(g4, h9, y11, w8), { Bh: u10, Bl: c9 } = { Bh: u10 ^ g4, Bl: c9 ^ h9 }, { Bh: u10, Bl: c9 } = { Bh: se(u10, c9, 63), Bl: ie(u10, c9, 63) }, N[2 * t6] = a6, N[2 * t6 + 1] = l9, N[2 * e11] = c9, N[2 * e11 + 1] = u10, N[2 * n5] = h9, N[2 * n5 + 1] = g4, N[2 * r8] = w8, N[2 * r8 + 1] = y11;
}
function Qi(t6, e11 = {}, n5, r8, o6) {
  if (mt(n5), t6 < 0 || t6 > n5) throw new Error("outputLen bigger than keyLen");
  const { key: s5, salt: i9, personalization: f16 } = e11;
  if (s5 !== void 0 && (s5.length < 1 || s5.length > n5)) throw new Error("key length must be undefined or 1.." + n5);
  if (i9 !== void 0 && i9.length !== r8) throw new Error("salt must be undefined or " + r8);
  if (f16 !== void 0 && f16.length !== o6) throw new Error("personalization must be undefined or " + o6);
}
var tf = class extends Ie {
  constructor(e11, n5) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, mt(e11), mt(n5), this.blockLen = e11, this.outputLen = n5, this.buffer = new Uint8Array(e11), this.buffer32 = fe(this.buffer);
  }
  update(e11) {
    Nt(this), e11 = ht(e11), at(e11);
    const { blockLen: n5, buffer: r8, buffer32: o6 } = this, s5 = e11.length, i9 = e11.byteOffset, f16 = e11.buffer;
    for (let a6 = 0; a6 < s5; ) {
      this.pos === n5 && (Ot(o6), this.compress(o6, 0, false), Ot(o6), this.pos = 0);
      const l9 = Math.min(n5 - this.pos, s5 - a6), c9 = i9 + a6;
      if (l9 === n5 && !(c9 % 4) && a6 + l9 < s5) {
        const u10 = new Uint32Array(f16, c9, Math.floor((s5 - a6) / 4));
        Ot(u10);
        for (let h9 = 0; a6 + n5 < s5; h9 += o6.length, a6 += n5) this.length += n5, this.compress(u10, h9, false);
        Ot(u10);
        continue;
      }
      r8.set(e11.subarray(a6, a6 + l9), this.pos), this.pos += l9, this.length += l9, a6 += l9;
    }
    return this;
  }
  digestInto(e11) {
    Nt(this), on(e11, this);
    const { pos: n5, buffer32: r8 } = this;
    this.finished = true, ut(this.buffer.subarray(n5)), Ot(r8), this.compress(r8, 0, true), Ot(r8);
    const o6 = fe(e11);
    this.get().forEach((s5, i9) => o6[i9] = wt(s5));
  }
  digest() {
    const { buffer: e11, outputLen: n5 } = this;
    this.digestInto(e11);
    const r8 = e11.slice(0, n5);
    return this.destroy(), r8;
  }
  _cloneInto(e11) {
    const { buffer: n5, length: r8, finished: o6, destroyed: s5, outputLen: i9, pos: f16 } = this;
    return e11 || (e11 = new this.constructor({ dkLen: i9 })), e11.set(...this.get()), e11.buffer.set(n5), e11.destroyed = s5, e11.finished = o6, e11.length = r8, e11.pos = f16, e11.outputLen = i9, e11;
  }
  clone() {
    return this._cloneInto();
  }
};
var ef = class extends tf {
  constructor(e11 = {}) {
    const n5 = e11.dkLen === void 0 ? 64 : e11.dkLen;
    super(128, n5), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n5, e11, 64, 16, 16);
    let { key: r8, personalization: o6, salt: s5 } = e11, i9 = 0;
    if (r8 !== void 0 && (r8 = ht(r8), i9 = r8.length), this.v0l ^= this.outputLen | i9 << 8 | 65536 | 1 << 24, s5 !== void 0) {
      s5 = ht(s5);
      const f16 = fe(s5);
      this.v4l ^= wt(f16[0]), this.v4h ^= wt(f16[1]), this.v5l ^= wt(f16[2]), this.v5h ^= wt(f16[3]);
    }
    if (o6 !== void 0) {
      o6 = ht(o6);
      const f16 = fe(o6);
      this.v6l ^= wt(f16[0]), this.v6h ^= wt(f16[1]), this.v7l ^= wt(f16[2]), this.v7h ^= wt(f16[3]);
    }
    if (r8 !== void 0) {
      const f16 = new Uint8Array(this.blockLen);
      f16.set(r8), this.update(f16);
    }
  }
  get() {
    let { v0l: e11, v0h: n5, v1l: r8, v1h: o6, v2l: s5, v2h: i9, v3l: f16, v3h: a6, v4l: l9, v4h: c9, v5l: u10, v5h: h9, v6l: g4, v6h: w8, v7l: y11, v7h: x7 } = this;
    return [e11, n5, r8, o6, s5, i9, f16, a6, l9, c9, u10, h9, g4, w8, y11, x7];
  }
  set(e11, n5, r8, o6, s5, i9, f16, a6, l9, c9, u10, h9, g4, w8, y11, x7) {
    this.v0l = e11 | 0, this.v0h = n5 | 0, this.v1l = r8 | 0, this.v1h = o6 | 0, this.v2l = s5 | 0, this.v2h = i9 | 0, this.v3l = f16 | 0, this.v3h = a6 | 0, this.v4l = l9 | 0, this.v4h = c9 | 0, this.v5l = u10 | 0, this.v5h = h9 | 0, this.v6l = g4 | 0, this.v6h = w8 | 0, this.v7l = y11 | 0, this.v7h = x7 | 0;
  }
  compress(e11, n5, r8) {
    this.get().forEach((a6, l9) => N[l9] = a6), N.set(F, 16);
    let { h: o6, l: s5 } = mr(BigInt(this.length));
    N[24] = F[8] ^ s5, N[25] = F[9] ^ o6, r8 && (N[28] = ~N[28], N[29] = ~N[29]);
    let i9 = 0;
    const f16 = Ji;
    for (let a6 = 0; a6 < 12; a6++) $t(0, 4, 8, 12, e11, n5 + 2 * f16[i9++]), Ct(0, 4, 8, 12, e11, n5 + 2 * f16[i9++]), $t(1, 5, 9, 13, e11, n5 + 2 * f16[i9++]), Ct(1, 5, 9, 13, e11, n5 + 2 * f16[i9++]), $t(2, 6, 10, 14, e11, n5 + 2 * f16[i9++]), Ct(2, 6, 10, 14, e11, n5 + 2 * f16[i9++]), $t(3, 7, 11, 15, e11, n5 + 2 * f16[i9++]), Ct(3, 7, 11, 15, e11, n5 + 2 * f16[i9++]), $t(0, 5, 10, 15, e11, n5 + 2 * f16[i9++]), Ct(0, 5, 10, 15, e11, n5 + 2 * f16[i9++]), $t(1, 6, 11, 12, e11, n5 + 2 * f16[i9++]), Ct(1, 6, 11, 12, e11, n5 + 2 * f16[i9++]), $t(2, 7, 8, 13, e11, n5 + 2 * f16[i9++]), Ct(2, 7, 8, 13, e11, n5 + 2 * f16[i9++]), $t(3, 4, 9, 14, e11, n5 + 2 * f16[i9++]), Ct(3, 4, 9, 14, e11, n5 + 2 * f16[i9++]);
    this.v0l ^= N[0] ^ N[16], this.v0h ^= N[1] ^ N[17], this.v1l ^= N[2] ^ N[18], this.v1h ^= N[3] ^ N[19], this.v2l ^= N[4] ^ N[20], this.v2h ^= N[5] ^ N[21], this.v3l ^= N[6] ^ N[22], this.v3h ^= N[7] ^ N[23], this.v4l ^= N[8] ^ N[24], this.v4h ^= N[9] ^ N[25], this.v5l ^= N[10] ^ N[26], this.v5h ^= N[11] ^ N[27], this.v6l ^= N[12] ^ N[28], this.v6h ^= N[13] ^ N[29], this.v7l ^= N[14] ^ N[30], this.v7h ^= N[15] ^ N[31], ut(N);
  }
  destroy() {
    this.destroyed = true, ut(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var nf = Ui((t6) => new ef(t6));
var rf = "https://rpc.walletconnect.org/v1";
function an(t6) {
  const e11 = `Ethereum Signed Message:
${t6.length}`, n5 = new TextEncoder().encode(e11 + t6);
  return "0x" + Buffer.from(Hi(n5)).toString("hex");
}
async function Cr(t6, e11, n5, r8, o6, s5) {
  switch (n5.t) {
    case "eip191":
      return await Lr(t6, e11, n5.s);
    case "eip1271":
      return await jr(t6, e11, n5.s, r8, o6, s5);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n5.t}`);
  }
}
async function Lr(t6, e11, n5) {
  return (await recoverAddress({ hash: an(e11), signature: n5 })).toLowerCase() === t6.toLowerCase();
}
async function jr(t6, e11, n5, r8, o6, s5) {
  const i9 = Fe(r8);
  if (!i9.namespace || !i9.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r8}`);
  try {
    const f16 = "0x1626ba7e", a6 = "0000000000000000000000000000000000000000000000000000000000000040", l9 = n5.substring(2), c9 = (l9.length / 2).toString(16).padStart(64, "0"), u10 = (e11.startsWith("0x") ? e11 : an(e11)).substring(2), h9 = f16 + u10 + a6 + c9 + l9, g4 = await fetch(`${s5 || rf}/?chainId=${r8}&projectId=${o6}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: of(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t6, data: h9 }, "latest"] }) }), { result: w8 } = await g4.json();
    return w8 ? w8.slice(0, f16.length).toLowerCase() === f16.toLowerCase() : false;
  } catch (f16) {
    return console.error("isValidEip1271Signature: ", f16), false;
  }
}
function of() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function sf(t6) {
  const e11 = atob(t6), n5 = new Uint8Array(e11.length);
  for (let i9 = 0; i9 < e11.length; i9++) n5[i9] = e11.charCodeAt(i9);
  const r8 = n5[0];
  if (r8 === 0) throw new Error("No signatures found");
  const o6 = 1 + r8 * 64;
  if (n5.length < o6) throw new Error("Transaction data too short for claimed signature count");
  if (n5.length < 100) throw new Error("Transaction too short");
  const s5 = Buffer.from(t6, "base64").slice(1, 65);
  return esm_default2.encode(s5);
}
function ff(t6) {
  const e11 = new Uint8Array(Buffer.from(t6, "base64")), n5 = Array.from("TransactionData::").map((s5) => s5.charCodeAt(0)), r8 = new Uint8Array(n5.length + e11.length);
  r8.set(n5), r8.set(e11, n5.length);
  const o6 = nf(r8, { dkLen: 32 });
  return esm_default2.encode(o6);
}
function cf(t6) {
  const e11 = new Uint8Array(Ae(kr(t6)));
  return esm_default2.encode(e11);
}
function kr(t6) {
  if (t6 instanceof Uint8Array) return t6;
  if (Array.isArray(t6)) return new Uint8Array(t6);
  if (typeof t6 == "object" && t6 != null && t6.data) return new Uint8Array(Object.values(t6.data));
  if (typeof t6 == "object" && t6) return new Uint8Array(Object.values(t6));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function af(t6) {
  const e11 = Buffer.from(t6, "base64"), n5 = decode2(e11).txn;
  if (!n5) throw new Error("Invalid signed transaction: missing 'txn' field");
  const r8 = encode5(n5), o6 = Buffer.from("TX"), s5 = Buffer.concat([o6, Buffer.from(r8)]), i9 = Xi(s5);
  return base32.encode(i9).replace(/=+$/, "");
}
function un(t6) {
  const e11 = [];
  let n5 = BigInt(t6);
  for (; n5 >= BigInt(128); ) e11.push(Number(n5 & BigInt(127) | BigInt(128))), n5 >>= BigInt(7);
  return e11.push(Number(n5)), Buffer.from(e11);
}
function uf(t6) {
  const e11 = Buffer.from(t6.signed.bodyBytes, "base64"), n5 = Buffer.from(t6.signed.authInfoBytes, "base64"), r8 = Buffer.from(t6.signature.signature, "base64"), o6 = [];
  o6.push(Buffer.from([10])), o6.push(un(e11.length)), o6.push(e11), o6.push(Buffer.from([18])), o6.push(un(n5.length)), o6.push(n5), o6.push(Buffer.from([26])), o6.push(un(r8.length)), o6.push(r8);
  const s5 = Buffer.concat(o6), i9 = Ae(s5);
  return Buffer.from(i9).toString("hex").toUpperCase();
}
var lf = Object.defineProperty;
var df = Object.defineProperties;
var hf = Object.getOwnPropertyDescriptors;
var Pr = Object.getOwnPropertySymbols;
var pf = Object.prototype.hasOwnProperty;
var gf = Object.prototype.propertyIsEnumerable;
var Hr = (t6, e11, n5) => e11 in t6 ? lf(t6, e11, { enumerable: true, configurable: true, writable: true, value: n5 }) : t6[e11] = n5;
var ln = (t6, e11) => {
  for (var n5 in e11 || (e11 = {})) pf.call(e11, n5) && Hr(t6, n5, e11[n5]);
  if (Pr) for (var n5 of Pr(e11)) gf.call(e11, n5) && Hr(t6, n5, e11[n5]);
  return t6;
};
var Dr = (t6, e11) => df(t6, hf(e11));
var bf = "did:pkh:";
var Se = (t6) => t6 == null ? void 0 : t6.split(":");
var Mr = (t6) => {
  const e11 = t6 && Se(t6);
  if (e11) return t6.includes(bf) ? e11[3] : e11[1];
};
var Vr = (t6) => {
  const e11 = t6 && Se(t6);
  if (e11) return e11[2] + ":" + e11[3];
};
var dn = (t6) => {
  const e11 = t6 && Se(t6);
  if (e11) return e11.pop();
};
async function yf(t6) {
  const { cacao: e11, projectId: n5 } = t6, { s: r8, p: o6 } = e11, s5 = qr(o6, o6.iss), i9 = dn(o6.iss);
  return await Cr(i9, s5, r8, Vr(o6.iss), n5);
}
var qr = (t6, e11) => {
  const n5 = `${t6.domain} wants you to sign in with your Ethereum account:`, r8 = dn(e11);
  if (!t6.aud && !t6.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o6 = t6.statement || void 0;
  const s5 = `URI: ${t6.aud || t6.uri}`, i9 = `Version: ${t6.version}`, f16 = `Chain ID: ${Mr(e11)}`, a6 = `Nonce: ${t6.nonce}`, l9 = `Issued At: ${t6.iat}`, c9 = t6.exp ? `Expiration Time: ${t6.exp}` : void 0, u10 = t6.nbf ? `Not Before: ${t6.nbf}` : void 0, h9 = t6.requestId ? `Request ID: ${t6.requestId}` : void 0, g4 = t6.resources ? `Resources:${t6.resources.map((y11) => `
- ${y11}`).join("")}` : void 0, w8 = Oe(t6.resources);
  if (w8) {
    const y11 = Lt(w8);
    o6 = gn(o6, y11);
  }
  return [n5, r8, "", o6, "", s5, i9, f16, a6, l9, c9, u10, h9, g4].filter((y11) => y11 != null).join(`
`);
};
function Gr(t6) {
  return Buffer.from(JSON.stringify(t6)).toString("base64");
}
function Zr(t6) {
  return JSON.parse(Buffer.from(t6, "base64").toString("utf-8"));
}
function bt(t6) {
  if (!t6) throw new Error("No recap provided, value is undefined");
  if (!t6.att) throw new Error("No `att` property found");
  const e11 = Object.keys(t6.att);
  if (!(e11 != null && e11.length)) throw new Error("No resources found in `att` property");
  e11.forEach((n5) => {
    const r8 = t6.att[n5];
    if (Array.isArray(r8)) throw new Error(`Resource must be an object: ${n5}`);
    if (typeof r8 != "object") throw new Error(`Resource must be an object: ${n5}`);
    if (!Object.keys(r8).length) throw new Error(`Resource object is empty: ${n5}`);
    Object.keys(r8).forEach((o6) => {
      const s5 = r8[o6];
      if (!Array.isArray(s5)) throw new Error(`Ability limits ${o6} must be an array of objects, found: ${s5}`);
      if (!s5.length) throw new Error(`Value of ${o6} is empty array, must be an array with objects`);
      s5.forEach((i9) => {
        if (typeof i9 != "object") throw new Error(`Ability limits (${o6}) must be an array of objects, found: ${i9}`);
      });
    });
  });
}
function Wr(t6, e11, n5, r8 = {}) {
  return n5 == null ? void 0 : n5.sort((o6, s5) => o6.localeCompare(s5)), { att: { [t6]: hn(e11, n5, r8) } };
}
function hn(t6, e11, n5 = {}) {
  e11 = e11 == null ? void 0 : e11.sort((o6, s5) => o6.localeCompare(s5));
  const r8 = e11.map((o6) => ({ [`${t6}/${o6}`]: [n5] }));
  return Object.assign({}, ...r8);
}
function Ne(t6) {
  return bt(t6), `urn:recap:${Gr(t6).replace(/=/g, "")}`;
}
function Lt(t6) {
  const e11 = Zr(t6.replace("urn:recap:", ""));
  return bt(e11), e11;
}
function Ef(t6, e11, n5) {
  const r8 = Wr(t6, e11, n5);
  return Ne(r8);
}
function pn(t6) {
  return t6 && t6.includes("urn:recap:");
}
function Bf(t6, e11) {
  const n5 = Lt(t6), r8 = Lt(e11), o6 = Xr(n5, r8);
  return Ne(o6);
}
function Xr(t6, e11) {
  bt(t6), bt(e11);
  const n5 = Object.keys(t6.att).concat(Object.keys(e11.att)).sort((o6, s5) => o6.localeCompare(s5)), r8 = { att: {} };
  return n5.forEach((o6) => {
    var s5, i9;
    Object.keys(((s5 = t6.att) == null ? void 0 : s5[o6]) || {}).concat(Object.keys(((i9 = e11.att) == null ? void 0 : i9[o6]) || {})).sort((f16, a6) => f16.localeCompare(a6)).forEach((f16) => {
      var a6, l9;
      r8.att[o6] = Dr(ln({}, r8.att[o6]), { [f16]: ((a6 = t6.att[o6]) == null ? void 0 : a6[f16]) || ((l9 = e11.att[o6]) == null ? void 0 : l9[f16]) });
    });
  }), r8;
}
function gn(t6 = "", e11) {
  bt(e11);
  const n5 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t6.includes(n5)) return t6;
  const r8 = [];
  let o6 = 0;
  Object.keys(e11.att).forEach((f16) => {
    const a6 = Object.keys(e11.att[f16]).map((u10) => ({ ability: u10.split("/")[0], action: u10.split("/")[1] }));
    a6.sort((u10, h9) => u10.action.localeCompare(h9.action));
    const l9 = {};
    a6.forEach((u10) => {
      l9[u10.ability] || (l9[u10.ability] = []), l9[u10.ability].push(u10.action);
    });
    const c9 = Object.keys(l9).map((u10) => (o6++, `(${o6}) '${u10}': '${l9[u10].join("', '")}' for '${f16}'.`));
    r8.push(c9.join(", ").replace(".,", "."));
  });
  const s5 = r8.join(" "), i9 = `${n5}${s5}`;
  return `${t6 ? t6 + " " : ""}${i9}`;
}
function If(t6) {
  var e11;
  const n5 = Lt(t6);
  bt(n5);
  const r8 = (e11 = n5.att) == null ? void 0 : e11.eip155;
  return r8 ? Object.keys(r8).map((o6) => o6.split("/")[1]) : [];
}
function Af(t6) {
  const e11 = Lt(t6);
  bt(e11);
  const n5 = [];
  return Object.values(e11.att).forEach((r8) => {
    Object.values(r8).forEach((o6) => {
      var s5;
      (s5 = o6 == null ? void 0 : o6[0]) != null && s5.chains && n5.push(o6[0].chains);
    });
  }), [...new Set(n5.flat())];
}
function Oe(t6) {
  if (!t6) return;
  const e11 = t6 == null ? void 0 : t6[t6.length - 1];
  return pn(e11) ? e11 : void 0;
}
function Qr(t6) {
  return t6 instanceof Uint8Array || ArrayBuffer.isView(t6) && t6.constructor.name === "Uint8Array";
}
function bn(t6) {
  if (typeof t6 != "boolean") throw new Error(`boolean expected, not ${t6}`);
}
function yn(t6) {
  if (!Number.isSafeInteger(t6) || t6 < 0) throw new Error("positive integer expected, got " + t6);
}
function nt(t6, ...e11) {
  if (!Qr(t6)) throw new Error("Uint8Array expected");
  if (e11.length > 0 && !e11.includes(t6.length)) throw new Error("Uint8Array expected of length " + e11 + ", got length=" + t6.length);
}
function to(t6, e11 = true) {
  if (t6.destroyed) throw new Error("Hash instance has been destroyed");
  if (e11 && t6.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t6, e11) {
  nt(t6);
  const n5 = e11.outputLen;
  if (t6.length < n5) throw new Error("digestInto() expects output buffer of length at least " + n5);
}
function jt(t6) {
  return new Uint32Array(t6.buffer, t6.byteOffset, Math.floor(t6.byteLength / 4));
}
function Wt(...t6) {
  for (let e11 = 0; e11 < t6.length; e11++) t6[e11].fill(0);
}
function Nf(t6) {
  return new DataView(t6.buffer, t6.byteOffset, t6.byteLength);
}
var Of = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Uf(t6) {
  if (typeof t6 != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t6));
}
function mn(t6) {
  if (typeof t6 == "string") t6 = Uf(t6);
  else if (Qr(t6)) t6 = wn(t6);
  else throw new Error("Uint8Array expected, got " + typeof t6);
  return t6;
}
function _f(t6, e11) {
  if (e11 == null || typeof e11 != "object") throw new Error("options must be defined");
  return Object.assign(t6, e11);
}
function Tf(t6, e11) {
  if (t6.length !== e11.length) return false;
  let n5 = 0;
  for (let r8 = 0; r8 < t6.length; r8++) n5 |= t6[r8] ^ e11[r8];
  return n5 === 0;
}
var Rf = (t6, e11) => {
  function n5(r8, ...o6) {
    if (nt(r8), !Of) throw new Error("Non little-endian hardware is not yet supported");
    if (t6.nonceLength !== void 0) {
      const c9 = o6[0];
      if (!c9) throw new Error("nonce / iv required");
      t6.varSizeNonce ? nt(c9) : nt(c9, t6.nonceLength);
    }
    const s5 = t6.tagLength;
    s5 && o6[1] !== void 0 && nt(o6[1]);
    const i9 = e11(r8, ...o6), f16 = (c9, u10) => {
      if (u10 !== void 0) {
        if (c9 !== 2) throw new Error("cipher output not supported");
        nt(u10);
      }
    };
    let a6 = false;
    return { encrypt(c9, u10) {
      if (a6) throw new Error("cannot encrypt() twice with same key + nonce");
      return a6 = true, nt(c9), f16(i9.encrypt.length, u10), i9.encrypt(c9, u10);
    }, decrypt(c9, u10) {
      if (nt(c9), s5 && c9.length < s5) throw new Error("invalid ciphertext length: smaller than tagLength=" + s5);
      return f16(i9.decrypt.length, u10), i9.decrypt(c9, u10);
    } };
  }
  return Object.assign(n5, t6), n5;
};
function eo(t6, e11, n5 = true) {
  if (e11 === void 0) return new Uint8Array(t6);
  if (e11.length !== t6) throw new Error("invalid output length, expected " + t6 + ", got: " + e11.length);
  if (n5 && !Cf(e11)) throw new Error("invalid output, must be aligned");
  return e11;
}
function no(t6, e11, n5, r8) {
  if (typeof t6.setBigUint64 == "function") return t6.setBigUint64(e11, n5, r8);
  const o6 = BigInt(32), s5 = BigInt(4294967295), i9 = Number(n5 >> o6 & s5), f16 = Number(n5 & s5), a6 = r8 ? 4 : 0, l9 = r8 ? 0 : 4;
  t6.setUint32(e11 + a6, i9, r8), t6.setUint32(e11 + l9, f16, r8);
}
function $f(t6, e11, n5) {
  bn(n5);
  const r8 = new Uint8Array(16), o6 = Nf(r8);
  return no(o6, 0, BigInt(e11), n5), no(o6, 8, BigInt(t6), n5), r8;
}
function Cf(t6) {
  return t6.byteOffset % 4 === 0;
}
function wn(t6) {
  return Uint8Array.from(t6);
}
var ro = (t6) => Uint8Array.from(t6.split("").map((e11) => e11.charCodeAt(0)));
var Lf = ro("expand 16-byte k");
var jf = ro("expand 32-byte k");
var kf = jt(Lf);
var Pf = jt(jf);
function D(t6, e11) {
  return t6 << e11 | t6 >>> 32 - e11;
}
function xn(t6) {
  return t6.byteOffset % 4 === 0;
}
var Ue = 64;
var Hf = 16;
var oo = 2 ** 32 - 1;
var so = new Uint32Array();
function Df(t6, e11, n5, r8, o6, s5, i9, f16) {
  const a6 = o6.length, l9 = new Uint8Array(Ue), c9 = jt(l9), u10 = xn(o6) && xn(s5), h9 = u10 ? jt(o6) : so, g4 = u10 ? jt(s5) : so;
  for (let w8 = 0; w8 < a6; i9++) {
    if (t6(e11, n5, r8, c9, i9, f16), i9 >= oo) throw new Error("arx: counter overflow");
    const y11 = Math.min(Ue, a6 - w8);
    if (u10 && y11 === Ue) {
      const x7 = w8 / 4;
      if (w8 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let R6 = 0, M8; R6 < Hf; R6++) M8 = x7 + R6, g4[M8] = h9[M8] ^ c9[R6];
      w8 += Ue;
      continue;
    }
    for (let x7 = 0, R6; x7 < y11; x7++) R6 = w8 + x7, s5[R6] = o6[R6] ^ l9[x7];
    w8 += y11;
  }
}
function Mf(t6, e11) {
  const { allowShortKeys: n5, extendNonceFn: r8, counterLength: o6, counterRight: s5, rounds: i9 } = _f({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e11);
  if (typeof t6 != "function") throw new Error("core must be a function");
  return yn(o6), yn(i9), bn(s5), bn(n5), (f16, a6, l9, c9, u10 = 0) => {
    nt(f16), nt(a6), nt(l9);
    const h9 = l9.length;
    if (c9 === void 0 && (c9 = new Uint8Array(h9)), nt(c9), yn(u10), u10 < 0 || u10 >= oo) throw new Error("arx: counter overflow");
    if (c9.length < h9) throw new Error(`arx: output (${c9.length}) is shorter than data (${h9})`);
    const g4 = [];
    let w8 = f16.length, y11, x7;
    if (w8 === 32) g4.push(y11 = wn(f16)), x7 = Pf;
    else if (w8 === 16 && n5) y11 = new Uint8Array(32), y11.set(f16), y11.set(f16, 16), x7 = kf, g4.push(y11);
    else throw new Error(`arx: invalid 32-byte key, got length=${w8}`);
    xn(a6) || g4.push(a6 = wn(a6));
    const R6 = jt(y11);
    if (r8) {
      if (a6.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r8(x7, R6, jt(a6.subarray(0, 16)), R6), a6 = a6.subarray(16);
    }
    const M8 = 16 - o6;
    if (M8 !== a6.length) throw new Error(`arx: nonce must be ${M8} or 16 bytes`);
    if (M8 !== 12) {
      const V8 = new Uint8Array(12);
      V8.set(a6, s5 ? 0 : 12 - a6.length), a6 = V8, g4.push(a6);
    }
    const L7 = jt(a6);
    return Df(t6, x7, R6, L7, l9, c9, u10, i9), Wt(...g4), c9;
  };
}
var G = (t6, e11) => t6[e11++] & 255 | (t6[e11++] & 255) << 8;
var Vf = class {
  constructor(e11) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e11 = mn(e11), nt(e11, 32);
    const n5 = G(e11, 0), r8 = G(e11, 2), o6 = G(e11, 4), s5 = G(e11, 6), i9 = G(e11, 8), f16 = G(e11, 10), a6 = G(e11, 12), l9 = G(e11, 14);
    this.r[0] = n5 & 8191, this.r[1] = (n5 >>> 13 | r8 << 3) & 8191, this.r[2] = (r8 >>> 10 | o6 << 6) & 7939, this.r[3] = (o6 >>> 7 | s5 << 9) & 8191, this.r[4] = (s5 >>> 4 | i9 << 12) & 255, this.r[5] = i9 >>> 1 & 8190, this.r[6] = (i9 >>> 14 | f16 << 2) & 8191, this.r[7] = (f16 >>> 11 | a6 << 5) & 8065, this.r[8] = (a6 >>> 8 | l9 << 8) & 8191, this.r[9] = l9 >>> 5 & 127;
    for (let c9 = 0; c9 < 8; c9++) this.pad[c9] = G(e11, 16 + 2 * c9);
  }
  process(e11, n5, r8 = false) {
    const o6 = r8 ? 0 : 2048, { h: s5, r: i9 } = this, f16 = i9[0], a6 = i9[1], l9 = i9[2], c9 = i9[3], u10 = i9[4], h9 = i9[5], g4 = i9[6], w8 = i9[7], y11 = i9[8], x7 = i9[9], R6 = G(e11, n5 + 0), M8 = G(e11, n5 + 2), L7 = G(e11, n5 + 4), V8 = G(e11, n5 + 6), _6 = G(e11, n5 + 8), k11 = G(e11, n5 + 10), j9 = G(e11, n5 + 12), $8 = G(e11, n5 + 14);
    let d7 = s5[0] + (R6 & 8191), m6 = s5[1] + ((R6 >>> 13 | M8 << 3) & 8191), p9 = s5[2] + ((M8 >>> 10 | L7 << 6) & 8191), b6 = s5[3] + ((L7 >>> 7 | V8 << 9) & 8191), v9 = s5[4] + ((V8 >>> 4 | _6 << 12) & 8191), B9 = s5[5] + (_6 >>> 1 & 8191), E8 = s5[6] + ((_6 >>> 14 | k11 << 2) & 8191), I8 = s5[7] + ((k11 >>> 11 | j9 << 5) & 8191), S8 = s5[8] + ((j9 >>> 8 | $8 << 8) & 8191), O8 = s5[9] + ($8 >>> 5 | o6), A9 = 0, T8 = A9 + d7 * f16 + m6 * (5 * x7) + p9 * (5 * y11) + b6 * (5 * w8) + v9 * (5 * g4);
    A9 = T8 >>> 13, T8 &= 8191, T8 += B9 * (5 * h9) + E8 * (5 * u10) + I8 * (5 * c9) + S8 * (5 * l9) + O8 * (5 * a6), A9 += T8 >>> 13, T8 &= 8191;
    let U6 = A9 + d7 * a6 + m6 * f16 + p9 * (5 * x7) + b6 * (5 * y11) + v9 * (5 * w8);
    A9 = U6 >>> 13, U6 &= 8191, U6 += B9 * (5 * g4) + E8 * (5 * h9) + I8 * (5 * u10) + S8 * (5 * c9) + O8 * (5 * l9), A9 += U6 >>> 13, U6 &= 8191;
    let C10 = A9 + d7 * l9 + m6 * a6 + p9 * f16 + b6 * (5 * x7) + v9 * (5 * y11);
    A9 = C10 >>> 13, C10 &= 8191, C10 += B9 * (5 * w8) + E8 * (5 * g4) + I8 * (5 * h9) + S8 * (5 * u10) + O8 * (5 * c9), A9 += C10 >>> 13, C10 &= 8191;
    let H4 = A9 + d7 * c9 + m6 * l9 + p9 * a6 + b6 * f16 + v9 * (5 * x7);
    A9 = H4 >>> 13, H4 &= 8191, H4 += B9 * (5 * y11) + E8 * (5 * w8) + I8 * (5 * g4) + S8 * (5 * h9) + O8 * (5 * u10), A9 += H4 >>> 13, H4 &= 8191;
    let q6 = A9 + d7 * u10 + m6 * c9 + p9 * l9 + b6 * a6 + v9 * f16;
    A9 = q6 >>> 13, q6 &= 8191, q6 += B9 * (5 * x7) + E8 * (5 * y11) + I8 * (5 * w8) + S8 * (5 * g4) + O8 * (5 * h9), A9 += q6 >>> 13, q6 &= 8191;
    let P7 = A9 + d7 * h9 + m6 * u10 + p9 * c9 + b6 * l9 + v9 * a6;
    A9 = P7 >>> 13, P7 &= 8191, P7 += B9 * f16 + E8 * (5 * x7) + I8 * (5 * y11) + S8 * (5 * w8) + O8 * (5 * g4), A9 += P7 >>> 13, P7 &= 8191;
    let K5 = A9 + d7 * g4 + m6 * h9 + p9 * u10 + b6 * c9 + v9 * l9;
    A9 = K5 >>> 13, K5 &= 8191, K5 += B9 * a6 + E8 * f16 + I8 * (5 * x7) + S8 * (5 * y11) + O8 * (5 * w8), A9 += K5 >>> 13, K5 &= 8191;
    let et3 = A9 + d7 * w8 + m6 * g4 + p9 * h9 + b6 * u10 + v9 * c9;
    A9 = et3 >>> 13, et3 &= 8191, et3 += B9 * l9 + E8 * a6 + I8 * f16 + S8 * (5 * x7) + O8 * (5 * y11), A9 += et3 >>> 13, et3 &= 8191;
    let Z5 = A9 + d7 * y11 + m6 * w8 + p9 * g4 + b6 * h9 + v9 * u10;
    A9 = Z5 >>> 13, Z5 &= 8191, Z5 += B9 * c9 + E8 * l9 + I8 * a6 + S8 * f16 + O8 * (5 * x7), A9 += Z5 >>> 13, Z5 &= 8191;
    let z9 = A9 + d7 * x7 + m6 * y11 + p9 * w8 + b6 * g4 + v9 * h9;
    A9 = z9 >>> 13, z9 &= 8191, z9 += B9 * u10 + E8 * c9 + I8 * l9 + S8 * a6 + O8 * f16, A9 += z9 >>> 13, z9 &= 8191, A9 = (A9 << 2) + A9 | 0, A9 = A9 + T8 | 0, T8 = A9 & 8191, A9 = A9 >>> 13, U6 += A9, s5[0] = T8, s5[1] = U6, s5[2] = C10, s5[3] = H4, s5[4] = q6, s5[5] = P7, s5[6] = K5, s5[7] = et3, s5[8] = Z5, s5[9] = z9;
  }
  finalize() {
    const { h: e11, pad: n5 } = this, r8 = new Uint16Array(10);
    let o6 = e11[1] >>> 13;
    e11[1] &= 8191;
    for (let f16 = 2; f16 < 10; f16++) e11[f16] += o6, o6 = e11[f16] >>> 13, e11[f16] &= 8191;
    e11[0] += o6 * 5, o6 = e11[0] >>> 13, e11[0] &= 8191, e11[1] += o6, o6 = e11[1] >>> 13, e11[1] &= 8191, e11[2] += o6, r8[0] = e11[0] + 5, o6 = r8[0] >>> 13, r8[0] &= 8191;
    for (let f16 = 1; f16 < 10; f16++) r8[f16] = e11[f16] + o6, o6 = r8[f16] >>> 13, r8[f16] &= 8191;
    r8[9] -= 8192;
    let s5 = (o6 ^ 1) - 1;
    for (let f16 = 0; f16 < 10; f16++) r8[f16] &= s5;
    s5 = ~s5;
    for (let f16 = 0; f16 < 10; f16++) e11[f16] = e11[f16] & s5 | r8[f16];
    e11[0] = (e11[0] | e11[1] << 13) & 65535, e11[1] = (e11[1] >>> 3 | e11[2] << 10) & 65535, e11[2] = (e11[2] >>> 6 | e11[3] << 7) & 65535, e11[3] = (e11[3] >>> 9 | e11[4] << 4) & 65535, e11[4] = (e11[4] >>> 12 | e11[5] << 1 | e11[6] << 14) & 65535, e11[5] = (e11[6] >>> 2 | e11[7] << 11) & 65535, e11[6] = (e11[7] >>> 5 | e11[8] << 8) & 65535, e11[7] = (e11[8] >>> 8 | e11[9] << 5) & 65535;
    let i9 = e11[0] + n5[0];
    e11[0] = i9 & 65535;
    for (let f16 = 1; f16 < 8; f16++) i9 = (e11[f16] + n5[f16] | 0) + (i9 >>> 16) | 0, e11[f16] = i9 & 65535;
    Wt(r8);
  }
  update(e11) {
    to(this), e11 = mn(e11), nt(e11);
    const { buffer: n5, blockLen: r8 } = this, o6 = e11.length;
    for (let s5 = 0; s5 < o6; ) {
      const i9 = Math.min(r8 - this.pos, o6 - s5);
      if (i9 === r8) {
        for (; r8 <= o6 - s5; s5 += r8) this.process(e11, s5);
        continue;
      }
      n5.set(e11.subarray(s5, s5 + i9), this.pos), this.pos += i9, s5 += i9, this.pos === r8 && (this.process(n5, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Wt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e11) {
    to(this), Sf(e11, this), this.finished = true;
    const { buffer: n5, h: r8 } = this;
    let { pos: o6 } = this;
    if (o6) {
      for (n5[o6++] = 1; o6 < 16; o6++) n5[o6] = 0;
      this.process(n5, 0, true);
    }
    this.finalize();
    let s5 = 0;
    for (let i9 = 0; i9 < 8; i9++) e11[s5++] = r8[i9] >>> 0, e11[s5++] = r8[i9] >>> 8;
    return e11;
  }
  digest() {
    const { buffer: e11, outputLen: n5 } = this;
    this.digestInto(e11);
    const r8 = e11.slice(0, n5);
    return this.destroy(), r8;
  }
};
function qf(t6) {
  const e11 = (r8, o6) => t6(o6).update(mn(r8)).digest(), n5 = t6(new Uint8Array(32));
  return e11.outputLen = n5.outputLen, e11.blockLen = n5.blockLen, e11.create = (r8) => t6(r8), e11;
}
var Kf = qf((t6) => new Vf(t6));
function Ff(t6, e11, n5, r8, o6, s5 = 20) {
  let i9 = t6[0], f16 = t6[1], a6 = t6[2], l9 = t6[3], c9 = e11[0], u10 = e11[1], h9 = e11[2], g4 = e11[3], w8 = e11[4], y11 = e11[5], x7 = e11[6], R6 = e11[7], M8 = o6, L7 = n5[0], V8 = n5[1], _6 = n5[2], k11 = i9, j9 = f16, $8 = a6, d7 = l9, m6 = c9, p9 = u10, b6 = h9, v9 = g4, B9 = w8, E8 = y11, I8 = x7, S8 = R6, O8 = M8, A9 = L7, T8 = V8, U6 = _6;
  for (let H4 = 0; H4 < s5; H4 += 2) k11 = k11 + m6 | 0, O8 = D(O8 ^ k11, 16), B9 = B9 + O8 | 0, m6 = D(m6 ^ B9, 12), k11 = k11 + m6 | 0, O8 = D(O8 ^ k11, 8), B9 = B9 + O8 | 0, m6 = D(m6 ^ B9, 7), j9 = j9 + p9 | 0, A9 = D(A9 ^ j9, 16), E8 = E8 + A9 | 0, p9 = D(p9 ^ E8, 12), j9 = j9 + p9 | 0, A9 = D(A9 ^ j9, 8), E8 = E8 + A9 | 0, p9 = D(p9 ^ E8, 7), $8 = $8 + b6 | 0, T8 = D(T8 ^ $8, 16), I8 = I8 + T8 | 0, b6 = D(b6 ^ I8, 12), $8 = $8 + b6 | 0, T8 = D(T8 ^ $8, 8), I8 = I8 + T8 | 0, b6 = D(b6 ^ I8, 7), d7 = d7 + v9 | 0, U6 = D(U6 ^ d7, 16), S8 = S8 + U6 | 0, v9 = D(v9 ^ S8, 12), d7 = d7 + v9 | 0, U6 = D(U6 ^ d7, 8), S8 = S8 + U6 | 0, v9 = D(v9 ^ S8, 7), k11 = k11 + p9 | 0, U6 = D(U6 ^ k11, 16), I8 = I8 + U6 | 0, p9 = D(p9 ^ I8, 12), k11 = k11 + p9 | 0, U6 = D(U6 ^ k11, 8), I8 = I8 + U6 | 0, p9 = D(p9 ^ I8, 7), j9 = j9 + b6 | 0, O8 = D(O8 ^ j9, 16), S8 = S8 + O8 | 0, b6 = D(b6 ^ S8, 12), j9 = j9 + b6 | 0, O8 = D(O8 ^ j9, 8), S8 = S8 + O8 | 0, b6 = D(b6 ^ S8, 7), $8 = $8 + v9 | 0, A9 = D(A9 ^ $8, 16), B9 = B9 + A9 | 0, v9 = D(v9 ^ B9, 12), $8 = $8 + v9 | 0, A9 = D(A9 ^ $8, 8), B9 = B9 + A9 | 0, v9 = D(v9 ^ B9, 7), d7 = d7 + m6 | 0, T8 = D(T8 ^ d7, 16), E8 = E8 + T8 | 0, m6 = D(m6 ^ E8, 12), d7 = d7 + m6 | 0, T8 = D(T8 ^ d7, 8), E8 = E8 + T8 | 0, m6 = D(m6 ^ E8, 7);
  let C10 = 0;
  r8[C10++] = i9 + k11 | 0, r8[C10++] = f16 + j9 | 0, r8[C10++] = a6 + $8 | 0, r8[C10++] = l9 + d7 | 0, r8[C10++] = c9 + m6 | 0, r8[C10++] = u10 + p9 | 0, r8[C10++] = h9 + b6 | 0, r8[C10++] = g4 + v9 | 0, r8[C10++] = w8 + B9 | 0, r8[C10++] = y11 + E8 | 0, r8[C10++] = x7 + I8 | 0, r8[C10++] = R6 + S8 | 0, r8[C10++] = M8 + O8 | 0, r8[C10++] = L7 + A9 | 0, r8[C10++] = V8 + T8 | 0, r8[C10++] = _6 + U6 | 0;
}
var zf = Mf(Ff, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Gf = new Uint8Array(16);
var io = (t6, e11) => {
  t6.update(e11);
  const n5 = e11.length % 16;
  n5 && t6.update(Gf.subarray(n5));
};
var Zf = new Uint8Array(32);
function fo(t6, e11, n5, r8, o6) {
  const s5 = t6(e11, n5, Zf), i9 = Kf.create(s5);
  o6 && io(i9, o6), io(i9, r8);
  const f16 = $f(r8.length, o6 ? o6.length : 0, true);
  i9.update(f16);
  const a6 = i9.digest();
  return Wt(s5, f16), a6;
}
var Wf = (t6) => (e11, n5, r8) => ({ encrypt(s5, i9) {
  const f16 = s5.length;
  i9 = eo(f16 + 16, i9, false), i9.set(s5);
  const a6 = i9.subarray(0, -16);
  t6(e11, n5, a6, a6, 1);
  const l9 = fo(t6, e11, n5, a6, r8);
  return i9.set(l9, f16), Wt(l9), i9;
}, decrypt(s5, i9) {
  i9 = eo(s5.length - 16, i9, false);
  const f16 = s5.subarray(0, -16), a6 = s5.subarray(-16), l9 = fo(t6, e11, n5, f16, r8);
  if (!Tf(a6, l9)) throw new Error("invalid tag");
  return i9.set(s5.subarray(0, -16)), t6(e11, n5, i9, i9, 1), Wt(l9), i9;
} });
var co = Rf({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Wf(zf));
var ao = class extends Ie {
  constructor(e11, n5) {
    super(), this.finished = false, this.destroyed = false, rn(e11);
    const r8 = ht(n5);
    if (this.iHash = e11.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o6 = this.blockLen, s5 = new Uint8Array(o6);
    s5.set(r8.length > o6 ? e11.create().update(r8).digest() : r8);
    for (let i9 = 0; i9 < s5.length; i9++) s5[i9] ^= 54;
    this.iHash.update(s5), this.oHash = e11.create();
    for (let i9 = 0; i9 < s5.length; i9++) s5[i9] ^= 106;
    this.oHash.update(s5), ut(s5);
  }
  update(e11) {
    return Nt(this), this.iHash.update(e11), this;
  }
  digestInto(e11) {
    Nt(this), at(e11, this.outputLen), this.finished = true, this.iHash.digestInto(e11), this.oHash.update(e11), this.oHash.digestInto(e11), this.destroy();
  }
  digest() {
    const e11 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e11), e11;
  }
  _cloneInto(e11) {
    e11 || (e11 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n5, iHash: r8, finished: o6, destroyed: s5, blockLen: i9, outputLen: f16 } = this;
    return e11 = e11, e11.finished = o6, e11.destroyed = s5, e11.blockLen = i9, e11.outputLen = f16, e11.oHash = n5._cloneInto(e11.oHash), e11.iHash = r8._cloneInto(e11.iHash), e11;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var _e = (t6, e11, n5) => new ao(t6, e11).update(n5).digest();
_e.create = (t6, e11) => new ao(t6, e11);
function Yf(t6, e11, n5) {
  return rn(t6), n5 === void 0 && (n5 = new Uint8Array(t6.outputLen)), _e(t6, ht(n5), ht(e11));
}
var vn = Uint8Array.from([0]);
var uo = Uint8Array.of();
function Xf(t6, e11, n5, r8 = 32) {
  rn(t6), mt(r8);
  const o6 = t6.outputLen;
  if (r8 > 255 * o6) throw new Error("Length should be <= 255*HashLen");
  const s5 = Math.ceil(r8 / o6);
  n5 === void 0 && (n5 = uo);
  const i9 = new Uint8Array(s5 * o6), f16 = _e.create(t6, e11), a6 = f16._cloneInto(), l9 = new Uint8Array(f16.outputLen);
  for (let c9 = 0; c9 < s5; c9++) vn[0] = c9 + 1, a6.update(c9 === 0 ? uo : l9).update(n5).update(vn).digestInto(l9), i9.set(l9, o6 * c9), f16._cloneInto(a6);
  return f16.destroy(), a6.destroy(), ut(l9, vn), i9.slice(0, r8);
}
var Jf = (t6, e11, n5, r8, o6) => Xf(t6, Yf(t6, e11, n5), r8, o6);
var Te = Ae;
var En = BigInt(0);
var Bn = BigInt(1);
function Re(t6, e11) {
  if (typeof e11 != "boolean") throw new Error(t6 + " boolean expected, got " + e11);
}
function $e(t6) {
  const e11 = t6.toString(16);
  return e11.length & 1 ? "0" + e11 : e11;
}
function lo(t6) {
  if (typeof t6 != "string") throw new Error("hex string expected, got " + typeof t6);
  return t6 === "" ? En : BigInt("0x" + t6);
}
function Ce(t6) {
  return lo(ce(t6));
}
function Le(t6) {
  return at(t6), lo(ce(Uint8Array.from(t6).reverse()));
}
function In(t6, e11) {
  return fn(t6.toString(16).padStart(e11 * 2, "0"));
}
function An(t6, e11) {
  return In(t6, e11).reverse();
}
function rt(t6, e11, n5) {
  let r8;
  if (typeof e11 == "string") try {
    r8 = fn(e11);
  } catch (s5) {
    throw new Error(t6 + " must be hex string or Uint8Array, cause: " + s5);
  }
  else if (nn(e11)) r8 = Uint8Array.from(e11);
  else throw new Error(t6 + " must be hex string or Uint8Array");
  const o6 = r8.length;
  if (typeof n5 == "number" && o6 !== n5) throw new Error(t6 + " of length " + n5 + " expected, got " + o6);
  return r8;
}
var Sn = (t6) => typeof t6 == "bigint" && En <= t6;
function Qf(t6, e11, n5) {
  return Sn(t6) && Sn(e11) && Sn(n5) && e11 <= t6 && t6 < n5;
}
function Nn(t6, e11, n5, r8) {
  if (!Qf(e11, n5, r8)) throw new Error("expected valid " + t6 + ": " + n5 + " <= n < " + r8 + ", got " + e11);
}
function tc(t6) {
  let e11;
  for (e11 = 0; t6 > En; t6 >>= Bn, e11 += 1) ;
  return e11;
}
var je = (t6) => (Bn << BigInt(t6)) - Bn;
function ec(t6, e11, n5) {
  if (typeof t6 != "number" || t6 < 2) throw new Error("hashLen must be a number");
  if (typeof e11 != "number" || e11 < 2) throw new Error("qByteLen must be a number");
  if (typeof n5 != "function") throw new Error("hmacFn must be a function");
  const r8 = (g4) => new Uint8Array(g4), o6 = (g4) => Uint8Array.of(g4);
  let s5 = r8(t6), i9 = r8(t6), f16 = 0;
  const a6 = () => {
    s5.fill(1), i9.fill(0), f16 = 0;
  }, l9 = (...g4) => n5(i9, s5, ...g4), c9 = (g4 = r8(0)) => {
    i9 = l9(o6(0), g4), s5 = l9(), g4.length !== 0 && (i9 = l9(o6(1), g4), s5 = l9());
  }, u10 = () => {
    if (f16++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let g4 = 0;
    const w8 = [];
    for (; g4 < e11; ) {
      s5 = l9();
      const y11 = s5.slice();
      w8.push(y11), g4 += s5.length;
    }
    return Ht(...w8);
  };
  return (g4, w8) => {
    a6(), c9(g4);
    let y11;
    for (; !(y11 = w8(u10())); ) c9();
    return a6(), y11;
  };
}
function ke(t6, e11, n5 = {}) {
  if (!t6 || typeof t6 != "object") throw new Error("expected valid options object");
  function r8(o6, s5, i9) {
    const f16 = t6[o6];
    if (i9 && f16 === void 0) return;
    const a6 = typeof f16;
    if (a6 !== s5 || f16 === null) throw new Error(`param "${o6}" is invalid: expected ${s5}, got ${a6}`);
  }
  Object.entries(e11).forEach(([o6, s5]) => r8(o6, s5, false)), Object.entries(n5).forEach(([o6, s5]) => r8(o6, s5, true));
}
function ho(t6) {
  const e11 = /* @__PURE__ */ new WeakMap();
  return (n5, ...r8) => {
    const o6 = e11.get(n5);
    if (o6 !== void 0) return o6;
    const s5 = t6(n5, ...r8);
    return e11.set(n5, s5), s5;
  };
}
var ot = BigInt(0);
var Q = BigInt(1);
var Dt = BigInt(2);
var nc = BigInt(3);
var po = BigInt(4);
var go = BigInt(5);
var bo = BigInt(8);
function lt(t6, e11) {
  const n5 = t6 % e11;
  return n5 >= ot ? n5 : e11 + n5;
}
function pt(t6, e11, n5) {
  let r8 = t6;
  for (; e11-- > ot; ) r8 *= r8, r8 %= n5;
  return r8;
}
function yo(t6, e11) {
  if (t6 === ot) throw new Error("invert: expected non-zero number");
  if (e11 <= ot) throw new Error("invert: expected positive modulus, got " + e11);
  let n5 = lt(t6, e11), r8 = e11, o6 = ot, s5 = Q;
  for (; n5 !== ot; ) {
    const f16 = r8 / n5, a6 = r8 % n5, l9 = o6 - s5 * f16;
    r8 = n5, n5 = a6, o6 = s5, s5 = l9;
  }
  if (r8 !== Q) throw new Error("invert: does not exist");
  return lt(o6, e11);
}
function mo(t6, e11) {
  const n5 = (t6.ORDER + Q) / po, r8 = t6.pow(e11, n5);
  if (!t6.eql(t6.sqr(r8), e11)) throw new Error("Cannot find square root");
  return r8;
}
function rc(t6, e11) {
  const n5 = (t6.ORDER - go) / bo, r8 = t6.mul(e11, Dt), o6 = t6.pow(r8, n5), s5 = t6.mul(e11, o6), i9 = t6.mul(t6.mul(s5, Dt), o6), f16 = t6.mul(s5, t6.sub(i9, t6.ONE));
  if (!t6.eql(t6.sqr(f16), e11)) throw new Error("Cannot find square root");
  return f16;
}
function oc(t6) {
  if (t6 < BigInt(3)) throw new Error("sqrt is not defined for small field");
  let e11 = t6 - Q, n5 = 0;
  for (; e11 % Dt === ot; ) e11 /= Dt, n5++;
  let r8 = Dt;
  const o6 = Yt(t6);
  for (; xo(o6, r8) === 1; ) if (r8++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (n5 === 1) return mo;
  let s5 = o6.pow(r8, e11);
  const i9 = (e11 + Q) / Dt;
  return function(a6, l9) {
    if (a6.is0(l9)) return l9;
    if (xo(a6, l9) !== 1) throw new Error("Cannot find square root");
    let c9 = n5, u10 = a6.mul(a6.ONE, s5), h9 = a6.pow(l9, e11), g4 = a6.pow(l9, i9);
    for (; !a6.eql(h9, a6.ONE); ) {
      if (a6.is0(h9)) return a6.ZERO;
      let w8 = 1, y11 = a6.sqr(h9);
      for (; !a6.eql(y11, a6.ONE); ) if (w8++, y11 = a6.sqr(y11), w8 === c9) throw new Error("Cannot find square root");
      const x7 = Q << BigInt(c9 - w8 - 1), R6 = a6.pow(u10, x7);
      c9 = w8, u10 = a6.sqr(R6), h9 = a6.mul(h9, u10), g4 = a6.mul(g4, R6);
    }
    return g4;
  };
}
function sc(t6) {
  return t6 % po === nc ? mo : t6 % bo === go ? rc : oc(t6);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function fc(t6) {
  const e11 = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n5 = ic.reduce((r8, o6) => (r8[o6] = "function", r8), e11);
  return ke(t6, n5), t6;
}
function cc(t6, e11, n5) {
  if (n5 < ot) throw new Error("invalid exponent, negatives unsupported");
  if (n5 === ot) return t6.ONE;
  if (n5 === Q) return e11;
  let r8 = t6.ONE, o6 = e11;
  for (; n5 > ot; ) n5 & Q && (r8 = t6.mul(r8, o6)), o6 = t6.sqr(o6), n5 >>= Q;
  return r8;
}
function wo(t6, e11, n5 = false) {
  const r8 = new Array(e11.length).fill(n5 ? t6.ZERO : void 0), o6 = e11.reduce((i9, f16, a6) => t6.is0(f16) ? i9 : (r8[a6] = i9, t6.mul(i9, f16)), t6.ONE), s5 = t6.inv(o6);
  return e11.reduceRight((i9, f16, a6) => t6.is0(f16) ? i9 : (r8[a6] = t6.mul(i9, r8[a6]), t6.mul(i9, f16)), s5), r8;
}
function xo(t6, e11) {
  const n5 = (t6.ORDER - Q) / Dt, r8 = t6.pow(e11, n5), o6 = t6.eql(r8, t6.ONE), s5 = t6.eql(r8, t6.ZERO), i9 = t6.eql(r8, t6.neg(t6.ONE));
  if (!o6 && !s5 && !i9) throw new Error("invalid Legendre symbol result");
  return o6 ? 1 : s5 ? 0 : -1;
}
function ac(t6, e11) {
  e11 !== void 0 && mt(e11);
  const n5 = e11 !== void 0 ? e11 : t6.toString(2).length, r8 = Math.ceil(n5 / 8);
  return { nBitLength: n5, nByteLength: r8 };
}
function Yt(t6, e11, n5 = false, r8 = {}) {
  if (t6 <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t6);
  let o6, s5;
  if (typeof e11 == "object" && e11 != null) {
    if (r8.sqrt || n5) throw new Error("cannot specify opts in two arguments");
    const c9 = e11;
    c9.BITS && (o6 = c9.BITS), c9.sqrt && (s5 = c9.sqrt), typeof c9.isLE == "boolean" && (n5 = c9.isLE);
  } else typeof e11 == "number" && (o6 = e11), r8.sqrt && (s5 = r8.sqrt);
  const { nBitLength: i9, nByteLength: f16 } = ac(t6, o6);
  if (f16 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let a6;
  const l9 = Object.freeze({ ORDER: t6, isLE: n5, BITS: i9, BYTES: f16, MASK: je(i9), ZERO: ot, ONE: Q, create: (c9) => lt(c9, t6), isValid: (c9) => {
    if (typeof c9 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c9);
    return ot <= c9 && c9 < t6;
  }, is0: (c9) => c9 === ot, isValidNot0: (c9) => !l9.is0(c9) && l9.isValid(c9), isOdd: (c9) => (c9 & Q) === Q, neg: (c9) => lt(-c9, t6), eql: (c9, u10) => c9 === u10, sqr: (c9) => lt(c9 * c9, t6), add: (c9, u10) => lt(c9 + u10, t6), sub: (c9, u10) => lt(c9 - u10, t6), mul: (c9, u10) => lt(c9 * u10, t6), pow: (c9, u10) => cc(l9, c9, u10), div: (c9, u10) => lt(c9 * yo(u10, t6), t6), sqrN: (c9) => c9 * c9, addN: (c9, u10) => c9 + u10, subN: (c9, u10) => c9 - u10, mulN: (c9, u10) => c9 * u10, inv: (c9) => yo(c9, t6), sqrt: s5 || ((c9) => (a6 || (a6 = sc(t6)), a6(l9, c9))), toBytes: (c9) => n5 ? An(c9, f16) : In(c9, f16), fromBytes: (c9) => {
    if (c9.length !== f16) throw new Error("Field.fromBytes: expected " + f16 + " bytes, got " + c9.length);
    return n5 ? Le(c9) : Ce(c9);
  }, invertBatch: (c9) => wo(l9, c9), cmov: (c9, u10, h9) => h9 ? u10 : c9 });
  return Object.freeze(l9);
}
function vo(t6) {
  if (typeof t6 != "bigint") throw new Error("field order must be bigint");
  const e11 = t6.toString(2).length;
  return Math.ceil(e11 / 8);
}
function Eo(t6) {
  const e11 = vo(t6);
  return e11 + Math.ceil(e11 / 2);
}
function uc(t6, e11, n5 = false) {
  const r8 = t6.length, o6 = vo(e11), s5 = Eo(e11);
  if (r8 < 16 || r8 < s5 || r8 > 1024) throw new Error("expected " + s5 + "-1024 bytes of input, got " + r8);
  const i9 = n5 ? Le(t6) : Ce(t6), f16 = lt(i9, e11 - Q) + Q;
  return n5 ? An(f16, o6) : In(f16, o6);
}
var Xt = BigInt(0);
var Mt = BigInt(1);
function le(t6, e11) {
  const n5 = e11.negate();
  return t6 ? n5 : e11;
}
function lc(t6, e11, n5) {
  const r8 = e11 === "pz" ? (i9) => i9.pz : (i9) => i9.ez, o6 = wo(t6.Fp, n5.map(r8));
  return n5.map((i9, f16) => i9.toAffine(o6[f16])).map(t6.fromAffine);
}
function Bo(t6, e11) {
  if (!Number.isSafeInteger(t6) || t6 <= 0 || t6 > e11) throw new Error("invalid window size, expected [1.." + e11 + "], got W=" + t6);
}
function On(t6, e11) {
  Bo(t6, e11);
  const n5 = Math.ceil(e11 / t6) + 1, r8 = 2 ** (t6 - 1), o6 = 2 ** t6, s5 = je(t6), i9 = BigInt(t6);
  return { windows: n5, windowSize: r8, mask: s5, maxNumber: o6, shiftBy: i9 };
}
function Io(t6, e11, n5) {
  const { windowSize: r8, mask: o6, maxNumber: s5, shiftBy: i9 } = n5;
  let f16 = Number(t6 & o6), a6 = t6 >> i9;
  f16 > r8 && (f16 -= s5, a6 += Mt);
  const l9 = e11 * r8, c9 = l9 + Math.abs(f16) - 1, u10 = f16 === 0, h9 = f16 < 0, g4 = e11 % 2 !== 0;
  return { nextN: a6, offset: c9, isZero: u10, isNeg: h9, isNegF: g4, offsetF: l9 };
}
function dc(t6, e11) {
  if (!Array.isArray(t6)) throw new Error("array expected");
  t6.forEach((n5, r8) => {
    if (!(n5 instanceof e11)) throw new Error("invalid point at index " + r8);
  });
}
function hc(t6, e11) {
  if (!Array.isArray(t6)) throw new Error("array of scalars expected");
  t6.forEach((n5, r8) => {
    if (!e11.isValid(n5)) throw new Error("invalid scalar at index " + r8);
  });
}
var Un = /* @__PURE__ */ new WeakMap();
var Ao = /* @__PURE__ */ new WeakMap();
function _n(t6) {
  return Ao.get(t6) || 1;
}
function So(t6) {
  if (t6 !== Xt) throw new Error("invalid wNAF");
}
function pc(t6, e11) {
  return { constTimeNegate: le, hasPrecomputes(n5) {
    return _n(n5) !== 1;
  }, unsafeLadder(n5, r8, o6 = t6.ZERO) {
    let s5 = n5;
    for (; r8 > Xt; ) r8 & Mt && (o6 = o6.add(s5)), s5 = s5.double(), r8 >>= Mt;
    return o6;
  }, precomputeWindow(n5, r8) {
    const { windows: o6, windowSize: s5 } = On(r8, e11), i9 = [];
    let f16 = n5, a6 = f16;
    for (let l9 = 0; l9 < o6; l9++) {
      a6 = f16, i9.push(a6);
      for (let c9 = 1; c9 < s5; c9++) a6 = a6.add(f16), i9.push(a6);
      f16 = a6.double();
    }
    return i9;
  }, wNAF(n5, r8, o6) {
    let s5 = t6.ZERO, i9 = t6.BASE;
    const f16 = On(n5, e11);
    for (let a6 = 0; a6 < f16.windows; a6++) {
      const { nextN: l9, offset: c9, isZero: u10, isNeg: h9, isNegF: g4, offsetF: w8 } = Io(o6, a6, f16);
      o6 = l9, u10 ? i9 = i9.add(le(g4, r8[w8])) : s5 = s5.add(le(h9, r8[c9]));
    }
    return So(o6), { p: s5, f: i9 };
  }, wNAFUnsafe(n5, r8, o6, s5 = t6.ZERO) {
    const i9 = On(n5, e11);
    for (let f16 = 0; f16 < i9.windows && o6 !== Xt; f16++) {
      const { nextN: a6, offset: l9, isZero: c9, isNeg: u10 } = Io(o6, f16, i9);
      if (o6 = a6, !c9) {
        const h9 = r8[l9];
        s5 = s5.add(u10 ? h9.negate() : h9);
      }
    }
    return So(o6), s5;
  }, getPrecomputes(n5, r8, o6) {
    let s5 = Un.get(r8);
    return s5 || (s5 = this.precomputeWindow(r8, n5), n5 !== 1 && (typeof o6 == "function" && (s5 = o6(s5)), Un.set(r8, s5))), s5;
  }, wNAFCached(n5, r8, o6) {
    const s5 = _n(n5);
    return this.wNAF(s5, this.getPrecomputes(s5, n5, o6), r8);
  }, wNAFCachedUnsafe(n5, r8, o6, s5) {
    const i9 = _n(n5);
    return i9 === 1 ? this.unsafeLadder(n5, r8, s5) : this.wNAFUnsafe(i9, this.getPrecomputes(i9, n5, o6), r8, s5);
  }, setWindowSize(n5, r8) {
    Bo(r8, e11), Ao.set(n5, r8), Un.delete(n5);
  } };
}
function gc(t6, e11, n5, r8) {
  let o6 = e11, s5 = t6.ZERO, i9 = t6.ZERO;
  for (; n5 > Xt || r8 > Xt; ) n5 & Mt && (s5 = s5.add(o6)), r8 & Mt && (i9 = i9.add(o6)), o6 = o6.double(), n5 >>= Mt, r8 >>= Mt;
  return { p1: s5, p2: i9 };
}
function bc(t6, e11, n5, r8) {
  dc(n5, t6), hc(r8, e11);
  const o6 = n5.length, s5 = r8.length;
  if (o6 !== s5) throw new Error("arrays of points and scalars must have equal length");
  const i9 = t6.ZERO, f16 = tc(BigInt(o6));
  let a6 = 1;
  f16 > 12 ? a6 = f16 - 3 : f16 > 4 ? a6 = f16 - 2 : f16 > 0 && (a6 = 2);
  const l9 = je(a6), c9 = new Array(Number(l9) + 1).fill(i9), u10 = Math.floor((e11.BITS - 1) / a6) * a6;
  let h9 = i9;
  for (let g4 = u10; g4 >= 0; g4 -= a6) {
    c9.fill(i9);
    for (let y11 = 0; y11 < s5; y11++) {
      const x7 = r8[y11], R6 = Number(x7 >> BigInt(g4) & l9);
      c9[R6] = c9[R6].add(n5[y11]);
    }
    let w8 = i9;
    for (let y11 = c9.length - 1, x7 = i9; y11 > 0; y11--) x7 = x7.add(c9[y11]), w8 = w8.add(x7);
    if (h9 = h9.add(w8), g4 !== 0) for (let y11 = 0; y11 < a6; y11++) h9 = h9.double();
  }
  return h9;
}
function No(t6, e11) {
  if (e11) {
    if (e11.ORDER !== t6) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return fc(e11), e11;
  } else return Yt(t6);
}
function yc(t6, e11, n5 = {}) {
  if (!e11 || typeof e11 != "object") throw new Error(`expected valid ${t6} CURVE object`);
  for (const f16 of ["p", "n", "h"]) {
    const a6 = e11[f16];
    if (!(typeof a6 == "bigint" && a6 > Xt)) throw new Error(`CURVE.${f16} must be positive bigint`);
  }
  const r8 = No(e11.p, n5.Fp), o6 = No(e11.n, n5.Fn), i9 = ["Gx", "Gy", "a", t6 === "weierstrass" ? "b" : "d"];
  for (const f16 of i9) if (!r8.isValid(e11[f16])) throw new Error(`CURVE.${f16} must be valid field element of CURVE.Fp`);
  return { Fp: r8, Fn: o6 };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var de = BigInt(0);
var Jt = BigInt(1);
var Pe = BigInt(2);
function mc(t6) {
  return ke(t6, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...t6 });
}
function wc(t6) {
  const e11 = mc(t6), { P: n5, type: r8, adjustScalarBytes: o6, powPminus2: s5, randomBytes: i9 } = e11, f16 = r8 === "x25519";
  if (!f16 && r8 !== "x448") throw new Error("invalid type");
  const a6 = i9 || Zt, l9 = f16 ? 255 : 448, c9 = f16 ? 32 : 56, u10 = BigInt(f16 ? 9 : 5), h9 = BigInt(f16 ? 121665 : 39081), g4 = f16 ? Pe ** BigInt(254) : Pe ** BigInt(447), w8 = f16 ? BigInt(8) * Pe ** BigInt(251) - Jt : BigInt(4) * Pe ** BigInt(445) - Jt, y11 = g4 + w8 + Jt, x7 = (d7) => lt(d7, n5), R6 = M8(u10);
  function M8(d7) {
    return An(x7(d7), c9);
  }
  function L7(d7) {
    const m6 = rt("u coordinate", d7, c9);
    return f16 && (m6[31] &= 127), x7(Le(m6));
  }
  function V8(d7) {
    return Le(o6(rt("scalar", d7, c9)));
  }
  function _6(d7, m6) {
    const p9 = $8(L7(m6), V8(d7));
    if (p9 === de) throw new Error("invalid private or public key received");
    return M8(p9);
  }
  function k11(d7) {
    return _6(d7, R6);
  }
  function j9(d7, m6, p9) {
    const b6 = x7(d7 * (m6 - p9));
    return m6 = x7(m6 - b6), p9 = x7(p9 + b6), { x_2: m6, x_3: p9 };
  }
  function $8(d7, m6) {
    Nn("u", d7, de, n5), Nn("scalar", m6, g4, y11);
    const p9 = m6, b6 = d7;
    let v9 = Jt, B9 = de, E8 = d7, I8 = Jt, S8 = de;
    for (let A9 = BigInt(l9 - 1); A9 >= de; A9--) {
      const T8 = p9 >> A9 & Jt;
      S8 ^= T8, { x_2: v9, x_3: E8 } = j9(S8, v9, E8), { x_2: B9, x_3: I8 } = j9(S8, B9, I8), S8 = T8;
      const U6 = v9 + B9, C10 = x7(U6 * U6), H4 = v9 - B9, q6 = x7(H4 * H4), P7 = C10 - q6, K5 = E8 + I8, et3 = E8 - I8, Z5 = x7(et3 * U6), z9 = x7(K5 * H4), Ft3 = Z5 + z9, yt4 = Z5 - z9;
      E8 = x7(Ft3 * Ft3), I8 = x7(b6 * x7(yt4 * yt4)), v9 = x7(C10 * q6), B9 = x7(P7 * (C10 + x7(h9 * P7)));
    }
    ({ x_2: v9, x_3: E8 } = j9(S8, v9, E8)), { x_2: B9, x_3: I8 } = j9(S8, B9, I8);
    const O8 = s5(B9);
    return x7(v9 * O8);
  }
  return { scalarMult: _6, scalarMultBase: k11, getSharedSecret: (d7, m6) => _6(d7, m6), getPublicKey: (d7) => k11(d7), utils: { randomPrivateKey: () => a6(c9) }, GuBytes: R6.slice() };
}
BigInt(0);
var xc = BigInt(1);
var Oo = BigInt(2);
var vc = BigInt(3);
var Ec = BigInt(5);
var Bc = BigInt(8);
var Uo = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: Bc, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function Ic(t6) {
  const e11 = BigInt(10), n5 = BigInt(20), r8 = BigInt(40), o6 = BigInt(80), s5 = Uo.p, f16 = t6 * t6 % s5 * t6 % s5, a6 = pt(f16, Oo, s5) * f16 % s5, l9 = pt(a6, xc, s5) * t6 % s5, c9 = pt(l9, Ec, s5) * l9 % s5, u10 = pt(c9, e11, s5) * c9 % s5, h9 = pt(u10, n5, s5) * u10 % s5, g4 = pt(h9, r8, s5) * h9 % s5, w8 = pt(g4, o6, s5) * g4 % s5, y11 = pt(w8, o6, s5) * g4 % s5, x7 = pt(y11, e11, s5) * c9 % s5;
  return { pow_p_5_8: pt(x7, Oo, s5) * t6 % s5, b2: f16 };
}
function Ac(t6) {
  return t6[0] &= 248, t6[31] &= 127, t6[31] |= 64, t6;
}
var Tn = (() => {
  const t6 = Uo.p;
  return wc({ P: t6, type: "x25519", powPminus2: (e11) => {
    const { pow_p_5_8: n5, b2: r8 } = Ic(e11);
    return lt(pt(n5, vc, t6) * r8, t6);
  }, adjustScalarBytes: Ac });
})();
function _o(t6) {
  t6.lowS !== void 0 && Re("lowS", t6.lowS), t6.prehash !== void 0 && Re("prehash", t6.prehash);
}
var Sc = class extends Error {
  constructor(e11 = "") {
    super(e11);
  }
};
var vt = { Err: Sc, _tlv: { encode: (t6, e11) => {
  const { Err: n5 } = vt;
  if (t6 < 0 || t6 > 256) throw new n5("tlv.encode: wrong tag");
  if (e11.length & 1) throw new n5("tlv.encode: unpadded data");
  const r8 = e11.length / 2, o6 = $e(r8);
  if (o6.length / 2 & 128) throw new n5("tlv.encode: long form length too big");
  const s5 = r8 > 127 ? $e(o6.length / 2 | 128) : "";
  return $e(t6) + s5 + o6 + e11;
}, decode(t6, e11) {
  const { Err: n5 } = vt;
  let r8 = 0;
  if (t6 < 0 || t6 > 256) throw new n5("tlv.encode: wrong tag");
  if (e11.length < 2 || e11[r8++] !== t6) throw new n5("tlv.decode: wrong tlv");
  const o6 = e11[r8++], s5 = !!(o6 & 128);
  let i9 = 0;
  if (!s5) i9 = o6;
  else {
    const a6 = o6 & 127;
    if (!a6) throw new n5("tlv.decode(long): indefinite length not supported");
    if (a6 > 4) throw new n5("tlv.decode(long): byte length is too big");
    const l9 = e11.subarray(r8, r8 + a6);
    if (l9.length !== a6) throw new n5("tlv.decode: length bytes not complete");
    if (l9[0] === 0) throw new n5("tlv.decode(long): zero leftmost byte");
    for (const c9 of l9) i9 = i9 << 8 | c9;
    if (r8 += a6, i9 < 128) throw new n5("tlv.decode(long): not minimal encoding");
  }
  const f16 = e11.subarray(r8, r8 + i9);
  if (f16.length !== i9) throw new n5("tlv.decode: wrong value length");
  return { v: f16, l: e11.subarray(r8 + i9) };
} }, _int: { encode(t6) {
  const { Err: e11 } = vt;
  if (t6 < he) throw new e11("integer: negative integers are not allowed");
  let n5 = $e(t6);
  if (Number.parseInt(n5[0], 16) & 8 && (n5 = "00" + n5), n5.length & 1) throw new e11("unexpected DER parsing assertion: unpadded hex");
  return n5;
}, decode(t6) {
  const { Err: e11 } = vt;
  if (t6[0] & 128) throw new e11("invalid signature integer: negative");
  if (t6[0] === 0 && !(t6[1] & 128)) throw new e11("invalid signature integer: unnecessary leading zero");
  return Ce(t6);
} }, toSig(t6) {
  const { Err: e11, _int: n5, _tlv: r8 } = vt, o6 = rt("signature", t6), { v: s5, l: i9 } = r8.decode(48, o6);
  if (i9.length) throw new e11("invalid signature: left bytes after parsing");
  const { v: f16, l: a6 } = r8.decode(2, s5), { v: l9, l: c9 } = r8.decode(2, a6);
  if (c9.length) throw new e11("invalid signature: left bytes after parsing");
  return { r: n5.decode(f16), s: n5.decode(l9) };
}, hexFromSig(t6) {
  const { _tlv: e11, _int: n5 } = vt, r8 = e11.encode(2, n5.encode(t6.r)), o6 = e11.encode(2, n5.encode(t6.s)), s5 = r8 + o6;
  return e11.encode(48, s5);
} };
var he = BigInt(0);
var pe = BigInt(1);
var Nc = BigInt(2);
var He = BigInt(3);
var Oc = BigInt(4);
function Uc(t6, e11, n5) {
  function r8(o6) {
    const s5 = t6.sqr(o6), i9 = t6.mul(s5, o6);
    return t6.add(t6.add(i9, t6.mul(o6, e11)), n5);
  }
  return r8;
}
function To(t6, e11, n5) {
  const { BYTES: r8 } = t6;
  function o6(s5) {
    let i9;
    if (typeof s5 == "bigint") i9 = s5;
    else {
      let f16 = rt("private key", s5);
      if (e11) {
        if (!e11.includes(f16.length * 2)) throw new Error("invalid private key");
        const a6 = new Uint8Array(r8);
        a6.set(f16, a6.length - f16.length), f16 = a6;
      }
      try {
        i9 = t6.fromBytes(f16);
      } catch {
        throw new Error(`invalid private key: expected ui8a of size ${r8}, got ${typeof s5}`);
      }
    }
    if (n5 && (i9 = t6.create(i9)), !t6.isValidNot0(i9)) throw new Error("invalid private key: out of range [1..N-1]");
    return i9;
  }
  return o6;
}
function _c(t6, e11 = {}) {
  const { Fp: n5, Fn: r8 } = yc("weierstrass", t6, e11), { h: o6, n: s5 } = t6;
  ke(e11, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: i9 } = e11;
  if (i9 && (!n5.is0(t6.a) || typeof i9.beta != "bigint" || typeof i9.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  function f16() {
    if (!n5.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function a6($8, d7, m6) {
    const { x: p9, y: b6 } = d7.toAffine(), v9 = n5.toBytes(p9);
    if (Re("isCompressed", m6), m6) {
      f16();
      const B9 = !n5.isOdd(b6);
      return Ht(Ro(B9), v9);
    } else return Ht(Uint8Array.of(4), v9, n5.toBytes(b6));
  }
  function l9($8) {
    at($8);
    const d7 = n5.BYTES, m6 = d7 + 1, p9 = 2 * d7 + 1, b6 = $8.length, v9 = $8[0], B9 = $8.subarray(1);
    if (b6 === m6 && (v9 === 2 || v9 === 3)) {
      const E8 = n5.fromBytes(B9);
      if (!n5.isValid(E8)) throw new Error("bad point: is not on curve, wrong x");
      const I8 = h9(E8);
      let S8;
      try {
        S8 = n5.sqrt(I8);
      } catch (T8) {
        const U6 = T8 instanceof Error ? ": " + T8.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + U6);
      }
      f16();
      const O8 = n5.isOdd(S8);
      return (v9 & 1) === 1 !== O8 && (S8 = n5.neg(S8)), { x: E8, y: S8 };
    } else if (b6 === p9 && v9 === 4) {
      const E8 = n5.fromBytes(B9.subarray(d7 * 0, d7 * 1)), I8 = n5.fromBytes(B9.subarray(d7 * 1, d7 * 2));
      if (!g4(E8, I8)) throw new Error("bad point: is not on curve");
      return { x: E8, y: I8 };
    } else throw new Error(`bad point: got length ${b6}, expected compressed=${m6} or uncompressed=${p9}`);
  }
  const c9 = e11.toBytes || a6, u10 = e11.fromBytes || l9, h9 = Uc(n5, t6.a, t6.b);
  function g4($8, d7) {
    const m6 = n5.sqr(d7), p9 = h9($8);
    return n5.eql(m6, p9);
  }
  if (!g4(t6.Gx, t6.Gy)) throw new Error("bad curve params: generator point");
  const w8 = n5.mul(n5.pow(t6.a, He), Oc), y11 = n5.mul(n5.sqr(t6.b), BigInt(27));
  if (n5.is0(n5.add(w8, y11))) throw new Error("bad curve params: a or b");
  function x7($8, d7, m6 = false) {
    if (!n5.isValid(d7) || m6 && n5.is0(d7)) throw new Error(`bad point coordinate ${$8}`);
    return d7;
  }
  function R6($8) {
    if (!($8 instanceof _6)) throw new Error("ProjectivePoint expected");
  }
  const M8 = ho(($8, d7) => {
    const { px: m6, py: p9, pz: b6 } = $8;
    if (n5.eql(b6, n5.ONE)) return { x: m6, y: p9 };
    const v9 = $8.is0();
    d7 == null && (d7 = v9 ? n5.ONE : n5.inv(b6));
    const B9 = n5.mul(m6, d7), E8 = n5.mul(p9, d7), I8 = n5.mul(b6, d7);
    if (v9) return { x: n5.ZERO, y: n5.ZERO };
    if (!n5.eql(I8, n5.ONE)) throw new Error("invZ was invalid");
    return { x: B9, y: E8 };
  }), L7 = ho(($8) => {
    if ($8.is0()) {
      if (e11.allowInfinityPoint && !n5.is0($8.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d7, y: m6 } = $8.toAffine();
    if (!n5.isValid(d7) || !n5.isValid(m6)) throw new Error("bad point: x or y not field elements");
    if (!g4(d7, m6)) throw new Error("bad point: equation left != right");
    if (!$8.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function V8($8, d7, m6, p9, b6) {
    return m6 = new _6(n5.mul(m6.px, $8), m6.py, m6.pz), d7 = le(p9, d7), m6 = le(b6, m6), d7.add(m6);
  }
  class _6 {
    constructor(d7, m6, p9) {
      this.px = x7("x", d7), this.py = x7("y", m6, true), this.pz = x7("z", p9), Object.freeze(this);
    }
    static fromAffine(d7) {
      const { x: m6, y: p9 } = d7 || {};
      if (!d7 || !n5.isValid(m6) || !n5.isValid(p9)) throw new Error("invalid affine point");
      if (d7 instanceof _6) throw new Error("projective point not allowed");
      return n5.is0(m6) && n5.is0(p9) ? _6.ZERO : new _6(m6, p9, n5.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d7) {
      return lc(_6, "pz", d7);
    }
    static fromBytes(d7) {
      return at(d7), _6.fromHex(d7);
    }
    static fromHex(d7) {
      const m6 = _6.fromAffine(u10(rt("pointHex", d7)));
      return m6.assertValidity(), m6;
    }
    static fromPrivateKey(d7) {
      const m6 = To(r8, e11.allowedPrivateKeyLengths, e11.wrapPrivateKey);
      return _6.BASE.multiply(m6(d7));
    }
    static msm(d7, m6) {
      return bc(_6, r8, d7, m6);
    }
    precompute(d7 = 8, m6 = true) {
      return j9.setWindowSize(this, d7), m6 || this.multiply(He), this;
    }
    _setWindowSize(d7) {
      this.precompute(d7);
    }
    assertValidity() {
      L7(this);
    }
    hasEvenY() {
      const { y: d7 } = this.toAffine();
      if (!n5.isOdd) throw new Error("Field doesn't support isOdd");
      return !n5.isOdd(d7);
    }
    equals(d7) {
      R6(d7);
      const { px: m6, py: p9, pz: b6 } = this, { px: v9, py: B9, pz: E8 } = d7, I8 = n5.eql(n5.mul(m6, E8), n5.mul(v9, b6)), S8 = n5.eql(n5.mul(p9, E8), n5.mul(B9, b6));
      return I8 && S8;
    }
    negate() {
      return new _6(this.px, n5.neg(this.py), this.pz);
    }
    double() {
      const { a: d7, b: m6 } = t6, p9 = n5.mul(m6, He), { px: b6, py: v9, pz: B9 } = this;
      let E8 = n5.ZERO, I8 = n5.ZERO, S8 = n5.ZERO, O8 = n5.mul(b6, b6), A9 = n5.mul(v9, v9), T8 = n5.mul(B9, B9), U6 = n5.mul(b6, v9);
      return U6 = n5.add(U6, U6), S8 = n5.mul(b6, B9), S8 = n5.add(S8, S8), E8 = n5.mul(d7, S8), I8 = n5.mul(p9, T8), I8 = n5.add(E8, I8), E8 = n5.sub(A9, I8), I8 = n5.add(A9, I8), I8 = n5.mul(E8, I8), E8 = n5.mul(U6, E8), S8 = n5.mul(p9, S8), T8 = n5.mul(d7, T8), U6 = n5.sub(O8, T8), U6 = n5.mul(d7, U6), U6 = n5.add(U6, S8), S8 = n5.add(O8, O8), O8 = n5.add(S8, O8), O8 = n5.add(O8, T8), O8 = n5.mul(O8, U6), I8 = n5.add(I8, O8), T8 = n5.mul(v9, B9), T8 = n5.add(T8, T8), O8 = n5.mul(T8, U6), E8 = n5.sub(E8, O8), S8 = n5.mul(T8, A9), S8 = n5.add(S8, S8), S8 = n5.add(S8, S8), new _6(E8, I8, S8);
    }
    add(d7) {
      R6(d7);
      const { px: m6, py: p9, pz: b6 } = this, { px: v9, py: B9, pz: E8 } = d7;
      let I8 = n5.ZERO, S8 = n5.ZERO, O8 = n5.ZERO;
      const A9 = t6.a, T8 = n5.mul(t6.b, He);
      let U6 = n5.mul(m6, v9), C10 = n5.mul(p9, B9), H4 = n5.mul(b6, E8), q6 = n5.add(m6, p9), P7 = n5.add(v9, B9);
      q6 = n5.mul(q6, P7), P7 = n5.add(U6, C10), q6 = n5.sub(q6, P7), P7 = n5.add(m6, b6);
      let K5 = n5.add(v9, E8);
      return P7 = n5.mul(P7, K5), K5 = n5.add(U6, H4), P7 = n5.sub(P7, K5), K5 = n5.add(p9, b6), I8 = n5.add(B9, E8), K5 = n5.mul(K5, I8), I8 = n5.add(C10, H4), K5 = n5.sub(K5, I8), O8 = n5.mul(A9, P7), I8 = n5.mul(T8, H4), O8 = n5.add(I8, O8), I8 = n5.sub(C10, O8), O8 = n5.add(C10, O8), S8 = n5.mul(I8, O8), C10 = n5.add(U6, U6), C10 = n5.add(C10, U6), H4 = n5.mul(A9, H4), P7 = n5.mul(T8, P7), C10 = n5.add(C10, H4), H4 = n5.sub(U6, H4), H4 = n5.mul(A9, H4), P7 = n5.add(P7, H4), U6 = n5.mul(C10, P7), S8 = n5.add(S8, U6), U6 = n5.mul(K5, P7), I8 = n5.mul(q6, I8), I8 = n5.sub(I8, U6), U6 = n5.mul(q6, C10), O8 = n5.mul(K5, O8), O8 = n5.add(O8, U6), new _6(I8, S8, O8);
    }
    subtract(d7) {
      return this.add(d7.negate());
    }
    is0() {
      return this.equals(_6.ZERO);
    }
    multiply(d7) {
      const { endo: m6 } = e11;
      if (!r8.isValidNot0(d7)) throw new Error("invalid scalar: out of range");
      let p9, b6;
      const v9 = (B9) => j9.wNAFCached(this, B9, _6.normalizeZ);
      if (m6) {
        const { k1neg: B9, k1: E8, k2neg: I8, k2: S8 } = m6.splitScalar(d7), { p: O8, f: A9 } = v9(E8), { p: T8, f: U6 } = v9(S8);
        b6 = A9.add(U6), p9 = V8(m6.beta, O8, T8, B9, I8);
      } else {
        const { p: B9, f: E8 } = v9(d7);
        p9 = B9, b6 = E8;
      }
      return _6.normalizeZ([p9, b6])[0];
    }
    multiplyUnsafe(d7) {
      const { endo: m6 } = e11, p9 = this;
      if (!r8.isValid(d7)) throw new Error("invalid scalar: out of range");
      if (d7 === he || p9.is0()) return _6.ZERO;
      if (d7 === pe) return p9;
      if (j9.hasPrecomputes(this)) return this.multiply(d7);
      if (m6) {
        const { k1neg: b6, k1: v9, k2neg: B9, k2: E8 } = m6.splitScalar(d7), { p1: I8, p2: S8 } = gc(_6, p9, v9, E8);
        return V8(m6.beta, I8, S8, b6, B9);
      } else return j9.wNAFCachedUnsafe(p9, d7);
    }
    multiplyAndAddUnsafe(d7, m6, p9) {
      const b6 = this.multiplyUnsafe(m6).add(d7.multiplyUnsafe(p9));
      return b6.is0() ? void 0 : b6;
    }
    toAffine(d7) {
      return M8(this, d7);
    }
    isTorsionFree() {
      const { isTorsionFree: d7 } = e11;
      return o6 === pe ? true : d7 ? d7(_6, this) : j9.wNAFCachedUnsafe(this, s5).is0();
    }
    clearCofactor() {
      const { clearCofactor: d7 } = e11;
      return o6 === pe ? this : d7 ? d7(_6, this) : this.multiplyUnsafe(o6);
    }
    toBytes(d7 = true) {
      return Re("isCompressed", d7), this.assertValidity(), c9(_6, this, d7);
    }
    toRawBytes(d7 = true) {
      return this.toBytes(d7);
    }
    toHex(d7 = true) {
      return ce(this.toBytes(d7));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  _6.BASE = new _6(t6.Gx, t6.Gy, n5.ONE), _6.ZERO = new _6(n5.ZERO, n5.ONE, n5.ZERO), _6.Fp = n5, _6.Fn = r8;
  const k11 = r8.BITS, j9 = pc(_6, e11.endo ? Math.ceil(k11 / 2) : k11);
  return _6;
}
function Ro(t6) {
  return Uint8Array.of(t6 ? 2 : 3);
}
function Tc(t6, e11, n5 = {}) {
  ke(e11, { hash: "function" }, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const r8 = e11.randomBytes || Zt, o6 = e11.hmac || ((p9, ...b6) => _e(e11.hash, p9, Ht(...b6))), { Fp: s5, Fn: i9 } = t6, { ORDER: f16, BITS: a6 } = i9;
  function l9(p9) {
    const b6 = f16 >> pe;
    return p9 > b6;
  }
  function c9(p9) {
    return l9(p9) ? i9.neg(p9) : p9;
  }
  function u10(p9, b6) {
    if (!i9.isValidNot0(b6)) throw new Error(`invalid signature ${p9}: out of range 1..CURVE.n`);
  }
  class h9 {
    constructor(b6, v9, B9) {
      u10("r", b6), u10("s", v9), this.r = b6, this.s = v9, B9 != null && (this.recovery = B9), Object.freeze(this);
    }
    static fromCompact(b6) {
      const v9 = i9.BYTES, B9 = rt("compactSignature", b6, v9 * 2);
      return new h9(i9.fromBytes(B9.subarray(0, v9)), i9.fromBytes(B9.subarray(v9, v9 * 2)));
    }
    static fromDER(b6) {
      const { r: v9, s: B9 } = vt.toSig(rt("DER", b6));
      return new h9(v9, B9);
    }
    assertValidity() {
    }
    addRecoveryBit(b6) {
      return new h9(this.r, this.s, b6);
    }
    recoverPublicKey(b6) {
      const v9 = s5.ORDER, { r: B9, s: E8, recovery: I8 } = this;
      if (I8 == null || ![0, 1, 2, 3].includes(I8)) throw new Error("recovery id invalid");
      if (f16 * Nc < v9 && I8 > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const O8 = I8 === 2 || I8 === 3 ? B9 + f16 : B9;
      if (!s5.isValid(O8)) throw new Error("recovery id 2 or 3 invalid");
      const A9 = s5.toBytes(O8), T8 = t6.fromHex(Ht(Ro((I8 & 1) === 0), A9)), U6 = i9.inv(O8), C10 = L7(rt("msgHash", b6)), H4 = i9.create(-C10 * U6), q6 = i9.create(E8 * U6), P7 = t6.BASE.multiplyUnsafe(H4).add(T8.multiplyUnsafe(q6));
      if (P7.is0()) throw new Error("point at infinify");
      return P7.assertValidity(), P7;
    }
    hasHighS() {
      return l9(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new h9(this.r, i9.neg(this.s), this.recovery) : this;
    }
    toBytes(b6) {
      if (b6 === "compact") return Ht(i9.toBytes(this.r), i9.toBytes(this.s));
      if (b6 === "der") return fn(vt.hexFromSig(this));
      throw new Error("invalid format");
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return ce(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return ce(this.toBytes("compact"));
    }
  }
  const g4 = To(i9, n5.allowedPrivateKeyLengths, n5.wrapPrivateKey), w8 = { isValidPrivateKey(p9) {
    try {
      return g4(p9), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: g4, randomPrivateKey: () => {
    const p9 = f16;
    return uc(r8(Eo(p9)), p9);
  }, precompute(p9 = 8, b6 = t6.BASE) {
    return b6.precompute(p9, false);
  } };
  function y11(p9, b6 = true) {
    return t6.fromPrivateKey(p9).toBytes(b6);
  }
  function x7(p9) {
    if (typeof p9 == "bigint") return false;
    if (p9 instanceof t6) return true;
    const v9 = rt("key", p9).length, B9 = s5.BYTES, E8 = B9 + 1, I8 = 2 * B9 + 1;
    if (!(n5.allowedPrivateKeyLengths || i9.BYTES === E8)) return v9 === E8 || v9 === I8;
  }
  function R6(p9, b6, v9 = true) {
    if (x7(p9) === true) throw new Error("first arg must be private key");
    if (x7(b6) === false) throw new Error("second arg must be public key");
    return t6.fromHex(b6).multiply(g4(p9)).toBytes(v9);
  }
  const M8 = e11.bits2int || function(p9) {
    if (p9.length > 8192) throw new Error("input is too large");
    const b6 = Ce(p9), v9 = p9.length * 8 - a6;
    return v9 > 0 ? b6 >> BigInt(v9) : b6;
  }, L7 = e11.bits2int_modN || function(p9) {
    return i9.create(M8(p9));
  }, V8 = je(a6);
  function _6(p9) {
    return Nn("num < 2^" + a6, p9, he, V8), i9.toBytes(p9);
  }
  function k11(p9, b6, v9 = j9) {
    if (["recovered", "canonical"].some((q6) => q6 in v9)) throw new Error("sign() legacy options not supported");
    const { hash: B9 } = e11;
    let { lowS: E8, prehash: I8, extraEntropy: S8 } = v9;
    E8 == null && (E8 = true), p9 = rt("msgHash", p9), _o(v9), I8 && (p9 = rt("prehashed msgHash", B9(p9)));
    const O8 = L7(p9), A9 = g4(b6), T8 = [_6(A9), _6(O8)];
    if (S8 != null && S8 !== false) {
      const q6 = S8 === true ? r8(s5.BYTES) : S8;
      T8.push(rt("extraEntropy", q6));
    }
    const U6 = Ht(...T8), C10 = O8;
    function H4(q6) {
      const P7 = M8(q6);
      if (!i9.isValidNot0(P7)) return;
      const K5 = i9.inv(P7), et3 = t6.BASE.multiply(P7).toAffine(), Z5 = i9.create(et3.x);
      if (Z5 === he) return;
      const z9 = i9.create(K5 * i9.create(C10 + Z5 * A9));
      if (z9 === he) return;
      let Ft3 = (et3.x === Z5 ? 0 : 2) | Number(et3.y & pe), yt4 = z9;
      return E8 && l9(z9) && (yt4 = c9(z9), Ft3 ^= 1), new h9(Z5, yt4, Ft3);
    }
    return { seed: U6, k2sig: H4 };
  }
  const j9 = { lowS: e11.lowS, prehash: false }, $8 = { lowS: e11.lowS, prehash: false };
  function d7(p9, b6, v9 = j9) {
    const { seed: B9, k2sig: E8 } = k11(p9, b6, v9);
    return ec(e11.hash.outputLen, i9.BYTES, o6)(B9, E8);
  }
  t6.BASE.precompute(8);
  function m6(p9, b6, v9, B9 = $8) {
    const E8 = p9;
    b6 = rt("msgHash", b6), v9 = rt("publicKey", v9), _o(B9);
    const { lowS: I8, prehash: S8, format: O8 } = B9;
    if ("strict" in B9) throw new Error("options.strict was renamed to lowS");
    if (O8 !== void 0 && !["compact", "der", "js"].includes(O8)) throw new Error('format must be "compact", "der" or "js"');
    const A9 = typeof E8 == "string" || nn(E8), T8 = !A9 && !O8 && typeof E8 == "object" && E8 !== null && typeof E8.r == "bigint" && typeof E8.s == "bigint";
    if (!A9 && !T8) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let U6, C10;
    try {
      if (T8) if (O8 === void 0 || O8 === "js") U6 = new h9(E8.r, E8.s);
      else throw new Error("invalid format");
      if (A9) {
        try {
          O8 !== "compact" && (U6 = h9.fromDER(E8));
        } catch (yt4) {
          if (!(yt4 instanceof vt.Err)) throw yt4;
        }
        !U6 && O8 !== "der" && (U6 = h9.fromCompact(E8));
      }
      C10 = t6.fromHex(v9);
    } catch {
      return false;
    }
    if (!U6 || I8 && U6.hasHighS()) return false;
    S8 && (b6 = e11.hash(b6));
    const { r: H4, s: q6 } = U6, P7 = L7(b6), K5 = i9.inv(q6), et3 = i9.create(P7 * K5), Z5 = i9.create(H4 * K5), z9 = t6.BASE.multiplyUnsafe(et3).add(C10.multiplyUnsafe(Z5));
    return z9.is0() ? false : i9.create(z9.x) === H4;
  }
  return Object.freeze({ getPublicKey: y11, getSharedSecret: R6, sign: d7, verify: m6, utils: w8, Point: t6, Signature: h9 });
}
function Rc(t6) {
  const e11 = { a: t6.a, b: t6.b, p: t6.Fp.ORDER, n: t6.n, h: t6.h, Gx: t6.Gx, Gy: t6.Gy }, n5 = t6.Fp, r8 = Yt(e11.n, t6.nBitLength), o6 = { Fp: n5, Fn: r8, allowedPrivateKeyLengths: t6.allowedPrivateKeyLengths, allowInfinityPoint: t6.allowInfinityPoint, endo: t6.endo, wrapPrivateKey: t6.wrapPrivateKey, isTorsionFree: t6.isTorsionFree, clearCofactor: t6.clearCofactor, fromBytes: t6.fromBytes, toBytes: t6.toBytes };
  return { CURVE: e11, curveOpts: o6 };
}
function $c(t6) {
  const { CURVE: e11, curveOpts: n5 } = Rc(t6), r8 = { hash: t6.hash, hmac: t6.hmac, randomBytes: t6.randomBytes, lowS: t6.lowS, bits2int: t6.bits2int, bits2int_modN: t6.bits2int_modN };
  return { CURVE: e11, curveOpts: n5, ecdsaOpts: r8 };
}
function Cc(t6, e11) {
  return Object.assign({}, e11, { ProjectivePoint: e11.Point, CURVE: t6 });
}
function Lc(t6) {
  const { CURVE: e11, curveOpts: n5, ecdsaOpts: r8 } = $c(t6), o6 = _c(e11, n5), s5 = Tc(o6, r8, n5);
  return Cc(t6, s5);
}
function Rn(t6, e11) {
  const n5 = (r8) => Lc({ ...t6, hash: r8 });
  return { ...n5(e11), create: n5 };
}
var $o = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Co = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Lo = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var jc = Yt($o.p);
var kc = Yt(Co.p);
var Pc = Yt(Lo.p);
var Hc = Rn({ ...$o, Fp: jc, lowS: false }, Ae);
Rn({ ...Co, Fp: kc, lowS: false }, Yi), Rn({ ...Lo, Fp: Pc, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, Wi);
var Dc = Hc;
var $n = "base10";
var tt = "base16";
var Qt = "base64pad";
var De = "base64url";
var te = "utf8";
var Cn = 0;
var ee = 1;
var ge = 2;
var Mc = 0;
var jo = 1;
var be = 12;
var Ln = 32;
function Vc() {
  const t6 = Tn.utils.randomPrivateKey(), e11 = Tn.getPublicKey(t6);
  return { privateKey: toString2(t6, tt), publicKey: toString2(e11, tt) };
}
function qc() {
  const t6 = Zt(Ln);
  return toString2(t6, tt);
}
function Kc(t6, e11) {
  const n5 = Tn.getSharedSecret(fromString5(t6, tt), fromString5(e11, tt)), r8 = Jf(Te, n5, void 0, void 0, Ln);
  return toString2(r8, tt);
}
function Fc(t6) {
  const e11 = Te(fromString5(t6, tt));
  return toString2(e11, tt);
}
function zc(t6) {
  const e11 = Te(fromString5(t6, te));
  return toString2(e11, tt);
}
function jn(t6) {
  return fromString5(`${t6}`, $n);
}
function Vt(t6) {
  return Number(toString2(t6, $n));
}
function ko(t6) {
  return t6.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Po2(t6) {
  const e11 = t6.replace(/-/g, "+").replace(/_/g, "/"), n5 = (4 - e11.length % 4) % 4;
  return e11 + "=".repeat(n5);
}
function Gc(t6) {
  const e11 = jn(typeof t6.type < "u" ? t6.type : Cn);
  if (Vt(e11) === ee && typeof t6.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n5 = typeof t6.senderPublicKey < "u" ? fromString5(t6.senderPublicKey, tt) : void 0, r8 = typeof t6.iv < "u" ? fromString5(t6.iv, tt) : Zt(be), o6 = fromString5(t6.symKey, tt), s5 = co(o6, r8).encrypt(fromString5(t6.message, te)), i9 = kn({ type: e11, sealed: s5, iv: r8, senderPublicKey: n5 });
  return t6.encoding === De ? ko(i9) : i9;
}
function Zc(t6) {
  const e11 = fromString5(t6.symKey, tt), { sealed: n5, iv: r8 } = Me({ encoded: t6.encoded, encoding: t6.encoding }), o6 = co(e11, r8).decrypt(n5);
  if (o6 === null) throw new Error("Failed to decrypt");
  return toString2(o6, te);
}
function Wc(t6, e11) {
  const n5 = jn(ge), r8 = Zt(be), o6 = fromString5(t6, te), s5 = kn({ type: n5, sealed: o6, iv: r8 });
  return e11 === De ? ko(s5) : s5;
}
function Yc(t6, e11) {
  const { sealed: n5 } = Me({ encoded: t6, encoding: e11 });
  return toString2(n5, te);
}
function kn(t6) {
  if (Vt(t6.type) === ge) return toString2(concat5([t6.type, t6.sealed]), Qt);
  if (Vt(t6.type) === ee) {
    if (typeof t6.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString2(concat5([t6.type, t6.senderPublicKey, t6.iv, t6.sealed]), Qt);
  }
  return toString2(concat5([t6.type, t6.iv, t6.sealed]), Qt);
}
function Me(t6) {
  const e11 = (t6.encoding || Qt) === De ? Po2(t6.encoded) : t6.encoded, n5 = fromString5(e11, Qt), r8 = n5.slice(Mc, jo), o6 = jo;
  if (Vt(r8) === ee) {
    const a6 = o6 + Ln, l9 = a6 + be, c9 = n5.slice(o6, a6), u10 = n5.slice(a6, l9), h9 = n5.slice(l9);
    return { type: r8, sealed: h9, iv: u10, senderPublicKey: c9 };
  }
  if (Vt(r8) === ge) {
    const a6 = n5.slice(o6), l9 = Zt(be);
    return { type: r8, sealed: a6, iv: l9 };
  }
  const s5 = o6 + be, i9 = n5.slice(o6, s5), f16 = n5.slice(s5);
  return { type: r8, sealed: f16, iv: i9 };
}
function Xc(t6, e11) {
  const n5 = Me({ encoded: t6, encoding: e11 == null ? void 0 : e11.encoding });
  return Ho({ type: Vt(n5.type), senderPublicKey: typeof n5.senderPublicKey < "u" ? toString2(n5.senderPublicKey, tt) : void 0, receiverPublicKey: e11 == null ? void 0 : e11.receiverPublicKey });
}
function Ho(t6) {
  const e11 = (t6 == null ? void 0 : t6.type) || Cn;
  if (e11 === ee) {
    if (typeof (t6 == null ? void 0 : t6.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t6 == null ? void 0 : t6.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e11, senderPublicKey: t6 == null ? void 0 : t6.senderPublicKey, receiverPublicKey: t6 == null ? void 0 : t6.receiverPublicKey };
}
function Jc(t6) {
  return t6.type === ee && typeof t6.senderPublicKey == "string" && typeof t6.receiverPublicKey == "string";
}
function Qc(t6) {
  return t6.type === ge;
}
function Do(t6) {
  const e11 = Buffer.from(t6.x, "base64"), n5 = Buffer.from(t6.y, "base64");
  return concat5([new Uint8Array([4]), e11, n5]);
}
function ta(t6, e11) {
  const [n5, r8, o6] = t6.split("."), s5 = Buffer.from(Po2(o6), "base64");
  if (s5.length !== 64) throw new Error("Invalid signature length");
  const i9 = s5.slice(0, 32), f16 = s5.slice(32, 64), a6 = `${n5}.${r8}`, l9 = Te(a6), c9 = Do(e11);
  if (!Dc.verify(concat5([i9, f16]), l9, c9)) throw new Error("Invalid signature");
  return sn(t6).payload;
}
var Mo = "irn";
function ea(t6) {
  return (t6 == null ? void 0 : t6.relay) || { protocol: Mo };
}
function na(t6) {
  const e11 = C[t6];
  if (typeof e11 > "u") throw new Error(`Relay Protocol not supported: ${t6}`);
  return e11;
}
function Vo(t6, e11 = "-") {
  const n5 = {}, r8 = "relay" + e11;
  return Object.keys(t6).forEach((o6) => {
    if (o6.startsWith(r8)) {
      const s5 = o6.replace(r8, ""), i9 = t6[o6];
      n5[s5] = i9;
    }
  }), n5;
}
function ra(t6) {
  if (!t6.includes("wc:")) {
    const l9 = Qe2(t6);
    l9 != null && l9.includes("wc:") && (t6 = l9);
  }
  t6 = t6.includes("wc://") ? t6.replace("wc://", "") : t6, t6 = t6.includes("wc:") ? t6.replace("wc:", "") : t6;
  const e11 = t6.indexOf(":"), n5 = t6.indexOf("?") !== -1 ? t6.indexOf("?") : void 0, r8 = t6.substring(0, e11), o6 = t6.substring(e11 + 1, n5).split("@"), s5 = typeof n5 < "u" ? t6.substring(n5) : "", i9 = new URLSearchParams(s5), f16 = {};
  i9.forEach((l9, c9) => {
    f16[c9] = l9;
  });
  const a6 = typeof f16.methods == "string" ? f16.methods.split(",") : void 0;
  return { protocol: r8, topic: qo(o6[0]), version: parseInt(o6[1], 10), symKey: f16.symKey, relay: Vo(f16), methods: a6, expiryTimestamp: f16.expiryTimestamp ? parseInt(f16.expiryTimestamp, 10) : void 0 };
}
function qo(t6) {
  return t6.startsWith("//") ? t6.substring(2) : t6;
}
function Ko(t6, e11 = "-") {
  const n5 = "relay", r8 = {};
  return Object.keys(t6).forEach((o6) => {
    const s5 = o6, i9 = n5 + e11 + s5;
    t6[s5] && (r8[i9] = t6[s5]);
  }), r8;
}
function oa(t6) {
  const e11 = new URLSearchParams(), n5 = Ko(t6.relay);
  Object.keys(n5).sort().forEach((o6) => {
    e11.set(o6, n5[o6]);
  }), e11.set("symKey", t6.symKey), t6.expiryTimestamp && e11.set("expiryTimestamp", t6.expiryTimestamp.toString()), t6.methods && e11.set("methods", t6.methods.join(","));
  const r8 = e11.toString();
  return `${t6.protocol}:${t6.topic}@${t6.version}?${r8}`;
}
function sa(t6, e11, n5) {
  return `${t6}?wc_ev=${n5}&topic=${e11}`;
}
var ia = Object.defineProperty;
var fa = Object.defineProperties;
var ca = Object.getOwnPropertyDescriptors;
var Fo = Object.getOwnPropertySymbols;
var aa = Object.prototype.hasOwnProperty;
var ua = Object.prototype.propertyIsEnumerable;
var zo = (t6, e11, n5) => e11 in t6 ? ia(t6, e11, { enumerable: true, configurable: true, writable: true, value: n5 }) : t6[e11] = n5;
var la = (t6, e11) => {
  for (var n5 in e11 || (e11 = {})) aa.call(e11, n5) && zo(t6, n5, e11[n5]);
  if (Fo) for (var n5 of Fo(e11)) ua.call(e11, n5) && zo(t6, n5, e11[n5]);
  return t6;
};
var da = (t6, e11) => fa(t6, ca(e11));
function qt(t6) {
  const e11 = [];
  return t6.forEach((n5) => {
    const [r8, o6] = n5.split(":");
    e11.push(`${r8}:${o6}`);
  }), e11;
}
function Go(t6) {
  const e11 = [];
  return Object.values(t6).forEach((n5) => {
    e11.push(...qt(n5.accounts));
  }), e11;
}
function Zo(t6, e11) {
  const n5 = [];
  return Object.values(t6).forEach((r8) => {
    qt(r8.accounts).includes(e11) && n5.push(...r8.methods);
  }), n5;
}
function Wo(t6, e11) {
  const n5 = [];
  return Object.values(t6).forEach((r8) => {
    qt(r8.accounts).includes(e11) && n5.push(...r8.events);
  }), n5;
}
function Pn(t6) {
  return t6.includes(":");
}
function Yo(t6) {
  return Pn(t6) ? t6.split(":")[0] : t6;
}
function ye(t6) {
  var e11, n5, r8;
  const o6 = {};
  if (!Ve(t6)) return o6;
  for (const [s5, i9] of Object.entries(t6)) {
    const f16 = Pn(s5) ? [s5] : i9.chains, a6 = i9.methods || [], l9 = i9.events || [], c9 = Yo(s5);
    o6[c9] = da(la({}, o6[c9]), { chains: ct(f16, (e11 = o6[c9]) == null ? void 0 : e11.chains), methods: ct(a6, (n5 = o6[c9]) == null ? void 0 : n5.methods), events: ct(l9, (r8 = o6[c9]) == null ? void 0 : r8.events) });
  }
  return o6;
}
function Xo(t6) {
  const e11 = {};
  return t6 == null ? void 0 : t6.forEach((n5) => {
    var r8;
    const [o6, s5] = n5.split(":");
    e11[o6] || (e11[o6] = { accounts: [], chains: [], events: [], methods: [] }), e11[o6].accounts.push(n5), (r8 = e11[o6].chains) == null || r8.push(`${o6}:${s5}`);
  }), e11;
}
function ga(t6, e11) {
  e11 = e11.map((r8) => r8.replace("did:pkh:", ""));
  const n5 = Xo(e11);
  for (const [r8, o6] of Object.entries(n5)) o6.methods ? o6.methods = ct(o6.methods, t6) : o6.methods = t6, o6.events = ["chainChanged", "accountsChanged"];
  return n5;
}
function ba(t6, e11) {
  var n5, r8, o6, s5, i9, f16;
  const a6 = ye(t6), l9 = ye(e11), c9 = {}, u10 = Object.keys(a6).concat(Object.keys(l9));
  for (const h9 of u10) c9[h9] = { chains: ct((n5 = a6[h9]) == null ? void 0 : n5.chains, (r8 = l9[h9]) == null ? void 0 : r8.chains), methods: ct((o6 = a6[h9]) == null ? void 0 : o6.methods, (s5 = l9[h9]) == null ? void 0 : s5.methods), events: ct((i9 = a6[h9]) == null ? void 0 : i9.events, (f16 = l9[h9]) == null ? void 0 : f16.events) };
  return c9;
}
var Jo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Qo2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function Et(t6, e11) {
  const { message: n5, code: r8 } = Qo2[t6];
  return { message: e11 ? `${n5} ${e11}` : n5, code: r8 };
}
function Kt(t6, e11) {
  const { message: n5, code: r8 } = Jo[t6];
  return { message: e11 ? `${n5} ${e11}` : n5, code: r8 };
}
function me(t6, e11) {
  return Array.isArray(t6) ? typeof e11 < "u" && t6.length ? t6.every(e11) : true : false;
}
function Ve(t6) {
  return Object.getPrototypeOf(t6) === Object.prototype && Object.keys(t6).length;
}
function kt(t6) {
  return typeof t6 > "u";
}
function it(t6, e11) {
  return e11 && kt(t6) ? true : typeof t6 == "string" && !!t6.trim().length;
}
function qe(t6, e11) {
  return e11 && kt(t6) ? true : typeof t6 == "number" && !isNaN(t6);
}
function ya(t6, e11) {
  const { requiredNamespaces: n5 } = e11, r8 = Object.keys(t6.namespaces), o6 = Object.keys(n5);
  let s5 = true;
  return It(o6, r8) ? (r8.forEach((i9) => {
    const { accounts: f16, methods: a6, events: l9 } = t6.namespaces[i9], c9 = qt(f16), u10 = n5[i9];
    (!It(ve(i9, u10), c9) || !It(u10.methods, a6) || !It(u10.events, l9)) && (s5 = false);
  }), s5) : false;
}
function we(t6) {
  return it(t6, false) && t6.includes(":") ? t6.split(":").length === 2 : false;
}
function ts(t6) {
  if (it(t6, false) && t6.includes(":")) {
    const e11 = t6.split(":");
    if (e11.length === 3) {
      const n5 = e11[0] + ":" + e11[1];
      return !!e11[2] && we(n5);
    }
  }
  return false;
}
function ma(t6) {
  function e11(n5) {
    try {
      return typeof new URL(n5) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (it(t6, false)) {
      if (e11(t6)) return true;
      const n5 = Qe2(t6);
      return e11(n5);
    }
  } catch {
  }
  return false;
}
function wa(t6) {
  var e11;
  return (e11 = t6 == null ? void 0 : t6.proposer) == null ? void 0 : e11.publicKey;
}
function xa(t6) {
  return t6 == null ? void 0 : t6.topic;
}
function va(t6, e11) {
  let n5 = null;
  return it(t6 == null ? void 0 : t6.publicKey, false) || (n5 = Et("MISSING_OR_INVALID", `${e11} controller public key should be a string`)), n5;
}
function Hn(t6) {
  let e11 = true;
  return me(t6) ? t6.length && (e11 = t6.every((n5) => it(n5, false))) : e11 = false, e11;
}
function es(t6, e11, n5) {
  let r8 = null;
  return me(e11) && e11.length ? e11.forEach((o6) => {
    r8 || we(o6) || (r8 = Kt("UNSUPPORTED_CHAINS", `${n5}, chain ${o6} should be a string and conform to "namespace:chainId" format`));
  }) : we(t6) || (r8 = Kt("UNSUPPORTED_CHAINS", `${n5}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r8;
}
function ns(t6, e11, n5) {
  let r8 = null;
  return Object.entries(t6).forEach(([o6, s5]) => {
    if (r8) return;
    const i9 = es(o6, ve(o6, s5), `${e11} ${n5}`);
    i9 && (r8 = i9);
  }), r8;
}
function rs(t6, e11) {
  let n5 = null;
  return me(t6) ? t6.forEach((r8) => {
    n5 || ts(r8) || (n5 = Kt("UNSUPPORTED_ACCOUNTS", `${e11}, account ${r8} should be a string and conform to "namespace:chainId:address" format`));
  }) : n5 = Kt("UNSUPPORTED_ACCOUNTS", `${e11}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n5;
}
function os(t6, e11) {
  let n5 = null;
  return Object.values(t6).forEach((r8) => {
    if (n5) return;
    const o6 = rs(r8 == null ? void 0 : r8.accounts, `${e11} namespace`);
    o6 && (n5 = o6);
  }), n5;
}
function ss(t6, e11) {
  let n5 = null;
  return Hn(t6 == null ? void 0 : t6.methods) ? Hn(t6 == null ? void 0 : t6.events) || (n5 = Kt("UNSUPPORTED_EVENTS", `${e11}, events should be an array of strings or empty array for no events`)) : n5 = Kt("UNSUPPORTED_METHODS", `${e11}, methods should be an array of strings or empty array for no methods`), n5;
}
function Dn(t6, e11) {
  let n5 = null;
  return Object.values(t6).forEach((r8) => {
    if (n5) return;
    const o6 = ss(r8, `${e11}, namespace`);
    o6 && (n5 = o6);
  }), n5;
}
function Ea(t6, e11, n5) {
  let r8 = null;
  if (t6 && Ve(t6)) {
    const o6 = Dn(t6, e11);
    o6 && (r8 = o6);
    const s5 = ns(t6, e11, n5);
    s5 && (r8 = s5);
  } else r8 = Et("MISSING_OR_INVALID", `${e11}, ${n5} should be an object with data`);
  return r8;
}
function is(t6, e11) {
  let n5 = null;
  if (t6 && Ve(t6)) {
    const r8 = Dn(t6, e11);
    r8 && (n5 = r8);
    const o6 = os(t6, e11);
    o6 && (n5 = o6);
  } else n5 = Et("MISSING_OR_INVALID", `${e11}, namespaces should be an object with data`);
  return n5;
}
function fs(t6) {
  return it(t6.protocol, true);
}
function Ba(t6, e11) {
  let n5 = false;
  return e11 && !t6 ? n5 = true : t6 && me(t6) && t6.length && t6.forEach((r8) => {
    n5 = fs(r8);
  }), n5;
}
function Ia(t6) {
  return typeof t6 == "number";
}
function Aa(t6) {
  return typeof t6 < "u" && typeof t6 !== null;
}
function Sa(t6) {
  return !(!t6 || typeof t6 != "object" || !t6.code || !qe(t6.code, false) || !t6.message || !it(t6.message, false));
}
function Na(t6) {
  return !(kt(t6) || !it(t6.method, false));
}
function Oa(t6) {
  return !(kt(t6) || kt(t6.result) && kt(t6.error) || !qe(t6.id, false) || !it(t6.jsonrpc, false));
}
function Ua(t6) {
  return !(kt(t6) || !it(t6.name, false));
}
function _a(t6, e11) {
  return !(!we(e11) || !Go(t6).includes(e11));
}
function Ta(t6, e11, n5) {
  return it(n5, false) ? Zo(t6, e11).includes(n5) : false;
}
function Ra(t6, e11, n5) {
  return it(n5, false) ? Wo(t6, e11).includes(n5) : false;
}
function cs(t6, e11, n5) {
  let r8 = null;
  const o6 = $a(t6), s5 = Ca(e11), i9 = Object.keys(o6), f16 = Object.keys(s5), a6 = as(Object.keys(t6)), l9 = as(Object.keys(e11)), c9 = a6.filter((u10) => !l9.includes(u10));
  return c9.length && (r8 = Et("NON_CONFORMING_NAMESPACES", `${n5} namespaces keys don't satisfy requiredNamespaces.
      Required: ${c9.toString()}
      Received: ${Object.keys(e11).toString()}`)), It(i9, f16) || (r8 = Et("NON_CONFORMING_NAMESPACES", `${n5} namespaces chains don't satisfy required namespaces.
      Required: ${i9.toString()}
      Approved: ${f16.toString()}`)), Object.keys(e11).forEach((u10) => {
    if (!u10.includes(":") || r8) return;
    const h9 = qt(e11[u10].accounts);
    h9.includes(u10) || (r8 = Et("NON_CONFORMING_NAMESPACES", `${n5} namespaces accounts don't satisfy namespace accounts for ${u10}
        Required: ${u10}
        Approved: ${h9.toString()}`));
  }), i9.forEach((u10) => {
    r8 || (It(o6[u10].methods, s5[u10].methods) ? It(o6[u10].events, s5[u10].events) || (r8 = Et("NON_CONFORMING_NAMESPACES", `${n5} namespaces events don't satisfy namespace events for ${u10}`)) : r8 = Et("NON_CONFORMING_NAMESPACES", `${n5} namespaces methods don't satisfy namespace methods for ${u10}`));
  }), r8;
}
function $a(t6) {
  const e11 = {};
  return Object.keys(t6).forEach((n5) => {
    var r8;
    n5.includes(":") ? e11[n5] = t6[n5] : (r8 = t6[n5].chains) == null || r8.forEach((o6) => {
      e11[o6] = { methods: t6[n5].methods, events: t6[n5].events };
    });
  }), e11;
}
function as(t6) {
  return [...new Set(t6.map((e11) => e11.includes(":") ? e11.split(":")[0] : e11))];
}
function Ca(t6) {
  const e11 = {};
  return Object.keys(t6).forEach((n5) => {
    if (n5.includes(":")) e11[n5] = t6[n5];
    else {
      const r8 = qt(t6[n5].accounts);
      r8 == null ? void 0 : r8.forEach((o6) => {
        e11[o6] = { accounts: t6[n5].accounts.filter((s5) => s5.includes(`${o6}:`)), methods: t6[n5].methods, events: t6[n5].events };
      });
    }
  }), e11;
}
function La(t6, e11) {
  return qe(t6, false) && t6 <= e11.max && t6 >= e11.min;
}
function ja() {
  const t6 = Pt();
  return new Promise((e11) => {
    switch (t6) {
      case J.browser:
        e11(us());
        break;
      case J.reactNative:
        e11(ls());
        break;
      case J.node:
        e11(ds());
        break;
      default:
        e11(true);
    }
  });
}
function us() {
  return zt() && (navigator == null ? void 0 : navigator.onLine);
}
async function ls() {
  if (Bt() && typeof global < "u" && global != null && global.NetInfo) {
    const t6 = await (global == null ? void 0 : global.NetInfo.fetch());
    return t6 == null ? void 0 : t6.isConnected;
  }
  return true;
}
function ds() {
  return true;
}
function ka(t6) {
  switch (Pt()) {
    case J.browser:
      hs(t6);
      break;
    case J.reactNative:
      ps(t6);
      break;
    case J.node:
      break;
  }
}
function hs(t6) {
  !Bt() && zt() && (window.addEventListener("online", () => t6(true)), window.addEventListener("offline", () => t6(false)));
}
function ps(t6) {
  Bt() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((e11) => t6(e11 == null ? void 0 : e11.isConnected)));
}
function Pa() {
  var t6;
  return zt() && (0, import_window_getters.getDocument)() ? ((t6 = (0, import_window_getters.getDocument)()) == null ? void 0 : t6.visibilityState) === "visible" : true;
}
var Mn = {};
var Ha = class {
  static get(e11) {
    return Mn[e11];
  }
  static set(e11, n5) {
    Mn[e11] = n5;
  }
  static delete(e11) {
    delete Mn[e11];
  }
};
function gs(t6) {
  const e11 = esm_default2.decode(t6);
  if (e11.length < 33) throw new Error("Too short to contain a public key");
  return e11.slice(1, 33);
}
function bs({ publicKey: t6, signature: e11, payload: n5 }) {
  var r8;
  const o6 = Vn(n5.method), s5 = 128 | parseInt(((r8 = n5.version) == null ? void 0 : r8.toString()) || "4"), i9 = Ma(n5.address), f16 = n5.era === "00" ? new Uint8Array([0]) : Vn(n5.era);
  if (f16.length !== 1 && f16.length !== 2) throw new Error("Invalid era length");
  const a6 = parseInt(n5.nonce, 16), l9 = new Uint8Array([a6 & 255, a6 >> 8 & 255]), c9 = BigInt(`0x${Da(n5.tip)}`), u10 = qa(c9), h9 = new Uint8Array([0, ...t6, i9, ...e11, ...f16, ...l9, ...u10, ...o6]), g4 = Va(h9.length + 1);
  return new Uint8Array([...g4, s5, ...h9]);
}
function ys(t6) {
  const e11 = Vn(t6), n5 = (0, import_blakejs.blake2b)(e11, void 0, 32);
  return "0x" + Buffer.from(n5).toString("hex");
}
function Vn(t6) {
  return new Uint8Array(t6.replace(/^0x/, "").match(/.{1,2}/g).map((e11) => parseInt(e11, 16)));
}
function Da(t6) {
  return t6.startsWith("0x") ? t6.slice(2) : t6;
}
function Ma(t6) {
  const e11 = esm_default2.decode(t6)[0];
  return e11 === 42 ? 0 : e11 === 60 ? 2 : 1;
}
function Va(t6) {
  if (t6 < 64) return new Uint8Array([t6 << 2]);
  if (t6 < 16384) {
    const e11 = t6 << 2 | 1;
    return new Uint8Array([e11 & 255, e11 >> 8 & 255]);
  } else if (t6 < 1 << 30) {
    const e11 = t6 << 2 | 2;
    return new Uint8Array([e11 & 255, e11 >> 8 & 255, e11 >> 16 & 255, e11 >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function qa(t6) {
  if (t6 < BigInt(1) << BigInt(6)) return new Uint8Array([Number(t6 << BigInt(2))]);
  if (t6 < BigInt(1) << BigInt(14)) {
    const e11 = t6 << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e11 & BigInt(255)), Number(e11 >> BigInt(8) & BigInt(255))]);
  } else if (t6 < BigInt(1) << BigInt(30)) {
    const e11 = t6 << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e11 & BigInt(255)), Number(e11 >> BigInt(8) & BigInt(255)), Number(e11 >> BigInt(16) & BigInt(255)), Number(e11 >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function Ka(t6) {
  const e11 = Uint8Array.from(Buffer.from(t6.signature, "hex")), n5 = gs(t6.transaction.address), r8 = bs({ publicKey: n5, signature: e11, payload: t6.transaction }), o6 = Buffer.from(r8).toString("hex");
  return ys(o6);
}

// node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/core/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs
function wrapToPromise(value2) {
  if (!value2 || typeof value2.then !== "function") {
    return Promise.resolve(value2);
  }
  return value2;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value2) {
  const type7 = typeof value2;
  return value2 === null || type7 !== "object" && type7 !== "function";
}
function isPureObject(value2) {
  const proto = Object.getPrototypeOf(value2);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify5(value2) {
  if (isPrimitive(value2)) {
    return String(value2);
  }
  if (isPureObject(value2) || Array.isArray(value2)) {
    return JSON.stringify(value2);
  }
  if (typeof value2.toJSON === "function") {
    return stringify5(value2.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value2) {
  if (typeof value2 === "string") {
    return value2;
  }
  return BASE64_PREFIX + base64Encode(value2);
}
function deserializeRaw(value2) {
  if (typeof value2 !== "string") {
    return value2;
  }
  if (!value2.startsWith(BASE64_PREFIX)) {
    return value2;
  }
  return base64Decode(value2.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c9) => c9.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a14;
  if (!key) {
    return "";
  }
  return ((_a14 = key.split("?")[0]) == null ? void 0 : _a14.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys5) {
  return normalizeKey(keys5.join(":"));
}
function normalizeBaseKey(base4) {
  base4 = normalizeKey(base4);
  return base4 ? base4 + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index2 = key.indexOf(":");
  while (index2 > -1) {
    substrCount++;
    index2 = key.indexOf(":", index2 + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base4) {
  if (base4) {
    return key.startsWith(base4) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/core/node_modules/unstorage/dist/index.mjs
function defineDriver(factory2) {
  return factory2;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value2) {
      data.set(key, value2);
    },
    setItemRaw(key, value2) {
      data.set(key, value2);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base4 of context.mountpoints) {
      if (key.startsWith(base4)) {
        return {
          base: base4,
          relativeKey: key.slice(base4.length),
          driver: context.mounts[base4]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base4, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base4) || includeParent && base4.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base4.length > mountpoint.length ? base4.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value2 = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value: value2,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r8) => r8.flat()
    );
  };
  const storage3 = {
    // Item
    hasItem(key, opts2 = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts2);
    },
    getItem(key, opts2 = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts2).then(
        (value2) => destr(value2)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r8) => r8.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value2) => ({
              key: item.key,
              value: destr(value2)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts2 = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts2);
      }
      return asyncCall(driver.getItem, relativeKey, opts2).then(
        (value2) => deserializeRaw(value2)
      );
    },
    async setItem(key, value2, opts2 = {}) {
      if (value2 === void 0) {
        return storage3.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify5(value2), opts2);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify5(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify5(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value2, opts2 = {}) {
      if (value2 === void 0) {
        return storage3.removeItem(key, opts2);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value2, opts2);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value2), opts2);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts2 = {}) {
      if (typeof opts2 === "boolean") {
        opts2 = { removeMeta: opts2 };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts2);
      if (opts2.removeMeta || opts2.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts2);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts2 = {}) {
      if (typeof opts2 === "boolean") {
        opts2 = { nativeOnly: opts2 };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts2));
      }
      if (!opts2.nativeOnly) {
        const value2 = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts2
        ).then((value_) => destr(value_));
        if (value2 && typeof value2 === "object") {
          if (typeof value2.atime === "string") {
            value2.atime = new Date(value2.atime);
          }
          if (typeof value2.mtime === "string") {
            value2.mtime = new Date(value2.mtime);
          }
          Object.assign(meta, value2);
        }
      }
      return meta;
    },
    setMeta(key, value2, opts2 = {}) {
      return this.setItem(key + "$", value2, opts2);
    },
    removeMeta(key, opts2 = {}) {
      return this.removeItem(key + "$", opts2);
    },
    // Keys
    async getKeys(base4, opts2 = {}) {
      var _a14;
      base4 = normalizeBaseKey(base4);
      const mounts = getMounts(base4, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a14 = mount.driver.flags) == null ? void 0 : _a14.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts2
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p9) => fullKey.startsWith(p9))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p9) => !p9.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts2.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts2.maxDepth)) && filterKeyByBase(key, base4)
      );
    },
    // Utils
    async clear(base4, opts2 = {}) {
      base4 = normalizeBaseKey(base4);
      await Promise.all(
        getMounts(base4, false).map(async (m6) => {
          if (m6.driver.clear) {
            return asyncCall(m6.driver.clear, m6.relativeBase, opts2);
          }
          if (m6.driver.removeItem) {
            const keys5 = await m6.driver.getKeys(m6.relativeBase || "", opts2);
            return Promise.all(
              keys5.map((key) => m6.driver.removeItem(key, opts2))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base4, driver) {
      base4 = normalizeBaseKey(base4);
      if (base4 && context.mounts[base4]) {
        throw new Error(`already mounted at ${base4}`);
      }
      if (base4) {
        context.mountpoints.push(base4);
        context.mountpoints.sort((a6, b6) => b6.length - a6.length);
      }
      context.mounts[base4] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base4)).then((unwatcher) => {
          context.unwatch[base4] = unwatcher;
        }).catch(console.error);
      }
      return storage3;
    },
    async unmount(base4, _dispose = true) {
      var _a14, _b;
      base4 = normalizeBaseKey(base4);
      if (!base4 || !context.mounts[base4]) {
        return;
      }
      if (context.watching && base4 in context.unwatch) {
        (_b = (_a14 = context.unwatch)[base4]) == null ? void 0 : _b.call(_a14);
        delete context.unwatch[base4];
      }
      if (_dispose) {
        await dispose(context.mounts[base4]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base4);
      delete context.mounts[base4];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m6 = getMount(key);
      return {
        driver: m6.driver,
        base: m6.base
      };
    },
    getMounts(base4 = "", opts2 = {}) {
      base4 = normalizeKey(base4);
      const mounts = getMounts(base4, opts2.parents);
      return mounts.map((m6) => ({
        driver: m6.driver,
        base: m6.mountpoint
      }));
    },
    // Aliases
    keys: (base4, opts2 = {}) => storage3.getKeys(base4, opts2),
    get: (key, opts2 = {}) => storage3.getItem(key, opts2),
    set: (key, value2, opts2 = {}) => storage3.setItem(key, value2, opts2),
    has: (key, opts2 = {}) => storage3.hasItem(key, opts2),
    del: (key, opts2 = {}) => storage3.removeItem(key, opts2),
    remove: (key, opts2 = {}) => storage3.removeItem(key, opts2)
  };
  return storage3;
}
function watch(driver, onChange, base4) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base4 + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i9 = {}) => {
  const t6 = i9.base && i9.base.length > 0 ? `${i9.base}:` : "", e11 = (s5) => t6 + s5;
  let n5;
  return i9.dbName && i9.storeName && (n5 = createStore(i9.dbName, i9.storeName)), { name: x, options: i9, async hasItem(s5) {
    return !(typeof await get(e11(s5), n5) > "u");
  }, async getItem(s5) {
    return await get(e11(s5), n5) ?? null;
  }, setItem(s5, a6) {
    return set(e11(s5), a6, n5);
  }, removeItem(s5) {
    return del(e11(s5), n5);
  }, getKeys() {
    return keys(n5);
  }, clear() {
    return clear(n5);
  } };
};
var D2 = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D2, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t6) => [t6.key, t6.value]);
  }
  async getItem(t6) {
    const e11 = await this.indexedDb.getItem(t6);
    if (e11 !== null) return e11;
  }
  async setItem(t6, e11) {
    await this.indexedDb.setItem(t6, safeJsonStringify(e11));
  }
  async removeItem(t6) {
    await this.indexedDb.removeItem(t6);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i9;
  function t6() {
  }
  i9 = t6, i9.prototype.getItem = function(e11) {
    return this.hasOwnProperty(e11) ? String(this[e11]) : null;
  }, i9.prototype.setItem = function(e11, n5) {
    this[e11] = String(n5);
  }, i9.prototype.removeItem = function(e11) {
    delete this[e11];
  }, i9.prototype.clear = function() {
    const e11 = this;
    Object.keys(e11).forEach(function(n5) {
      e11[n5] = void 0, delete e11[n5];
    });
  }, i9.prototype.key = function(e11) {
    return e11 = e11 || 0, Object.keys(this)[e11];
  }, i9.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t6();
})();
function k2(i9) {
  var t6;
  return [i9[0], safeJsonParse((t6 = i9[1]) != null ? t6 : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t6) {
    const e11 = this.localStorage.getItem(t6);
    if (e11 !== null) return safeJsonParse(e11);
  }
  async setItem(t6, e11) {
    this.localStorage.setItem(t6, safeJsonStringify(e11));
  }
  async removeItem(t6) {
    this.localStorage.removeItem(t6);
  }
};
var N2 = "wc_storage_version";
var y2 = 1;
var O = async (i9, t6, e11) => {
  const n5 = N2, s5 = await t6.getItem(n5);
  if (s5 && s5 >= y2) {
    e11(t6);
    return;
  }
  const a6 = await i9.getKeys();
  if (!a6.length) {
    e11(t6);
    return;
  }
  const m6 = [];
  for (; a6.length; ) {
    const r8 = a6.shift();
    if (!r8) continue;
    const o6 = r8.toLowerCase();
    if (o6.includes("wc@") || o6.includes("walletconnect") || o6.includes("wc_") || o6.includes("wallet_connect")) {
      const f16 = await i9.getItem(r8);
      await t6.setItem(r8, f16), m6.push(r8);
    }
  }
  await t6.setItem(n5, y2), e11(t6), j(i9, m6);
};
var j = async (i9, t6) => {
  t6.length && t6.forEach(async (e11) => {
    await i9.removeItem(e11);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e11) => {
      this.storage = e11, this.initialized = true;
    };
    const t6 = new K();
    this.storage = t6;
    try {
      const e11 = new _();
      O(t6, e11, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t6) {
    return await this.initialize(), this.storage.getItem(t6);
  }
  async setItem(t6, e11) {
    return await this.initialize(), this.storage.setItem(t6, e11);
  }
  async removeItem(t6) {
    return await this.initialize(), this.storage.removeItem(t6);
  }
  async initialize() {
    this.initialized || await new Promise((t6) => {
      const e11 = setInterval(() => {
        this.initialized && (clearInterval(e11), t6());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e11, s5, r8) => s5 in e11 ? a(e11, s5, { enumerable: true, configurable: true, writable: true, value: r8 }) : e11[s5] = r8;
var c2 = (e11, s5, r8) => u(e11, typeof s5 != "symbol" ? s5 + "" : s5, r8);
var h2 = class extends IEvents {
  constructor(s5) {
    super(), this.opts = s5, c2(this, "protocol", "wc"), c2(this, "version", 2);
  }
};
var p = Object.defineProperty;
var b = (e11, s5, r8) => s5 in e11 ? p(e11, s5, { enumerable: true, configurable: true, writable: true, value: r8 }) : e11[s5] = r8;
var v = (e11, s5, r8) => b(e11, typeof s5 != "symbol" ? s5 + "" : s5, r8);
var I = class extends IEvents {
  constructor(s5, r8) {
    super(), this.core = s5, this.logger = r8, v(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s5, r8) {
    this.logger = s5, this.core = r8;
  }
};
var m = class extends IEvents {
  constructor(s5, r8) {
    super(), this.relayer = s5, this.logger = r8;
  }
};
var d = class extends IEvents {
  constructor(s5) {
    super();
  }
};
var f3 = class {
  constructor(s5, r8, t6, q6) {
    this.core = s5, this.logger = r8, this.name = t6;
  }
};
var P = class extends IEvents {
  constructor(s5, r8) {
    super(), this.relayer = s5, this.logger = r8;
  }
};
var S = class extends IEvents {
  constructor(s5, r8) {
    super(), this.core = s5, this.logger = r8;
  }
};
var M = class {
  constructor(s5, r8, t6) {
    this.core = s5, this.logger = r8, this.store = t6;
  }
};
var O2 = class {
  constructor(s5, r8) {
    this.projectId = s5, this.logger = r8;
  }
};
var R = class {
  constructor(s5, r8, t6) {
    this.core = s5, this.logger = r8, this.telemetryEnabled = t6;
  }
};
var T = Object.defineProperty;
var k3 = (e11, s5, r8) => s5 in e11 ? T(e11, s5, { enumerable: true, configurable: true, writable: true, value: r8 }) : e11[s5] = r8;
var i2 = (e11, s5, r8) => k3(e11, typeof s5 != "symbol" ? s5 + "" : s5, r8);
var J2 = class {
  constructor(s5) {
    this.opts = s5, i2(this, "protocol", "wc"), i2(this, "version", 2);
  }
};
var V = class {
  constructor(s5) {
    this.client = s5;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs2());
var ze = "wc";
var Le2 = 2;
var he2 = "core";
var B = `${ze}@2:${he2}:`;
var Et2 = { name: he2, logger: "error" };
var It2 = { database: ":memory:" };
var Tt2 = "crypto";
var ke2 = "client_ed25519_seed";
var Ct2 = import_time2.ONE_DAY;
var Pt2 = "keychain";
var St2 = "0.3";
var Ot2 = "messages";
var Rt2 = "0.3";
var je2 = import_time2.SIX_HOURS;
var At2 = "publisher";
var xt2 = "irn";
var Nt2 = "error";
var Ue2 = "wss://relay.walletconnect.org";
var $t2 = "relayer";
var C2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt2 = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt2 = 0.1;
var _e2 = "2.21.5";
var Q2 = { link_mode: "link_mode", relay: "relay" };
var le2 = { inbound: "inbound", outbound: "outbound" };
var kt2 = "0.3";
var jt2 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut2 = "subscription";
var Ft = "0.3";
var Js = import_time2.FIVE_SECONDS * 1e3;
var Mt2 = "pairing";
var Kt2 = "0.3";
var se2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var re = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt2 = "history";
var Vt2 = "0.3";
var qt2 = "expirer";
var M2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt2 = "0.3";
var Wt2 = "verify-api";
var Qs = "https://verify.walletconnect.com";
var Ht2 = "https://verify.walletconnect.org";
var ue2 = Ht2;
var Yt2 = `${ue2}/v3`;
var Jt2 = [Qs, Ht2];
var Xt2 = "echo";
var Zt2 = "https://echo.walletconnect.com";
var G2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var tr2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var ir2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var sr2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var rr2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt2 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii2 = "https://pulse.walletconnect.org/batch";
function nr(r8, e11) {
  if (r8.length >= 255) throw new TypeError("Alphabet too long");
  for (var t6 = new Uint8Array(256), i9 = 0; i9 < t6.length; i9++) t6[i9] = 255;
  for (var s5 = 0; s5 < r8.length; s5++) {
    var n5 = r8.charAt(s5), o6 = n5.charCodeAt(0);
    if (t6[o6] !== 255) throw new TypeError(n5 + " is ambiguous");
    t6[o6] = s5;
  }
  var a6 = r8.length, c9 = r8.charAt(0), h9 = Math.log(a6) / Math.log(256), l9 = Math.log(256) / Math.log(a6);
  function d7(u10) {
    if (u10 instanceof Uint8Array || (ArrayBuffer.isView(u10) ? u10 = new Uint8Array(u10.buffer, u10.byteOffset, u10.byteLength) : Array.isArray(u10) && (u10 = Uint8Array.from(u10))), !(u10 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u10.length === 0) return "";
    for (var b6 = 0, x7 = 0, I8 = 0, D9 = u10.length; I8 !== D9 && u10[I8] === 0; ) I8++, b6++;
    for (var j9 = (D9 - I8) * l9 + 1 >>> 0, T8 = new Uint8Array(j9); I8 !== D9; ) {
      for (var q6 = u10[I8], J5 = 0, K5 = j9 - 1; (q6 !== 0 || J5 < x7) && K5 !== -1; K5--, J5++) q6 += 256 * T8[K5] >>> 0, T8[K5] = q6 % a6 >>> 0, q6 = q6 / a6 >>> 0;
      if (q6 !== 0) throw new Error("Non-zero carry");
      x7 = J5, I8++;
    }
    for (var H4 = j9 - x7; H4 !== j9 && T8[H4] === 0; ) H4++;
    for (var me5 = c9.repeat(b6); H4 < j9; ++H4) me5 += r8.charAt(T8[H4]);
    return me5;
  }
  function g4(u10) {
    if (typeof u10 != "string") throw new TypeError("Expected String");
    if (u10.length === 0) return new Uint8Array();
    var b6 = 0;
    if (u10[b6] !== " ") {
      for (var x7 = 0, I8 = 0; u10[b6] === c9; ) x7++, b6++;
      for (var D9 = (u10.length - b6) * h9 + 1 >>> 0, j9 = new Uint8Array(D9); u10[b6]; ) {
        var T8 = t6[u10.charCodeAt(b6)];
        if (T8 === 255) return;
        for (var q6 = 0, J5 = D9 - 1; (T8 !== 0 || q6 < I8) && J5 !== -1; J5--, q6++) T8 += a6 * j9[J5] >>> 0, j9[J5] = T8 % 256 >>> 0, T8 = T8 / 256 >>> 0;
        if (T8 !== 0) throw new Error("Non-zero carry");
        I8 = q6, b6++;
      }
      if (u10[b6] !== " ") {
        for (var K5 = D9 - I8; K5 !== D9 && j9[K5] === 0; ) K5++;
        for (var H4 = new Uint8Array(x7 + (D9 - K5)), me5 = x7; K5 !== D9; ) H4[me5++] = j9[K5++];
        return H4;
      }
    }
  }
  function _6(u10) {
    var b6 = g4(u10);
    if (b6) return b6;
    throw new Error(`Non-${e11} character`);
  }
  return { encode: d7, decodeUnsafe: g4, decode: _6 };
}
var or2 = nr;
var ar = or2;
var si2 = (r8) => {
  if (r8 instanceof Uint8Array && r8.constructor.name === "Uint8Array") return r8;
  if (r8 instanceof ArrayBuffer) return new Uint8Array(r8);
  if (ArrayBuffer.isView(r8)) return new Uint8Array(r8.buffer, r8.byteOffset, r8.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var cr2 = (r8) => new TextEncoder().encode(r8);
var hr2 = (r8) => new TextDecoder().decode(r8);
var lr = class {
  constructor(e11, t6, i9) {
    this.name = e11, this.prefix = t6, this.baseEncode = i9;
  }
  encode(e11) {
    if (e11 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e11)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ur = class {
  constructor(e11, t6, i9) {
    if (this.name = e11, this.prefix = t6, t6.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t6.codePointAt(0), this.baseDecode = i9;
  }
  decode(e11) {
    if (typeof e11 == "string") {
      if (e11.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e11)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e11.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e11) {
    return ri2(this, e11);
  }
};
var dr2 = class {
  constructor(e11) {
    this.decoders = e11;
  }
  or(e11) {
    return ri2(this, e11);
  }
  decode(e11) {
    const t6 = e11[0], i9 = this.decoders[t6];
    if (i9) return i9.decode(e11);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e11)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r8, e11) => new dr2({ ...r8.decoders || { [r8.prefix]: r8 }, ...e11.decoders || { [e11.prefix]: e11 } });
var gr2 = class {
  constructor(e11, t6, i9, s5) {
    this.name = e11, this.prefix = t6, this.baseEncode = i9, this.baseDecode = s5, this.encoder = new lr(e11, t6, i9), this.decoder = new ur(e11, t6, s5);
  }
  encode(e11) {
    return this.encoder.encode(e11);
  }
  decode(e11) {
    return this.decoder.decode(e11);
  }
};
var Ee = ({ name: r8, prefix: e11, encode: t6, decode: i9 }) => new gr2(r8, e11, t6, i9);
var de2 = ({ prefix: r8, name: e11, alphabet: t6 }) => {
  const { encode: i9, decode: s5 } = ar(t6, e11);
  return Ee({ prefix: r8, name: e11, encode: i9, decode: (n5) => si2(s5(n5)) });
};
var pr2 = (r8, e11, t6, i9) => {
  const s5 = {};
  for (let l9 = 0; l9 < e11.length; ++l9) s5[e11[l9]] = l9;
  let n5 = r8.length;
  for (; r8[n5 - 1] === "="; ) --n5;
  const o6 = new Uint8Array(n5 * t6 / 8 | 0);
  let a6 = 0, c9 = 0, h9 = 0;
  for (let l9 = 0; l9 < n5; ++l9) {
    const d7 = s5[r8[l9]];
    if (d7 === void 0) throw new SyntaxError(`Non-${i9} character`);
    c9 = c9 << t6 | d7, a6 += t6, a6 >= 8 && (a6 -= 8, o6[h9++] = 255 & c9 >> a6);
  }
  if (a6 >= t6 || 255 & c9 << 8 - a6) throw new SyntaxError("Unexpected end of data");
  return o6;
};
var yr2 = (r8, e11, t6) => {
  const i9 = e11[e11.length - 1] === "=", s5 = (1 << t6) - 1;
  let n5 = "", o6 = 0, a6 = 0;
  for (let c9 = 0; c9 < r8.length; ++c9) for (a6 = a6 << 8 | r8[c9], o6 += 8; o6 > t6; ) o6 -= t6, n5 += e11[s5 & a6 >> o6];
  if (o6 && (n5 += e11[s5 & a6 << t6 - o6]), i9) for (; n5.length * t6 & 7; ) n5 += "=";
  return n5;
};
var P2 = ({ name: r8, prefix: e11, bitsPerChar: t6, alphabet: i9 }) => Ee({ prefix: e11, name: r8, encode(s5) {
  return yr2(s5, i9, t6);
}, decode(s5) {
  return pr2(s5, i9, t6, r8);
} });
var br2 = Ee({ prefix: "\0", name: "identity", encode: (r8) => hr2(r8), decode: (r8) => cr2(r8) });
var mr2 = Object.freeze({ __proto__: null, identity: br2 });
var fr2 = P2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Dr2 = Object.freeze({ __proto__: null, base2: fr2 });
var vr2 = P2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var wr2 = Object.freeze({ __proto__: null, base8: vr2 });
var _r2 = de2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Er2 = Object.freeze({ __proto__: null, base10: _r2 });
var Ir2 = P2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Tr2 = P2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Cr2 = Object.freeze({ __proto__: null, base16: Ir2, base16upper: Tr2 });
var Pr2 = P2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Sr2 = P2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Or2 = P2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Rr2 = P2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ar2 = P2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var xr2 = P2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Nr2 = P2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var $r2 = P2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var zr = P2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Lr2 = Object.freeze({ __proto__: null, base32: Pr2, base32upper: Sr2, base32pad: Or2, base32padupper: Rr2, base32hex: Ar2, base32hexupper: xr2, base32hexpad: Nr2, base32hexpadupper: $r2, base32z: zr });
var kr2 = de2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jr2 = de2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ur2 = Object.freeze({ __proto__: null, base36: kr2, base36upper: jr2 });
var Fr = de2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Mr2 = de2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Kr = Object.freeze({ __proto__: null, base58btc: Fr, base58flickr: Mr2 });
var Br2 = P2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Vr2 = P2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var qr2 = P2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gr2 = P2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Wr2 = Object.freeze({ __proto__: null, base64: Br2, base64pad: Vr2, base64url: qr2, base64urlpad: Gr2 });
var ni2 = Array.from("");
var Hr2 = ni2.reduce((r8, e11, t6) => (r8[t6] = e11, r8), []);
var Yr = ni2.reduce((r8, e11, t6) => (r8[e11.codePointAt(0)] = t6, r8), []);
function Jr(r8) {
  return r8.reduce((e11, t6) => (e11 += Hr2[t6], e11), "");
}
function Xr2(r8) {
  const e11 = [];
  for (const t6 of r8) {
    const i9 = Yr[t6.codePointAt(0)];
    if (i9 === void 0) throw new Error(`Non-base256emoji character: ${t6}`);
    e11.push(i9);
  }
  return new Uint8Array(e11);
}
var Zr2 = Ee({ prefix: "", name: "base256emoji", encode: Jr, decode: Xr2 });
var Qr2 = Object.freeze({ __proto__: null, base256emoji: Zr2 });
var en2 = ai2;
var oi2 = 128;
var tn2 = 127;
var sn3 = ~tn2;
var rn2 = Math.pow(2, 31);
function ai2(r8, e11, t6) {
  e11 = e11 || [], t6 = t6 || 0;
  for (var i9 = t6; r8 >= rn2; ) e11[t6++] = r8 & 255 | oi2, r8 /= 128;
  for (; r8 & sn3; ) e11[t6++] = r8 & 255 | oi2, r8 >>>= 7;
  return e11[t6] = r8 | 0, ai2.bytes = t6 - i9 + 1, e11;
}
var nn2 = Me2;
var on2 = 128;
var ci2 = 127;
function Me2(r8, i9) {
  var t6 = 0, i9 = i9 || 0, s5 = 0, n5 = i9, o6, a6 = r8.length;
  do {
    if (n5 >= a6) throw Me2.bytes = 0, new RangeError("Could not decode varint");
    o6 = r8[n5++], t6 += s5 < 28 ? (o6 & ci2) << s5 : (o6 & ci2) * Math.pow(2, s5), s5 += 7;
  } while (o6 >= on2);
  return Me2.bytes = n5 - i9, t6;
}
var an2 = Math.pow(2, 7);
var cn2 = Math.pow(2, 14);
var hn2 = Math.pow(2, 21);
var ln2 = Math.pow(2, 28);
var un2 = Math.pow(2, 35);
var dn2 = Math.pow(2, 42);
var gn2 = Math.pow(2, 49);
var pn2 = Math.pow(2, 56);
var yn2 = Math.pow(2, 63);
var bn2 = function(r8) {
  return r8 < an2 ? 1 : r8 < cn2 ? 2 : r8 < hn2 ? 3 : r8 < ln2 ? 4 : r8 < un2 ? 5 : r8 < dn2 ? 6 : r8 < gn2 ? 7 : r8 < pn2 ? 8 : r8 < yn2 ? 9 : 10;
};
var mn2 = { encode: en2, decode: nn2, encodingLength: bn2 };
var hi2 = mn2;
var li2 = (r8, e11, t6 = 0) => (hi2.encode(r8, e11, t6), e11);
var ui2 = (r8) => hi2.encodingLength(r8);
var Ke2 = (r8, e11) => {
  const t6 = e11.byteLength, i9 = ui2(r8), s5 = i9 + ui2(t6), n5 = new Uint8Array(s5 + t6);
  return li2(r8, n5, 0), li2(t6, n5, i9), n5.set(e11, s5), new fn2(r8, t6, e11, n5);
};
var fn2 = class {
  constructor(e11, t6, i9, s5) {
    this.code = e11, this.size = t6, this.digest = i9, this.bytes = s5;
  }
};
var di2 = ({ name: r8, code: e11, encode: t6 }) => new Dn2(r8, e11, t6);
var Dn2 = class {
  constructor(e11, t6, i9) {
    this.name = e11, this.code = t6, this.encode = i9;
  }
  digest(e11) {
    if (e11 instanceof Uint8Array) {
      const t6 = this.encode(e11);
      return t6 instanceof Uint8Array ? Ke2(this.code, t6) : t6.then((i9) => Ke2(this.code, i9));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r8) => async (e11) => new Uint8Array(await crypto.subtle.digest(r8, e11));
var vn2 = di2({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var wn2 = di2({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var _n2 = Object.freeze({ __proto__: null, sha256: vn2, sha512: wn2 });
var pi2 = 0;
var En2 = "identity";
var yi2 = si2;
var In2 = (r8) => Ke2(pi2, yi2(r8));
var Tn2 = { code: pi2, name: En2, encode: yi2, digest: In2 };
var Cn2 = Object.freeze({ __proto__: null, identity: Tn2 });
new TextEncoder(), new TextDecoder();
var bi2 = { ...mr2, ...Dr2, ...wr2, ...Er2, ...Cr2, ...Lr2, ...Ur2, ...Kr, ...Wr2, ...Qr2 };
({ ..._n2, ...Cn2 });
function mi2(r8) {
  return globalThis.Buffer != null ? new Uint8Array(r8.buffer, r8.byteOffset, r8.byteLength) : r8;
}
function Pn2(r8 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? mi2(globalThis.Buffer.allocUnsafe(r8)) : new Uint8Array(r8);
}
function fi2(r8, e11, t6, i9) {
  return { name: r8, prefix: e11, encoder: { name: r8, prefix: e11, encode: t6 }, decoder: { decode: i9 } };
}
var Di2 = fi2("utf8", "u", (r8) => "u" + new TextDecoder("utf8").decode(r8), (r8) => new TextEncoder().encode(r8.substring(1)));
var Be2 = fi2("ascii", "a", (r8) => {
  let e11 = "a";
  for (let t6 = 0; t6 < r8.length; t6++) e11 += String.fromCharCode(r8[t6]);
  return e11;
}, (r8) => {
  r8 = r8.substring(1);
  const e11 = Pn2(r8.length);
  for (let t6 = 0; t6 < r8.length; t6++) e11[t6] = r8.charCodeAt(t6);
  return e11;
});
var Sn2 = { utf8: Di2, "utf-8": Di2, hex: bi2.base16, latin1: Be2, ascii: Be2, binary: Be2, ...bi2 };
function On2(r8, e11 = "utf8") {
  const t6 = Sn2[e11];
  if (!t6) throw new Error(`Unsupported encoding "${e11}"`);
  return (e11 === "utf8" || e11 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? mi2(globalThis.Buffer.from(r8, "utf-8")) : t6.decoder.decode(`${t6.prefix}${r8}`);
}
var Rn2 = Object.defineProperty;
var An2 = (r8, e11, t6) => e11 in r8 ? Rn2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var W2 = (r8, e11, t6) => An2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var vi2 = class {
  constructor(e11, t6) {
    this.core = e11, this.logger = t6, W2(this, "keychain", /* @__PURE__ */ new Map()), W2(this, "name", Pt2), W2(this, "version", St2), W2(this, "initialized", false), W2(this, "storagePrefix", B), W2(this, "init", async () => {
      if (!this.initialized) {
        const i9 = await this.getKeyChain();
        typeof i9 < "u" && (this.keychain = i9), this.initialized = true;
      }
    }), W2(this, "has", (i9) => (this.isInitialized(), this.keychain.has(i9))), W2(this, "set", async (i9, s5) => {
      this.isInitialized(), this.keychain.set(i9, s5), await this.persist();
    }), W2(this, "get", (i9) => {
      this.isInitialized();
      const s5 = this.keychain.get(i9);
      if (typeof s5 > "u") {
        const { message: n5 } = Et("NO_MATCHING_KEY", `${this.name}: ${i9}`);
        throw new Error(n5);
      }
      return s5;
    }), W2(this, "del", async (i9) => {
      this.isInitialized(), this.keychain.delete(i9), await this.persist();
    }), this.core = e11, this.logger = E(t6, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e11) {
    await this.core.storage.setItem(this.storageKey, Ys(e11));
  }
  async getKeyChain() {
    const e11 = await this.core.storage.getItem(this.storageKey);
    return typeof e11 < "u" ? Xs(e11) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
};
var xn2 = Object.defineProperty;
var Nn2 = (r8, e11, t6) => e11 in r8 ? xn2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var S2 = (r8, e11, t6) => Nn2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var wi2 = class {
  constructor(e11, t6, i9) {
    this.core = e11, this.logger = t6, S2(this, "name", Tt2), S2(this, "keychain"), S2(this, "randomSessionIdentifier", qc()), S2(this, "initialized", false), S2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S2(this, "hasKeys", (s5) => (this.isInitialized(), this.keychain.has(s5))), S2(this, "getClientId", async () => {
      this.isInitialized();
      const s5 = await this.getClientSeed(), n5 = Po(s5);
      return Qe(n5.publicKey);
    }), S2(this, "generateKeyPair", () => {
      this.isInitialized();
      const s5 = Vc();
      return this.setPrivateKey(s5.publicKey, s5.privateKey);
    }), S2(this, "signJWT", async (s5) => {
      this.isInitialized();
      const n5 = await this.getClientSeed(), o6 = Po(n5), a6 = this.randomSessionIdentifier, c9 = Ct2;
      return await Qo(a6, s5, c9, o6);
    }), S2(this, "generateSharedKey", (s5, n5, o6) => {
      this.isInitialized();
      const a6 = this.getPrivateKey(s5), c9 = Kc(a6, n5);
      return this.setSymKey(c9, o6);
    }), S2(this, "setSymKey", async (s5, n5) => {
      this.isInitialized();
      const o6 = n5 || Fc(s5);
      return await this.keychain.set(o6, s5), o6;
    }), S2(this, "deleteKeyPair", async (s5) => {
      this.isInitialized(), await this.keychain.del(s5);
    }), S2(this, "deleteSymKey", async (s5) => {
      this.isInitialized(), await this.keychain.del(s5);
    }), S2(this, "encode", async (s5, n5, o6) => {
      this.isInitialized();
      const a6 = Ho(o6), c9 = safeJsonStringify(n5);
      if (Qc(a6)) return Wc(c9, o6 == null ? void 0 : o6.encoding);
      if (Jc(a6)) {
        const g4 = a6.senderPublicKey, _6 = a6.receiverPublicKey;
        s5 = await this.generateSharedKey(g4, _6);
      }
      const h9 = this.getSymKey(s5), { type: l9, senderPublicKey: d7 } = a6;
      return Gc({ type: l9, symKey: h9, message: c9, senderPublicKey: d7, encoding: o6 == null ? void 0 : o6.encoding });
    }), S2(this, "decode", async (s5, n5, o6) => {
      this.isInitialized();
      const a6 = Xc(n5, o6);
      if (Qc(a6)) {
        const c9 = Yc(n5, o6 == null ? void 0 : o6.encoding);
        return safeJsonParse(c9);
      }
      if (Jc(a6)) {
        const c9 = a6.receiverPublicKey, h9 = a6.senderPublicKey;
        s5 = await this.generateSharedKey(c9, h9);
      }
      try {
        const c9 = this.getSymKey(s5), h9 = Zc({ symKey: c9, encoded: n5, encoding: o6 == null ? void 0 : o6.encoding });
        return safeJsonParse(h9);
      } catch (c9) {
        this.logger.error(`Failed to decode message from topic: '${s5}', clientId: '${await this.getClientId()}'`), this.logger.error(c9);
      }
    }), S2(this, "getPayloadType", (s5, n5 = Qt) => {
      const o6 = Me({ encoded: s5, encoding: n5 });
      return Vt(o6.type);
    }), S2(this, "getPayloadSenderPublicKey", (s5, n5 = Qt) => {
      const o6 = Me({ encoded: s5, encoding: n5 });
      return o6.senderPublicKey ? toString2(o6.senderPublicKey, tt) : void 0;
    }), this.core = e11, this.logger = E(t6, this.name), this.keychain = i9 || new vi2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e11, t6) {
    return await this.keychain.set(e11, t6), e11;
  }
  getPrivateKey(e11) {
    return this.keychain.get(e11);
  }
  async getClientSeed() {
    let e11 = "";
    try {
      e11 = this.keychain.get(ke2);
    } catch {
      e11 = qc(), await this.keychain.set(ke2, e11);
    }
    return On2(e11, "base16");
  }
  getSymKey(e11) {
    return this.keychain.get(e11);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
};
var $n2 = Object.defineProperty;
var zn2 = Object.defineProperties;
var Ln2 = Object.getOwnPropertyDescriptors;
var _i2 = Object.getOwnPropertySymbols;
var kn2 = Object.prototype.hasOwnProperty;
var jn2 = Object.prototype.propertyIsEnumerable;
var Ve2 = (r8, e11, t6) => e11 in r8 ? $n2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var Un2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) kn2.call(e11, t6) && Ve2(r8, t6, e11[t6]);
  if (_i2) for (var t6 of _i2(e11)) jn2.call(e11, t6) && Ve2(r8, t6, e11[t6]);
  return r8;
};
var Fn2 = (r8, e11) => zn2(r8, Ln2(e11));
var k4 = (r8, e11, t6) => Ve2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Ei2 = class extends y3 {
  constructor(e11, t6) {
    super(e11, t6), this.logger = e11, this.core = t6, k4(this, "messages", /* @__PURE__ */ new Map()), k4(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k4(this, "name", Ot2), k4(this, "version", Rt2), k4(this, "initialized", false), k4(this, "storagePrefix", B), k4(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i9 = await this.getRelayerMessages();
          typeof i9 < "u" && (this.messages = i9);
          const s5 = await this.getRelayerMessagesWithoutClientAck();
          typeof s5 < "u" && (this.messagesWithoutClientAck = s5), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i9) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i9);
        } finally {
          this.initialized = true;
        }
      }
    }), k4(this, "set", async (i9, s5, n5) => {
      this.isInitialized();
      const o6 = zc(s5);
      let a6 = this.messages.get(i9);
      if (typeof a6 > "u" && (a6 = {}), typeof a6[o6] < "u") return o6;
      if (a6[o6] = s5, this.messages.set(i9, a6), n5 === le2.inbound) {
        const c9 = this.messagesWithoutClientAck.get(i9) || {};
        this.messagesWithoutClientAck.set(i9, Fn2(Un2({}, c9), { [o6]: s5 }));
      }
      return await this.persist(), o6;
    }), k4(this, "get", (i9) => {
      this.isInitialized();
      let s5 = this.messages.get(i9);
      return typeof s5 > "u" && (s5 = {}), s5;
    }), k4(this, "getWithoutAck", (i9) => {
      this.isInitialized();
      const s5 = {};
      for (const n5 of i9) {
        const o6 = this.messagesWithoutClientAck.get(n5) || {};
        s5[n5] = Object.values(o6);
      }
      return s5;
    }), k4(this, "has", (i9, s5) => {
      this.isInitialized();
      const n5 = this.get(i9), o6 = zc(s5);
      return typeof n5[o6] < "u";
    }), k4(this, "ack", async (i9, s5) => {
      this.isInitialized();
      const n5 = this.messagesWithoutClientAck.get(i9);
      if (typeof n5 > "u") return;
      const o6 = zc(s5);
      delete n5[o6], Object.keys(n5).length === 0 ? this.messagesWithoutClientAck.delete(i9) : this.messagesWithoutClientAck.set(i9, n5), await this.persist();
    }), k4(this, "del", async (i9) => {
      this.isInitialized(), this.messages.delete(i9), this.messagesWithoutClientAck.delete(i9), await this.persist();
    }), this.logger = E(e11, this.name), this.core = t6;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e11) {
    await this.core.storage.setItem(this.storageKey, Ys(e11));
  }
  async setRelayerMessagesWithoutClientAck(e11) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Ys(e11));
  }
  async getRelayerMessages() {
    const e11 = await this.core.storage.getItem(this.storageKey);
    return typeof e11 < "u" ? Xs(e11) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e11 = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e11 < "u" ? Xs(e11) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
};
var Mn2 = Object.defineProperty;
var Kn2 = Object.defineProperties;
var Bn2 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Vn2 = Object.prototype.hasOwnProperty;
var qn2 = Object.prototype.propertyIsEnumerable;
var qe2 = (r8, e11, t6) => e11 in r8 ? Mn2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var Ie2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) Vn2.call(e11, t6) && qe2(r8, t6, e11[t6]);
  if (Ii2) for (var t6 of Ii2(e11)) qn2.call(e11, t6) && qe2(r8, t6, e11[t6]);
  return r8;
};
var Ge = (r8, e11) => Kn2(r8, Bn2(e11));
var V2 = (r8, e11, t6) => qe2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Gn = class extends m {
  constructor(e11, t6) {
    super(e11, t6), this.relayer = e11, this.logger = t6, V2(this, "events", new import_events3.EventEmitter()), V2(this, "name", At2), V2(this, "queue", /* @__PURE__ */ new Map()), V2(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), V2(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), V2(this, "needsTransportRestart", false), V2(this, "publish", async (i9, s5, n5) => {
      var o6;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i9, message: s5, opts: n5 } });
      const a6 = (n5 == null ? void 0 : n5.ttl) || je2, c9 = ea(n5), h9 = (n5 == null ? void 0 : n5.prompt) || false, l9 = (n5 == null ? void 0 : n5.tag) || 0, d7 = (n5 == null ? void 0 : n5.id) || getBigIntRpcId().toString(), g4 = { topic: i9, message: s5, opts: { ttl: a6, relay: c9, prompt: h9, tag: l9, id: d7, attestation: n5 == null ? void 0 : n5.attestation, tvf: n5 == null ? void 0 : n5.tvf } }, _6 = `Failed to publish payload, please try again. id:${d7} tag:${l9}`;
      try {
        const u10 = new Promise(async (b6) => {
          const x7 = ({ id: D9 }) => {
            g4.opts.id === D9 && (this.removeRequestFromQueue(D9), this.relayer.events.removeListener(C2.publish, x7), b6(g4));
          };
          this.relayer.events.on(C2.publish, x7);
          const I8 = ni(new Promise((D9, j9) => {
            this.rpcPublish({ topic: i9, message: s5, ttl: a6, prompt: h9, tag: l9, id: d7, attestation: n5 == null ? void 0 : n5.attestation, tvf: n5 == null ? void 0 : n5.tvf }).then(D9).catch((T8) => {
              this.logger.warn(T8, T8 == null ? void 0 : T8.message), j9(T8);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d7} tag:${l9}`);
          try {
            await I8, this.events.removeListener(C2.publish, x7);
          } catch (D9) {
            this.queue.set(d7, Ge(Ie2({}, g4), { attempt: 1 })), this.logger.warn(D9, D9 == null ? void 0 : D9.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d7, topic: i9, message: s5, opts: n5 } }), await ni(u10, this.publishTimeout, _6);
      } catch (u10) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u10), (o6 = n5 == null ? void 0 : n5.internal) != null && o6.throwOnFailedPublish) throw u10;
      } finally {
        this.queue.delete(d7);
      }
    }), V2(this, "on", (i9, s5) => {
      this.events.on(i9, s5);
    }), V2(this, "once", (i9, s5) => {
      this.events.once(i9, s5);
    }), V2(this, "off", (i9, s5) => {
      this.events.off(i9, s5);
    }), V2(this, "removeListener", (i9, s5) => {
      this.events.removeListener(i9, s5);
    }), this.relayer = e11, this.logger = E(t6, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e11) {
    var t6, i9, s5, n5;
    const { topic: o6, message: a6, ttl: c9 = je2, prompt: h9, tag: l9, id: d7, attestation: g4, tvf: _6 } = e11, u10 = { method: na(ea().protocol).publish, params: Ie2({ topic: o6, message: a6, ttl: c9, prompt: h9, tag: l9, attestation: g4 }, _6), id: d7 };
    kt((t6 = u10.params) == null ? void 0 : t6.prompt) && ((i9 = u10.params) == null || delete i9.prompt), kt((s5 = u10.params) == null ? void 0 : s5.tag) && ((n5 = u10.params) == null || delete n5.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u10 });
    const b6 = await this.relayer.request(u10);
    return this.relayer.events.emit(C2.publish, e11), this.logger.debug("Successfully Published Payload"), b6;
  }
  removeRequestFromQueue(e11) {
    this.queue.delete(e11);
  }
  checkQueue() {
    this.queue.forEach(async (e11, t6) => {
      const i9 = e11.attempt + 1;
      this.queue.set(t6, Ge(Ie2({}, e11), { attempt: i9 }));
      const { topic: s5, message: n5, opts: o6, attestation: a6 } = e11;
      this.logger.warn({}, `Publisher: queue->publishing: ${e11.opts.id}, tag: ${e11.opts.tag}, attempt: ${i9}`), await this.rpcPublish(Ge(Ie2({}, e11), { topic: s5, message: n5, ttl: o6.ttl, prompt: o6.prompt, tag: o6.tag, id: o6.id, attestation: a6, tvf: o6.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e11.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C2.message_ack, (e11) => {
      this.removeRequestFromQueue(e11.id.toString());
    });
  }
};
var Wn = Object.defineProperty;
var Hn2 = (r8, e11, t6) => e11 in r8 ? Wn(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var ne2 = (r8, e11, t6) => Hn2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Yn = class {
  constructor() {
    ne2(this, "map", /* @__PURE__ */ new Map()), ne2(this, "set", (e11, t6) => {
      const i9 = this.get(e11);
      this.exists(e11, t6) || this.map.set(e11, [...i9, t6]);
    }), ne2(this, "get", (e11) => this.map.get(e11) || []), ne2(this, "exists", (e11, t6) => this.get(e11).includes(t6)), ne2(this, "delete", (e11, t6) => {
      if (typeof t6 > "u") {
        this.map.delete(e11);
        return;
      }
      if (!this.map.has(e11)) return;
      const i9 = this.get(e11);
      if (!this.exists(e11, t6)) return;
      const s5 = i9.filter((n5) => n5 !== t6);
      if (!s5.length) {
        this.map.delete(e11);
        return;
      }
      this.map.set(e11, s5);
    }), ne2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Jn2 = Object.defineProperty;
var Xn = Object.defineProperties;
var Zn = Object.getOwnPropertyDescriptors;
var Ti2 = Object.getOwnPropertySymbols;
var Qn2 = Object.prototype.hasOwnProperty;
var eo2 = Object.prototype.propertyIsEnumerable;
var We = (r8, e11, t6) => e11 in r8 ? Jn2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var ge2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) Qn2.call(e11, t6) && We(r8, t6, e11[t6]);
  if (Ti2) for (var t6 of Ti2(e11)) eo2.call(e11, t6) && We(r8, t6, e11[t6]);
  return r8;
};
var He2 = (r8, e11) => Xn(r8, Zn(e11));
var f4 = (r8, e11, t6) => We(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Ci2 = class extends P {
  constructor(e11, t6) {
    super(e11, t6), this.relayer = e11, this.logger = t6, f4(this, "subscriptions", /* @__PURE__ */ new Map()), f4(this, "topicMap", new Yn()), f4(this, "events", new import_events3.EventEmitter()), f4(this, "name", Ut2), f4(this, "version", Ft), f4(this, "pending", /* @__PURE__ */ new Map()), f4(this, "cached", []), f4(this, "initialized", false), f4(this, "storagePrefix", B), f4(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), f4(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), f4(this, "clientId"), f4(this, "batchSubscribeTopicsLimit", 500), f4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f4(this, "subscribe", async (i9, s5) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i9, opts: s5 } });
      try {
        const n5 = ea(s5), o6 = { topic: i9, relay: n5, transportType: s5 == null ? void 0 : s5.transportType };
        this.pending.set(i9, o6);
        const a6 = await this.rpcSubscribe(i9, n5, s5);
        return typeof a6 == "string" && (this.onSubscribe(a6, o6), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i9, opts: s5 } })), a6;
      } catch (n5) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n5), n5;
      }
    }), f4(this, "unsubscribe", async (i9, s5) => {
      this.isInitialized(), typeof (s5 == null ? void 0 : s5.id) < "u" ? await this.unsubscribeById(i9, s5.id, s5) : await this.unsubscribeByTopic(i9, s5);
    }), f4(this, "isSubscribed", (i9) => new Promise((s5) => {
      s5(this.topicMap.topics.includes(i9));
    })), f4(this, "isKnownTopic", (i9) => new Promise((s5) => {
      s5(this.topicMap.topics.includes(i9) || this.pending.has(i9) || this.cached.some((n5) => n5.topic === i9));
    })), f4(this, "on", (i9, s5) => {
      this.events.on(i9, s5);
    }), f4(this, "once", (i9, s5) => {
      this.events.once(i9, s5);
    }), f4(this, "off", (i9, s5) => {
      this.events.off(i9, s5);
    }), f4(this, "removeListener", (i9, s5) => {
      this.events.removeListener(i9, s5);
    }), f4(this, "start", async () => {
      await this.onConnect();
    }), f4(this, "stop", async () => {
      await this.onDisconnect();
    }), f4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i9 = [];
      this.pending.forEach((s5) => {
        i9.push(s5);
      }), await this.batchSubscribe(i9);
    }), f4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i9) => {
        const s5 = $.created;
        this.logger.info(`Emitting ${s5}`), this.logger.debug({ type: "event", event: s5, data: i9 }), await this.persist();
      }), this.events.on($.deleted, async (i9) => {
        const s5 = $.deleted;
        this.logger.info(`Emitting ${s5}`), this.logger.debug({ type: "event", event: s5, data: i9 }), await this.persist();
      });
    }), this.relayer = e11, this.logger = E(t6, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e11, t6) {
    let i9 = false;
    try {
      i9 = this.getSubscription(e11).topic === t6;
    } catch {
    }
    return i9;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e11, t6) {
    const i9 = this.topicMap.get(e11);
    await Promise.all(i9.map(async (s5) => await this.unsubscribeById(e11, s5, t6)));
  }
  async unsubscribeById(e11, t6, i9) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e11, id: t6, opts: i9 } });
    try {
      const s5 = ea(i9);
      await this.restartToComplete({ topic: e11, id: t6, relay: s5 }), await this.rpcUnsubscribe(e11, t6, s5);
      const n5 = Kt("USER_DISCONNECTED", `${this.name}, ${e11}`);
      await this.onUnsubscribe(e11, t6, n5), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e11, id: t6, opts: i9 } });
    } catch (s5) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s5), s5;
    }
  }
  async rpcSubscribe(e11, t6, i9) {
    var s5;
    (!i9 || (i9 == null ? void 0 : i9.transportType) === Q2.relay) && await this.restartToComplete({ topic: e11, id: e11, relay: t6 });
    const n5 = { method: na(t6.protocol).subscribe, params: { topic: e11 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n5 });
    const o6 = (s5 = i9 == null ? void 0 : i9.internal) == null ? void 0 : s5.throwOnFailedPublish;
    try {
      const a6 = await this.getSubscriptionId(e11);
      if ((i9 == null ? void 0 : i9.transportType) === Q2.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n5).catch((l9) => this.logger.warn(l9));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), a6;
      const c9 = new Promise(async (l9) => {
        const d7 = (g4) => {
          g4.topic === e11 && (this.events.removeListener($.created, d7), l9(g4.id));
        };
        this.events.on($.created, d7);
        try {
          const g4 = await ni(new Promise((_6, u10) => {
            this.relayer.request(n5).catch((b6) => {
              this.logger.warn(b6, b6 == null ? void 0 : b6.message), u10(b6);
            }).then(_6);
          }), this.initialSubscribeTimeout, `Subscribing to ${e11} failed, please try again`);
          this.events.removeListener($.created, d7), l9(g4);
        } catch {
        }
      }), h9 = await ni(c9, this.subscribeTimeout, `Subscribing to ${e11} failed, please try again`);
      if (!h9 && o6) throw new Error(`Subscribing to ${e11} failed, please try again`);
      return h9 ? a6 : null;
    } catch (a6) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C2.connection_stalled), o6) throw a6;
    }
    return null;
  }
  async rpcBatchSubscribe(e11) {
    if (!e11.length) return;
    const t6 = e11[0].relay, i9 = { method: na(t6.protocol).batchSubscribe, params: { topics: e11.map((s5) => s5.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i9 });
    try {
      await await ni(new Promise((s5) => {
        this.relayer.request(i9).catch((n5) => this.logger.warn(n5)).then(s5);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e11) {
    if (!e11.length) return;
    const t6 = e11[0].relay, i9 = { method: na(t6.protocol).batchFetchMessages, params: { topics: e11.map((n5) => n5.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i9 });
    let s5;
    try {
      s5 = await await ni(new Promise((n5, o6) => {
        this.relayer.request(i9).catch((a6) => {
          this.logger.warn(a6), o6(a6);
        }).then(n5);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C2.connection_stalled);
    }
    return s5;
  }
  rpcUnsubscribe(e11, t6, i9) {
    const s5 = { method: na(i9.protocol).unsubscribe, params: { topic: e11, id: t6 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s5 }), this.relayer.request(s5);
  }
  onSubscribe(e11, t6) {
    this.setSubscription(e11, He2(ge2({}, t6), { id: e11 })), this.pending.delete(t6.topic);
  }
  onBatchSubscribe(e11) {
    e11.length && e11.forEach((t6) => {
      this.setSubscription(t6.id, ge2({}, t6)), this.pending.delete(t6.topic);
    });
  }
  async onUnsubscribe(e11, t6, i9) {
    this.events.removeAllListeners(t6), this.hasSubscription(t6, e11) && this.deleteSubscription(t6, i9), await this.relayer.messages.del(e11);
  }
  async setRelayerSubscriptions(e11) {
    await this.relayer.core.storage.setItem(this.storageKey, e11);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e11, t6) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e11, subscription: t6 }), this.addSubscription(e11, t6);
  }
  addSubscription(e11, t6) {
    this.subscriptions.set(e11, ge2({}, t6)), this.topicMap.set(t6.topic, e11), this.events.emit($.created, t6);
  }
  getSubscription(e11) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e11 });
    const t6 = this.subscriptions.get(e11);
    if (!t6) {
      const { message: i9 } = Et("NO_MATCHING_KEY", `${this.name}: ${e11}`);
      throw new Error(i9);
    }
    return t6;
  }
  deleteSubscription(e11, t6) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e11, reason: t6 });
    const i9 = this.getSubscription(e11);
    this.subscriptions.delete(e11), this.topicMap.delete(i9.topic, e11), this.events.emit($.deleted, He2(ge2({}, i9), { reason: t6 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e11 = [...this.cached], t6 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i9 = 0; i9 < t6; i9++) {
        const s5 = e11.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s5);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e11 = await this.getRelayerSubscriptions();
      if (typeof e11 > "u" || !e11.length) return;
      if (this.subscriptions.size) {
        const { message: t6 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t6), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t6);
      }
      this.cached = e11, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e11) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e11);
    }
  }
  async batchSubscribe(e11) {
    e11.length && (await this.rpcBatchSubscribe(e11), this.onBatchSubscribe(await Promise.all(e11.map(async (t6) => He2(ge2({}, t6), { id: await this.getSubscriptionId(t6.topic) })))));
  }
  async batchFetchMessages(e11) {
    if (!e11.length) return;
    this.logger.trace(`Fetching batch messages for ${e11.length} subscriptions`);
    const t6 = await this.rpcBatchFetchMessages(e11);
    t6 && t6.messages && (await pi((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t6.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
  async restartToComplete(e11) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e11), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e11) {
    return zc(e11 + await this.getClientId());
  }
};
var to2 = Object.defineProperty;
var Pi2 = Object.getOwnPropertySymbols;
var io2 = Object.prototype.hasOwnProperty;
var so2 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r8, e11, t6) => e11 in r8 ? to2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var Si2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) io2.call(e11, t6) && Ye2(r8, t6, e11[t6]);
  if (Pi2) for (var t6 of Pi2(e11)) so2.call(e11, t6) && Ye2(r8, t6, e11[t6]);
  return r8;
};
var y4 = (r8, e11, t6) => Ye2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Oi2 = class extends d {
  constructor(e11) {
    super(e11), y4(this, "protocol", "wc"), y4(this, "version", 2), y4(this, "core"), y4(this, "logger"), y4(this, "events", new import_events3.EventEmitter()), y4(this, "provider"), y4(this, "messages"), y4(this, "subscriber"), y4(this, "publisher"), y4(this, "name", $t2), y4(this, "transportExplicitlyClosed", false), y4(this, "initialized", false), y4(this, "connectionAttemptInProgress", false), y4(this, "relayUrl"), y4(this, "projectId"), y4(this, "packageName"), y4(this, "bundleId"), y4(this, "hasExperiencedNetworkDisruption", false), y4(this, "pingTimeout"), y4(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), y4(this, "reconnectTimeout"), y4(this, "connectPromise"), y4(this, "reconnectInProgress", false), y4(this, "requestsInFlight", []), y4(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), y4(this, "request", async (t6) => {
      var i9, s5;
      this.logger.debug("Publishing Request Payload");
      const n5 = t6.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n5, method: t6.method, topic: (i9 = t6.params) == null ? void 0 : i9.topic }, "relayer.request - publishing...");
        const o6 = `${n5}:${((s5 = t6.params) == null ? void 0 : s5.tag) || ""}`;
        this.requestsInFlight.push(o6);
        const a6 = await this.provider.request(t6);
        return this.requestsInFlight = this.requestsInFlight.filter((c9) => c9 !== o6), a6;
      } catch (o6) {
        throw this.logger.debug(`Failed to Publish Request: ${n5}`), o6;
      }
    }), y4(this, "resetPingTimeout", () => {
      Ye() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t6, i9, s5, n5;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n5 = (s5 = (i9 = (t6 = this.provider) == null ? void 0 : t6.connection) == null ? void 0 : i9.socket) == null ? void 0 : s5.terminate) == null || n5.call(s5);
        } catch (o6) {
          this.logger.warn(o6, o6 == null ? void 0 : o6.message);
        }
      }, this.heartBeatTimeout));
    }), y4(this, "onPayloadHandler", (t6) => {
      this.onProviderPayload(t6), this.resetPingTimeout();
    }), y4(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C2.connect);
    }), y4(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y4(this, "onProviderErrorHandler", (t6) => {
      this.logger.fatal(`Fatal socket error: ${t6.message}`), this.events.emit(C2.error, t6), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y4(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e11.core, this.logger = typeof e11.logger < "u" && typeof e11.logger != "string" ? E(e11.logger, this.name) : (0, import_pino.default)(k({ level: e11.logger || Nt2 })), this.messages = new Ei2(this.logger, e11.core), this.subscriber = new Ci2(this, this.logger), this.publisher = new Gn(this, this.logger), this.relayUrl = (e11 == null ? void 0 : e11.relayUrl) || Ue2, this.projectId = e11.projectId, Ms() ? this.packageName = qs() : Vs() && (this.bundleId = qs()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e11) => this.logger.warn(e11, e11 == null ? void 0 : e11.message));
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e11, t6, i9;
    return ((i9 = (t6 = (e11 = this.provider) == null ? void 0 : e11.connection) == null ? void 0 : t6.socket) == null ? void 0 : i9.readyState) === 1 || false;
  }
  get connecting() {
    var e11, t6, i9;
    return ((i9 = (t6 = (e11 = this.provider) == null ? void 0 : e11.connection) == null ? void 0 : t6.socket) == null ? void 0 : i9.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e11, t6, i9) {
    this.isInitialized(), await this.publisher.publish(e11, t6, i9), await this.recordMessageEvent({ topic: e11, message: t6, publishedAt: Date.now(), transportType: Q2.relay }, le2.outbound);
  }
  async subscribe(e11, t6) {
    var i9, s5, n5;
    this.isInitialized(), (!(t6 != null && t6.transportType) || (t6 == null ? void 0 : t6.transportType) === "relay") && await this.toEstablishConnection();
    const o6 = typeof ((i9 = t6 == null ? void 0 : t6.internal) == null ? void 0 : i9.throwOnFailedPublish) > "u" ? true : (s5 = t6 == null ? void 0 : t6.internal) == null ? void 0 : s5.throwOnFailedPublish;
    let a6 = ((n5 = this.subscriber.topicMap.get(e11)) == null ? void 0 : n5[0]) || "", c9;
    const h9 = (l9) => {
      l9.topic === e11 && (this.subscriber.off($.created, h9), c9());
    };
    return await Promise.all([new Promise((l9) => {
      c9 = l9, this.subscriber.on($.created, h9);
    }), new Promise(async (l9, d7) => {
      a6 = await this.subscriber.subscribe(e11, Si2({ internal: { throwOnFailedPublish: o6 } }, t6)).catch((g4) => {
        o6 && d7(g4);
      }) || a6, l9();
    })]), a6;
  }
  async unsubscribe(e11, t6) {
    this.isInitialized(), await this.subscriber.unsubscribe(e11, t6);
  }
  on(e11, t6) {
    this.events.on(e11, t6);
  }
  once(e11, t6) {
    this.events.once(e11, t6);
  }
  off(e11, t6) {
    this.events.off(e11, t6);
  }
  removeListener(e11, t6) {
    this.events.removeListener(e11, t6);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await ni(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e11) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t6, i9) => {
      await this.connect(e11).then(t6).catch(i9).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e11) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e11 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await ja()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e11) {
    if ((e11 == null ? void 0 : e11.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t6 = e11.sort((i9, s5) => i9.publishedAt - s5.publishedAt);
    this.logger.debug(`Batch of ${t6.length} message events sorted`);
    for (const i9 of t6) try {
      await this.onMessageEvent(i9);
    } catch (s5) {
      this.logger.warn(s5, "Error while processing batch message event: " + (s5 == null ? void 0 : s5.message));
    }
    this.logger.trace(`Batch of ${t6.length} message events processed`);
  }
  async onLinkMessageEvent(e11, t6) {
    const { topic: i9 } = e11;
    if (!t6.sessionExists) {
      const s5 = ii(import_time2.FIVE_MINUTES), n5 = { topic: i9, expiry: s5, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i9, n5);
    }
    this.events.emit(C2.message, e11), await this.recordMessageEvent(e11, le2.inbound);
  }
  async connect(e11) {
    await this.confirmOnlineStateOrThrow(), e11 && e11 !== this.relayUrl && (this.relayUrl = e11, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t6 = 1;
    for (; t6 < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t6}...`), await this.createProvider(), await new Promise(async (i9, s5) => {
          const n5 = () => {
            s5(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(L.disconnect, n5), await ni(new Promise((o6, a6) => {
            this.provider.connect().then(o6).catch(a6);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o6) => {
            s5(o6);
          }).finally(() => {
            this.provider.off(L.disconnect, n5), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o6, a6) => {
            const c9 = () => {
              s5(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c9), await this.subscriber.start().then(o6).catch(a6).finally(() => {
              this.provider.off(L.disconnect, c9);
            });
          }), this.hasExperiencedNetworkDisruption = false, i9();
        });
      } catch (i9) {
        await this.subscriber.stop();
        const s5 = i9;
        this.logger.warn({}, s5.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t6}`);
        break;
      }
      await new Promise((i9) => setTimeout(i9, (0, import_time2.toMiliseconds)(t6 * 1))), t6++;
    }
  }
  startPingTimeout() {
    var e11, t6, i9, s5, n5;
    if (Ye()) try {
      (t6 = (e11 = this.provider) == null ? void 0 : e11.connection) != null && t6.socket && ((n5 = (s5 = (i9 = this.provider) == null ? void 0 : i9.connection) == null ? void 0 : s5.socket) == null || n5.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o6) {
      this.logger.warn(o6, o6 == null ? void 0 : o6.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e11 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(zs({ sdkVersion: _e2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e11, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e11, t6) {
    const { topic: i9, message: s5 } = e11;
    await this.messages.set(i9, s5, t6);
  }
  async shouldIgnoreMessageEvent(e11) {
    const { topic: t6, message: i9 } = e11;
    if (!i9 || i9.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i9}`), true;
    if (!await this.subscriber.isKnownTopic(t6)) return this.logger.warn(`Ignoring message for unknown topic ${t6}`), true;
    const s5 = this.messages.has(t6, i9);
    return s5 && this.logger.warn(`Ignoring duplicate message: ${i9}`), s5;
  }
  async onProviderPayload(e11) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e11 }), isJsonRpcRequest(e11)) {
      if (!e11.method.endsWith(zt2)) return;
      const t6 = e11.params, { topic: i9, message: s5, publishedAt: n5, attestation: o6 } = t6.data, a6 = { topic: i9, message: s5, publishedAt: n5, transportType: Q2.relay, attestation: o6 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Si2({ type: "event", event: t6.id }, a6)), this.events.emit(t6.id, a6), await this.acknowledgePayload(e11), await this.onMessageEvent(a6);
    } else isJsonRpcResponse(e11) && this.events.emit(C2.message_ack, e11);
  }
  async onMessageEvent(e11) {
    await this.shouldIgnoreMessageEvent(e11) || (await this.recordMessageEvent(e11, le2.inbound), this.events.emit(C2.message, e11));
  }
  async acknowledgePayload(e11) {
    const t6 = formatJsonRpcResult(e11.id, true);
    await this.provider.connection.send(t6);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e11 = await ja();
    ka(async (t6) => {
      e11 !== t6 && (e11 = t6, t6 ? await this.transportOpen().catch((i9) => this.logger.error(i9, i9 == null ? void 0 : i9.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Pa()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t6) {
        this.logger.warn(t6, t6 == null ? void 0 : t6.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C2.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e11) => this.logger.error(e11, e11 == null ? void 0 : e11.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(Lt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function ro2(r8, e11) {
  return r8 === e11 || Number.isNaN(r8) && Number.isNaN(e11);
}
function Ri2(r8) {
  return Object.getOwnPropertySymbols(r8).filter((e11) => Object.prototype.propertyIsEnumerable.call(r8, e11));
}
function Ai2(r8) {
  return r8 == null ? r8 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r8);
}
var no2 = "[object RegExp]";
var oo2 = "[object String]";
var ao2 = "[object Number]";
var co2 = "[object Boolean]";
var xi2 = "[object Arguments]";
var ho2 = "[object Symbol]";
var lo2 = "[object Date]";
var uo2 = "[object Map]";
var go2 = "[object Set]";
var po2 = "[object Array]";
var yo2 = "[object Function]";
var bo2 = "[object ArrayBuffer]";
var Je = "[object Object]";
var mo2 = "[object Error]";
var fo2 = "[object DataView]";
var Do2 = "[object Uint8Array]";
var vo2 = "[object Uint8ClampedArray]";
var wo2 = "[object Uint16Array]";
var _o2 = "[object Uint32Array]";
var Eo2 = "[object BigUint64Array]";
var Io2 = "[object Int8Array]";
var To2 = "[object Int16Array]";
var Co2 = "[object Int32Array]";
var Po3 = "[object BigInt64Array]";
var So2 = "[object Float32Array]";
var Oo2 = "[object Float64Array]";
function Ro2() {
}
function Ni2(r8) {
  if (!r8 || typeof r8 != "object") return false;
  const e11 = Object.getPrototypeOf(r8);
  return e11 === null || e11 === Object.prototype || Object.getPrototypeOf(e11) === null ? Object.prototype.toString.call(r8) === "[object Object]" : false;
}
function Ao2(r8, e11, t6) {
  return pe2(r8, e11, void 0, void 0, void 0, void 0, t6);
}
function pe2(r8, e11, t6, i9, s5, n5, o6) {
  const a6 = o6(r8, e11, t6, i9, s5, n5);
  if (a6 !== void 0) return a6;
  if (typeof r8 == typeof e11) switch (typeof r8) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r8 === e11;
    case "number":
      return r8 === e11 || Object.is(r8, e11);
    case "function":
      return r8 === e11;
    case "object":
      return ye2(r8, e11, n5, o6);
  }
  return ye2(r8, e11, n5, o6);
}
function ye2(r8, e11, t6, i9) {
  if (Object.is(r8, e11)) return true;
  let s5 = Ai2(r8), n5 = Ai2(e11);
  if (s5 === xi2 && (s5 = Je), n5 === xi2 && (n5 = Je), s5 !== n5) return false;
  switch (s5) {
    case oo2:
      return r8.toString() === e11.toString();
    case ao2: {
      const c9 = r8.valueOf(), h9 = e11.valueOf();
      return ro2(c9, h9);
    }
    case co2:
    case lo2:
    case ho2:
      return Object.is(r8.valueOf(), e11.valueOf());
    case no2:
      return r8.source === e11.source && r8.flags === e11.flags;
    case yo2:
      return r8 === e11;
  }
  t6 = t6 ?? /* @__PURE__ */ new Map();
  const o6 = t6.get(r8), a6 = t6.get(e11);
  if (o6 != null && a6 != null) return o6 === e11;
  t6.set(r8, e11), t6.set(e11, r8);
  try {
    switch (s5) {
      case uo2: {
        if (r8.size !== e11.size) return false;
        for (const [c9, h9] of r8.entries()) if (!e11.has(c9) || !pe2(h9, e11.get(c9), c9, r8, e11, t6, i9)) return false;
        return true;
      }
      case go2: {
        if (r8.size !== e11.size) return false;
        const c9 = Array.from(r8.values()), h9 = Array.from(e11.values());
        for (let l9 = 0; l9 < c9.length; l9++) {
          const d7 = c9[l9], g4 = h9.findIndex((_6) => pe2(d7, _6, void 0, r8, e11, t6, i9));
          if (g4 === -1) return false;
          h9.splice(g4, 1);
        }
        return true;
      }
      case po2:
      case Do2:
      case vo2:
      case wo2:
      case _o2:
      case Eo2:
      case Io2:
      case To2:
      case Co2:
      case Po3:
      case So2:
      case Oo2: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r8) !== Buffer.isBuffer(e11) || r8.length !== e11.length) return false;
        for (let c9 = 0; c9 < r8.length; c9++) if (!pe2(r8[c9], e11[c9], c9, r8, e11, t6, i9)) return false;
        return true;
      }
      case bo2:
        return r8.byteLength !== e11.byteLength ? false : ye2(new Uint8Array(r8), new Uint8Array(e11), t6, i9);
      case fo2:
        return r8.byteLength !== e11.byteLength || r8.byteOffset !== e11.byteOffset ? false : ye2(new Uint8Array(r8), new Uint8Array(e11), t6, i9);
      case mo2:
        return r8.name === e11.name && r8.message === e11.message;
      case Je: {
        if (!(ye2(r8.constructor, e11.constructor, t6, i9) || Ni2(r8) && Ni2(e11))) return false;
        const h9 = [...Object.keys(r8), ...Ri2(r8)], l9 = [...Object.keys(e11), ...Ri2(e11)];
        if (h9.length !== l9.length) return false;
        for (let d7 = 0; d7 < h9.length; d7++) {
          const g4 = h9[d7], _6 = r8[g4];
          if (!Object.hasOwn(e11, g4)) return false;
          const u10 = e11[g4];
          if (!pe2(_6, u10, g4, r8, e11, t6, i9)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t6.delete(r8), t6.delete(e11);
  }
}
function xo2(r8, e11) {
  return Ao2(r8, e11, Ro2);
}
var No2 = Object.defineProperty;
var $i2 = Object.getOwnPropertySymbols;
var $o2 = Object.prototype.hasOwnProperty;
var zo2 = Object.prototype.propertyIsEnumerable;
var Xe2 = (r8, e11, t6) => e11 in r8 ? No2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var zi2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) $o2.call(e11, t6) && Xe2(r8, t6, e11[t6]);
  if ($i2) for (var t6 of $i2(e11)) zo2.call(e11, t6) && Xe2(r8, t6, e11[t6]);
  return r8;
};
var z2 = (r8, e11, t6) => Xe2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Li2 = class extends f3 {
  constructor(e11, t6, i9, s5 = B, n5 = void 0) {
    super(e11, t6, i9, s5), this.core = e11, this.logger = t6, this.name = i9, z2(this, "map", /* @__PURE__ */ new Map()), z2(this, "version", kt2), z2(this, "cached", []), z2(this, "initialized", false), z2(this, "getKey"), z2(this, "storagePrefix", B), z2(this, "recentlyDeleted", []), z2(this, "recentlyDeletedLimit", 200), z2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o6) => {
        this.getKey && o6 !== null && !kt(o6) ? this.map.set(this.getKey(o6), o6) : wa(o6) ? this.map.set(o6.id, o6) : xa(o6) && this.map.set(o6.topic, o6);
      }), this.cached = [], this.initialized = true);
    }), z2(this, "set", async (o6, a6) => {
      this.isInitialized(), this.map.has(o6) ? await this.update(o6, a6) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o6, value: a6 }), this.map.set(o6, a6), await this.persist());
    }), z2(this, "get", (o6) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o6 }), this.getData(o6))), z2(this, "getAll", (o6) => (this.isInitialized(), o6 ? this.values.filter((a6) => Object.keys(o6).every((c9) => xo2(a6[c9], o6[c9]))) : this.values)), z2(this, "update", async (o6, a6) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o6, update: a6 });
      const c9 = zi2(zi2({}, this.getData(o6)), a6);
      this.map.set(o6, c9), await this.persist();
    }), z2(this, "delete", async (o6, a6) => {
      this.isInitialized(), this.map.has(o6) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o6, reason: a6 }), this.map.delete(o6), this.addToRecentlyDeleted(o6), await this.persist());
    }), this.logger = E(t6, this.name), this.storagePrefix = s5, this.getKey = n5;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e11) {
    this.recentlyDeleted.push(e11), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e11) {
    await this.core.storage.setItem(this.storageKey, e11);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e11) {
    const t6 = this.map.get(e11);
    if (!t6) {
      if (this.recentlyDeleted.includes(e11)) {
        const { message: s5 } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e11}`);
        throw this.logger.error(s5), new Error(s5);
      }
      const { message: i9 } = Et("NO_MATCHING_KEY", `${this.name}: ${e11}`);
      throw this.logger.error(i9), new Error(i9);
    }
    return t6;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e11 = await this.getDataStore();
      if (typeof e11 > "u" || !e11.length) return;
      if (this.map.size) {
        const { message: t6 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t6), new Error(t6);
      }
      this.cached = e11, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e11) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e11);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
};
var Lo2 = Object.defineProperty;
var ko2 = (r8, e11, t6) => e11 in r8 ? Lo2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var p2 = (r8, e11, t6) => ko2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var ki2 = class {
  constructor(e11, t6) {
    this.core = e11, this.logger = t6, p2(this, "name", Mt2), p2(this, "version", Kt2), p2(this, "events", new import_events3.default()), p2(this, "pairings"), p2(this, "initialized", false), p2(this, "storagePrefix", B), p2(this, "ignoredPayloadTypes", [ee]), p2(this, "registeredMethods", []), p2(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p2(this, "register", ({ methods: i9 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i9])];
    }), p2(this, "create", async (i9) => {
      this.isInitialized();
      const s5 = qc(), n5 = await this.core.crypto.setSymKey(s5), o6 = ii(import_time2.FIVE_MINUTES), a6 = { protocol: xt2 }, c9 = { topic: n5, expiry: o6, relay: a6, active: false, methods: i9 == null ? void 0 : i9.methods }, h9 = oa({ protocol: this.core.protocol, version: this.core.version, topic: n5, symKey: s5, relay: a6, expiryTimestamp: o6, methods: i9 == null ? void 0 : i9.methods });
      return this.events.emit(re.create, c9), this.core.expirer.set(n5, o6), await this.pairings.set(n5, c9), await this.core.relayer.subscribe(n5, { transportType: i9 == null ? void 0 : i9.transportType }), { topic: n5, uri: h9 };
    }), p2(this, "pair", async (i9) => {
      this.isInitialized();
      const s5 = this.core.eventClient.createEvent({ properties: { topic: i9 == null ? void 0 : i9.uri, trace: [G2.pairing_started] } });
      this.isValidPair(i9, s5);
      const { topic: n5, symKey: o6, relay: a6, expiryTimestamp: c9, methods: h9 } = ra(i9.uri);
      s5.props.properties.topic = n5, s5.addTrace(G2.pairing_uri_validation_success), s5.addTrace(G2.pairing_uri_not_expired);
      let l9;
      if (this.pairings.keys.includes(n5)) {
        if (l9 = this.pairings.get(n5), s5.addTrace(G2.existing_pairing), l9.active) throw s5.setError(Y2.active_pairing_already_exists), new Error(`Pairing already exists: ${n5}. Please try again with a new connection URI.`);
        s5.addTrace(G2.pairing_not_expired);
      }
      const d7 = c9 || ii(import_time2.FIVE_MINUTES), g4 = { topic: n5, relay: a6, expiry: d7, active: false, methods: h9 };
      this.core.expirer.set(n5, d7), await this.pairings.set(n5, g4), s5.addTrace(G2.store_new_pairing), i9.activatePairing && await this.activate({ topic: n5 }), this.events.emit(re.create, g4), s5.addTrace(G2.emit_inactive_pairing), this.core.crypto.keychain.has(n5) || await this.core.crypto.setSymKey(o6, n5), s5.addTrace(G2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s5.setError(Y2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n5, { relay: a6 });
      } catch (_6) {
        throw s5.setError(Y2.subscribe_pairing_topic_failure), _6;
      }
      return s5.addTrace(G2.subscribe_pairing_topic_success), g4;
    }), p2(this, "activate", async ({ topic: i9 }) => {
      this.isInitialized();
      const s5 = ii(import_time2.FIVE_MINUTES);
      this.core.expirer.set(i9, s5), await this.pairings.update(i9, { active: true, expiry: s5 });
    }), p2(this, "ping", async (i9) => {
      this.isInitialized(), await this.isValidPing(i9), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s5 } = i9;
      if (this.pairings.keys.includes(s5)) {
        const n5 = await this.sendRequest(s5, "wc_pairingPing", {}), { done: o6, resolve: a6, reject: c9 } = ei();
        this.events.once(ci("pairing_ping", n5), ({ error: h9 }) => {
          h9 ? c9(h9) : a6();
        }), await o6();
      }
    }), p2(this, "updateExpiry", async ({ topic: i9, expiry: s5 }) => {
      this.isInitialized(), await this.pairings.update(i9, { expiry: s5 });
    }), p2(this, "updateMetadata", async ({ topic: i9, metadata: s5 }) => {
      this.isInitialized(), await this.pairings.update(i9, { peerMetadata: s5 });
    }), p2(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p2(this, "disconnect", async (i9) => {
      this.isInitialized(), await this.isValidDisconnect(i9);
      const { topic: s5 } = i9;
      this.pairings.keys.includes(s5) && (await this.sendRequest(s5, "wc_pairingDelete", Kt("USER_DISCONNECTED")), await this.deletePairing(s5));
    }), p2(this, "formatUriFromPairing", (i9) => {
      this.isInitialized();
      const { topic: s5, relay: n5, expiry: o6, methods: a6 } = i9, c9 = this.core.crypto.keychain.get(s5);
      return oa({ protocol: this.core.protocol, version: this.core.version, topic: s5, symKey: c9, relay: n5, expiryTimestamp: o6, methods: a6 });
    }), p2(this, "sendRequest", async (i9, s5, n5) => {
      const o6 = formatJsonRpcRequest(s5, n5), a6 = await this.core.crypto.encode(i9, o6), c9 = se2[s5].req;
      return this.core.history.set(i9, o6), this.core.relayer.publish(i9, a6, c9), o6.id;
    }), p2(this, "sendResult", async (i9, s5, n5) => {
      const o6 = formatJsonRpcResult(i9, n5), a6 = await this.core.crypto.encode(s5, o6), c9 = (await this.core.history.get(s5, i9)).request.method, h9 = se2[c9].res;
      await this.core.relayer.publish(s5, a6, h9), await this.core.history.resolve(o6);
    }), p2(this, "sendError", async (i9, s5, n5) => {
      const o6 = formatJsonRpcError(i9, n5), a6 = await this.core.crypto.encode(s5, o6), c9 = (await this.core.history.get(s5, i9)).request.method, h9 = se2[c9] ? se2[c9].res : se2.unregistered_method.res;
      await this.core.relayer.publish(s5, a6, h9), await this.core.history.resolve(o6);
    }), p2(this, "deletePairing", async (i9, s5) => {
      await this.core.relayer.unsubscribe(i9), await Promise.all([this.pairings.delete(i9, Kt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i9), s5 ? Promise.resolve() : this.core.expirer.del(i9)]);
    }), p2(this, "cleanup", async () => {
      const i9 = this.pairings.getAll().filter((s5) => fi(s5.expiry));
      await Promise.all(i9.map((s5) => this.deletePairing(s5.topic)));
    }), p2(this, "onRelayEventRequest", async (i9) => {
      const { topic: s5, payload: n5 } = i9;
      switch (n5.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s5, n5);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s5, n5);
        default:
          return await this.onUnknownRpcMethodRequest(s5, n5);
      }
    }), p2(this, "onRelayEventResponse", async (i9) => {
      const { topic: s5, payload: n5 } = i9, o6 = (await this.core.history.get(s5, n5.id)).request.method;
      switch (o6) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s5, n5);
        default:
          return this.onUnknownRpcMethodResponse(o6);
      }
    }), p2(this, "onPairingPingRequest", async (i9, s5) => {
      const { id: n5 } = s5;
      try {
        this.isValidPing({ topic: i9 }), await this.sendResult(n5, i9, true), this.events.emit(re.ping, { id: n5, topic: i9 });
      } catch (o6) {
        await this.sendError(n5, i9, o6), this.logger.error(o6);
      }
    }), p2(this, "onPairingPingResponse", (i9, s5) => {
      const { id: n5 } = s5;
      setTimeout(() => {
        isJsonRpcResult(s5) ? this.events.emit(ci("pairing_ping", n5), {}) : isJsonRpcError(s5) && this.events.emit(ci("pairing_ping", n5), { error: s5.error });
      }, 500);
    }), p2(this, "onPairingDeleteRequest", async (i9, s5) => {
      const { id: n5 } = s5;
      try {
        this.isValidDisconnect({ topic: i9 }), await this.deletePairing(i9), this.events.emit(re.delete, { id: n5, topic: i9 });
      } catch (o6) {
        await this.sendError(n5, i9, o6), this.logger.error(o6);
      }
    }), p2(this, "onUnknownRpcMethodRequest", async (i9, s5) => {
      const { id: n5, method: o6 } = s5;
      try {
        if (this.registeredMethods.includes(o6)) return;
        const a6 = Kt("WC_METHOD_UNSUPPORTED", o6);
        await this.sendError(n5, i9, a6), this.logger.error(a6);
      } catch (a6) {
        await this.sendError(n5, i9, a6), this.logger.error(a6);
      }
    }), p2(this, "onUnknownRpcMethodResponse", (i9) => {
      this.registeredMethods.includes(i9) || this.logger.error(Kt("WC_METHOD_UNSUPPORTED", i9));
    }), p2(this, "isValidPair", (i9, s5) => {
      var n5;
      if (!Aa(i9)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `pair() params: ${i9}`);
        throw s5.setError(Y2.malformed_pairing_uri), new Error(a6);
      }
      if (!ma(i9.uri)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `pair() uri: ${i9.uri}`);
        throw s5.setError(Y2.malformed_pairing_uri), new Error(a6);
      }
      const o6 = ra(i9 == null ? void 0 : i9.uri);
      if (!((n5 = o6 == null ? void 0 : o6.relay) != null && n5.protocol)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s5.setError(Y2.malformed_pairing_uri), new Error(a6);
      }
      if (!(o6 != null && o6.symKey)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s5.setError(Y2.malformed_pairing_uri), new Error(a6);
      }
      if (o6 != null && o6.expiryTimestamp && (0, import_time2.toMiliseconds)(o6 == null ? void 0 : o6.expiryTimestamp) < Date.now()) {
        s5.setError(Y2.pairing_expired);
        const { message: a6 } = Et("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a6);
      }
    }), p2(this, "isValidPing", async (i9) => {
      if (!Aa(i9)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `ping() params: ${i9}`);
        throw new Error(n5);
      }
      const { topic: s5 } = i9;
      await this.isValidPairingTopic(s5);
    }), p2(this, "isValidDisconnect", async (i9) => {
      if (!Aa(i9)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `disconnect() params: ${i9}`);
        throw new Error(n5);
      }
      const { topic: s5 } = i9;
      await this.isValidPairingTopic(s5);
    }), p2(this, "isValidPairingTopic", async (i9) => {
      if (!it(i9, false)) {
        const { message: s5 } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${i9}`);
        throw new Error(s5);
      }
      if (!this.pairings.keys.includes(i9)) {
        const { message: s5 } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i9}`);
        throw new Error(s5);
      }
      if (fi(this.pairings.get(i9).expiry)) {
        await this.deletePairing(i9);
        const { message: s5 } = Et("EXPIRED", `pairing topic: ${i9}`);
        throw new Error(s5);
      }
    }), this.core = e11, this.logger = E(t6, this.name), this.pairings = new Li2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C2.message, async (e11) => {
      const { topic: t6, message: i9, transportType: s5 } = e11;
      if (this.pairings.keys.includes(t6) && s5 !== Q2.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i9))) try {
        const n5 = await this.core.crypto.decode(t6, i9);
        isJsonRpcRequest(n5) ? (this.core.history.set(t6, n5), await this.onRelayEventRequest({ topic: t6, payload: n5 })) : isJsonRpcResponse(n5) && (await this.core.history.resolve(n5), await this.onRelayEventResponse({ topic: t6, payload: n5 }), this.core.history.delete(t6, n5.id)), await this.core.relayer.messages.ack(t6, i9);
      } catch (n5) {
        this.logger.error(n5);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M2.expired, async (e11) => {
      const { topic: t6 } = si(e11.target);
      t6 && this.pairings.keys.includes(t6) && (await this.deletePairing(t6, true), this.events.emit(re.expire, { topic: t6 }));
    });
  }
};
var jo2 = Object.defineProperty;
var Uo2 = (r8, e11, t6) => e11 in r8 ? jo2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var O3 = (r8, e11, t6) => Uo2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var ji2 = class extends I {
  constructor(e11, t6) {
    super(e11, t6), this.core = e11, this.logger = t6, O3(this, "records", /* @__PURE__ */ new Map()), O3(this, "events", new import_events3.EventEmitter()), O3(this, "name", Bt2), O3(this, "version", Vt2), O3(this, "cached", []), O3(this, "initialized", false), O3(this, "storagePrefix", B), O3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i9) => this.records.set(i9.id, i9)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), O3(this, "set", (i9, s5, n5) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i9, request: s5, chainId: n5 }), this.records.has(s5.id)) return;
      const o6 = { id: s5.id, topic: i9, request: { method: s5.method, params: s5.params || null }, chainId: n5, expiry: ii(import_time2.THIRTY_DAYS) };
      this.records.set(o6.id, o6), this.persist(), this.events.emit(F2.created, o6);
    }), O3(this, "resolve", async (i9) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i9 }), !this.records.has(i9.id)) return;
      const s5 = await this.getRecord(i9.id);
      typeof s5.response > "u" && (s5.response = isJsonRpcError(i9) ? { error: i9.error } : { result: i9.result }, this.records.set(s5.id, s5), this.persist(), this.events.emit(F2.updated, s5));
    }), O3(this, "get", async (i9, s5) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i9, id: s5 }), await this.getRecord(s5))), O3(this, "delete", (i9, s5) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s5 }), this.values.forEach((n5) => {
        if (n5.topic === i9) {
          if (typeof s5 < "u" && n5.id !== s5) return;
          this.records.delete(n5.id), this.events.emit(F2.deleted, n5);
        }
      }), this.persist();
    }), O3(this, "exists", async (i9, s5) => (this.isInitialized(), this.records.has(s5) ? (await this.getRecord(s5)).topic === i9 : false)), O3(this, "on", (i9, s5) => {
      this.events.on(i9, s5);
    }), O3(this, "once", (i9, s5) => {
      this.events.once(i9, s5);
    }), O3(this, "off", (i9, s5) => {
      this.events.off(i9, s5);
    }), O3(this, "removeListener", (i9, s5) => {
      this.events.removeListener(i9, s5);
    }), this.logger = E(t6, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e11 = [];
    return this.values.forEach((t6) => {
      if (typeof t6.response < "u") return;
      const i9 = { topic: t6.topic, request: formatJsonRpcRequest(t6.request.method, t6.request.params, t6.id), chainId: t6.chainId };
      return e11.push(i9);
    }), e11;
  }
  async setJsonRpcRecords(e11) {
    await this.core.storage.setItem(this.storageKey, e11);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e11) {
    this.isInitialized();
    const t6 = this.records.get(e11);
    if (!t6) {
      const { message: i9 } = Et("NO_MATCHING_KEY", `${this.name}: ${e11}`);
      throw new Error(i9);
    }
    return t6;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
  }
  async restore() {
    try {
      const e11 = await this.getJsonRpcRecords();
      if (typeof e11 > "u" || !e11.length) return;
      if (this.records.size) {
        const { message: t6 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t6), new Error(t6);
      }
      this.cached = e11, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e11) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e11);
    }
  }
  registerEventListeners() {
    this.events.on(F2.created, (e11) => {
      const t6 = F2.created;
      this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, record: e11 });
    }), this.events.on(F2.updated, (e11) => {
      const t6 = F2.updated;
      this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, record: e11 });
    }), this.events.on(F2.deleted, (e11) => {
      const t6 = F2.deleted;
      this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, record: e11 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e11 = false;
      this.records.forEach((t6) => {
        (0, import_time2.toMiliseconds)(t6.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t6.id}`), this.records.delete(t6.id), this.events.emit(F2.deleted, t6, false), e11 = true);
      }), e11 && this.persist();
    } catch (e11) {
      this.logger.warn(e11);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
};
var Fo2 = Object.defineProperty;
var Mo2 = (r8, e11, t6) => e11 in r8 ? Fo2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var A2 = (r8, e11, t6) => Mo2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Ui2 = class extends S {
  constructor(e11, t6) {
    super(e11, t6), this.core = e11, this.logger = t6, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events3.EventEmitter()), A2(this, "name", qt2), A2(this, "version", Gt2), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i9) => this.expirations.set(i9.target, i9)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i9) => {
      try {
        const s5 = this.formatTarget(i9);
        return typeof this.getExpiration(s5) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i9, s5) => {
      this.isInitialized();
      const n5 = this.formatTarget(i9), o6 = { target: n5, expiry: s5 };
      this.expirations.set(n5, o6), this.checkExpiry(n5, o6), this.events.emit(M2.created, { target: n5, expiration: o6 });
    }), A2(this, "get", (i9) => {
      this.isInitialized();
      const s5 = this.formatTarget(i9);
      return this.getExpiration(s5);
    }), A2(this, "del", (i9) => {
      if (this.isInitialized(), this.has(i9)) {
        const s5 = this.formatTarget(i9), n5 = this.getExpiration(s5);
        this.expirations.delete(s5), this.events.emit(M2.deleted, { target: s5, expiration: n5 });
      }
    }), A2(this, "on", (i9, s5) => {
      this.events.on(i9, s5);
    }), A2(this, "once", (i9, s5) => {
      this.events.once(i9, s5);
    }), A2(this, "off", (i9, s5) => {
      this.events.off(i9, s5);
    }), A2(this, "removeListener", (i9, s5) => {
      this.events.removeListener(i9, s5);
    }), this.logger = E(t6, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e11) {
    if (typeof e11 == "string") return ri(e11);
    if (typeof e11 == "number") return oi(e11);
    const { message: t6 } = Et("UNKNOWN_TYPE", `Target type: ${typeof e11}`);
    throw new Error(t6);
  }
  async setExpirations(e11) {
    await this.core.storage.setItem(this.storageKey, e11);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M2.sync);
  }
  async restore() {
    try {
      const e11 = await this.getExpirations();
      if (typeof e11 > "u" || !e11.length) return;
      if (this.expirations.size) {
        const { message: t6 } = Et("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t6), new Error(t6);
      }
      this.cached = e11, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e11) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e11);
    }
  }
  getExpiration(e11) {
    const t6 = this.expirations.get(e11);
    if (!t6) {
      const { message: i9 } = Et("NO_MATCHING_KEY", `${this.name}: ${e11}`);
      throw this.logger.warn(i9), new Error(i9);
    }
    return t6;
  }
  checkExpiry(e11, t6) {
    const { expiry: i9 } = t6;
    (0, import_time2.toMiliseconds)(i9) - Date.now() <= 0 && this.expire(e11, t6);
  }
  expire(e11, t6) {
    this.expirations.delete(e11), this.events.emit(M2.expired, { target: e11, expiration: t6 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e11, t6) => this.checkExpiry(t6, e11));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M2.created, (e11) => {
      const t6 = M2.created;
      this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e11 }), this.persist();
    }), this.events.on(M2.expired, (e11) => {
      const t6 = M2.expired;
      this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e11 }), this.persist();
    }), this.events.on(M2.deleted, (e11) => {
      const t6 = M2.deleted;
      this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e11 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e11 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(e11);
    }
  }
};
var Ko2 = Object.defineProperty;
var Bo2 = (r8, e11, t6) => e11 in r8 ? Ko2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var w = (r8, e11, t6) => Bo2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Fi2 = class extends M {
  constructor(e11, t6, i9) {
    super(e11, t6, i9), this.core = e11, this.logger = t6, this.store = i9, w(this, "name", Wt2), w(this, "abortController"), w(this, "isDevEnv"), w(this, "verifyUrlV3", Yt2), w(this, "storagePrefix", B), w(this, "version", Le2), w(this, "publicKey"), w(this, "fetchPromise"), w(this, "init", async () => {
      var s5;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((s5 = this.publicKey) == null ? void 0 : s5.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w(this, "register", async (s5) => {
      if (!zt() || this.isDevEnv) return;
      const n5 = window.location.origin, { id: o6, decryptedId: a6 } = s5, c9 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n5}&id=${o6}&decryptedId=${a6}`;
      try {
        const h9 = (0, import_window_getters2.getDocument)(), l9 = this.startAbortTimer(import_time2.ONE_SECOND * 5), d7 = await new Promise((g4, _6) => {
          const u10 = () => {
            window.removeEventListener("message", x7), h9.body.removeChild(b6), _6("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u10);
          const b6 = h9.createElement("iframe");
          b6.src = c9, b6.style.display = "none", b6.addEventListener("error", u10, { signal: this.abortController.signal });
          const x7 = (I8) => {
            if (I8.data && typeof I8.data == "string") try {
              const D9 = JSON.parse(I8.data);
              if (D9.type === "verify_attestation") {
                if (sn(D9.attestation).payload.id !== o6) return;
                clearInterval(l9), h9.body.removeChild(b6), this.abortController.signal.removeEventListener("abort", u10), window.removeEventListener("message", x7), g4(D9.attestation === null ? "" : D9.attestation);
              }
            } catch (D9) {
              this.logger.warn(D9);
            }
          };
          h9.body.appendChild(b6), window.addEventListener("message", x7, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d7), d7;
      } catch (h9) {
        this.logger.warn(h9);
      }
      return "";
    }), w(this, "resolve", async (s5) => {
      if (this.isDevEnv) return "";
      const { attestationId: n5, hash: o6, encryptedId: a6 } = s5;
      if (n5 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n5) {
        if (sn(n5).payload.id !== a6) return;
        const h9 = await this.isValidJwtAttestation(n5);
        if (h9) {
          if (!h9.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h9;
        }
      }
      if (!o6) return;
      const c9 = this.getVerifyUrl(s5 == null ? void 0 : s5.verifyUrl);
      return this.fetchAttestation(o6, c9);
    }), w(this, "fetchAttestation", async (s5, n5) => {
      this.logger.debug(`resolving attestation: ${s5} from url: ${n5}`);
      const o6 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a6 = await fetch(`${n5}/attestation/${s5}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o6), a6.status === 200 ? await a6.json() : void 0;
    }), w(this, "getVerifyUrl", (s5) => {
      let n5 = s5 || ue2;
      return Jt2.includes(n5) || (this.logger.info(`verify url: ${n5}, not included in trusted list, assigning default: ${ue2}`), n5 = ue2), n5;
    }), w(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s5 = this.startAbortTimer(import_time2.FIVE_SECONDS), n5 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s5), await n5.json();
      } catch (s5) {
        this.logger.warn(s5);
      }
    }), w(this, "persistPublicKey", async (s5) => {
      this.logger.debug("persisting public key to local storage", s5), await this.store.setItem(this.storeKey, s5), this.publicKey = s5;
    }), w(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w(this, "isValidJwtAttestation", async (s5) => {
      const n5 = await this.getPublicKey();
      try {
        if (n5) return this.validateAttestation(s5, n5);
      } catch (a6) {
        this.logger.error(a6), this.logger.warn("error validating attestation");
      }
      const o6 = await this.fetchAndPersistPublicKey();
      try {
        if (o6) return this.validateAttestation(s5, o6);
      } catch (a6) {
        this.logger.error(a6), this.logger.warn("error validating attestation");
      }
    }), w(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n5) => {
        const o6 = await this.fetchPublicKey();
        o6 && (await this.persistPublicKey(o6), n5(o6));
      });
      const s5 = await this.fetchPromise;
      return this.fetchPromise = void 0, s5;
    }), w(this, "validateAttestation", (s5, n5) => {
      const o6 = ta(s5, n5.publicKey), a6 = { hasExpired: (0, import_time2.toMiliseconds)(o6.exp) < Date.now(), payload: o6 };
      if (a6.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a6.payload.origin, isScam: a6.payload.isScam, isVerified: a6.payload.isVerified };
    }), this.logger = E(t6, this.name), this.abortController = new AbortController(), this.isDevEnv = hi(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e11) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e11));
  }
};
var Vo2 = Object.defineProperty;
var qo2 = (r8, e11, t6) => e11 in r8 ? Vo2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var Mi2 = (r8, e11, t6) => qo2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Ki2 = class extends O2 {
  constructor(e11, t6) {
    super(e11, t6), this.projectId = e11, this.logger = t6, Mi2(this, "context", Xt2), Mi2(this, "registerDeviceToken", async (i9) => {
      const { clientId: s5, token: n5, notificationType: o6, enableEncrypted: a6 = false } = i9, c9 = `${Zt2}/${this.projectId}/clients`;
      await fetch(c9, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s5, type: o6, token: n5, always_raw: a6 }) });
    }), this.logger = E(t6, this.context);
  }
};
var Go2 = Object.defineProperty;
var Bi2 = Object.getOwnPropertySymbols;
var Wo2 = Object.prototype.hasOwnProperty;
var Ho2 = Object.prototype.propertyIsEnumerable;
var Ze2 = (r8, e11, t6) => e11 in r8 ? Go2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var be2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) Wo2.call(e11, t6) && Ze2(r8, t6, e11[t6]);
  if (Bi2) for (var t6 of Bi2(e11)) Ho2.call(e11, t6) && Ze2(r8, t6, e11[t6]);
  return r8;
};
var E3 = (r8, e11, t6) => Ze2(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Vi2 = class extends R {
  constructor(e11, t6, i9 = true) {
    super(e11, t6, i9), this.core = e11, this.logger = t6, E3(this, "context", ei2), E3(this, "storagePrefix", B), E3(this, "storageVersion", Qt2), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!hi()) try {
        const s5 = { eventId: di(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cr(this.core.relayer.protocol, this.core.relayer.version, _e2) } } };
        await this.sendEvent([s5]);
      } catch (s5) {
        this.logger.warn(s5);
      }
    }), E3(this, "createEvent", (s5) => {
      const { event: n5 = "ERROR", type: o6 = "", properties: { topic: a6, trace: c9 } } = s5, h9 = di(), l9 = this.core.projectId || "", d7 = Date.now(), g4 = be2({ eventId: h9, timestamp: d7, props: { event: n5, type: o6, properties: { topic: a6, trace: c9 } }, bundleId: l9, domain: this.getAppDomain() }, this.setMethods(h9));
      return this.telemetryEnabled && (this.events.set(h9, g4), this.shouldPersist = true), g4;
    }), E3(this, "getEvent", (s5) => {
      const { eventId: n5, topic: o6 } = s5;
      if (n5) return this.events.get(n5);
      const a6 = Array.from(this.events.values()).find((c9) => c9.props.properties.topic === o6);
      if (a6) return be2(be2({}, a6), this.setMethods(a6.eventId));
    }), E3(this, "deleteEvent", (s5) => {
      const { eventId: n5 } = s5;
      this.events.delete(n5), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s5) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(s5.timestamp) > ti && (this.events.delete(s5.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (s5) => ({ addTrace: (n5) => this.addTrace(s5, n5), setError: (n5) => this.setError(s5, n5) })), E3(this, "addTrace", (s5, n5) => {
      const o6 = this.events.get(s5);
      o6 && (o6.props.properties.trace.push(n5), this.events.set(s5, o6), this.shouldPersist = true);
    }), E3(this, "setError", (s5, n5) => {
      const o6 = this.events.get(s5);
      o6 && (o6.props.type = n5, o6.timestamp = Date.now(), this.events.set(s5, o6), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const s5 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s5.length) return;
        s5.forEach((n5) => {
          this.events.set(n5.eventId, be2(be2({}, n5), this.setMethods(n5.eventId)));
        });
      } catch (s5) {
        this.logger.warn(s5);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s5 = [];
      for (const [n5, o6] of this.events) o6.props.type && s5.push(o6);
      if (s5.length !== 0) try {
        if ((await this.sendEvent(s5)).ok) for (const n5 of s5) this.events.delete(n5.eventId), this.shouldPersist = true;
      } catch (n5) {
        this.logger.warn(n5);
      }
    }), E3(this, "sendEvent", async (s5) => {
      const n5 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii2}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e2}${n5}`, { method: "POST", body: JSON.stringify(s5) });
    }), E3(this, "getAppDomain", () => sr().url), this.logger = E(t6, this.context), this.telemetryEnabled = i9, i9 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Yo2 = Object.defineProperty;
var qi2 = Object.getOwnPropertySymbols;
var Jo2 = Object.prototype.hasOwnProperty;
var Xo2 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r8, e11, t6) => e11 in r8 ? Yo2(r8, e11, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e11] = t6;
var Gi2 = (r8, e11) => {
  for (var t6 in e11 || (e11 = {})) Jo2.call(e11, t6) && Qe3(r8, t6, e11[t6]);
  if (qi2) for (var t6 of qi2(e11)) Xo2.call(e11, t6) && Qe3(r8, t6, e11[t6]);
  return r8;
};
var v2 = (r8, e11, t6) => Qe3(r8, typeof e11 != "symbol" ? e11 + "" : e11, t6);
var Te2 = class _Te extends h2 {
  constructor(e11) {
    var t6;
    super(e11), v2(this, "protocol", ze), v2(this, "version", Le2), v2(this, "name", he2), v2(this, "relayUrl"), v2(this, "projectId"), v2(this, "customStoragePrefix"), v2(this, "events", new import_events3.EventEmitter()), v2(this, "logger"), v2(this, "heartbeat"), v2(this, "relayer"), v2(this, "crypto"), v2(this, "storage"), v2(this, "history"), v2(this, "expirer"), v2(this, "pairing"), v2(this, "verify"), v2(this, "echoClient"), v2(this, "linkModeSupportedApps"), v2(this, "eventClient"), v2(this, "initialized", false), v2(this, "logChunkController"), v2(this, "on", (a6, c9) => this.events.on(a6, c9)), v2(this, "once", (a6, c9) => this.events.once(a6, c9)), v2(this, "off", (a6, c9) => this.events.off(a6, c9)), v2(this, "removeListener", (a6, c9) => this.events.removeListener(a6, c9)), v2(this, "dispatchEnvelope", ({ topic: a6, message: c9, sessionExists: h9 }) => {
      if (!a6 || !c9) return;
      const l9 = { topic: a6, message: c9, publishedAt: Date.now(), transportType: Q2.link_mode };
      this.relayer.onLinkMessageEvent(l9, { sessionExists: h9 });
    });
    const i9 = this.getGlobalCore(e11 == null ? void 0 : e11.customStoragePrefix);
    if (i9) try {
      return this.customStoragePrefix = i9.customStoragePrefix, this.logger = i9.logger, this.heartbeat = i9.heartbeat, this.crypto = i9.crypto, this.history = i9.history, this.expirer = i9.expirer, this.storage = i9.storage, this.relayer = i9.relayer, this.pairing = i9.pairing, this.verify = i9.verify, this.echoClient = i9.echoClient, this.linkModeSupportedApps = i9.linkModeSupportedApps, this.eventClient = i9.eventClient, this.initialized = i9.initialized, this.logChunkController = i9.logChunkController, i9;
    } catch (a6) {
      console.warn("Failed to copy global core", a6);
    }
    this.projectId = e11 == null ? void 0 : e11.projectId, this.relayUrl = (e11 == null ? void 0 : e11.relayUrl) || Ue2, this.customStoragePrefix = e11 != null && e11.customStoragePrefix ? `:${e11.customStoragePrefix}` : "";
    const s5 = k({ level: typeof (e11 == null ? void 0 : e11.logger) == "string" && e11.logger ? e11.logger : Et2.logger, name: he2 }), { logger: n5, chunkLoggerController: o6 } = A({ opts: s5, maxSizeInBytes: e11 == null ? void 0 : e11.maxLogBlobSizeInBytes, loggerOverride: e11 == null ? void 0 : e11.logger });
    this.logChunkController = o6, (t6 = this.logChunkController) != null && t6.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a6, c9;
      (a6 = this.logChunkController) != null && a6.downloadLogsBlobInBrowser && ((c9 = this.logChunkController) == null || c9.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(n5, this.name), this.heartbeat = new i(), this.crypto = new wi2(this, this.logger, e11 == null ? void 0 : e11.keychain), this.history = new ji2(this, this.logger), this.expirer = new Ui2(this, this.logger), this.storage = e11 != null && e11.storage ? e11.storage : new h(Gi2(Gi2({}, It2), e11 == null ? void 0 : e11.storageOptions)), this.relayer = new Oi2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ki2(this, this.logger), this.verify = new Fi2(this, this.logger, this.storage), this.echoClient = new Ki2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Vi2(this, this.logger, e11 == null ? void 0 : e11.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e11) {
    const t6 = new _Te(e11);
    await t6.initialize();
    const i9 = await t6.crypto.getClientId();
    return await t6.storage.setItem(jt2, i9), t6;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e11;
    return (e11 = this.logChunkController) == null ? void 0 : e11.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e11) {
    this.linkModeSupportedApps.includes(e11) || (this.linkModeSupportedApps.push(e11), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e11) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e11), this.logger.error(e11.message), e11;
    }
  }
  getGlobalCore(e11 = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t6 = `_walletConnectCore_${e11}`, i9 = `${t6}_count`;
      return globalThis[i9] = (globalThis[i9] || 0) + 1, globalThis[i9] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i9]} times.`), globalThis[t6];
    } catch (t6) {
      console.warn("Failed to get global WalletConnect core", t6);
      return;
    }
  }
  setGlobalCore(e11) {
    var t6;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i9 = `_walletConnectCore_${((t6 = e11.opts) == null ? void 0 : t6.customStoragePrefix) || ""}`;
      globalThis[i9] = e11;
    } catch (i9) {
      console.warn("Failed to set global WalletConnect core", i9);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Zo2 = Te2;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events4 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var Ce3 = "wc";
var ke3 = 2;
var De2 = "client";
var me2 = `${Ce3}@${ke3}:${De2}:`;
var we2 = { name: De2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Le3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ht2 = "proposal";
var Me3 = "Proposal expired";
var dt2 = "session";
var X2 = import_time3.SEVEN_DAYS;
var ut2 = "engine";
var N3 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var gt2 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var yt = "request";
var mt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var wt2 = "wc";
var _t2 = "auth";
var Et3 = "authKeys";
var ft = "pairingTopics";
var St3 = "requests";
var ae2 = `${wt2}@${1.5}:${_t2}:`;
var ce2 = `${ae2}:PUB_KEY`;
var Os = Object.defineProperty;
var bs2 = Object.defineProperties;
var As = Object.getOwnPropertyDescriptors;
var Rt3 = Object.getOwnPropertySymbols;
var xs2 = Object.prototype.hasOwnProperty;
var Vs2 = Object.prototype.propertyIsEnumerable;
var $e2 = (S8, o6, t6) => o6 in S8 ? Os(S8, o6, { enumerable: true, configurable: true, writable: true, value: t6 }) : S8[o6] = t6;
var I2 = (S8, o6) => {
  for (var t6 in o6 || (o6 = {})) xs2.call(o6, t6) && $e2(S8, t6, o6[t6]);
  if (Rt3) for (var t6 of Rt3(o6)) Vs2.call(o6, t6) && $e2(S8, t6, o6[t6]);
  return S8;
};
var x2 = (S8, o6) => bs2(S8, As(o6));
var c3 = (S8, o6, t6) => $e2(S8, typeof o6 != "symbol" ? o6 + "" : o6, t6);
var Cs2 = class extends V {
  constructor(o6) {
    super(o6), c3(this, "name", ut2), c3(this, "events", new import_events4.default()), c3(this, "initialized", false), c3(this, "requestQueue", { state: $2.idle, queue: [] }), c3(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c3(this, "emittedSessionRequests", new gi({ limit: 500 })), c3(this, "requestQueueDelay", import_time3.ONE_SECOND), c3(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c3(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c3(this, "recentlyDeletedLimit", 200), c3(this, "relayMessageCache", []), c3(this, "pendingSessions", /* @__PURE__ */ new Map()), c3(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N3) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c3(this, "connect", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const e11 = x2(I2({}, t6), { requiredNamespaces: t6.requiredNamespaces || {}, optionalNamespaces: t6.optionalNamespaces || {} });
      await this.isValidConnect(e11), e11.optionalNamespaces = ba(e11.requiredNamespaces, e11.optionalNamespaces), e11.requiredNamespaces = {};
      const { pairingTopic: s5, requiredNamespaces: i9, optionalNamespaces: r8, sessionProperties: n5, scopedProperties: a6, relays: l9 } = e11;
      let p9 = s5, h9, u10 = false;
      try {
        if (p9) {
          const T8 = this.client.core.pairing.pairings.get(p9);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u10 = T8.active;
        }
      } catch (T8) {
        throw this.client.logger.error(`connect() -> pairing.get(${p9}) failed`), T8;
      }
      if (!p9 || !u10) {
        const { topic: T8, uri: K5 } = await this.client.core.pairing.create();
        p9 = T8, h9 = K5;
      }
      if (!p9) {
        const { message: T8 } = Et("NO_MATCHING_KEY", `connect() pairing topic: ${p9}`);
        throw new Error(T8);
      }
      const d7 = await this.client.core.crypto.generateKeyPair(), w8 = N3.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, m6 = ii(w8), y11 = x2(I2(I2({ requiredNamespaces: i9, optionalNamespaces: r8, relays: l9 ?? [{ protocol: xt2 }], proposer: { publicKey: d7, metadata: this.client.metadata }, expiryTimestamp: m6, pairingTopic: p9 }, n5 && { sessionProperties: n5 }), a6 && { scopedProperties: a6 }), { id: payloadId() }), E8 = ci("session_connect", y11.id), { reject: _6, resolve: V8, done: C10 } = ei(w8, Me3), v9 = ({ id: T8 }) => {
        T8 === y11.id && (this.client.events.off("proposal_expire", v9), this.pendingSessions.delete(y11.id), this.events.emit(E8, { error: { message: Me3, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", v9), this.events.once(E8, ({ error: T8, session: K5 }) => {
        this.client.events.off("proposal_expire", v9), T8 ? _6(T8) : K5 && V8(K5);
      }), await this.sendRequest({ topic: p9, method: "wc_sessionPropose", params: y11, throwOnFailedPublish: true, clientRpcId: y11.id }), await this.setProposal(y11.id, y11), { uri: h9, approval: C10 };
    }), c3(this, "pair", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t6);
      } catch (e11) {
        throw this.client.logger.error("pair() failed"), e11;
      }
    }), c3(this, "approve", async (t6) => {
      var e11, s5, i9;
      const r8 = this.client.core.eventClient.createEvent({ properties: { topic: (e11 = t6 == null ? void 0 : t6.id) == null ? void 0 : e11.toString(), trace: [tr2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q6) {
        throw r8.setError(ir2.no_internet_connection), q6;
      }
      try {
        await this.isValidProposalId(t6 == null ? void 0 : t6.id);
      } catch (q6) {
        throw this.client.logger.error(`approve() -> proposal.get(${t6 == null ? void 0 : t6.id}) failed`), r8.setError(ir2.proposal_not_found), q6;
      }
      try {
        await this.isValidApprove(t6);
      } catch (q6) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r8.setError(ir2.session_approve_namespace_validation_failure), q6;
      }
      const { id: n5, relayProtocol: a6, namespaces: l9, sessionProperties: p9, scopedProperties: h9, sessionConfig: u10 } = t6, d7 = this.client.proposal.get(n5);
      this.client.core.eventClient.deleteEvent({ eventId: r8.eventId });
      const { pairingTopic: w8, proposer: m6, requiredNamespaces: y11, optionalNamespaces: E8 } = d7;
      let _6 = (s5 = this.client.core.eventClient) == null ? void 0 : s5.getEvent({ topic: w8 });
      _6 || (_6 = (i9 = this.client.core.eventClient) == null ? void 0 : i9.createEvent({ type: tr2.session_approve_started, properties: { topic: w8, trace: [tr2.session_approve_started, tr2.session_namespaces_validation_success] } }));
      const V8 = await this.client.core.crypto.generateKeyPair(), C10 = m6.publicKey, v9 = await this.client.core.crypto.generateSharedKey(V8, C10), T8 = I2(I2(I2({ relay: { protocol: a6 ?? "irn" }, namespaces: l9, controller: { publicKey: V8, metadata: this.client.metadata }, expiry: ii(X2) }, p9 && { sessionProperties: p9 }), h9 && { scopedProperties: h9 }), u10 && { sessionConfig: u10 }), K5 = Q2.relay;
      _6.addTrace(tr2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(v9, { transportType: K5 });
      } catch (q6) {
        throw _6.setError(ir2.subscribe_session_topic_failure), q6;
      }
      _6.addTrace(tr2.subscribe_session_topic_success);
      const fe5 = x2(I2({}, T8), { topic: v9, requiredNamespaces: y11, optionalNamespaces: E8, pairingTopic: w8, acknowledged: false, self: T8.controller, peer: { publicKey: m6.publicKey, metadata: m6.metadata }, controller: V8, transportType: Q2.relay });
      await this.client.session.set(v9, fe5), _6.addTrace(tr2.store_session);
      try {
        _6.addTrace(tr2.publishing_session_settle), await this.sendRequest({ topic: v9, method: "wc_sessionSettle", params: T8, throwOnFailedPublish: true }).catch((q6) => {
          throw _6 == null ? void 0 : _6.setError(ir2.session_settle_publish_failure), q6;
        }), _6.addTrace(tr2.session_settle_publish_success), _6.addTrace(tr2.publishing_session_approve), await this.sendResult({ id: n5, topic: w8, result: { relay: { protocol: a6 ?? "irn" }, responderPublicKey: V8 }, throwOnFailedPublish: true }).catch((q6) => {
          throw _6 == null ? void 0 : _6.setError(ir2.session_approve_publish_failure), q6;
        }), _6.addTrace(tr2.session_approve_publish_success);
      } catch (q6) {
        throw this.client.logger.error(q6), this.client.session.delete(v9, Kt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(v9), q6;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _6.eventId }), await this.client.core.pairing.updateMetadata({ topic: w8, metadata: m6.metadata }), await this.deleteProposal(n5), await this.client.core.pairing.activate({ topic: w8 }), await this.setExpiry(v9, ii(X2)), { topic: v9, acknowledged: () => Promise.resolve(this.client.session.get(v9)) };
    }), c3(this, "reject", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t6);
      } catch (r8) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r8;
      }
      const { id: e11, reason: s5 } = t6;
      let i9;
      try {
        i9 = this.client.proposal.get(e11).pairingTopic;
      } catch (r8) {
        throw this.client.logger.error(`reject() -> proposal.get(${e11}) failed`), r8;
      }
      i9 && await this.sendError({ id: e11, topic: i9, error: s5, rpcOpts: N3.wc_sessionPropose.reject }), await this.deleteProposal(e11);
    }), c3(this, "update", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t6);
      } catch (h9) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h9;
      }
      const { topic: e11, namespaces: s5 } = t6, { done: i9, resolve: r8, reject: n5 } = ei(), a6 = payloadId(), l9 = getBigIntRpcId().toString(), p9 = this.client.session.get(e11).namespaces;
      return this.events.once(ci("session_update", a6), ({ error: h9 }) => {
        h9 ? n5(h9) : r8();
      }), await this.client.session.update(e11, { namespaces: s5 }), await this.sendRequest({ topic: e11, method: "wc_sessionUpdate", params: { namespaces: s5 }, throwOnFailedPublish: true, clientRpcId: a6, relayRpcId: l9 }).catch((h9) => {
        this.client.logger.error(h9), this.client.session.update(e11, { namespaces: p9 }), n5(h9);
      }), { acknowledged: i9 };
    }), c3(this, "extend", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t6);
      } catch (a6) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a6;
      }
      const { topic: e11 } = t6, s5 = payloadId(), { done: i9, resolve: r8, reject: n5 } = ei();
      return this.events.once(ci("session_extend", s5), ({ error: a6 }) => {
        a6 ? n5(a6) : r8();
      }), await this.setExpiry(e11, ii(X2)), this.sendRequest({ topic: e11, method: "wc_sessionExtend", params: {}, clientRpcId: s5, throwOnFailedPublish: true }).catch((a6) => {
        n5(a6);
      }), { acknowledged: i9 };
    }), c3(this, "request", async (t6) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t6);
      } catch (y11) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), y11;
      }
      const { chainId: e11, request: s5, topic: i9, expiry: r8 = N3.wc_sessionRequest.req.ttl } = t6, n5 = this.client.session.get(i9);
      (n5 == null ? void 0 : n5.transportType) === Q2.relay && await this.confirmOnlineStateOrThrow();
      const a6 = payloadId(), l9 = getBigIntRpcId().toString(), { done: p9, resolve: h9, reject: u10 } = ei(r8, "Request expired. Please try again.");
      this.events.once(ci("session_request", a6), ({ error: y11, result: E8 }) => {
        y11 ? u10(y11) : h9(E8);
      });
      const d7 = "wc_sessionRequest", w8 = this.getAppLinkIfEnabled(n5.peer.metadata, n5.transportType);
      if (w8) return await this.sendRequest({ clientRpcId: a6, relayRpcId: l9, topic: i9, method: d7, params: { request: x2(I2({}, s5), { expiryTimestamp: ii(r8) }), chainId: e11 }, expiry: r8, throwOnFailedPublish: true, appLink: w8 }).catch((y11) => u10(y11)), this.client.events.emit("session_request_sent", { topic: i9, request: s5, chainId: e11, id: a6 }), await p9();
      const m6 = { request: x2(I2({}, s5), { expiryTimestamp: ii(r8) }), chainId: e11 };
      return await Promise.all([new Promise(async (y11) => {
        await this.sendRequest({ clientRpcId: a6, relayRpcId: l9, topic: i9, method: d7, params: m6, expiry: r8, throwOnFailedPublish: true, tvf: this.getTVFParams(a6, m6) }).catch((E8) => u10(E8)), this.client.events.emit("session_request_sent", { topic: i9, request: s5, chainId: e11, id: a6 }), y11();
      }), new Promise(async (y11) => {
        var E8;
        if (!((E8 = n5.sessionConfig) != null && E8.disableDeepLink)) {
          const _6 = await ui(this.client.core.storage, Le3);
          await ai({ id: a6, topic: i9, wcDeepLink: _6 });
        }
        y11();
      }), p9()]).then((y11) => y11[2]);
    }), c3(this, "respond", async (t6) => {
      this.isInitialized(), await this.isValidRespond(t6);
      const { topic: e11, response: s5 } = t6, { id: i9 } = s5, r8 = this.client.session.get(e11);
      r8.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const n5 = this.getAppLinkIfEnabled(r8.peer.metadata, r8.transportType);
      isJsonRpcResult(s5) ? await this.sendResult({ id: i9, topic: e11, result: s5.result, throwOnFailedPublish: true, appLink: n5 }) : isJsonRpcError(s5) && await this.sendError({ id: i9, topic: e11, error: s5.error, appLink: n5 }), this.cleanupAfterResponse(t6);
    }), c3(this, "ping", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t6);
      } catch (s5) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s5;
      }
      const { topic: e11 } = t6;
      if (this.client.session.keys.includes(e11)) {
        const s5 = payloadId(), i9 = getBigIntRpcId().toString(), { done: r8, resolve: n5, reject: a6 } = ei();
        this.events.once(ci("session_ping", s5), ({ error: l9 }) => {
          l9 ? a6(l9) : n5();
        }), await Promise.all([this.sendRequest({ topic: e11, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s5, relayRpcId: i9 }), r8()]);
      } else this.client.core.pairing.pairings.keys.includes(e11) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: e11 }));
    }), c3(this, "emit", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t6);
      const { topic: e11, event: s5, chainId: i9 } = t6, r8 = getBigIntRpcId().toString(), n5 = payloadId();
      await this.sendRequest({ topic: e11, method: "wc_sessionEvent", params: { event: s5, chainId: i9 }, throwOnFailedPublish: true, relayRpcId: r8, clientRpcId: n5 });
    }), c3(this, "disconnect", async (t6) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t6);
      const { topic: e11 } = t6;
      if (this.client.session.keys.includes(e11)) await this.sendRequest({ topic: e11, method: "wc_sessionDelete", params: Kt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: e11, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(e11)) await this.client.core.pairing.disconnect({ topic: e11 });
      else {
        const { message: s5 } = Et("MISMATCHED_TOPIC", `Session or pairing topic not found: ${e11}`);
        throw new Error(s5);
      }
    }), c3(this, "find", (t6) => (this.isInitialized(), this.client.session.getAll().filter((e11) => ya(e11, t6)))), c3(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c3(this, "authenticate", async (t6, e11) => {
      var s5;
      this.isInitialized(), this.isValidAuthenticate(t6);
      const i9 = e11 && this.client.core.linkModeSupportedApps.includes(e11) && ((s5 = this.client.metadata.redirect) == null ? void 0 : s5.linkMode), r8 = i9 ? Q2.link_mode : Q2.relay;
      r8 === Q2.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n5, statement: a6 = "", uri: l9, domain: p9, nonce: h9, type: u10, exp: d7, nbf: w8, methods: m6 = [], expiry: y11 } = t6, E8 = [...t6.resources || []], { topic: _6, uri: V8 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r8 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: _6, uri: V8 } });
      const C10 = await this.client.core.crypto.generateKeyPair(), v9 = Fc(C10);
      if (await Promise.all([this.client.auth.authKeys.set(ce2, { responseTopic: v9, publicKey: C10 }), this.client.auth.pairingTopics.set(v9, { topic: v9, pairingTopic: _6 })]), await this.client.core.relayer.subscribe(v9, { transportType: r8 }), this.client.logger.info(`sending request to new pairing topic: ${_6}`), m6.length > 0) {
        const { namespace: O8 } = Fe(n5[0]);
        let k11 = Ef(O8, "request", m6);
        Oe(E8) && (k11 = Bf(k11, E8.pop())), E8.push(k11);
      }
      const T8 = y11 && y11 > N3.wc_sessionAuthenticate.req.ttl ? y11 : N3.wc_sessionAuthenticate.req.ttl, K5 = { authPayload: { type: u10 ?? "caip122", chains: n5, statement: a6, aud: l9, domain: p9, version: "1", nonce: h9, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d7, nbf: w8, resources: E8 }, requester: { publicKey: C10, metadata: this.client.metadata }, expiryTimestamp: ii(T8) }, fe5 = { eip155: { chains: n5, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m6])], events: ["chainChanged", "accountsChanged"] } }, q6 = { requiredNamespaces: {}, optionalNamespaces: fe5, relays: [{ protocol: "irn" }], pairingTopic: _6, proposer: { publicKey: C10, metadata: this.client.metadata }, expiryTimestamp: ii(N3.wc_sessionPropose.req.ttl), id: payloadId() }, { done: It5, resolve: Ue5, reject: Se5 } = ei(T8, "Request expired"), te4 = payloadId(), le5 = ci("session_connect", q6.id), Re4 = ci("session_request", te4), pe5 = async ({ error: O8, session: k11 }) => {
        this.events.off(Re4, ve4), O8 ? Se5(O8) : k11 && Ue5({ session: k11 });
      }, ve4 = async (O8) => {
        var k11, Ge4, je5;
        if (await this.deletePendingAuthRequest(te4, { message: "fulfilled", code: 0 }), O8.error) {
          const ie5 = Kt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O8.error.code === ie5.code ? void 0 : (this.events.off(le5, pe5), Se5(O8.error.message));
        }
        await this.deleteProposal(q6.id), this.events.off(le5, pe5);
        const { cacaos: Fe5, responder: Q7 } = O8.result, Te5 = [], Qe6 = [];
        for (const ie5 of Fe5) {
          await yf({ cacao: ie5, projectId: this.client.core.projectId }) || (this.client.logger.error(ie5, "Signature verification failed"), Se5(Kt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe5 } = ie5, Pe5 = Oe(qe5.resources), He5 = [Vr(qe5.iss)], Tt5 = dn(qe5.iss);
          if (Pe5) {
            const Ne4 = If(Pe5), qt4 = Af(Pe5);
            Te5.push(...Ne4), He5.push(...qt4);
          }
          for (const Ne4 of He5) Qe6.push(`${Ne4}:${Tt5}`);
        }
        const se5 = await this.client.core.crypto.generateSharedKey(C10, Q7.publicKey);
        let he5;
        Te5.length > 0 && (he5 = { topic: se5, acknowledged: true, self: { publicKey: C10, metadata: this.client.metadata }, peer: Q7, controller: Q7.publicKey, expiry: ii(X2), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: _6, namespaces: ga([...new Set(Te5)], [...new Set(Qe6)]), transportType: r8 }, await this.client.core.relayer.subscribe(se5, { transportType: r8 }), await this.client.session.set(se5, he5), _6 && await this.client.core.pairing.updateMetadata({ topic: _6, metadata: Q7.metadata }), he5 = this.client.session.get(se5)), (k11 = this.client.metadata.redirect) != null && k11.linkMode && (Ge4 = Q7.metadata.redirect) != null && Ge4.linkMode && (je5 = Q7.metadata.redirect) != null && je5.universal && e11 && (this.client.core.addLinkModeSupportedApp(Q7.metadata.redirect.universal), this.client.session.update(se5, { transportType: Q2.link_mode })), Ue5({ auths: Fe5, session: he5 });
      };
      this.events.once(le5, pe5), this.events.once(Re4, ve4);
      let Ie5;
      try {
        if (i9) {
          const O8 = formatJsonRpcRequest("wc_sessionAuthenticate", K5, te4);
          this.client.core.history.set(_6, O8);
          const k11 = await this.client.core.crypto.encode("", O8, { type: ge, encoding: De });
          Ie5 = sa(e11, _6, k11);
        } else await Promise.all([this.sendRequest({ topic: _6, method: "wc_sessionAuthenticate", params: K5, expiry: t6.expiry, throwOnFailedPublish: true, clientRpcId: te4 }), this.sendRequest({ topic: _6, method: "wc_sessionPropose", params: q6, expiry: N3.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q6.id })]);
      } catch (O8) {
        throw this.events.off(le5, pe5), this.events.off(Re4, ve4), O8;
      }
      return await this.setProposal(q6.id, q6), await this.setAuthRequest(te4, { request: x2(I2({}, K5), { verifyContext: {} }), pairingTopic: _6, transportType: r8 }), { uri: Ie5 ?? V8, response: It5 };
    }), c3(this, "approveSessionAuthenticate", async (t6) => {
      const { id: e11, auths: s5 } = t6, i9 = this.client.core.eventClient.createEvent({ properties: { topic: e11.toString(), trace: [sr2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y11) {
        throw i9.setError(rr2.no_internet_connection), y11;
      }
      const r8 = this.getPendingAuthRequest(e11);
      if (!r8) throw i9.setError(rr2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${e11}`);
      const n5 = r8.transportType || Q2.relay;
      n5 === Q2.relay && await this.confirmOnlineStateOrThrow();
      const a6 = r8.requester.publicKey, l9 = await this.client.core.crypto.generateKeyPair(), p9 = Fc(a6), h9 = { type: ee, receiverPublicKey: a6, senderPublicKey: l9 }, u10 = [], d7 = [];
      for (const y11 of s5) {
        if (!await yf({ cacao: y11, projectId: this.client.core.projectId })) {
          i9.setError(rr2.invalid_cacao);
          const v9 = Kt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: e11, topic: p9, error: v9, encodeOpts: h9 }), new Error(v9.message);
        }
        i9.addTrace(sr2.cacaos_verified);
        const { p: E8 } = y11, _6 = Oe(E8.resources), V8 = [Vr(E8.iss)], C10 = dn(E8.iss);
        if (_6) {
          const v9 = If(_6), T8 = Af(_6);
          u10.push(...v9), V8.push(...T8);
        }
        for (const v9 of V8) d7.push(`${v9}:${C10}`);
      }
      const w8 = await this.client.core.crypto.generateSharedKey(l9, a6);
      i9.addTrace(sr2.create_authenticated_session_topic);
      let m6;
      if ((u10 == null ? void 0 : u10.length) > 0) {
        m6 = { topic: w8, acknowledged: true, self: { publicKey: l9, metadata: this.client.metadata }, peer: { publicKey: a6, metadata: r8.requester.metadata }, controller: a6, expiry: ii(X2), authentication: s5, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r8.pairingTopic, namespaces: ga([...new Set(u10)], [...new Set(d7)]), transportType: n5 }, i9.addTrace(sr2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w8, { transportType: n5 });
        } catch (y11) {
          throw i9.setError(rr2.subscribe_authenticated_session_topic_failure), y11;
        }
        i9.addTrace(sr2.subscribe_authenticated_session_topic_success), await this.client.session.set(w8, m6), i9.addTrace(sr2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r8.pairingTopic, metadata: r8.requester.metadata });
      }
      i9.addTrace(sr2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p9, id: e11, result: { cacaos: s5, responder: { publicKey: l9, metadata: this.client.metadata } }, encodeOpts: h9, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r8.requester.metadata, n5) });
      } catch (y11) {
        throw i9.setError(rr2.authenticated_session_approve_publish_failure), y11;
      }
      return await this.client.auth.requests.delete(e11, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r8.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i9.eventId }), { session: m6 };
    }), c3(this, "rejectSessionAuthenticate", async (t6) => {
      this.isInitialized();
      const { id: e11, reason: s5 } = t6, i9 = this.getPendingAuthRequest(e11);
      if (!i9) throw new Error(`Could not find pending auth request with id ${e11}`);
      i9.transportType === Q2.relay && await this.confirmOnlineStateOrThrow();
      const r8 = i9.requester.publicKey, n5 = await this.client.core.crypto.generateKeyPair(), a6 = Fc(r8), l9 = { type: ee, receiverPublicKey: r8, senderPublicKey: n5 };
      await this.sendError({ id: e11, topic: a6, error: s5, encodeOpts: l9, rpcOpts: N3.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i9.requester.metadata, i9.transportType) }), await this.client.auth.requests.delete(e11, { message: "rejected", code: 0 }), await this.deleteProposal(e11);
    }), c3(this, "formatAuthMessage", (t6) => {
      this.isInitialized();
      const { request: e11, iss: s5 } = t6;
      return qr(e11, s5);
    }), c3(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t6 = this.relayMessageCache.shift();
          t6 && await this.onRelayMessage(t6);
        } catch (t6) {
          this.client.logger.error(t6);
        }
      }, 50);
    }), c3(this, "cleanupDuplicatePairings", async (t6) => {
      if (t6.pairingTopic) try {
        const e11 = this.client.core.pairing.pairings.get(t6.pairingTopic), s5 = this.client.core.pairing.pairings.getAll().filter((i9) => {
          var r8, n5;
          return ((r8 = i9.peerMetadata) == null ? void 0 : r8.url) && ((n5 = i9.peerMetadata) == null ? void 0 : n5.url) === t6.peer.metadata.url && i9.topic && i9.topic !== e11.topic;
        });
        if (s5.length === 0) return;
        this.client.logger.info(`Cleaning up ${s5.length} duplicate pairing(s)`), await Promise.all(s5.map((i9) => this.client.core.pairing.disconnect({ topic: i9.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (e11) {
        this.client.logger.error(e11);
      }
    }), c3(this, "deleteSession", async (t6) => {
      var e11;
      const { topic: s5, expirerHasDeleted: i9 = false, emitEvent: r8 = true, id: n5 = 0 } = t6, { self: a6 } = this.client.session.get(s5);
      await this.client.core.relayer.unsubscribe(s5), await this.client.session.delete(s5, Kt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s5, "session"), this.client.core.crypto.keychain.has(a6.publicKey) && await this.client.core.crypto.deleteKeyPair(a6.publicKey), this.client.core.crypto.keychain.has(s5) && await this.client.core.crypto.deleteSymKey(s5), i9 || this.client.core.expirer.del(s5), this.client.core.storage.removeItem(Le3).catch((l9) => this.client.logger.warn(l9)), this.getPendingSessionRequests().forEach((l9) => {
        l9.topic === s5 && this.deletePendingSessionRequest(l9.id, Kt("USER_DISCONNECTED"));
      }), s5 === ((e11 = this.sessionRequestQueue.queue[0]) == null ? void 0 : e11.topic) && (this.sessionRequestQueue.state = $2.idle), r8 && this.client.events.emit("session_delete", { id: n5, topic: s5 });
    }), c3(this, "deleteProposal", async (t6, e11) => {
      if (e11) try {
        const s5 = this.client.proposal.get(t6), i9 = this.client.core.eventClient.getEvent({ topic: s5.pairingTopic });
        i9 == null ? void 0 : i9.setError(ir2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t6, Kt("USER_DISCONNECTED")), e11 ? Promise.resolve() : this.client.core.expirer.del(t6)]), this.addToRecentlyDeleted(t6, "proposal");
    }), c3(this, "deletePendingSessionRequest", async (t6, e11, s5 = false) => {
      await Promise.all([this.client.pendingRequest.delete(t6, e11), s5 ? Promise.resolve() : this.client.core.expirer.del(t6)]), this.addToRecentlyDeleted(t6, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i9) => i9.id !== t6), s5 && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: t6 }));
    }), c3(this, "deletePendingAuthRequest", async (t6, e11, s5 = false) => {
      await Promise.all([this.client.auth.requests.delete(t6, e11), s5 ? Promise.resolve() : this.client.core.expirer.del(t6)]);
    }), c3(this, "setExpiry", async (t6, e11) => {
      this.client.session.keys.includes(t6) && (this.client.core.expirer.set(t6, e11), await this.client.session.update(t6, { expiry: e11 }));
    }), c3(this, "setProposal", async (t6, e11) => {
      this.client.core.expirer.set(t6, ii(N3.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t6, e11);
    }), c3(this, "setAuthRequest", async (t6, e11) => {
      const { request: s5, pairingTopic: i9, transportType: r8 = Q2.relay } = e11;
      this.client.core.expirer.set(t6, s5.expiryTimestamp), await this.client.auth.requests.set(t6, { authPayload: s5.authPayload, requester: s5.requester, expiryTimestamp: s5.expiryTimestamp, id: t6, pairingTopic: i9, verifyContext: s5.verifyContext, transportType: r8 });
    }), c3(this, "setPendingSessionRequest", async (t6) => {
      const { id: e11, topic: s5, params: i9, verifyContext: r8 } = t6, n5 = i9.request.expiryTimestamp || ii(N3.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(e11, n5), await this.client.pendingRequest.set(e11, { id: e11, topic: s5, params: i9, verifyContext: r8 });
    }), c3(this, "sendRequest", async (t6) => {
      const { topic: e11, method: s5, params: i9, expiry: r8, relayRpcId: n5, clientRpcId: a6, throwOnFailedPublish: l9, appLink: p9, tvf: h9 } = t6, u10 = formatJsonRpcRequest(s5, i9, a6);
      let d7;
      const w8 = !!p9;
      try {
        const E8 = w8 ? De : Qt;
        d7 = await this.client.core.crypto.encode(e11, u10, { encoding: E8 });
      } catch (E8) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${e11} failed`), E8;
      }
      let m6;
      if (mt2.includes(s5)) {
        const E8 = zc(JSON.stringify(u10)), _6 = zc(d7);
        m6 = await this.client.core.verify.register({ id: _6, decryptedId: E8 });
      }
      const y11 = N3[s5].req;
      if (y11.attestation = m6, r8 && (y11.ttl = r8), n5 && (y11.id = n5), this.client.core.history.set(e11, u10), w8) {
        const E8 = sa(p9, e11, d7);
        await global.Linking.openURL(E8, this.client.name);
      } else {
        const E8 = N3[s5].req;
        r8 && (E8.ttl = r8), n5 && (E8.id = n5), E8.tvf = x2(I2({}, h9), { correlationId: u10.id }), l9 ? (E8.internal = x2(I2({}, E8.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(e11, d7, E8)) : this.client.core.relayer.publish(e11, d7, E8).catch((_6) => this.client.logger.error(_6));
      }
      return u10.id;
    }), c3(this, "sendResult", async (t6) => {
      const { id: e11, topic: s5, result: i9, throwOnFailedPublish: r8, encodeOpts: n5, appLink: a6 } = t6, l9 = formatJsonRpcResult(e11, i9);
      let p9;
      const h9 = a6 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w8 = h9 ? De : Qt;
        p9 = await this.client.core.crypto.encode(s5, l9, x2(I2({}, n5 || {}), { encoding: w8 }));
      } catch (w8) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s5} failed`), w8;
      }
      let u10, d7;
      try {
        u10 = await this.client.core.history.get(s5, e11);
        const w8 = u10.request;
        try {
          d7 = this.getTVFParams(e11, w8.params, i9);
        } catch (m6) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${m6 == null ? void 0 : m6.message}`);
        }
      } catch (w8) {
        throw this.client.logger.error(`sendResult() -> history.get(${s5}, ${e11}) failed`), w8;
      }
      if (h9) {
        const w8 = sa(a6, s5, p9);
        await global.Linking.openURL(w8, this.client.name);
      } else {
        const w8 = u10.request.method, m6 = N3[w8].res;
        m6.tvf = x2(I2({}, d7), { correlationId: e11 }), r8 ? (m6.internal = x2(I2({}, m6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s5, p9, m6)) : this.client.core.relayer.publish(s5, p9, m6).catch((y11) => this.client.logger.error(y11));
      }
      await this.client.core.history.resolve(l9);
    }), c3(this, "sendError", async (t6) => {
      const { id: e11, topic: s5, error: i9, encodeOpts: r8, rpcOpts: n5, appLink: a6 } = t6, l9 = formatJsonRpcError(e11, i9);
      let p9;
      const h9 = a6 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d7 = h9 ? De : Qt;
        p9 = await this.client.core.crypto.encode(s5, l9, x2(I2({}, r8 || {}), { encoding: d7 }));
      } catch (d7) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s5} failed`), d7;
      }
      let u10;
      try {
        u10 = await this.client.core.history.get(s5, e11);
      } catch (d7) {
        throw this.client.logger.error(`sendError() -> history.get(${s5}, ${e11}) failed`), d7;
      }
      if (h9) {
        const d7 = sa(a6, s5, p9);
        await global.Linking.openURL(d7, this.client.name);
      } else {
        const d7 = u10.request.method, w8 = n5 || N3[d7].res;
        this.client.core.relayer.publish(s5, p9, w8);
      }
      await this.client.core.history.resolve(l9);
    }), c3(this, "cleanup", async () => {
      const t6 = [], e11 = [];
      this.client.session.getAll().forEach((s5) => {
        let i9 = false;
        fi(s5.expiry) && (i9 = true), this.client.core.crypto.keychain.has(s5.topic) || (i9 = true), i9 && t6.push(s5.topic);
      }), this.client.proposal.getAll().forEach((s5) => {
        fi(s5.expiryTimestamp) && e11.push(s5.id);
      }), await Promise.all([...t6.map((s5) => this.deleteSession({ topic: s5 })), ...e11.map((s5) => this.deleteProposal(s5))]);
    }), c3(this, "onProviderMessageEvent", async (t6) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t6) : await this.onRelayMessage(t6);
    }), c3(this, "onRelayEventRequest", async (t6) => {
      this.requestQueue.queue.push(t6), await this.processRequestsQueue();
    }), c3(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const t6 = this.requestQueue.queue.shift();
        if (t6) try {
          await this.processRequest(t6);
        } catch (e11) {
          this.client.logger.warn(e11);
        }
      }
      this.requestQueue.state = $2.idle;
    }), c3(this, "processRequest", async (t6) => {
      const { topic: e11, payload: s5, attestation: i9, transportType: r8, encryptedId: n5 } = t6, a6 = s5.method;
      if (!this.shouldIgnorePairingRequest({ topic: e11, requestMethod: a6 })) switch (a6) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: e11, payload: s5, attestation: i9, encryptedId: n5 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(e11, s5);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(e11, s5);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(e11, s5);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(e11, s5);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(e11, s5);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: e11, payload: s5, attestation: i9, encryptedId: n5, transportType: r8 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(e11, s5);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: e11, payload: s5, attestation: i9, encryptedId: n5, transportType: r8 });
        default:
          return this.client.logger.info(`Unsupported request method ${a6}`);
      }
    }), c3(this, "onRelayEventResponse", async (t6) => {
      const { topic: e11, payload: s5, transportType: i9 } = t6, r8 = (await this.client.core.history.get(e11, s5.id)).request.method;
      switch (r8) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(e11, s5, i9);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(e11, s5);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(e11, s5);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(e11, s5);
        case "wc_sessionPing":
          return this.onSessionPingResponse(e11, s5);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(e11, s5);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(e11, s5);
        default:
          return this.client.logger.info(`Unsupported response method ${r8}`);
      }
    }), c3(this, "onRelayEventUnknownPayload", (t6) => {
      const { topic: e11 } = t6, { message: s5 } = Et("MISSING_OR_INVALID", `Decoded payload on topic ${e11} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s5);
    }), c3(this, "shouldIgnorePairingRequest", (t6) => {
      const { topic: e11, requestMethod: s5 } = t6, i9 = this.expectedPairingMethodMap.get(e11);
      return !i9 || i9.includes(s5) ? false : !!(i9.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c3(this, "onSessionProposeRequest", async (t6) => {
      const { topic: e11, payload: s5, attestation: i9, encryptedId: r8 } = t6, { params: n5, id: a6 } = s5;
      try {
        const l9 = this.client.core.eventClient.getEvent({ topic: e11 });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l9 == null ? void 0 : l9.setError(Y2.proposal_listener_not_found)), this.isValidConnect(I2({}, s5.params));
        const p9 = n5.expiryTimestamp || ii(N3.wc_sessionPropose.req.ttl), h9 = I2({ id: a6, pairingTopic: e11, expiryTimestamp: p9, attestation: i9, encryptedId: r8 }, n5);
        await this.setProposal(a6, h9);
        const u10 = await this.getVerifyContext({ attestationId: i9, hash: zc(JSON.stringify(s5)), encryptedId: r8, metadata: h9.proposer.metadata });
        l9 == null ? void 0 : l9.addTrace(G2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a6, params: h9, verifyContext: u10 });
      } catch (l9) {
        await this.sendError({ id: a6, topic: e11, error: l9, rpcOpts: N3.wc_sessionPropose.autoReject }), this.client.logger.error(l9);
      }
    }), c3(this, "onSessionProposeResponse", async (t6, e11, s5) => {
      const { id: i9 } = e11;
      if (isJsonRpcResult(e11)) {
        const { result: r8 } = e11;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r8 });
        const n5 = this.client.proposal.get(i9);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n5 });
        const a6 = n5.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a6 });
        const l9 = r8.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l9 });
        const p9 = await this.client.core.crypto.generateSharedKey(a6, l9);
        this.pendingSessions.set(i9, { sessionTopic: p9, pairingTopic: t6, proposalId: i9, publicKey: a6 });
        const h9 = await this.client.core.relayer.subscribe(p9, { transportType: s5 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h9 }), await this.client.core.pairing.activate({ topic: t6 });
      } else if (isJsonRpcError(e11)) {
        await this.deleteProposal(i9);
        const r8 = ci("session_connect", i9);
        if (this.events.listenerCount(r8) === 0) throw new Error(`emitting ${r8} without any listeners, 954`);
        this.events.emit(r8, { error: e11.error });
      }
    }), c3(this, "onSessionSettleRequest", async (t6, e11) => {
      const { id: s5, params: i9 } = e11;
      try {
        this.isValidSessionSettleRequest(i9);
        const { relay: r8, controller: n5, expiry: a6, namespaces: l9, sessionProperties: p9, scopedProperties: h9, sessionConfig: u10 } = e11.params, d7 = [...this.pendingSessions.values()].find((y11) => y11.sessionTopic === t6);
        if (!d7) return this.client.logger.error(`Pending session not found for topic ${t6}`);
        const w8 = this.client.proposal.get(d7.proposalId), m6 = x2(I2(I2(I2({ topic: t6, relay: r8, expiry: a6, namespaces: l9, acknowledged: true, pairingTopic: d7.pairingTopic, requiredNamespaces: w8.requiredNamespaces, optionalNamespaces: w8.optionalNamespaces, controller: n5.publicKey, self: { publicKey: d7.publicKey, metadata: this.client.metadata }, peer: { publicKey: n5.publicKey, metadata: n5.metadata } }, p9 && { sessionProperties: p9 }), h9 && { scopedProperties: h9 }), u10 && { sessionConfig: u10 }), { transportType: Q2.relay });
        await this.client.session.set(m6.topic, m6), await this.setExpiry(m6.topic, m6.expiry), await this.client.core.pairing.updateMetadata({ topic: d7.pairingTopic, metadata: m6.peer.metadata }), this.client.events.emit("session_connect", { session: m6 }), this.events.emit(ci("session_connect", d7.proposalId), { session: m6 }), this.pendingSessions.delete(d7.proposalId), this.deleteProposal(d7.proposalId, false), this.cleanupDuplicatePairings(m6), await this.sendResult({ id: e11.id, topic: t6, result: true });
      } catch (r8) {
        await this.sendError({ id: s5, topic: t6, error: r8 }), this.client.logger.error(r8);
      }
    }), c3(this, "onSessionSettleResponse", async (t6, e11) => {
      const { id: s5 } = e11;
      isJsonRpcResult(e11) ? (await this.client.session.update(t6, { acknowledged: true }), this.events.emit(ci("session_approve", s5), {})) : isJsonRpcError(e11) && (await this.client.session.delete(t6, Kt("USER_DISCONNECTED")), this.events.emit(ci("session_approve", s5), { error: e11.error }));
    }), c3(this, "onSessionUpdateRequest", async (t6, e11) => {
      const { params: s5, id: i9 } = e11;
      try {
        const r8 = `${t6}_session_update`, n5 = Ha.get(r8);
        if (n5 && this.isRequestOutOfSync(n5, i9)) {
          this.client.logger.warn(`Discarding out of sync request - ${i9}`), this.sendError({ id: i9, topic: t6, error: Kt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I2({ topic: t6 }, s5));
        try {
          Ha.set(r8, i9), await this.client.session.update(t6, { namespaces: s5.namespaces }), await this.sendResult({ id: i9, topic: t6, result: true });
        } catch (a6) {
          throw Ha.delete(r8), a6;
        }
        this.client.events.emit("session_update", { id: i9, topic: t6, params: s5 });
      } catch (r8) {
        await this.sendError({ id: i9, topic: t6, error: r8 }), this.client.logger.error(r8);
      }
    }), c3(this, "isRequestOutOfSync", (t6, e11) => e11.toString().slice(0, -3) < t6.toString().slice(0, -3)), c3(this, "onSessionUpdateResponse", (t6, e11) => {
      const { id: s5 } = e11, i9 = ci("session_update", s5);
      if (this.events.listenerCount(i9) === 0) throw new Error(`emitting ${i9} without any listeners`);
      isJsonRpcResult(e11) ? this.events.emit(ci("session_update", s5), {}) : isJsonRpcError(e11) && this.events.emit(ci("session_update", s5), { error: e11.error });
    }), c3(this, "onSessionExtendRequest", async (t6, e11) => {
      const { id: s5 } = e11;
      try {
        this.isValidExtend({ topic: t6 }), await this.setExpiry(t6, ii(X2)), await this.sendResult({ id: s5, topic: t6, result: true }), this.client.events.emit("session_extend", { id: s5, topic: t6 });
      } catch (i9) {
        await this.sendError({ id: s5, topic: t6, error: i9 }), this.client.logger.error(i9);
      }
    }), c3(this, "onSessionExtendResponse", (t6, e11) => {
      const { id: s5 } = e11, i9 = ci("session_extend", s5);
      if (this.events.listenerCount(i9) === 0) throw new Error(`emitting ${i9} without any listeners`);
      isJsonRpcResult(e11) ? this.events.emit(ci("session_extend", s5), {}) : isJsonRpcError(e11) && this.events.emit(ci("session_extend", s5), { error: e11.error });
    }), c3(this, "onSessionPingRequest", async (t6, e11) => {
      const { id: s5 } = e11;
      try {
        this.isValidPing({ topic: t6 }), await this.sendResult({ id: s5, topic: t6, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s5, topic: t6 });
      } catch (i9) {
        await this.sendError({ id: s5, topic: t6, error: i9 }), this.client.logger.error(i9);
      }
    }), c3(this, "onSessionPingResponse", (t6, e11) => {
      const { id: s5 } = e11, i9 = ci("session_ping", s5);
      setTimeout(() => {
        if (this.events.listenerCount(i9) === 0) throw new Error(`emitting ${i9} without any listeners 2176`);
        isJsonRpcResult(e11) ? this.events.emit(ci("session_ping", s5), {}) : isJsonRpcError(e11) && this.events.emit(ci("session_ping", s5), { error: e11.error });
      }, 500);
    }), c3(this, "onSessionDeleteRequest", async (t6, e11) => {
      const { id: s5 } = e11;
      try {
        this.isValidDisconnect({ topic: t6, reason: e11.params }), Promise.all([new Promise((i9) => {
          this.client.core.relayer.once(C2.publish, async () => {
            i9(await this.deleteSession({ topic: t6, id: s5 }));
          });
        }), this.sendResult({ id: s5, topic: t6, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t6, error: Kt("USER_DISCONNECTED") })]).catch((i9) => this.client.logger.error(i9));
      } catch (i9) {
        this.client.logger.error(i9);
      }
    }), c3(this, "onSessionRequest", async (t6) => {
      var e11, s5, i9;
      const { topic: r8, payload: n5, attestation: a6, encryptedId: l9, transportType: p9 } = t6, { id: h9, params: u10 } = n5;
      try {
        await this.isValidRequest(I2({ topic: r8 }, u10));
        const d7 = this.client.session.get(r8), w8 = await this.getVerifyContext({ attestationId: a6, hash: zc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u10, h9))), encryptedId: l9, metadata: d7.peer.metadata, transportType: p9 }), m6 = { id: h9, topic: r8, params: u10, verifyContext: w8 };
        await this.setPendingSessionRequest(m6), p9 === Q2.link_mode && (e11 = d7.peer.metadata.redirect) != null && e11.universal && this.client.core.addLinkModeSupportedApp((s5 = d7.peer.metadata.redirect) == null ? void 0 : s5.universal), (i9 = this.client.signConfig) != null && i9.disableRequestQueue ? this.emitSessionRequest(m6) : (this.addSessionRequestToSessionRequestQueue(m6), this.processSessionRequestQueue());
      } catch (d7) {
        await this.sendError({ id: h9, topic: r8, error: d7 }), this.client.logger.error(d7);
      }
    }), c3(this, "onSessionRequestResponse", (t6, e11) => {
      const { id: s5 } = e11, i9 = ci("session_request", s5);
      if (this.events.listenerCount(i9) === 0) throw new Error(`emitting ${i9} without any listeners`);
      isJsonRpcResult(e11) ? this.events.emit(ci("session_request", s5), { result: e11.result }) : isJsonRpcError(e11) && this.events.emit(ci("session_request", s5), { error: e11.error });
    }), c3(this, "onSessionEventRequest", async (t6, e11) => {
      const { id: s5, params: i9 } = e11;
      try {
        const r8 = `${t6}_session_event_${i9.event.name}`, n5 = Ha.get(r8);
        if (n5 && this.isRequestOutOfSync(n5, s5)) {
          this.client.logger.info(`Discarding out of sync request - ${s5}`);
          return;
        }
        this.isValidEmit(I2({ topic: t6 }, i9)), this.client.events.emit("session_event", { id: s5, topic: t6, params: i9 }), Ha.set(r8, s5);
      } catch (r8) {
        await this.sendError({ id: s5, topic: t6, error: r8 }), this.client.logger.error(r8);
      }
    }), c3(this, "onSessionAuthenticateResponse", (t6, e11) => {
      const { id: s5 } = e11;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t6, payload: e11 }), isJsonRpcResult(e11) ? this.events.emit(ci("session_request", s5), { result: e11.result }) : isJsonRpcError(e11) && this.events.emit(ci("session_request", s5), { error: e11.error });
    }), c3(this, "onSessionAuthenticateRequest", async (t6) => {
      var e11;
      const { topic: s5, payload: i9, attestation: r8, encryptedId: n5, transportType: a6 } = t6;
      try {
        const { requester: l9, authPayload: p9, expiryTimestamp: h9 } = i9.params, u10 = await this.getVerifyContext({ attestationId: r8, hash: zc(JSON.stringify(i9)), encryptedId: n5, metadata: l9.metadata, transportType: a6 }), d7 = { requester: l9, pairingTopic: s5, id: i9.id, authPayload: p9, verifyContext: u10, expiryTimestamp: h9 };
        await this.setAuthRequest(i9.id, { request: d7, pairingTopic: s5, transportType: a6 }), a6 === Q2.link_mode && (e11 = l9.metadata.redirect) != null && e11.universal && this.client.core.addLinkModeSupportedApp(l9.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s5, params: i9.params, id: i9.id, verifyContext: u10 });
      } catch (l9) {
        this.client.logger.error(l9);
        const p9 = i9.params.requester.publicKey, h9 = await this.client.core.crypto.generateKeyPair(), u10 = this.getAppLinkIfEnabled(i9.params.requester.metadata, a6), d7 = { type: ee, receiverPublicKey: p9, senderPublicKey: h9 };
        await this.sendError({ id: i9.id, topic: s5, error: l9, encodeOpts: d7, rpcOpts: N3.wc_sessionAuthenticate.autoReject, appLink: u10 });
      }
    }), c3(this, "addSessionRequestToSessionRequestQueue", (t6) => {
      this.sessionRequestQueue.queue.push(t6);
    }), c3(this, "cleanupAfterResponse", (t6) => {
      this.deletePendingSessionRequest(t6.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c3(this, "cleanupPendingSentRequestsForTopic", ({ topic: t6, error: e11 }) => {
      const s5 = this.client.core.history.pending;
      s5.length > 0 && s5.filter((i9) => i9.topic === t6 && i9.request.method === "wc_sessionRequest").forEach((i9) => {
        const r8 = i9.request.id, n5 = ci("session_request", r8);
        if (this.events.listenerCount(n5) === 0) throw new Error(`emitting ${n5} without any listeners`);
        this.events.emit(ci("session_request", i9.request.id), { error: e11 });
      });
    }), c3(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t6 = this.sessionRequestQueue.queue[0];
      if (!t6) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t6);
      } catch (e11) {
        this.client.logger.error(e11);
      }
    }), c3(this, "emitSessionRequest", (t6) => {
      if (this.emittedSessionRequests.has(t6.id)) {
        this.client.logger.warn({ id: t6.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t6.id}`);
        return;
      }
      this.sessionRequestQueue.state = $2.active, this.emittedSessionRequests.add(t6.id), this.client.events.emit("session_request", t6);
    }), c3(this, "onPairingCreated", (t6) => {
      if (t6.methods && this.expectedPairingMethodMap.set(t6.topic, t6.methods), t6.active) return;
      const e11 = this.client.proposal.getAll().find((s5) => s5.pairingTopic === t6.topic);
      e11 && this.onSessionProposeRequest({ topic: t6.topic, payload: formatJsonRpcRequest("wc_sessionPropose", x2(I2({}, e11), { requiredNamespaces: e11.requiredNamespaces, optionalNamespaces: e11.optionalNamespaces, relays: e11.relays, proposer: e11.proposer, sessionProperties: e11.sessionProperties, scopedProperties: e11.scopedProperties }), e11.id), attestation: e11.attestation, encryptedId: e11.encryptedId });
    }), c3(this, "isValidConnect", async (t6) => {
      if (!Aa(t6)) {
        const { message: l9 } = Et("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t6)}`);
        throw new Error(l9);
      }
      const { pairingTopic: e11, requiredNamespaces: s5, optionalNamespaces: i9, sessionProperties: r8, scopedProperties: n5, relays: a6 } = t6;
      if (kt(e11) || await this.isValidPairingTopic(e11), !Ba(a6, true)) {
        const { message: l9 } = Et("MISSING_OR_INVALID", `connect() relays: ${a6}`);
        throw new Error(l9);
      }
      if (!kt(s5) && Ve(s5) !== 0) {
        const l9 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l9) : this.client.logger.warn(l9), this.validateNamespaces(s5, "requiredNamespaces");
      }
      if (!kt(i9) && Ve(i9) !== 0 && this.validateNamespaces(i9, "optionalNamespaces"), kt(r8) || this.validateSessionProps(r8, "sessionProperties"), !kt(n5)) {
        this.validateSessionProps(n5, "scopedProperties");
        const l9 = Object.keys(s5 || {}).concat(Object.keys(i9 || {}));
        if (!Object.keys(n5).every((p9) => l9.includes(p9.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(n5)}, required/optional namespaces: ${JSON.stringify(l9)}`);
      }
    }), c3(this, "validateNamespaces", (t6, e11) => {
      const s5 = Ea(t6, "connect()", e11);
      if (s5) throw new Error(s5.message);
    }), c3(this, "isValidApprove", async (t6) => {
      if (!Aa(t6)) throw new Error(Et("MISSING_OR_INVALID", `approve() params: ${t6}`).message);
      const { id: e11, namespaces: s5, relayProtocol: i9, sessionProperties: r8, scopedProperties: n5 } = t6;
      this.checkRecentlyDeleted(e11), await this.isValidProposalId(e11);
      const a6 = this.client.proposal.get(e11), l9 = is(s5, "approve()");
      if (l9) throw new Error(l9.message);
      const p9 = cs(a6.requiredNamespaces, s5, "approve()");
      if (p9) throw new Error(p9.message);
      if (!it(i9, true)) {
        const { message: h9 } = Et("MISSING_OR_INVALID", `approve() relayProtocol: ${i9}`);
        throw new Error(h9);
      }
      if (kt(r8) || this.validateSessionProps(r8, "sessionProperties"), !kt(n5)) {
        this.validateSessionProps(n5, "scopedProperties");
        const h9 = new Set(Object.keys(s5));
        if (!Object.keys(n5).every((u10) => h9.has(u10.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(n5)}, approved namespaces: ${Array.from(h9).join(", ")}`);
      }
    }), c3(this, "isValidReject", async (t6) => {
      if (!Aa(t6)) {
        const { message: i9 } = Et("MISSING_OR_INVALID", `reject() params: ${t6}`);
        throw new Error(i9);
      }
      const { id: e11, reason: s5 } = t6;
      if (this.checkRecentlyDeleted(e11), await this.isValidProposalId(e11), !Sa(s5)) {
        const { message: i9 } = Et("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s5)}`);
        throw new Error(i9);
      }
    }), c3(this, "isValidSessionSettleRequest", (t6) => {
      if (!Aa(t6)) {
        const { message: l9 } = Et("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t6}`);
        throw new Error(l9);
      }
      const { relay: e11, controller: s5, namespaces: i9, expiry: r8 } = t6;
      if (!fs(e11)) {
        const { message: l9 } = Et("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l9);
      }
      const n5 = va(s5, "onSessionSettleRequest()");
      if (n5) throw new Error(n5.message);
      const a6 = is(i9, "onSessionSettleRequest()");
      if (a6) throw new Error(a6.message);
      if (fi(r8)) {
        const { message: l9 } = Et("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l9);
      }
    }), c3(this, "isValidUpdate", async (t6) => {
      if (!Aa(t6)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `update() params: ${t6}`);
        throw new Error(a6);
      }
      const { topic: e11, namespaces: s5 } = t6;
      this.checkRecentlyDeleted(e11), await this.isValidSessionTopic(e11);
      const i9 = this.client.session.get(e11), r8 = is(s5, "update()");
      if (r8) throw new Error(r8.message);
      const n5 = cs(i9.requiredNamespaces, s5, "update()");
      if (n5) throw new Error(n5.message);
    }), c3(this, "isValidExtend", async (t6) => {
      if (!Aa(t6)) {
        const { message: s5 } = Et("MISSING_OR_INVALID", `extend() params: ${t6}`);
        throw new Error(s5);
      }
      const { topic: e11 } = t6;
      this.checkRecentlyDeleted(e11), await this.isValidSessionTopic(e11);
    }), c3(this, "isValidRequest", async (t6) => {
      if (!Aa(t6)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `request() params: ${t6}`);
        throw new Error(a6);
      }
      const { topic: e11, request: s5, chainId: i9, expiry: r8 } = t6;
      this.checkRecentlyDeleted(e11), await this.isValidSessionTopic(e11);
      const { namespaces: n5 } = this.client.session.get(e11);
      if (!_a(n5, i9)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `request() chainId: ${i9}`);
        throw new Error(a6);
      }
      if (!Na(s5)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `request() ${JSON.stringify(s5)}`);
        throw new Error(a6);
      }
      if (!Ta(n5, i9, s5.method)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `request() method: ${s5.method}`);
        throw new Error(a6);
      }
      if (r8 && !La(r8, _e3)) {
        const { message: a6 } = Et("MISSING_OR_INVALID", `request() expiry: ${r8}. Expiry must be a number (in seconds) between ${_e3.min} and ${_e3.max}`);
        throw new Error(a6);
      }
    }), c3(this, "isValidRespond", async (t6) => {
      var e11;
      if (!Aa(t6)) {
        const { message: r8 } = Et("MISSING_OR_INVALID", `respond() params: ${t6}`);
        throw new Error(r8);
      }
      const { topic: s5, response: i9 } = t6;
      try {
        await this.isValidSessionTopic(s5);
      } catch (r8) {
        throw (e11 = t6 == null ? void 0 : t6.response) != null && e11.id && this.cleanupAfterResponse(t6), r8;
      }
      if (!Oa(i9)) {
        const { message: r8 } = Et("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i9)}`);
        throw new Error(r8);
      }
    }), c3(this, "isValidPing", async (t6) => {
      if (!Aa(t6)) {
        const { message: s5 } = Et("MISSING_OR_INVALID", `ping() params: ${t6}`);
        throw new Error(s5);
      }
      const { topic: e11 } = t6;
      await this.isValidSessionOrPairingTopic(e11);
    }), c3(this, "isValidEmit", async (t6) => {
      if (!Aa(t6)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() params: ${t6}`);
        throw new Error(n5);
      }
      const { topic: e11, event: s5, chainId: i9 } = t6;
      await this.isValidSessionTopic(e11);
      const { namespaces: r8 } = this.client.session.get(e11);
      if (!_a(r8, i9)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() chainId: ${i9}`);
        throw new Error(n5);
      }
      if (!Ua(s5)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s5)}`);
        throw new Error(n5);
      }
      if (!Ra(r8, i9, s5.name)) {
        const { message: n5 } = Et("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s5)}`);
        throw new Error(n5);
      }
    }), c3(this, "isValidDisconnect", async (t6) => {
      if (!Aa(t6)) {
        const { message: s5 } = Et("MISSING_OR_INVALID", `disconnect() params: ${t6}`);
        throw new Error(s5);
      }
      const { topic: e11 } = t6;
      await this.isValidSessionOrPairingTopic(e11);
    }), c3(this, "isValidAuthenticate", (t6) => {
      const { chains: e11, uri: s5, domain: i9, nonce: r8 } = t6;
      if (!Array.isArray(e11) || e11.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!it(s5, false)) throw new Error("uri is required parameter");
      if (!it(i9, false)) throw new Error("domain is required parameter");
      if (!it(r8, false)) throw new Error("nonce is required parameter");
      if ([...new Set(e11.map((a6) => Fe(a6).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n5 } = Fe(e11[0]);
      if (n5 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c3(this, "getVerifyContext", async (t6) => {
      const { attestationId: e11, hash: s5, encryptedId: i9, metadata: r8, transportType: n5 } = t6, a6 = { verified: { verifyUrl: r8.verifyUrl || ue2, validation: "UNKNOWN", origin: r8.url || "" } };
      try {
        if (n5 === Q2.link_mode) {
          const p9 = this.getAppLinkIfEnabled(r8, n5);
          return a6.verified.validation = p9 && new URL(p9).origin === new URL(r8.url).origin ? "VALID" : "INVALID", a6;
        }
        const l9 = await this.client.core.verify.resolve({ attestationId: e11, hash: s5, encryptedId: i9, verifyUrl: r8.verifyUrl });
        l9 && (a6.verified.origin = l9.origin, a6.verified.isScam = l9.isScam, a6.verified.validation = l9.origin === new URL(r8.url).origin ? "VALID" : "INVALID");
      } catch (l9) {
        this.client.logger.warn(l9);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a6)}`), a6;
    }), c3(this, "validateSessionProps", (t6, e11) => {
      Object.values(t6).forEach((s5, i9) => {
        if (s5 == null) {
          const { message: r8 } = Et("MISSING_OR_INVALID", `${e11} must contain an existing value for each key. Received: ${s5} for key ${Object.keys(t6)[i9]}`);
          throw new Error(r8);
        }
      });
    }), c3(this, "getPendingAuthRequest", (t6) => {
      const e11 = this.client.auth.requests.get(t6);
      return typeof e11 == "object" ? e11 : void 0;
    }), c3(this, "addToRecentlyDeleted", (t6, e11) => {
      if (this.recentlyDeletedMap.set(t6, e11), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s5 = 0;
        const i9 = this.recentlyDeletedLimit / 2;
        for (const r8 of this.recentlyDeletedMap.keys()) {
          if (s5++ >= i9) break;
          this.recentlyDeletedMap.delete(r8);
        }
      }
    }), c3(this, "checkRecentlyDeleted", (t6) => {
      const e11 = this.recentlyDeletedMap.get(t6);
      if (e11) {
        const { message: s5 } = Et("MISSING_OR_INVALID", `Record was recently deleted - ${e11}: ${t6}`);
        throw new Error(s5);
      }
    }), c3(this, "isLinkModeEnabled", (t6, e11) => {
      var s5, i9, r8, n5, a6, l9, p9, h9, u10;
      return !t6 || e11 !== Q2.link_mode ? false : ((i9 = (s5 = this.client.metadata) == null ? void 0 : s5.redirect) == null ? void 0 : i9.linkMode) === true && ((n5 = (r8 = this.client.metadata) == null ? void 0 : r8.redirect) == null ? void 0 : n5.universal) !== void 0 && ((l9 = (a6 = this.client.metadata) == null ? void 0 : a6.redirect) == null ? void 0 : l9.universal) !== "" && ((p9 = t6 == null ? void 0 : t6.redirect) == null ? void 0 : p9.universal) !== void 0 && ((h9 = t6 == null ? void 0 : t6.redirect) == null ? void 0 : h9.universal) !== "" && ((u10 = t6 == null ? void 0 : t6.redirect) == null ? void 0 : u10.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t6.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c3(this, "getAppLinkIfEnabled", (t6, e11) => {
      var s5;
      return this.isLinkModeEnabled(t6, e11) ? (s5 = t6 == null ? void 0 : t6.redirect) == null ? void 0 : s5.universal : void 0;
    }), c3(this, "handleLinkModeMessage", ({ url: t6 }) => {
      if (!t6 || !t6.includes("wc_ev") || !t6.includes("topic")) return;
      const e11 = li(t6, "topic") || "", s5 = decodeURIComponent(li(t6, "wc_ev") || ""), i9 = this.client.session.keys.includes(e11);
      i9 && this.client.session.update(e11, { transportType: Q2.link_mode }), this.client.core.dispatchEnvelope({ topic: e11, message: s5, sessionExists: i9 });
    }), c3(this, "registerLinkModeListeners", async () => {
      var t6;
      if (hi() || Bt() && (t6 = this.client.metadata.redirect) != null && t6.linkMode) {
        const e11 = global == null ? void 0 : global.Linking;
        if (typeof e11 < "u") {
          e11.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s5 = await e11.getInitialURL();
          s5 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s5 });
          }, 50);
        }
      }
    }), c3(this, "getTVFParams", (t6, e11, s5) => {
      var i9, r8, n5;
      if (!((i9 = e11.request) != null && i9.method)) return {};
      const a6 = { correlationId: t6, rpcMethods: [e11.request.method], chainId: e11.chainId };
      try {
        const l9 = this.extractTxHashesFromResult(e11.request, s5);
        a6.txHashes = l9, a6.contractAddresses = this.isValidContractData(e11.request.params) ? [(n5 = (r8 = e11.request.params) == null ? void 0 : r8[0]) == null ? void 0 : n5.to] : [];
      } catch (l9) {
        this.client.logger.warn("Error getting TVF params", l9);
      }
      return a6;
    }), c3(this, "isValidContractData", (t6) => {
      var e11;
      if (!t6) return false;
      try {
        const s5 = (t6 == null ? void 0 : t6.data) || ((e11 = t6 == null ? void 0 : t6[0]) == null ? void 0 : e11.data);
        if (!s5.startsWith("0x")) return false;
        const i9 = s5.slice(2);
        return /^[0-9a-fA-F]*$/.test(i9) ? i9.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c3(this, "extractTxHashesFromResult", (t6, e11) => {
      var s5;
      try {
        if (!e11) return [];
        const i9 = t6.method, r8 = gt2[i9];
        if (i9 === "sui_signTransaction") return [ff(e11.transactionBytes)];
        if (i9 === "near_signTransaction") return [cf(e11)];
        if (i9 === "near_signTransactions") return e11.map((a6) => cf(a6));
        if (i9 === "xrpl_signTransactionFor" || i9 === "xrpl_signTransaction") return [(s5 = e11.tx_json) == null ? void 0 : s5.hash];
        if (i9 === "polkadot_signTransaction") return [Ka({ transaction: t6.params.transactionPayload, signature: e11.signature })];
        if (i9 === "algo_signTxn") return me(e11) ? e11.map((a6) => af(a6)) : [af(e11)];
        if (i9 === "cosmos_signDirect") return [uf(e11)];
        if (typeof e11 == "string") return [e11];
        const n5 = e11[r8.key];
        if (me(n5)) return i9 === "solana_signAllTransactions" ? n5.map((a6) => sf(a6)) : n5;
        if (typeof n5 == "string") return [n5];
      } catch (i9) {
        this.client.logger.warn("Error extracting tx hashes from result", i9);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const o6 = this.client.session.keys, t6 = this.client.core.relayer.messages.getWithoutAck(o6);
      for (const [e11, s5] of Object.entries(t6)) for (const i9 of s5) try {
        await this.onProviderMessageEvent({ topic: e11, message: i9, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${e11}, message: ${i9}`);
      }
    } catch (o6) {
      this.client.logger.warn("processPendingMessageEvents failed", o6);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o6 } = Et("NOT_INITIALIZED", this.name);
      throw new Error(o6);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C2.message, (o6) => {
      this.onProviderMessageEvent(o6);
    });
  }
  async onRelayMessage(o6) {
    const { topic: t6, message: e11, attestation: s5, transportType: i9 } = o6, { publicKey: r8 } = this.client.auth.authKeys.keys.includes(ce2) ? this.client.auth.authKeys.get(ce2) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const n5 = await this.client.core.crypto.decode(t6, e11, { receiverPublicKey: r8, encoding: i9 === Q2.link_mode ? De : Qt });
      isJsonRpcRequest(n5) ? (this.client.core.history.set(t6, n5), await this.onRelayEventRequest({ topic: t6, payload: n5, attestation: s5, transportType: i9, encryptedId: zc(e11) })) : isJsonRpcResponse(n5) ? (await this.client.core.history.resolve(n5), await this.onRelayEventResponse({ topic: t6, payload: n5, transportType: i9 }), this.client.core.history.delete(t6, n5.id)) : await this.onRelayEventUnknownPayload({ topic: t6, payload: n5, transportType: i9 }), await this.client.core.relayer.messages.ack(t6, e11);
    } catch (n5) {
      this.client.logger.error(n5);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M2.expired, async (o6) => {
      const { topic: t6, id: e11 } = si(o6.target);
      if (e11 && this.client.pendingRequest.keys.includes(e11)) return await this.deletePendingSessionRequest(e11, Et("EXPIRED"), true);
      if (e11 && this.client.auth.requests.keys.includes(e11)) return await this.deletePendingAuthRequest(e11, Et("EXPIRED"), true);
      t6 ? this.client.session.keys.includes(t6) && (await this.deleteSession({ topic: t6, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t6 })) : e11 && (await this.deleteProposal(e11, true), this.client.events.emit("proposal_expire", { id: e11 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re.create, (o6) => this.onPairingCreated(o6)), this.client.core.pairing.events.on(re.delete, (o6) => {
      this.addToRecentlyDeleted(o6.topic, "pairing");
    });
  }
  isValidPairingTopic(o6) {
    if (!it(o6, false)) {
      const { message: t6 } = Et("MISSING_OR_INVALID", `pairing topic should be a string: ${o6}`);
      throw new Error(t6);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o6)) {
      const { message: t6 } = Et("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o6}`);
      throw new Error(t6);
    }
    if (fi(this.client.core.pairing.pairings.get(o6).expiry)) {
      const { message: t6 } = Et("EXPIRED", `pairing topic: ${o6}`);
      throw new Error(t6);
    }
  }
  async isValidSessionTopic(o6) {
    if (!it(o6, false)) {
      const { message: t6 } = Et("MISSING_OR_INVALID", `session topic should be a string: ${o6}`);
      throw new Error(t6);
    }
    if (this.checkRecentlyDeleted(o6), !this.client.session.keys.includes(o6)) {
      const { message: t6 } = Et("NO_MATCHING_KEY", `session topic doesn't exist: ${o6}`);
      throw new Error(t6);
    }
    if (fi(this.client.session.get(o6).expiry)) {
      await this.deleteSession({ topic: o6 });
      const { message: t6 } = Et("EXPIRED", `session topic: ${o6}`);
      throw new Error(t6);
    }
    if (!this.client.core.crypto.keychain.has(o6)) {
      const { message: t6 } = Et("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o6}`);
      throw await this.deleteSession({ topic: o6 }), new Error(t6);
    }
  }
  async isValidSessionOrPairingTopic(o6) {
    if (this.checkRecentlyDeleted(o6), this.client.session.keys.includes(o6)) await this.isValidSessionTopic(o6);
    else if (this.client.core.pairing.pairings.keys.includes(o6)) this.isValidPairingTopic(o6);
    else if (it(o6, false)) {
      const { message: t6 } = Et("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o6}`);
      throw new Error(t6);
    } else {
      const { message: t6 } = Et("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o6}`);
      throw new Error(t6);
    }
  }
  async isValidProposalId(o6) {
    if (!Ia(o6)) {
      const { message: t6 } = Et("MISSING_OR_INVALID", `proposal id should be a number: ${o6}`);
      throw new Error(t6);
    }
    if (!this.client.proposal.keys.includes(o6)) {
      const { message: t6 } = Et("NO_MATCHING_KEY", `proposal id doesn't exist: ${o6}`);
      throw new Error(t6);
    }
    if (fi(this.client.proposal.get(o6).expiryTimestamp)) {
      await this.deleteProposal(o6);
      const { message: t6 } = Et("EXPIRED", `proposal id: ${o6}`);
      throw new Error(t6);
    }
  }
};
var ks2 = class extends Li2 {
  constructor(o6, t6) {
    super(o6, t6, ht2, me2), this.core = o6, this.logger = t6;
  }
};
var vt2 = class extends Li2 {
  constructor(o6, t6) {
    super(o6, t6, dt2, me2), this.core = o6, this.logger = t6;
  }
};
var Ds = class extends Li2 {
  constructor(o6, t6) {
    super(o6, t6, yt, me2, (e11) => e11.id), this.core = o6, this.logger = t6;
  }
};
var Ls2 = class extends Li2 {
  constructor(o6, t6) {
    super(o6, t6, Et3, ae2, () => ce2), this.core = o6, this.logger = t6;
  }
};
var Ms2 = class extends Li2 {
  constructor(o6, t6) {
    super(o6, t6, ft, ae2), this.core = o6, this.logger = t6;
  }
};
var $s2 = class extends Li2 {
  constructor(o6, t6) {
    super(o6, t6, St3, ae2, (e11) => e11.id), this.core = o6, this.logger = t6;
  }
};
var Ks2 = Object.defineProperty;
var Us = (S8, o6, t6) => o6 in S8 ? Ks2(S8, o6, { enumerable: true, configurable: true, writable: true, value: t6 }) : S8[o6] = t6;
var Ke3 = (S8, o6, t6) => Us(S8, typeof o6 != "symbol" ? o6 + "" : o6, t6);
var Gs2 = class {
  constructor(o6, t6) {
    this.core = o6, this.logger = t6, Ke3(this, "authKeys"), Ke3(this, "pairingTopics"), Ke3(this, "requests"), this.authKeys = new Ls2(this.core, this.logger), this.pairingTopics = new Ms2(this.core, this.logger), this.requests = new $s2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var js2 = Object.defineProperty;
var Fs = (S8, o6, t6) => o6 in S8 ? js2(S8, o6, { enumerable: true, configurable: true, writable: true, value: t6 }) : S8[o6] = t6;
var f5 = (S8, o6, t6) => Fs(S8, typeof o6 != "symbol" ? o6 + "" : o6, t6);
var Ee2 = class _Ee extends J2 {
  constructor(o6) {
    super(o6), f5(this, "protocol", Ce3), f5(this, "version", ke3), f5(this, "name", we2.name), f5(this, "metadata"), f5(this, "core"), f5(this, "logger"), f5(this, "events", new import_events4.EventEmitter()), f5(this, "engine"), f5(this, "session"), f5(this, "proposal"), f5(this, "pendingRequest"), f5(this, "auth"), f5(this, "signConfig"), f5(this, "on", (e11, s5) => this.events.on(e11, s5)), f5(this, "once", (e11, s5) => this.events.once(e11, s5)), f5(this, "off", (e11, s5) => this.events.off(e11, s5)), f5(this, "removeListener", (e11, s5) => this.events.removeListener(e11, s5)), f5(this, "removeAllListeners", (e11) => this.events.removeAllListeners(e11)), f5(this, "connect", async (e11) => {
      try {
        return await this.engine.connect(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "pair", async (e11) => {
      try {
        return await this.engine.pair(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "approve", async (e11) => {
      try {
        return await this.engine.approve(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "reject", async (e11) => {
      try {
        return await this.engine.reject(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "update", async (e11) => {
      try {
        return await this.engine.update(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "extend", async (e11) => {
      try {
        return await this.engine.extend(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "request", async (e11) => {
      try {
        return await this.engine.request(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "respond", async (e11) => {
      try {
        return await this.engine.respond(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "ping", async (e11) => {
      try {
        return await this.engine.ping(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "emit", async (e11) => {
      try {
        return await this.engine.emit(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "disconnect", async (e11) => {
      try {
        return await this.engine.disconnect(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "find", (e11) => {
      try {
        return this.engine.find(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (e11) {
        throw this.logger.error(e11.message), e11;
      }
    }), f5(this, "authenticate", async (e11, s5) => {
      try {
        return await this.engine.authenticate(e11, s5);
      } catch (i9) {
        throw this.logger.error(i9.message), i9;
      }
    }), f5(this, "formatAuthMessage", (e11) => {
      try {
        return this.engine.formatAuthMessage(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "approveSessionAuthenticate", async (e11) => {
      try {
        return await this.engine.approveSessionAuthenticate(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), f5(this, "rejectSessionAuthenticate", async (e11) => {
      try {
        return await this.engine.rejectSessionAuthenticate(e11);
      } catch (s5) {
        throw this.logger.error(s5.message), s5;
      }
    }), this.name = (o6 == null ? void 0 : o6.name) || we2.name, this.metadata = Ks(o6 == null ? void 0 : o6.metadata), this.signConfig = o6 == null ? void 0 : o6.signConfig;
    const t6 = typeof (o6 == null ? void 0 : o6.logger) < "u" && typeof (o6 == null ? void 0 : o6.logger) != "string" ? o6.logger : (0, import_pino.default)(k({ level: (o6 == null ? void 0 : o6.logger) || we2.logger }));
    this.core = (o6 == null ? void 0 : o6.core) || new Zo2(o6), this.logger = E(t6, this.name), this.session = new vt2(this.core, this.logger), this.proposal = new ks2(this.core, this.logger), this.pendingRequest = new Ds(this.core, this.logger), this.engine = new Cs2(this), this.auth = new Gs2(this.core, this.logger);
  }
  static async init(o6) {
    const t6 = new _Ee(o6);
    return await t6.initialize(), t6;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (o6) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o6.message), o6;
    }
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var rt2 = "error";
var Lt3 = "wss://relay.walletconnect.org";
var Mt3 = "wc";
var Bt3 = "universal_provider";
var U3 = `${Mt3}@2:${Bt3}:`;
var nt2 = "https://rpc.walletconnect.org/v1/";
var I3 = "generic";
var Gt3 = `${nt2}bundler`;
var l3 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function W3(i9) {
  return i9 == null || typeof i9 != "object" && typeof i9 != "function";
}
function at2(i9) {
  return Object.getOwnPropertySymbols(i9).filter((t6) => Object.prototype.propertyIsEnumerable.call(i9, t6));
}
function ct3(i9) {
  return i9 == null ? i9 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(i9);
}
var Jt3 = "[object RegExp]";
var ot2 = "[object String]";
var ht3 = "[object Number]";
var pt3 = "[object Boolean]";
var dt3 = "[object Arguments]";
var zt3 = "[object Symbol]";
var kt3 = "[object Date]";
var Wt3 = "[object Map]";
var Kt3 = "[object Set]";
var Vt3 = "[object Array]";
var Xt3 = "[object ArrayBuffer]";
var Yt3 = "[object Object]";
var Qt3 = "[object DataView]";
var Zt3 = "[object Uint8Array]";
var Tt3 = "[object Uint8ClampedArray]";
var te2 = "[object Uint16Array]";
var ee3 = "[object Uint32Array]";
var ie3 = "[object Int8Array]";
var se3 = "[object Int16Array]";
var re2 = "[object Int32Array]";
var ne3 = "[object Float32Array]";
var ae3 = "[object Float64Array]";
function K2(i9) {
  return ArrayBuffer.isView(i9) && !(i9 instanceof DataView);
}
function ce3(i9, t6) {
  return $3(i9, void 0, i9, /* @__PURE__ */ new Map(), t6);
}
function $3(i9, t6, e11, s5 = /* @__PURE__ */ new Map(), n5 = void 0) {
  const a6 = n5 == null ? void 0 : n5(i9, t6, e11, s5);
  if (a6 != null) return a6;
  if (W3(i9)) return i9;
  if (s5.has(i9)) return s5.get(i9);
  if (Array.isArray(i9)) {
    const r8 = new Array(i9.length);
    s5.set(i9, r8);
    for (let c9 = 0; c9 < i9.length; c9++) r8[c9] = $3(i9[c9], c9, e11, s5, n5);
    return Object.hasOwn(i9, "index") && (r8.index = i9.index), Object.hasOwn(i9, "input") && (r8.input = i9.input), r8;
  }
  if (i9 instanceof Date) return new Date(i9.getTime());
  if (i9 instanceof RegExp) {
    const r8 = new RegExp(i9.source, i9.flags);
    return r8.lastIndex = i9.lastIndex, r8;
  }
  if (i9 instanceof Map) {
    const r8 = /* @__PURE__ */ new Map();
    s5.set(i9, r8);
    for (const [c9, o6] of i9) r8.set(c9, $3(o6, c9, e11, s5, n5));
    return r8;
  }
  if (i9 instanceof Set) {
    const r8 = /* @__PURE__ */ new Set();
    s5.set(i9, r8);
    for (const c9 of i9) r8.add($3(c9, void 0, e11, s5, n5));
    return r8;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(i9)) return i9.subarray();
  if (K2(i9)) {
    const r8 = new (Object.getPrototypeOf(i9)).constructor(i9.length);
    s5.set(i9, r8);
    for (let c9 = 0; c9 < i9.length; c9++) r8[c9] = $3(i9[c9], c9, e11, s5, n5);
    return r8;
  }
  if (i9 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && i9 instanceof SharedArrayBuffer) return i9.slice(0);
  if (i9 instanceof DataView) {
    const r8 = new DataView(i9.buffer.slice(0), i9.byteOffset, i9.byteLength);
    return s5.set(i9, r8), y5(r8, i9, e11, s5, n5), r8;
  }
  if (typeof File < "u" && i9 instanceof File) {
    const r8 = new File([i9], i9.name, { type: i9.type });
    return s5.set(i9, r8), y5(r8, i9, e11, s5, n5), r8;
  }
  if (i9 instanceof Blob) {
    const r8 = new Blob([i9], { type: i9.type });
    return s5.set(i9, r8), y5(r8, i9, e11, s5, n5), r8;
  }
  if (i9 instanceof Error) {
    const r8 = new i9.constructor();
    return s5.set(i9, r8), r8.message = i9.message, r8.name = i9.name, r8.stack = i9.stack, r8.cause = i9.cause, y5(r8, i9, e11, s5, n5), r8;
  }
  if (typeof i9 == "object" && oe(i9)) {
    const r8 = Object.create(Object.getPrototypeOf(i9));
    return s5.set(i9, r8), y5(r8, i9, e11, s5, n5), r8;
  }
  return i9;
}
function y5(i9, t6, e11 = i9, s5, n5) {
  const a6 = [...Object.keys(t6), ...at2(t6)];
  for (let r8 = 0; r8 < a6.length; r8++) {
    const c9 = a6[r8], o6 = Object.getOwnPropertyDescriptor(i9, c9);
    (o6 == null || o6.writable) && (i9[c9] = $3(t6[c9], c9, e11, s5, n5));
  }
}
function oe(i9) {
  switch (ct3(i9)) {
    case dt3:
    case Vt3:
    case Xt3:
    case Qt3:
    case pt3:
    case kt3:
    case ne3:
    case ae3:
    case ie3:
    case se3:
    case re2:
    case Wt3:
    case ht3:
    case Yt3:
    case Jt3:
    case Kt3:
    case ot2:
    case zt3:
    case Zt3:
    case Tt3:
    case te2:
    case ee3:
      return true;
    default:
      return false;
  }
}
function he3(i9, t6) {
  return ce3(i9, (e11, s5, n5, a6) => {
    const r8 = t6 == null ? void 0 : t6(e11, s5, n5, a6);
    if (r8 != null) return r8;
    if (typeof i9 == "object") switch (Object.prototype.toString.call(i9)) {
      case ht3:
      case ot2:
      case pt3: {
        const c9 = new i9.constructor(i9 == null ? void 0 : i9.valueOf());
        return y5(c9, i9), c9;
      }
      case dt3: {
        const c9 = {};
        return y5(c9, i9), c9.length = i9.length, c9[Symbol.iterator] = i9[Symbol.iterator], c9;
      }
      default:
        return;
    }
  });
}
function ut3(i9) {
  return he3(i9);
}
function lt3(i9) {
  return i9 !== null && typeof i9 == "object" && ct3(i9) === "[object Arguments]";
}
function ft2(i9) {
  return typeof i9 == "object" && i9 !== null;
}
function pe3() {
}
function de3(i9) {
  return K2(i9);
}
function ue3(i9) {
  var _a14;
  if (typeof i9 != "object" || i9 == null) return false;
  if (Object.getPrototypeOf(i9) === null) return true;
  if (Object.prototype.toString.call(i9) !== "[object Object]") {
    const e11 = i9[Symbol.toStringTag];
    return e11 == null || !((_a14 = Object.getOwnPropertyDescriptor(i9, Symbol.toStringTag)) == null ? void 0 : _a14.writable) ? false : i9.toString() === `[object ${e11}]`;
  }
  let t6 = i9;
  for (; Object.getPrototypeOf(t6) !== null; ) t6 = Object.getPrototypeOf(t6);
  return Object.getPrototypeOf(i9) === t6;
}
function le3(i9) {
  if (W3(i9)) return i9;
  if (Array.isArray(i9) || K2(i9) || i9 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && i9 instanceof SharedArrayBuffer) return i9.slice(0);
  const t6 = Object.getPrototypeOf(i9), e11 = t6.constructor;
  if (i9 instanceof Date || i9 instanceof Map || i9 instanceof Set) return new e11(i9);
  if (i9 instanceof RegExp) {
    const s5 = new e11(i9);
    return s5.lastIndex = i9.lastIndex, s5;
  }
  if (i9 instanceof DataView) return new e11(i9.buffer.slice(0));
  if (i9 instanceof Error) {
    const s5 = new e11(i9.message);
    return s5.stack = i9.stack, s5.name = i9.name, s5.cause = i9.cause, s5;
  }
  if (typeof File < "u" && i9 instanceof File) return new e11([i9], i9.name, { type: i9.type, lastModified: i9.lastModified });
  if (typeof i9 == "object") {
    const s5 = Object.create(t6);
    return Object.assign(s5, i9);
  }
  return i9;
}
function fe3(i9, ...t6) {
  const e11 = t6.slice(0, -1), s5 = t6[t6.length - 1];
  let n5 = i9;
  for (let a6 = 0; a6 < e11.length; a6++) {
    const r8 = e11[a6];
    n5 = x3(n5, r8, s5, /* @__PURE__ */ new Map());
  }
  return n5;
}
function x3(i9, t6, e11, s5) {
  if (W3(i9) && (i9 = Object(i9)), t6 == null || typeof t6 != "object") return i9;
  if (s5.has(t6)) return le3(s5.get(t6));
  if (s5.set(t6, i9), Array.isArray(t6)) {
    t6 = t6.slice();
    for (let a6 = 0; a6 < t6.length; a6++) t6[a6] = t6[a6] ?? void 0;
  }
  const n5 = [...Object.keys(t6), ...at2(t6)];
  for (let a6 = 0; a6 < n5.length; a6++) {
    const r8 = n5[a6];
    let c9 = t6[r8], o6 = i9[r8];
    if (lt3(c9) && (c9 = { ...c9 }), lt3(o6) && (o6 = { ...o6 }), typeof Buffer < "u" && Buffer.isBuffer(c9) && (c9 = ut3(c9)), Array.isArray(c9)) if (typeof o6 == "object" && o6 != null) {
      const v9 = [], w8 = Reflect.ownKeys(o6);
      for (let P7 = 0; P7 < w8.length; P7++) {
        const d7 = w8[P7];
        v9[d7] = o6[d7];
      }
      o6 = v9;
    } else o6 = [];
    const p9 = e11(o6, c9, r8, i9, t6, s5);
    p9 != null ? i9[r8] = p9 : Array.isArray(c9) || ft2(o6) && ft2(c9) ? i9[r8] = x3(o6, c9, e11, s5) : o6 == null && ue3(c9) ? i9[r8] = x3({}, c9, e11, s5) : o6 == null && de3(c9) ? i9[r8] = ut3(c9) : (o6 === void 0 || c9 !== void 0) && (i9[r8] = c9);
  }
  return i9;
}
function me3(i9, ...t6) {
  return fe3(i9, ...t6, pe3);
}
var ve2 = Object.defineProperty;
var ge3 = Object.defineProperties;
var Pe3 = Object.getOwnPropertyDescriptors;
var mt3 = Object.getOwnPropertySymbols;
var we3 = Object.prototype.hasOwnProperty;
var ye3 = Object.prototype.propertyIsEnumerable;
var vt3 = (i9, t6, e11) => t6 in i9 ? ve2(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var L2 = (i9, t6) => {
  for (var e11 in t6 || (t6 = {})) we3.call(t6, e11) && vt3(i9, e11, t6[e11]);
  if (mt3) for (var e11 of mt3(t6)) ye3.call(t6, e11) && vt3(i9, e11, t6[e11]);
  return i9;
};
var be3 = (i9, t6) => ge3(i9, Pe3(t6));
function u2(i9, t6, e11) {
  var s5;
  const n5 = Fe(i9);
  return ((s5 = t6.rpcMap) == null ? void 0 : s5[n5.reference]) || `${nt2}?chainId=${n5.namespace}:${n5.reference}&projectId=${e11}`;
}
function b2(i9) {
  return i9.includes(":") ? i9.split(":")[1] : i9;
}
function gt3(i9) {
  return i9.map((t6) => `${t6.split(":")[0]}:${t6.split(":")[1]}`);
}
function Ie3(i9, t6) {
  const e11 = Object.keys(t6.namespaces).filter((n5) => n5.includes(i9));
  if (!e11.length) return [];
  const s5 = [];
  return e11.forEach((n5) => {
    const a6 = t6.namespaces[n5].accounts;
    s5.push(...a6);
  }), s5;
}
function Pt3(i9) {
  return Object.fromEntries(Object.entries(i9).filter(([t6, e11]) => {
    var s5, n5;
    return ((s5 = e11 == null ? void 0 : e11.chains) == null ? void 0 : s5.length) && ((n5 = e11 == null ? void 0 : e11.chains) == null ? void 0 : n5.length) > 0;
  }));
}
function M3(i9 = {}, t6 = {}) {
  const e11 = Pt3(wt3(i9)), s5 = Pt3(wt3(t6));
  return me3(e11, s5);
}
function wt3(i9) {
  var t6, e11, s5, n5, a6;
  const r8 = {};
  if (!Ve(i9)) return r8;
  for (const [c9, o6] of Object.entries(i9)) {
    const p9 = Pn(c9) ? [c9] : o6.chains, v9 = o6.methods || [], w8 = o6.events || [], P7 = o6.rpcMap || {}, d7 = Yo(c9);
    r8[d7] = be3(L2(L2({}, r8[d7]), o6), { chains: ct(p9, (t6 = r8[d7]) == null ? void 0 : t6.chains), methods: ct(v9, (e11 = r8[d7]) == null ? void 0 : e11.methods), events: ct(w8, (s5 = r8[d7]) == null ? void 0 : s5.events) }), (Ve(P7) || Ve(((n5 = r8[d7]) == null ? void 0 : n5.rpcMap) || {})) && (r8[d7].rpcMap = L2(L2({}, P7), (a6 = r8[d7]) == null ? void 0 : a6.rpcMap));
  }
  return r8;
}
function yt2(i9) {
  return i9.includes(":") ? i9.split(":")[2] : i9;
}
function bt2(i9) {
  const t6 = {};
  for (const [e11, s5] of Object.entries(i9)) {
    const n5 = s5.methods || [], a6 = s5.events || [], r8 = s5.accounts || [], c9 = Pn(e11) ? [e11] : s5.chains ? s5.chains : gt3(s5.accounts);
    t6[e11] = { chains: c9, methods: n5, events: a6, accounts: r8 };
  }
  return t6;
}
function V3(i9) {
  return typeof i9 == "number" ? i9 : i9.includes("0x") ? parseInt(i9, 16) : (i9 = i9.includes(":") ? i9.split(":")[1] : i9, isNaN(Number(i9)) ? i9 : Number(i9));
}
var It3 = {};
var h3 = (i9) => It3[i9];
var X3 = (i9, t6) => {
  It3[i9] = t6;
};
var $e3 = Object.defineProperty;
var $t3 = Object.getOwnPropertySymbols;
var Oe2 = Object.prototype.hasOwnProperty;
var Ae2 = Object.prototype.propertyIsEnumerable;
var Ot3 = (i9, t6, e11) => t6 in i9 ? $e3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var At3 = (i9, t6) => {
  for (var e11 in t6 || (t6 = {})) Oe2.call(t6, e11) && Ot3(i9, e11, t6[e11]);
  if ($t3) for (var e11 of $t3(t6)) Ae2.call(t6, e11) && Ot3(i9, e11, t6[e11]);
  return i9;
};
var Ct3 = "eip155";
var Ce4 = ["atomic", "flow-control", "paymasterService", "sessionKeys", "auxiliaryFunds"];
var Ee3 = (i9) => i9 && i9.startsWith("0x") ? BigInt(i9).toString(10) : i9;
var Y3 = (i9) => i9 && i9.startsWith("0x") ? i9 : `0x${BigInt(i9).toString(16)}`;
var Et4 = (i9) => Object.keys(i9).filter((t6) => Ce4.includes(t6)).reduce((t6, e11) => (t6[e11] = i9[e11], t6), {});
var He3 = (i9, t6, e11) => {
  const { sessionProperties: s5 = {}, scopedProperties: n5 = {} } = i9, a6 = {};
  if (!Ve(n5) && !Ve(s5)) return;
  const r8 = Et4(s5);
  for (const c9 of e11) {
    const o6 = Ee3(c9);
    if (!o6) continue;
    a6[Y3(o6)] = r8;
    const p9 = n5 == null ? void 0 : n5[`${Ct3}:${o6}`];
    if (p9) {
      const v9 = p9 == null ? void 0 : p9[`${Ct3}:${o6}:${t6}`];
      a6[Y3(o6)] = At3(At3({}, a6[Y3(o6)]), Et4(v9 || p9));
    }
  }
  for (const [c9, o6] of Object.entries(a6)) Object.keys(o6).length === 0 && delete a6[c9];
  return Object.keys(a6).length > 0 ? a6 : void 0;
};
var Se3 = Object.defineProperty;
var Ne2 = (i9, t6, e11) => t6 in i9 ? Se3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var O4 = (i9, t6, e11) => Ne2(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var De3 = class {
  constructor(t6) {
    O4(this, "name", "polkadot"), O4(this, "client"), O4(this, "httpProviders"), O4(this, "events"), O4(this, "namespace"), O4(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t6}`);
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      const n5 = b2(e11);
      t6[n5] = this.createHttpProvider(n5, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var qe3 = Object.defineProperty;
var je3 = Object.defineProperties;
var Re2 = Object.getOwnPropertyDescriptors;
var Ht3 = Object.getOwnPropertySymbols;
var _e4 = Object.prototype.hasOwnProperty;
var Fe3 = Object.prototype.propertyIsEnumerable;
var Q3 = (i9, t6, e11) => t6 in i9 ? qe3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var St4 = (i9, t6) => {
  for (var e11 in t6 || (t6 = {})) _e4.call(t6, e11) && Q3(i9, e11, t6[e11]);
  if (Ht3) for (var e11 of Ht3(t6)) Fe3.call(t6, e11) && Q3(i9, e11, t6[e11]);
  return i9;
};
var Nt3 = (i9, t6) => je3(i9, Re2(t6));
var A4 = (i9, t6, e11) => Q3(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var Ue3 = class {
  constructor(t6) {
    A4(this, "name", "eip155"), A4(this, "client"), A4(this, "chainId"), A4(this, "namespace"), A4(this, "httpProviders"), A4(this, "events"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t6) {
    switch (t6.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t6);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t6);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t6);
    }
    return this.namespace.methods.includes(t6.request.method) ? await this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(parseInt(t6), e11), this.chainId = parseInt(t6), this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t6}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(`${this.name}:${t6}`, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      const n5 = parseInt(b2(e11));
      t6[n5] = this.createHttpProvider(n5, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t6 = this.chainId, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  async handleSwitchChain(t6) {
    var e11, s5;
    let n5 = t6.request.params ? (e11 = t6.request.params[0]) == null ? void 0 : e11.chainId : "0x0";
    n5 = n5.startsWith("0x") ? n5 : `0x${n5}`;
    const a6 = parseInt(n5, 16);
    if (this.isChainApproved(a6)) this.setDefaultChain(`${a6}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t6.topic, request: { method: t6.request.method, params: [{ chainId: n5 }] }, chainId: (s5 = this.namespace.chains) == null ? void 0 : s5[0] }), this.setDefaultChain(`${a6}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a6}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t6) {
    return this.namespace.chains.includes(`${this.name}:${t6}`);
  }
  async getCapabilities(t6) {
    var e11, s5, n5, a6, r8;
    const c9 = (s5 = (e11 = t6.request) == null ? void 0 : e11.params) == null ? void 0 : s5[0], o6 = ((a6 = (n5 = t6.request) == null ? void 0 : n5.params) == null ? void 0 : a6[1]) || [];
    if (!c9) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const p9 = this.client.session.get(t6.topic), v9 = ((r8 = p9 == null ? void 0 : p9.sessionProperties) == null ? void 0 : r8.capabilities) || {}, w8 = `${c9}${o6.join(",")}`, P7 = v9 == null ? void 0 : v9[w8];
    if (P7) return P7;
    let d7;
    try {
      d7 = He3(p9, c9, o6);
    } catch (J5) {
      console.warn("Failed to extract capabilities from session", J5);
    }
    if (d7) return d7;
    const tt5 = await this.client.request(t6);
    try {
      await this.client.session.update(t6.topic, { sessionProperties: Nt3(St4({}, p9.sessionProperties || {}), { capabilities: Nt3(St4({}, v9 || {}), { [w8]: tt5 }) }) });
    } catch (J5) {
      console.warn("Failed to update session with capabilities", J5);
    }
    return tt5;
  }
  async getCallStatus(t6) {
    var e11, s5;
    const n5 = this.client.session.get(t6.topic), a6 = (e11 = n5.sessionProperties) == null ? void 0 : e11.bundler_name;
    if (a6) {
      const c9 = this.getBundlerUrl(t6.chainId, a6);
      try {
        return await this.getUserOperationReceipt(c9, t6);
      } catch (o6) {
        console.warn("Failed to fetch call status from bundler", o6, c9);
      }
    }
    const r8 = (s5 = n5.sessionProperties) == null ? void 0 : s5.bundler_url;
    if (r8) try {
      return await this.getUserOperationReceipt(r8, t6);
    } catch (c9) {
      console.warn("Failed to fetch call status from custom bundler", c9, r8);
    }
    if (this.namespace.methods.includes(t6.request.method)) return await this.client.request(t6);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t6, e11) {
    var s5;
    const n5 = new URL(t6), a6 = await fetch(n5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(s5 = e11.request.params) == null ? void 0 : s5[0]])) });
    if (!a6.ok) throw new Error(`Failed to fetch user operation receipt - ${a6.status}`);
    return await a6.json();
  }
  getBundlerUrl(t6, e11) {
    return `${Gt3}?projectId=${this.client.core.projectId}&chainId=${t6}&bundler=${e11}`;
  }
};
var xe2 = Object.defineProperty;
var Le4 = (i9, t6, e11) => t6 in i9 ? xe2(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var C3 = (i9, t6, e11) => Le4(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var Me4 = class {
  constructor(t6) {
    C3(this, "name", "solana"), C3(this, "client"), C3(this, "httpProviders"), C3(this, "events"), C3(this, "namespace"), C3(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t6}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      const n5 = b2(e11);
      t6[n5] = this.createHttpProvider(n5, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var Be3 = Object.defineProperty;
var Ge2 = (i9, t6, e11) => t6 in i9 ? Be3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var E4 = (i9, t6, e11) => Ge2(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var Je2 = class {
  constructor(t6) {
    E4(this, "name", "cosmos"), E4(this, "client"), E4(this, "httpProviders"), E4(this, "events"), E4(this, "namespace"), E4(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      const n5 = b2(e11);
      t6[n5] = this.createHttpProvider(n5, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var ze2 = Object.defineProperty;
var ke4 = (i9, t6, e11) => t6 in i9 ? ze2(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var H = (i9, t6, e11) => ke4(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var We2 = class {
  constructor(t6) {
    H(this, "name", "algorand"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    if (!this.httpProviders[t6]) {
      const s5 = e11 || u2(`${this.name}:${t6}`, this.namespace, this.client.core.projectId);
      if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
      this.setHttpProvider(t6, s5);
    }
    this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      t6[e11] = this.createHttpProvider(e11, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    return typeof s5 > "u" ? void 0 : new o(new f2(s5, h3("disableProviderPing")));
  }
};
var Ke4 = Object.defineProperty;
var Ve3 = (i9, t6, e11) => t6 in i9 ? Ke4(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var S3 = (i9, t6, e11) => Ve3(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var Xe3 = class {
  constructor(t6) {
    S3(this, "name", "cip34"), S3(this, "client"), S3(this, "httpProviders"), S3(this, "events"), S3(this, "namespace"), S3(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      const s5 = this.getCardanoRPCUrl(e11), n5 = b2(e11);
      t6[n5] = this.createHttpProvider(n5, s5);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  getCardanoRPCUrl(t6) {
    const e11 = this.namespace.rpcMap;
    if (e11) return e11[t6];
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || this.getCardanoRPCUrl(t6);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var Ye3 = Object.defineProperty;
var Qe4 = (i9, t6, e11) => t6 in i9 ? Ye3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var N4 = (i9, t6, e11) => Qe4(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var Ze3 = class {
  constructor(t6) {
    N4(this, "name", "elrond"), N4(this, "client"), N4(this, "httpProviders"), N4(this, "events"), N4(this, "namespace"), N4(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t6}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      const n5 = b2(e11);
      t6[n5] = this.createHttpProvider(n5, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var Te3 = Object.defineProperty;
var ti2 = (i9, t6, e11) => t6 in i9 ? Te3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var D3 = (i9, t6, e11) => ti2(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var ei3 = class {
  constructor(t6) {
    D3(this, "name", "multiversx"), D3(this, "client"), D3(this, "httpProviders"), D3(this, "events"), D3(this, "namespace"), D3(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t6}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      const n5 = b2(e11);
      t6[n5] = this.createHttpProvider(n5, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var ii3 = Object.defineProperty;
var si3 = (i9, t6, e11) => t6 in i9 ? ii3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var q = (i9, t6, e11) => si3(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var ri3 = class {
  constructor(t6) {
    q(this, "name", "near"), q(this, "client"), q(this, "httpProviders"), q(this, "events"), q(this, "namespace"), q(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    if (this.chainId = t6, !this.httpProviders[t6]) {
      const s5 = e11 || u2(`${this.name}:${t6}`, this.namespace);
      if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
      this.setHttpProvider(t6, s5);
    }
    this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      var s5;
      t6[e11] = this.createHttpProvider(e11, (s5 = this.namespace.rpcMap) == null ? void 0 : s5[e11]);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace);
    return typeof s5 > "u" ? void 0 : new o(new f2(s5, h3("disableProviderPing")));
  }
};
var ni3 = Object.defineProperty;
var ai3 = (i9, t6, e11) => t6 in i9 ? ni3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var j2 = (i9, t6, e11) => ai3(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var ci3 = class {
  constructor(t6) {
    j2(this, "name", "tezos"), j2(this, "client"), j2(this, "httpProviders"), j2(this, "events"), j2(this, "namespace"), j2(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace = Object.assign(this.namespace, t6);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider().request(t6.request);
  }
  setDefaultChain(t6, e11) {
    if (this.chainId = t6, !this.httpProviders[t6]) {
      const s5 = e11 || u2(`${this.name}:${t6}`, this.namespace);
      if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
      this.setHttpProvider(t6, s5);
    }
    this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t6 = {};
    return this.namespace.chains.forEach((e11) => {
      t6[e11] = this.createHttpProvider(e11);
    }), t6;
  }
  getHttpProvider() {
    const t6 = `${this.name}:${this.chainId}`, e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace);
    return typeof s5 > "u" ? void 0 : new o(new f2(s5));
  }
};
var oi3 = Object.defineProperty;
var hi3 = (i9, t6, e11) => t6 in i9 ? oi3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var R3 = (i9, t6, e11) => hi3(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var pi3 = class {
  constructor(t6) {
    R3(this, "name", I3), R3(this, "client"), R3(this, "httpProviders"), R3(this, "events"), R3(this, "namespace"), R3(this, "chainId"), this.namespace = t6.namespace, this.events = h3("events"), this.client = h3("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t6) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t6.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t6.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t6.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t6.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t6) {
    return this.namespace.methods.includes(t6.request.method) ? this.client.request(t6) : this.getHttpProvider(t6.chainId).request(t6.request);
  }
  setDefaultChain(t6, e11) {
    this.httpProviders[t6] || this.setHttpProvider(t6, e11), this.chainId = t6, this.events.emit(l3.DEFAULT_CHAIN_CHANGED, `${this.name}:${t6}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t6 = this.namespace.chains[0];
    if (!t6) throw new Error("ChainId not found");
    return t6.split(":")[1];
  }
  getAccounts() {
    const t6 = this.namespace.accounts;
    return t6 ? [...new Set(t6.filter((e11) => e11.split(":")[1] === this.chainId.toString()).map((e11) => e11.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t6, e11;
    const s5 = {};
    return (e11 = (t6 = this.namespace) == null ? void 0 : t6.accounts) == null || e11.forEach((n5) => {
      const a6 = Fe(n5);
      s5[`${a6.namespace}:${a6.reference}`] = this.createHttpProvider(n5);
    }), s5;
  }
  getHttpProvider(t6) {
    const e11 = this.httpProviders[t6];
    if (typeof e11 > "u") throw new Error(`JSON-RPC provider for ${t6} not found`);
    return e11;
  }
  setHttpProvider(t6, e11) {
    const s5 = this.createHttpProvider(t6, e11);
    s5 && (this.httpProviders[t6] = s5);
  }
  createHttpProvider(t6, e11) {
    const s5 = e11 || u2(t6, this.namespace, this.client.core.projectId);
    if (!s5) throw new Error(`No RPC url provided for chainId: ${t6}`);
    return new o(new f2(s5, h3("disableProviderPing")));
  }
};
var di3 = Object.defineProperty;
var ui3 = Object.defineProperties;
var li3 = Object.getOwnPropertyDescriptors;
var Dt2 = Object.getOwnPropertySymbols;
var fi3 = Object.prototype.hasOwnProperty;
var mi3 = Object.prototype.propertyIsEnumerable;
var Z2 = (i9, t6, e11) => t6 in i9 ? di3(i9, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : i9[t6] = e11;
var B2 = (i9, t6) => {
  for (var e11 in t6 || (t6 = {})) fi3.call(t6, e11) && Z2(i9, e11, t6[e11]);
  if (Dt2) for (var e11 of Dt2(t6)) mi3.call(t6, e11) && Z2(i9, e11, t6[e11]);
  return i9;
};
var T2 = (i9, t6) => ui3(i9, li3(t6));
var f6 = (i9, t6, e11) => Z2(i9, typeof t6 != "symbol" ? t6 + "" : t6, e11);
var G3 = class _G {
  constructor(t6) {
    f6(this, "client"), f6(this, "namespaces"), f6(this, "optionalNamespaces"), f6(this, "sessionProperties"), f6(this, "scopedProperties"), f6(this, "events", new import_events5.default()), f6(this, "rpcProviders", {}), f6(this, "session"), f6(this, "providerOpts"), f6(this, "logger"), f6(this, "uri"), f6(this, "disableProviderPing", false), this.providerOpts = t6, this.logger = typeof (t6 == null ? void 0 : t6.logger) < "u" && typeof (t6 == null ? void 0 : t6.logger) != "string" ? t6.logger : (0, import_pino.default)(k({ level: (t6 == null ? void 0 : t6.logger) || rt2 })), this.disableProviderPing = (t6 == null ? void 0 : t6.disableProviderPing) || false;
  }
  static async init(t6) {
    const e11 = new _G(t6);
    return await e11.initialize(), e11;
  }
  async request(t6, e11, s5) {
    const [n5, a6] = this.validateChain(e11);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(n5).request({ request: B2({}, t6), chainId: `${n5}:${a6}`, topic: this.session.topic, expiry: s5 });
  }
  sendAsync(t6, e11, s5, n5) {
    const a6 = (/* @__PURE__ */ new Date()).getTime();
    this.request(t6, s5, n5).then((r8) => e11(null, formatJsonRpcResult(a6, r8))).catch((r8) => e11(r8, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t6;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t6 = this.session) == null ? void 0 : t6.topic, reason: Kt("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t6) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t6), await this.cleanupPendingPairings(), !t6.skipPairing) return await this.pair(t6.pairingTopic);
  }
  async authenticate(t6, e11) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t6), await this.cleanupPendingPairings();
    const { uri: s5, response: n5 } = await this.client.authenticate(t6, e11);
    s5 && (this.uri = s5, this.events.emit("display_uri", s5));
    const a6 = await n5();
    if (this.session = a6.session, this.session) {
      const r8 = bt2(this.session.namespaces);
      this.namespaces = M3(this.namespaces, r8), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a6;
  }
  on(t6, e11) {
    this.events.on(t6, e11);
  }
  once(t6, e11) {
    this.events.once(t6, e11);
  }
  removeListener(t6, e11) {
    this.events.removeListener(t6, e11);
  }
  off(t6, e11) {
    this.events.off(t6, e11);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t6) {
    const { uri: e11, approval: s5 } = await this.client.connect({ pairingTopic: t6, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e11 && (this.uri = e11, this.events.emit("display_uri", e11));
    const n5 = await s5();
    this.session = n5;
    const a6 = bt2(n5.namespaces);
    return this.namespaces = M3(this.namespaces, a6), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t6, e11) {
    try {
      if (!this.session) return;
      const [s5, n5] = this.validateChain(t6), a6 = this.getProvider(s5);
      a6.name === I3 ? a6.setDefaultChain(`${s5}:${n5}`, e11) : a6.setDefaultChain(n5, e11);
    } catch (s5) {
      if (!/Please call connect/.test(s5.message)) throw s5;
    }
  }
  async cleanupPendingPairings(t6 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e11 = this.client.pairing.getAll();
    if (me(e11)) {
      for (const s5 of e11) t6.deletePairings ? this.client.core.expirer.set(s5.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s5.topic);
      this.logger.info(`Inactive pairings cleared: ${e11.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t6, e11;
    if (this.client = this.providerOpts.client || await Ee2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || rt2, relayUrl: this.providerOpts.relayUrl || Lt3, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (s5) {
      throw this.logger.error("Failed to get session", s5), new Error(`The provided session: ${(e11 = (t6 = this.providerOpts) == null ? void 0 : t6.session) == null ? void 0 : e11.topic} doesn't exist in the Sign client`);
    }
    else {
      const s5 = this.client.session.getAll();
      this.session = s5[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t6 = [...new Set(Object.keys(this.session.namespaces).map((e11) => Yo(e11)))];
    X3("client", this.client), X3("events", this.events), X3("disableProviderPing", this.disableProviderPing), t6.forEach((e11) => {
      if (!this.session) return;
      const s5 = Ie3(e11, this.session);
      if ((s5 == null ? void 0 : s5.length) === 0) return;
      const n5 = gt3(s5), a6 = M3(this.namespaces, this.optionalNamespaces), r8 = T2(B2({}, a6[e11]), { accounts: s5, chains: n5 });
      switch (e11) {
        case "eip155":
          this.rpcProviders[e11] = new Ue3({ namespace: r8 });
          break;
        case "algorand":
          this.rpcProviders[e11] = new We2({ namespace: r8 });
          break;
        case "solana":
          this.rpcProviders[e11] = new Me4({ namespace: r8 });
          break;
        case "cosmos":
          this.rpcProviders[e11] = new Je2({ namespace: r8 });
          break;
        case "polkadot":
          this.rpcProviders[e11] = new De3({ namespace: r8 });
          break;
        case "cip34":
          this.rpcProviders[e11] = new Xe3({ namespace: r8 });
          break;
        case "elrond":
          this.rpcProviders[e11] = new Ze3({ namespace: r8 });
          break;
        case "multiversx":
          this.rpcProviders[e11] = new ei3({ namespace: r8 });
          break;
        case "near":
          this.rpcProviders[e11] = new ri3({ namespace: r8 });
          break;
        case "tezos":
          this.rpcProviders[e11] = new ci3({ namespace: r8 });
          break;
        default:
          this.rpcProviders[I3] ? this.rpcProviders[I3].updateNamespace(r8) : this.rpcProviders[I3] = new pi3({ namespace: r8 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t6) => {
      var e11;
      const { topic: s5 } = t6;
      s5 === ((e11 = this.session) == null ? void 0 : e11.topic) && this.events.emit("session_ping", t6);
    }), this.client.on("session_event", (t6) => {
      var e11;
      const { params: s5, topic: n5 } = t6;
      if (n5 !== ((e11 = this.session) == null ? void 0 : e11.topic)) return;
      const { event: a6 } = s5;
      if (a6.name === "accountsChanged") {
        const r8 = a6.data;
        r8 && me(r8) && this.events.emit("accountsChanged", r8.map(yt2));
      } else if (a6.name === "chainChanged") {
        const r8 = s5.chainId, c9 = s5.event.data, o6 = Yo(r8), p9 = V3(r8) !== V3(c9) ? `${o6}:${V3(c9)}` : r8;
        this.onChainChanged(p9);
      } else this.events.emit(a6.name, a6.data);
      this.events.emit("session_event", t6);
    }), this.client.on("session_update", ({ topic: t6, params: e11 }) => {
      var s5, n5;
      if (t6 !== ((s5 = this.session) == null ? void 0 : s5.topic)) return;
      const { namespaces: a6 } = e11, r8 = (n5 = this.client) == null ? void 0 : n5.session.get(t6);
      this.session = T2(B2({}, r8), { namespaces: a6 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t6, params: e11 });
    }), this.client.on("session_delete", async (t6) => {
      var e11;
      t6.topic === ((e11 = this.session) == null ? void 0 : e11.topic) && (await this.cleanup(), this.events.emit("session_delete", t6), this.events.emit("disconnect", T2(B2({}, Kt("USER_DISCONNECTED")), { data: t6.topic })));
    }), this.on(l3.DEFAULT_CHAIN_CHANGED, (t6) => {
      this.onChainChanged(t6, true);
    });
  }
  getProvider(t6) {
    return this.rpcProviders[t6] || this.rpcProviders[I3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t6) => {
      var e11;
      this.getProvider(t6).updateNamespace((e11 = this.session) == null ? void 0 : e11.namespaces[t6]);
    });
  }
  setNamespaces(t6) {
    const { namespaces: e11 = {}, optionalNamespaces: s5 = {}, sessionProperties: n5, scopedProperties: a6 } = t6;
    this.optionalNamespaces = M3(e11, s5), this.sessionProperties = n5, this.scopedProperties = a6;
  }
  validateChain(t6) {
    const [e11, s5] = (t6 == null ? void 0 : t6.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e11, s5];
    if (e11 && !Object.keys(this.namespaces || {}).map((r8) => Yo(r8)).includes(e11)) throw new Error(`Namespace '${e11}' is not configured. Please call connect() first with namespace config.`);
    if (e11 && s5) return [e11, s5];
    const n5 = Yo(Object.keys(this.namespaces)[0]), a6 = this.rpcProviders[n5].getDefaultChain();
    return [n5, a6];
  }
  async requestAccounts() {
    const [t6] = this.validateChain();
    return await this.getProvider(t6).requestAccounts();
  }
  async onChainChanged(t6, e11 = false) {
    if (!this.namespaces) return;
    const [s5, n5] = this.validateChain(t6);
    if (!n5) return;
    this.updateNamespaceChain(s5, n5), this.events.emit("chainChanged", n5);
    const a6 = this.getProvider(s5).getDefaultChain();
    e11 || this.getProvider(s5).setDefaultChain(n5), this.emitAccountsChangedOnChainChange({ namespace: s5, previousChainId: a6, newChainId: t6 }), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: t6, previousChainId: e11, newChainId: s5 }) {
    var n5, a6;
    try {
      if (e11 === s5) return;
      const r8 = (a6 = (n5 = this.session) == null ? void 0 : n5.namespaces[t6]) == null ? void 0 : a6.accounts;
      if (!r8) return;
      const c9 = r8.filter((o6) => o6.includes(`${s5}:`)).map(yt2);
      if (!me(c9)) return;
      this.events.emit("accountsChanged", c9);
    } catch (r8) {
      this.logger.warn("Failed to emit accountsChanged on chain change", r8);
    }
  }
  updateNamespaceChain(t6, e11) {
    if (!this.namespaces) return;
    const s5 = this.namespaces[t6] ? t6 : `${t6}:${e11}`, n5 = { chains: [], methods: [], events: [], defaultChain: e11 };
    this.namespaces[s5] ? this.namespaces[s5] && (this.namespaces[s5].defaultChain = e11) : this.namespaces[s5] = n5;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t6, e11) {
    var s5;
    const n5 = ((s5 = this.session) == null ? void 0 : s5.topic) || "";
    await this.client.core.storage.setItem(`${U3}/${t6}${n5}`, e11);
  }
  async getFromStore(t6) {
    var e11;
    const s5 = ((e11 = this.session) == null ? void 0 : e11.topic) || "";
    return await this.client.core.storage.getItem(`${U3}/${t6}${s5}`);
  }
  async deleteFromStore(t6) {
    var e11;
    const s5 = ((e11 = this.session) == null ? void 0 : e11.topic) || "";
    await this.client.core.storage.removeItem(`${U3}/${t6}${s5}`);
  }
  async cleanupStorage() {
    var t6;
    try {
      if (((t6 = this.client) == null ? void 0 : t6.session.length) > 0) return;
      const e11 = await this.client.core.storage.getKeys();
      for (const s5 of e11) s5.startsWith(U3) && await this.client.core.storage.removeItem(s5);
    } catch (e11) {
      this.logger.warn("Failed to cleanup storage", e11);
    }
  }
};
var vi3 = G3;

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var $4 = "wc";
var k5 = "ethereum_provider";
var q2 = `${$4}@2:${k5}:`;
var U4 = "https://rpc.walletconnect.org/v1/";
var f7 = ["eth_sendTransaction", "personal_sign"];
var A5 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"];
var C4 = ["chainChanged", "accountsChanged"];
var P3 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var D4 = async () => {
  const { createAppKit: s5 } = await import("./core-NVOPQ7WH.js");
  return s5;
};
var z3 = Object.defineProperty;
var L3 = Object.defineProperties;
var K3 = Object.getOwnPropertyDescriptors;
var M4 = Object.getOwnPropertySymbols;
var Q4 = Object.prototype.hasOwnProperty;
var V4 = Object.prototype.propertyIsEnumerable;
var _2 = (s5, t6, e11) => t6 in s5 ? z3(s5, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : s5[t6] = e11;
var v3 = (s5, t6) => {
  for (var e11 in t6 || (t6 = {})) Q4.call(t6, e11) && _2(s5, e11, t6[e11]);
  if (M4) for (var e11 of M4(t6)) V4.call(t6, e11) && _2(s5, e11, t6[e11]);
  return s5;
};
var w2 = (s5, t6) => L3(s5, K3(t6));
var p3 = (s5, t6, e11) => _2(s5, typeof t6 != "symbol" ? t6 + "" : t6, e11);
function I4(s5) {
  return Number(s5[0].split(":")[1]);
}
function E5(s5) {
  return `0x${s5.toString(16)}`;
}
function G4(s5) {
  const { chains: t6, optionalChains: e11, methods: n5, optionalMethods: i9, events: a6, optionalEvents: o6, rpcMap: u10 } = s5;
  if (!me(t6)) throw new Error("Invalid chains");
  const c9 = { chains: t6, methods: n5 || f7, events: a6 || C4, rpcMap: v3({}, t6.length ? { [I4(t6)]: u10[I4(t6)] } : {}) }, l9 = a6 == null ? void 0 : a6.filter((d7) => !C4.includes(d7)), r8 = n5 == null ? void 0 : n5.filter((d7) => !f7.includes(d7));
  if (!e11 && !o6 && !i9 && !(l9 != null && l9.length) && !(r8 != null && r8.length)) return { required: t6.length ? c9 : void 0 };
  const m6 = (l9 == null ? void 0 : l9.length) && (r8 == null ? void 0 : r8.length) || !e11, h9 = { chains: [...new Set(m6 ? c9.chains.concat(e11 || []) : e11)], methods: [...new Set(c9.methods.concat(i9 != null && i9.length ? i9 : A5))], events: [...new Set(c9.events.concat(o6 != null && o6.length ? o6 : P3))], rpcMap: u10 };
  return { required: t6.length ? c9 : void 0, optional: e11.length ? h9 : void 0 };
}
var b3 = class _b {
  constructor() {
    p3(this, "events", new import_events6.EventEmitter()), p3(this, "namespace", "eip155"), p3(this, "accounts", []), p3(this, "signer"), p3(this, "chainId", 1), p3(this, "modal"), p3(this, "rpc"), p3(this, "STORAGE_KEY", q2), p3(this, "on", (t6, e11) => (this.events.on(t6, e11), this)), p3(this, "once", (t6, e11) => (this.events.once(t6, e11), this)), p3(this, "removeListener", (t6, e11) => (this.events.removeListener(t6, e11), this)), p3(this, "off", (t6, e11) => (this.events.off(t6, e11), this)), p3(this, "parseAccount", (t6) => this.isCompatibleChainId(t6) ? this.parseAccountId(t6).address : t6), this.signer = {}, this.rpc = {};
  }
  static async init(t6) {
    const e11 = new _b();
    return await e11.initialize(t6), e11;
  }
  async request(t6, e11) {
    return await this.signer.request(t6, this.formatChainId(this.chainId), e11);
  }
  sendAsync(t6, e11, n5) {
    this.signer.sendAsync(t6, e11, this.formatChainId(this.chainId), n5);
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t6) {
    var e11;
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t6);
    const { required: n5, optional: i9 } = G4(this.rpc);
    try {
      const a6 = await new Promise(async (u10, c9) => {
        var l9, r8;
        this.rpc.showQrModal && ((l9 = this.modal) == null || l9.open(), (r8 = this.modal) == null || r8.subscribeState((h9) => {
          !h9.open && !this.signer.session && (this.signer.abortPairingAttempt(), c9(new Error("Connection request reset. Please try again.")));
        }));
        const m6 = t6 != null && t6.scopedProperties ? { [this.namespace]: t6.scopedProperties } : void 0;
        await this.signer.connect(w2(v3({ namespaces: v3({}, n5 && { [this.namespace]: n5 }) }, i9 && { optionalNamespaces: { [this.namespace]: i9 } }), { pairingTopic: t6 == null ? void 0 : t6.pairingTopic, scopedProperties: m6 })).then((h9) => {
          u10(h9);
        }).catch((h9) => {
          var d7;
          (d7 = this.modal) == null || d7.showErrorMessage("Unable to connect"), c9(new Error(h9.message));
        });
      });
      if (!a6) return;
      const o6 = _s(a6.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o6), this.setAccounts(o6), this.events.emit("connect", { chainId: E5(this.chainId) });
    } catch (a6) {
      throw this.signer.logger.error(a6), a6;
    } finally {
      (e11 = this.modal) == null || e11.close();
    }
  }
  async authenticate(t6, e11) {
    var n5;
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts({ chains: t6 == null ? void 0 : t6.chains });
    try {
      const i9 = await new Promise(async (o6, u10) => {
        var c9, l9;
        this.rpc.showQrModal && ((c9 = this.modal) == null || c9.open(), (l9 = this.modal) == null || l9.subscribeState((r8) => {
          !r8.open && !this.signer.session && (this.signer.abortPairingAttempt(), u10(new Error("Connection request reset. Please try again.")));
        })), await this.signer.authenticate(w2(v3({}, t6), { chains: this.rpc.chains }), e11).then((r8) => {
          o6(r8);
        }).catch((r8) => {
          var m6;
          (m6 = this.modal) == null || m6.showErrorMessage("Unable to connect"), u10(new Error(r8.message));
        });
      }), a6 = i9.session;
      if (a6) {
        const o6 = _s(a6.namespaces, [this.namespace]);
        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o6), this.setAccounts(o6), this.events.emit("connect", { chainId: E5(this.chainId) });
      }
      return i9;
    } catch (i9) {
      throw this.signer.logger.error(i9), i9;
    } finally {
      (n5 = this.modal) == null || n5.close();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t6) => {
      const { params: e11 } = t6, { event: n5 } = e11;
      n5.name === "accountsChanged" ? (this.accounts = this.parseAccounts(n5.data), this.events.emit("accountsChanged", this.accounts)) : n5.name === "chainChanged" ? this.setChainId(this.formatChainId(n5.data)) : this.events.emit(n5.name, n5.data), this.events.emit("session_event", t6);
    }), this.signer.on("accountsChanged", (t6) => {
      this.accounts = this.parseAccounts(t6), this.events.emit("accountsChanged", this.accounts);
    }), this.signer.on("chainChanged", (t6) => {
      const e11 = parseInt(t6);
      this.chainId = e11, this.events.emit("chainChanged", E5(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t6) => {
      this.events.emit("session_update", t6);
    }), this.signer.on("session_delete", (t6) => {
      this.reset(), this.events.emit("session_delete", t6), this.events.emit("disconnect", w2(v3({}, Kt("USER_DISCONNECTED")), { data: t6.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t6) => {
      this.events.emit("display_uri", t6);
    });
  }
  switchEthereumChain(t6) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t6.toString(16) }] });
  }
  isCompatibleChainId(t6) {
    return typeof t6 == "string" ? t6.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t6) {
    return `${this.namespace}:${t6}`;
  }
  parseChainId(t6) {
    return Number(t6.split(":")[1]);
  }
  setChainIds(t6) {
    const e11 = t6.filter((n5) => this.isCompatibleChainId(n5)).map((n5) => this.parseChainId(n5));
    e11.length && (this.chainId = e11[0], this.events.emit("chainChanged", E5(this.chainId)), this.persist());
  }
  setChainId(t6) {
    if (this.isCompatibleChainId(t6)) {
      const e11 = this.parseChainId(t6);
      this.chainId = e11, this.switchEthereumChain(e11);
    }
  }
  parseAccountId(t6) {
    const [e11, n5, i9] = t6.split(":");
    return { chainId: `${e11}:${n5}`, address: i9 };
  }
  setAccounts(t6) {
    this.accounts = t6.filter((e11) => this.parseChainId(this.parseAccountId(e11).chainId) === this.chainId).map((e11) => this.parseAccountId(e11).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t6) {
    var e11, n5;
    const i9 = (e11 = t6 == null ? void 0 : t6.chains) != null ? e11 : [], a6 = (n5 = t6 == null ? void 0 : t6.optionalChains) != null ? n5 : [], o6 = i9.concat(a6);
    if (!o6.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
    const u10 = i9.length ? (t6 == null ? void 0 : t6.methods) || f7 : [], c9 = i9.length ? (t6 == null ? void 0 : t6.events) || C4 : [], l9 = (t6 == null ? void 0 : t6.optionalMethods) || [], r8 = (t6 == null ? void 0 : t6.optionalEvents) || [], m6 = (t6 == null ? void 0 : t6.rpcMap) || this.buildRpcMap(o6, t6.projectId), h9 = (t6 == null ? void 0 : t6.qrModalOptions) || void 0;
    return { chains: i9 == null ? void 0 : i9.map((d7) => this.formatChainId(d7)), optionalChains: a6.map((d7) => this.formatChainId(d7)), methods: u10, events: c9, optionalMethods: l9, optionalEvents: r8, rpcMap: m6, showQrModal: !!(t6 != null && t6.showQrModal), qrModalOptions: h9, projectId: t6.projectId, metadata: t6.metadata };
  }
  buildRpcMap(t6, e11) {
    const n5 = {};
    return t6.forEach((i9) => {
      n5[i9] = this.getRpcUrl(i9, e11);
    }), n5;
  }
  async initialize(t6) {
    if (this.rpc = this.getRpcConfig(t6), this.chainId = this.rpc.chains.length ? I4(this.rpc.chains) : I4(this.rpc.optionalChains), this.signer = await vi3.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t6.disableProviderPing, relayUrl: t6.relayUrl, storage: t6.storage, storageOptions: t6.storageOptions, customStoragePrefix: t6.customStoragePrefix, telemetryEnabled: t6.telemetryEnabled, logger: t6.logger }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let e11;
      try {
        const n5 = await D4(), { convertWCMToAppKitOptions: i9 } = await Promise.resolve().then(function() {
          return nt3;
        }), a6 = i9(w2(v3({}, this.rpc.qrModalOptions), { chains: [.../* @__PURE__ */ new Set([...this.rpc.chains, ...this.rpc.optionalChains])], metadata: this.rpc.metadata, projectId: this.rpc.projectId }));
        if (!a6.networks.length) throw new Error("No networks found for WalletConnect");
        e11 = n5(w2(v3({}, a6), { universalProvider: this.signer, manualWCControl: true }));
      } catch (n5) {
        throw console.warn(n5), new Error("To use QR modal, please install @reown/appkit package");
      }
      if (e11) try {
        this.modal = e11;
      } catch (n5) {
        throw this.signer.logger.error(n5), new Error("Could not generate WalletConnectModal Instance");
      }
    }
  }
  loadConnectOpts(t6) {
    if (!t6) return;
    const { chains: e11, optionalChains: n5, rpcMap: i9 } = t6;
    e11 && me(e11) && (this.rpc.chains = e11.map((a6) => this.formatChainId(a6)), e11.forEach((a6) => {
      this.rpc.rpcMap[a6] = (i9 == null ? void 0 : i9[a6]) || this.getRpcUrl(a6);
    })), n5 && me(n5) && (this.rpc.optionalChains = [], this.rpc.optionalChains = n5 == null ? void 0 : n5.map((a6) => this.formatChainId(a6)), n5.forEach((a6) => {
      this.rpc.rpcMap[a6] = (i9 == null ? void 0 : i9[a6]) || this.getRpcUrl(a6);
    }));
  }
  getRpcUrl(t6, e11) {
    var n5;
    return ((n5 = this.rpc.rpcMap) == null ? void 0 : n5[t6]) || `${U4}?chainId=eip155:${t6}&projectId=${e11 || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (this.session) try {
      const t6 = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), e11 = this.session.namespaces[`${this.namespace}:${t6}`] ? this.session.namespaces[`${this.namespace}:${t6}`] : this.session.namespaces[this.namespace];
      this.setChainIds(t6 ? [this.formatChainId(t6)] : e11 == null ? void 0 : e11.accounts), this.setAccounts(e11 == null ? void 0 : e11.accounts);
    } catch (t6) {
      this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(t6), await this.disconnect().catch((e11) => this.signer.logger.warn(e11));
    }
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t6) {
    return typeof t6 == "string" || t6 instanceof String ? [this.parseAccount(t6)] : t6.map((e11) => this.parseAccount(e11));
  }
};
var H2 = Object.defineProperty;
var B3 = Object.defineProperties;
var F3 = Object.getOwnPropertyDescriptors;
var S4 = Object.getOwnPropertySymbols;
var X4 = Object.prototype.hasOwnProperty;
var J3 = Object.prototype.propertyIsEnumerable;
var T3 = (s5, t6, e11) => t6 in s5 ? H2(s5, t6, { enumerable: true, configurable: true, writable: true, value: e11 }) : s5[t6] = e11;
var R4 = (s5, t6) => {
  for (var e11 in t6 || (t6 = {})) X4.call(t6, e11) && T3(s5, e11, t6[e11]);
  if (S4) for (var e11 of S4(t6)) J3.call(t6, e11) && T3(s5, e11, t6[e11]);
  return s5;
};
var Z3 = (s5, t6) => B3(s5, F3(t6));
function tt3(s5) {
  if (s5) return { "--w3m-font-family": s5["--wcm-font-family"], "--w3m-accent": s5["--wcm-accent-color"], "--w3m-color-mix": s5["--wcm-background-color"], "--w3m-z-index": s5["--wcm-z-index"] ? Number(s5["--wcm-z-index"]) : void 0, "--w3m-qr-color": s5["--wcm-accent-color"], "--w3m-font-size-master": s5["--wcm-text-medium-regular-size"], "--w3m-border-radius-master": s5["--wcm-container-border-radius"], "--w3m-color-mix-strength": 0 };
}
var et = (s5) => {
  const [t6, e11] = s5.split(":");
  return W4({ id: e11, caipNetworkId: s5, chainNamespace: t6, name: "", nativeCurrency: { name: "", symbol: "", decimals: 8 }, rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } } });
};
function st(s5) {
  var t6, e11, n5, i9, a6, o6, u10;
  const c9 = (t6 = s5.chains) == null ? void 0 : t6.map(et).filter(Boolean);
  if (c9.length === 0) throw new Error("At least one chain must be specified");
  const l9 = c9.find((m6) => {
    var h9;
    return m6.id === ((h9 = s5.defaultChain) == null ? void 0 : h9.id);
  }), r8 = { projectId: s5.projectId, networks: c9, themeMode: s5.themeMode, themeVariables: tt3(s5.themeVariables), chainImages: s5.chainImages, connectorImages: s5.walletImages, defaultNetwork: l9, metadata: Z3(R4({}, s5.metadata), { name: ((e11 = s5.metadata) == null ? void 0 : e11.name) || "WalletConnect", description: ((n5 = s5.metadata) == null ? void 0 : n5.description) || "Connect to WalletConnect-compatible wallets", url: ((i9 = s5.metadata) == null ? void 0 : i9.url) || "https://walletconnect.org", icons: ((a6 = s5.metadata) == null ? void 0 : a6.icons) || ["https://walletconnect.org/walletconnect-logo.png"] }), showWallets: true, featuredWalletIds: s5.explorerRecommendedWalletIds === "NONE" ? [] : Array.isArray(s5.explorerRecommendedWalletIds) ? s5.explorerRecommendedWalletIds : [], excludeWalletIds: s5.explorerExcludedWalletIds === "ALL" ? [] : Array.isArray(s5.explorerExcludedWalletIds) ? s5.explorerExcludedWalletIds : [], enableEIP6963: false, enableInjected: false, enableCoinbase: true, enableWalletConnect: true, features: { email: false, socials: false } };
  if ((o6 = s5.mobileWallets) != null && o6.length || (u10 = s5.desktopWallets) != null && u10.length) {
    const m6 = [...(s5.mobileWallets || []).map((g4) => ({ id: g4.id, name: g4.name, links: g4.links })), ...(s5.desktopWallets || []).map((g4) => ({ id: g4.id, name: g4.name, links: { native: g4.links.native, universal: g4.links.universal } }))], h9 = [...r8.featuredWalletIds || [], ...r8.excludeWalletIds || []], d7 = m6.filter((g4) => !h9.includes(g4.id));
    d7.length && (r8.customWallets = d7);
  }
  return r8;
}
function W4(s5) {
  return R4({ formatters: void 0, fees: void 0, serializers: void 0 }, s5);
}
var nt3 = Object.freeze({ __proto__: null, convertWCMToAppKitOptions: st, defineChain: W4 });

// node_modules/@dynamic-labs/ethereum/src/walletConnect/WalletConnectProvider/WalletConnectProvider.js
var _a2;
var WalletConnectProvider = class {
  constructor() {
    throw new Error("WalletConnectProvider is not instantiable");
  }
  static getMappedChainsByPreferredOrder() {
    const allChains = _a2.enabledNetworks.map((network) => `eip155:${network.chainId}`);
    const reorderedChains = _a2.preferredChains.filter((chain6) => allChains.includes(chain6));
    const remainingChains = allChains.filter((chain6) => !_a2.preferredChains.includes(chain6));
    return [...reorderedChains, ...remainingChains].map((chain6) => Number(chain6.split(":")[1]));
  }
};
_a2 = WalletConnectProvider;
WalletConnectProvider.isInitializing = false;
WalletConnectProvider.isInitialized = false;
WalletConnectProvider.enabledNetworks = [];
WalletConnectProvider.preferredChains = [];
WalletConnectProvider.evmNetworkRpcMap = {};
WalletConnectProvider.eventListenersSetup = false;
WalletConnectProvider.accountChangedHandler = () => {
};
WalletConnectProvider.chainChangedHandler = () => {
};
WalletConnectProvider.disconnectHandler = () => {
};
WalletConnectProvider.init = (...args_1) => __awaiter2(void 0, [...args_1], void 0, function* ({ storePrefix = "dynamic-wc2" } = {}) {
  logger3.debug("[WalletConnectProvider] init", {
    isInitialized: _a2.isInitialized,
    isInitializing: _a2.isInitializing
  });
  if (_a2.isInitializing || _a2.isInitialized) {
    return;
  }
  _a2.isInitializing = true;
  logger3.debug("[WalletConnectProvider] initializing");
  _a2.providerInitPromise = b3.init({
    customStoragePrefix: storePrefix,
    disableProviderPing: true,
    optionalChains: _a2.getMappedChainsByPreferredOrder(),
    optionalEvents: ["chainChanged", "accountsChanged"],
    optionalMethods: [
      "eth_chainId",
      "eth_signTypedData",
      "eth_signTransaction",
      "eth_sign",
      "personal_sign",
      "eth_sendTransaction",
      "eth_signTypedData_v4",
      "wallet_switchEthereumChain",
      "wallet_addEthereumChain"
    ],
    projectId: _a2.projectId,
    rpcMap: _a2.evmNetworkRpcMap,
    showQrModal: false
  });
  _a2.provider = yield _a2.providerInitPromise;
  _a2.isInitialized = true;
  _a2.isInitializing = false;
  logger3.debug("[WalletConnectProvider] initialized");
});
WalletConnectProvider.connect = (_b) => __awaiter2(void 0, [_b], void 0, function* ({ deepLinks, deepLinkPreference, connectionOpts }) {
  const handleDisplayURI = (uri) => {
    var _b2;
    logger3.debug("[WalletConnectProvider] handleDisplayURI", uri);
    _a2.connectionUri = uri;
    performPlatformSpecificConnectionMethod(_a2.connectionUri, deepLinks, {
      onDesktopUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDesktopUri,
      onDisplayUri: connectionOpts === null || connectionOpts === void 0 ? void 0 : connectionOpts.onDisplayUri
    }, deepLinkPreference);
    logger3.debug("[WalletConnectProvider] removing display_uri event listener");
    (_b2 = _a2.provider) === null || _b2 === void 0 ? void 0 : _b2.off("display_uri", handleDisplayURI);
  };
  if (!_a2.provider) {
    logger3.error("[WalletConnectProvider] connect - provider is not initialized");
    throw new DynamicError("WalletConnectProvider is not initialized");
  }
  if (_a2.connectionUri) {
    handleDisplayURI(_a2.connectionUri);
    return;
  }
  logger3.debug("[WalletConnectProvider] adding display_uri event listener");
  _a2.provider.on("display_uri", handleDisplayURI);
  try {
    const result = yield _a2.provider.enable();
    logger3.debug("[WalletConnectProvider] connected to WalletConnect", result);
    return result;
  } catch (error) {
    logger3.error("[WalletConnectProvider] Failed to connect to WalletConnect", error);
    if (typeof error !== "object" || error === null || !("message" in error) || typeof error.message !== "string") {
      throw error;
    }
    const customError = new DynamicError(error.message);
    if (error.message.includes("rejected")) {
      customError.code = ErrorCode.CONNECTION_REJECTED;
    } else if (error.message.includes("expired")) {
      customError.code = ErrorCode.CONNECTION_PROPOSAL_EXPIRED;
    }
    throw customError;
  } finally {
    _a2.connectionUri = void 0;
  }
});
WalletConnectProvider.disconnect = () => __awaiter2(void 0, void 0, void 0, function* () {
  if (!_a2.provider) {
    logger3.debug("[WalletConnectProvider] disconnect - provider is not initialized");
    return;
  }
  _a2.connectionUri = void 0;
  logger3.debug("[WalletConnectProvider] disconnecting from WalletConnect");
  try {
    yield _a2.provider.disconnect();
  } catch (error) {
    logger3.error("[WalletConnectProvider] Failed to disconnect from WalletConnect", error);
  }
});
WalletConnectProvider.awaitAndGetProvider = () => __awaiter2(void 0, void 0, void 0, function* () {
  return _a2.providerInitPromise;
});
WalletConnectProvider.getProvider = () => _a2.provider;
WalletConnectProvider.getConnectionUri = () => _a2.connectionUri;
WalletConnectProvider.handleChainChangedEvent = (chain6, onChainChanged) => {
  logger3.debug("[WalletConnectProvider] handling chain change event", {
    chain: chain6
  });
  const chainId = parseIntSafe(chain6);
  if (!chainId) {
    return;
  }
  onChainChanged === null || onChainChanged === void 0 ? void 0 : onChainChanged(chainId);
};
WalletConnectProvider.handleAccountChangedEvent = (accounts, onAccountChanged) => {
  logger3.debug("[WalletConnectProvider] handling account change event", {
    accounts
  });
  const [account2] = accounts;
  const address = account2.includes(":") ? account2.split(":").pop() : account2;
  if (!address) {
    return;
  }
  onAccountChanged === null || onAccountChanged === void 0 ? void 0 : onAccountChanged(address);
};
WalletConnectProvider.setupEventListeners = ({ onChainChanged, onAccountChanged, onDisconnect }) => {
  if (!_a2.provider || _a2.eventListenersSetup) {
    return;
  }
  _a2.chainChangedHandler = (chainId) => {
    _a2.handleChainChangedEvent(chainId, onChainChanged);
  };
  _a2.accountChangedHandler = (account2) => {
    _a2.handleAccountChangedEvent(account2, onAccountChanged);
  };
  _a2.disconnectHandler = () => {
    logger3.debug("[WalletConnectProvider] handling disconnect event");
    onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect();
  };
  _a2.provider.on("accountsChanged", _a2.accountChangedHandler);
  _a2.provider.on("chainChanged", _a2.chainChangedHandler);
  _a2.provider.on("disconnect", _a2.disconnectHandler);
  _a2.eventListenersSetup = true;
};
WalletConnectProvider.teardownEventListeners = () => {
  if (!_a2.provider || !_a2.eventListenersSetup) {
    return;
  }
  _a2.provider.off("accountsChanged", _a2.accountChangedHandler);
  _a2.provider.off("chainChanged", _a2.chainChangedHandler);
  _a2.provider.off("disconnect", _a2.disconnectHandler);
  _a2.eventListenersSetup = false;
};

// node_modules/@dynamic-labs/ethereum/src/walletConnect/WalletConnectConnector/WalletConnectConnector.js
var WC_CURRENT_CHAIN_KEY = "dynamic-wc2-current-chain";
var WalletConnectConnector = class extends EthereumWalletConnector {
  constructor(opts2) {
    super(opts2);
    this.canConnectViaQrCode = true;
    this.isWalletConnect = true;
    this.canHandleMultipleConnections = false;
    this.name = opts2.walletName;
    this.deepLinkPreference = opts2.deepLinkPreference || "native";
    const storedChainId = StorageService.getItem(WC_CURRENT_CHAIN_KEY);
    if (storedChainId) {
      this.currentChainId = parseIntSafe(storedChainId);
    }
    if (!opts2.projectId) {
      throw new DynamicError("WalletConnect project ID is required");
    }
    WalletConnectProvider.projectId = opts2.projectId;
    WalletConnectProvider.enabledNetworks = opts2.evmNetworks;
    WalletConnectProvider.preferredChains = opts2.walletConnectPreferredChains || [];
    WalletConnectProvider.evmNetworkRpcMap = this.evmNetworkRpcMap();
  }
  init() {
    return __awaiter2(this, void 0, void 0, function* () {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] init called", {
        isInitialized: WalletConnectProvider.isInitialized,
        isInitializing: WalletConnectProvider.isInitializing
      });
      if (WalletConnectProvider.isInitialized || WalletConnectProvider.isInitializing) {
        logger.debug("[WalletConnect] init - already initialized or initializing - skipping");
        return;
      }
      logger.debug("[WalletConnect] init");
      this.walletConnectorEventsEmitter.emit("connectorInitStarted", "walletconnect");
      try {
        yield WalletConnectProvider.init();
      } catch (error) {
        logger.error("[WalletConnect] init - error", error);
        throw new DynamicError("WalletConnectProvider failed to initialize");
      }
      this.setupWCEventListeners();
      this.walletConnectorEventsEmitter.emit("connectorInitCompleted", "walletconnect");
    });
  }
  setupWCEventListeners() {
    logger.debug("[WalletConnect] setupWCEventListeners");
    WalletConnectProvider.teardownEventListeners();
    WalletConnectProvider.setupEventListeners({
      onAccountChanged: (account2) => {
        logger.debug("[WalletConnect] onAccountChanged", { account: account2 });
        this.emit("accountChange", { accounts: [account2] });
      },
      onChainChanged: (chainId) => {
        logger.debug("[WalletConnect] onChainChange", { chainId });
        if (chainId === this.currentChainId) {
          logger.debug(`[WalletConnect] onChainChange - ignoring chainChanged event with same chain id as current chain id: ${chainId}`);
          return;
        }
        this.currentChainId = chainId;
        this.emit("chainChange", { chain: String(chainId) });
      },
      onDisconnect: () => {
        logger.debug("[WalletConnect] onDisconnect");
        this.endSession();
        this.emit("disconnect");
      }
    });
  }
  endSession() {
    return __awaiter2(this, void 0, void 0, function* () {
      logger.debug("[WalletConnect] endSession");
      this.currentChainId = void 0;
      yield WalletConnectProvider.disconnect();
    });
  }
  getAddress(opts2) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a14;
      logger.debug("[WalletConnect] getAddress", opts2);
      logger.logVerboseTroubleshootingMessage("[WalletConnectConnector] getAddress", {
        inAppBrowserUrl: (_a14 = this.metadata) === null || _a14 === void 0 ? void 0 : _a14.inAppBrowserUrl,
        isMobile: isMobile(),
        mobileExperience: this.mobileExperience
      });
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      const provider = yield WalletConnectProvider.awaitAndGetProvider();
      logger.debug("[WalletConnect] getAddress - connecting to WalletConnect", {
        provider
      });
      const addresses = yield WalletConnectProvider.connect({
        connectionOpts: opts2,
        deepLinkPreference: this.deepLinkPreference,
        deepLinks: this.metadata.deepLinks
      });
      logger.debug("[WalletConnect] getAddress - connection result", addresses);
      const address = addresses === null || addresses === void 0 ? void 0 : addresses[0];
      return address;
    });
  }
  getWalletClient(chainId) {
    logger.logVerboseTroubleshootingMessage("[WalletConnect] getWalletClient was called - chainId", chainId);
    const provider = WalletConnectProvider.getProvider();
    if (!provider) {
      logger.debug("[WalletConnect] getWalletClient - provider is not initialized");
      throw new DynamicError("WalletConnectProvider is not initialized");
    }
    const walletClient = createWalletClient({
      account: this.getActiveAccount(),
      chain: chainsMap[chainId !== null && chainId !== void 0 ? chainId : String(this.currentChainId)],
      transport: custom({
        request: (args) => {
          this.deepLinkIfApplicable(args.method);
          return provider.request(args).catch(normalizeRpcError);
        }
      }, this.providersConfig.httpTransportConfig)
    });
    return walletClient;
  }
  deepLinkIfApplicable(method) {
    const methodsThatRequireDeepLink = [
      "personal_sign",
      "eth_sendTransaction",
      "eth_signTypedData_v4"
    ];
    const deepLink = this.getDeepLink();
    if (isMobile() && deepLink && methodsThatRequireDeepLink.includes(method)) {
      PlatformService.openURL(deepLink);
    }
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] signMessage", messageToSign);
      const activeAccount = this.getActiveAccount();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] signMessage - activeAccount", activeAccount);
      if (!activeAccount) {
        return;
      }
      const walletClient = yield this.getWalletClient();
      return walletClient.signMessage({
        account: activeAccount,
        message: messageToSign
      });
    });
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      const activeAccount = this.getActiveAccount();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] getConnectedAccounts - activeAccount", activeAccount);
      return activeAccount ? [activeAccount.address] : [];
    });
  }
  getActiveAccount() {
    var _a14;
    const provider = WalletConnectProvider.getProvider();
    const connectedAccount = (_a14 = provider === null || provider === void 0 ? void 0 : provider.accounts) === null || _a14 === void 0 ? void 0 : _a14[0];
    logger.logVerboseTroubleshootingMessage("[WalletConnect] getActiveAccount - connectedAccount", connectedAccount);
    if (!connectedAccount) {
      return void 0;
    }
    return toAccount(connectedAccount);
  }
  get currentChainId() {
    const lsCurrentChain = StorageService.getItem(WC_CURRENT_CHAIN_KEY);
    try {
      return lsCurrentChain ? parseIntSafe(lsCurrentChain) : void 0;
    } catch (e11) {
      logger.debug("[WalletConnect] getCurrentChainId - error", e11);
      return void 0;
    }
  }
  set currentChainId(value2) {
    if (value2) {
      StorageService.setItem(WC_CURRENT_CHAIN_KEY, value2.toString());
    } else {
      StorageService.removeItem(WC_CURRENT_CHAIN_KEY);
    }
  }
  getActiveChain() {
    if (!this.currentChainId) {
      return void 0;
    }
    return chainsMap[this.currentChainId];
  }
  getNetwork() {
    return __awaiter2(this, void 0, void 0, function* () {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] getNetwork");
      const provider = yield WalletConnectProvider.awaitAndGetProvider();
      if (provider === null || provider === void 0 ? void 0 : provider.chainId) {
        const network = provider.chainId;
        this.currentChainId = network;
        logger.logVerboseTroubleshootingMessage("[WalletConnect] getNetwork - provider network", network);
        return network;
      }
      logger.logVerboseTroubleshootingMessage("[WalletConnect] getNetwork - no provider found, returning current chain id", {
        currentChainId: this.currentChainId
      });
      return this.currentChainId;
    });
  }
  providerSwitchNetwork(_a14) {
    const _super = Object.create(null, {
      providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
    });
    return __awaiter2(this, arguments, void 0, function* ({ network }) {
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - network", {
        network,
        switchNetworkOnlyFromWallet: this.switchNetworkOnlyFromWallet
      });
      yield this.reconnectIfRequired();
      const currentNetworkId = yield this.getNetwork();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - currentNetworkId", currentNetworkId);
      if (currentNetworkId && currentNetworkId === network.chainId) {
        return;
      }
      if (this.switchNetworkOnlyFromWallet) {
        throw new DynamicError("Network switching is only supported through the wallet");
      }
      const walletClient = yield this.getWalletClient();
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - will switch network");
      yield _super.providerSwitchNetwork.call(this, { network, provider: walletClient });
      this.currentChainId = network.chainId;
      logger.logVerboseTroubleshootingMessage("[WalletConnect] providerSwitchNetwork - switched network", network.chainId);
      this.emit("chainChange", { chain: String(network.chainId) });
    });
  }
  supportsNetworkSwitching() {
    return true;
  }
  getSupportedNetworks() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a14;
      const enabledNetworks = this.evmNetworks.map((network) => network.chainId.toString());
      const provider = yield WalletConnectProvider.awaitAndGetProvider();
      if (!(provider === null || provider === void 0 ? void 0 : provider.session)) {
        return enabledNetworks;
      }
      const sessionNetworks = [];
      Object.keys(provider === null || provider === void 0 ? void 0 : provider.session.namespaces).forEach((key) => {
        if (key.startsWith("eip155:")) {
          sessionNetworks.push(key.split(":")[1]);
        }
      });
      (_a14 = provider === null || provider === void 0 ? void 0 : provider.session.namespaces.eip155) === null || _a14 === void 0 ? void 0 : _a14.accounts.forEach((account2) => sessionNetworks.push(account2.split(":")[1]));
      return sessionNetworks.length ? sessionNetworks : enabledNetworks;
    });
  }
  getDeepLink() {
    var _a14;
    const provider = WalletConnectProvider.getProvider();
    logger.debug("[WalletConnect] getDeepLink", {
      hasSession: Boolean(provider === null || provider === void 0 ? void 0 : provider.session),
      topic: (_a14 = provider === null || provider === void 0 ? void 0 : provider.session) === null || _a14 === void 0 ? void 0 : _a14.topic,
      uri: provider === null || provider === void 0 ? void 0 : provider.signer.uri
    });
    if (!(provider === null || provider === void 0 ? void 0 : provider.session)) {
      return;
    }
    const deepLink = getDeepLink({
      deepLinks: this.metadata.deepLinks,
      mode: "regular",
      preference: this.deepLinkPreference,
      uri: provider.signer.uri
    });
    logger.logVerboseTroubleshootingMessage("[WalletConnect] getDeepLink - deepLink", deepLink);
    if (!deepLink) {
      return;
    }
    return `${deepLink}?sessionTopic=${provider.session.topic}`;
  }
  getConnectionUri() {
    return WalletConnectProvider.getConnectionUri();
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger.debug("[WalletConnect] validateActiveWallet - validating wallet", expectedAddress);
      const [activeAddress] = yield this.getConnectedAccounts();
      const isWalletActive = activeAddress && isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (isWalletActive) {
        logger.debug("[WalletConnect] validateActiveWallet - wallet is active");
        return;
      }
      if (activeAddress) {
        logger.debug("[WalletConnect] validateActiveWallet - ending existing WC session");
        yield this.endSession();
      }
      logger.debug("[WalletConnect] validateActiveWallet - trying to reconnect WalletConnect wallet...");
      return this.handleWalletNotActive({
        activeAddress,
        expectedAddress
      });
    });
  }
  reconnectIfRequired() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a14, _b;
      const wcProvider = yield WalletConnectProvider.awaitAndGetProvider();
      if (wcProvider === null || wcProvider === void 0 ? void 0 : wcProvider.session) {
        return;
      }
      yield this.handleWalletNotActive({
        expectedAddress: (_b = (_a14 = this.getActiveAccount()) === null || _a14 === void 0 ? void 0 : _a14.address) !== null && _b !== void 0 ? _b : ""
      });
    });
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/InjectedWalletBase.js
var InjectedWalletBase = class extends EthereumWalletConnector {
  constructor() {
    super(...arguments);
    this.walletConnectorFallback = false;
  }
  get ethProviderHelper() {
    if (!this._ethProviderHelper) {
      this._ethProviderHelper = new EthProviderHelper(this);
    }
    return this._ethProviderHelper;
  }
  getMobileOrInstalledWallet() {
    const canUseWalletConnect = this.walletConnectorFallback && this.constructorProps.projectId;
    logger3.logVerboseTroubleshootingMessage("[InjectedWalletBase] getMobileOrInstalledWallet", {
      canUseWalletConnect,
      isInstalledOnBrowser: this.isInstalledOnBrowser(),
      projectId: this.constructorProps.projectId,
      walletConnectorFallback: this.walletConnectorFallback
    });
    if (this.isInstalledOnBrowser() || !canUseWalletConnect) {
      return this;
    }
    return new WalletConnectConnector(Object.assign(Object.assign({}, this.constructorProps), { walletName: this.name }));
  }
  findProvider() {
    var _a14;
    return (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.getInstalledProvider();
  }
  setupEventListeners() {
    const provider = this.getWalletClient();
    if (!provider)
      return;
    if (!this.ethProviderHelper)
      return;
    const { tearDownEventListeners } = this.ethProviderHelper._setupEventListeners(this);
    this.teardownEventListeners = tearDownEventListeners;
  }
  getWalletClient(chainId) {
    var _a14;
    return (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.findWalletClient(chainId);
  }
  isInstalledOnBrowser() {
    var _a14;
    return ((_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.findProvider()) !== void 0;
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a14;
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      return (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.getAddress();
    });
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getAddress();
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a14;
      return (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.signMessage(messageToSign);
    });
  }
  proveOwnership(address, messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      return this.signMessage(messageToSign);
    });
  }
  endSession() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a14;
      const provider = (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.findProvider();
      if (!provider)
        return;
      void provider.request({
        method: "wallet_revokePermissions",
        params: [
          {
            eth_accounts: {}
          }
        ]
      }).catch((err) => {
        logger3.debug("[InjectedWalletBase] endSession - Error revoking permissions", err);
      });
    });
  }
  providerSwitchNetwork(_a14) {
    const _super = Object.create(null, {
      providerSwitchNetwork: { get: () => super.providerSwitchNetwork }
    });
    return __awaiter2(this, arguments, void 0, function* ({ network, provider }) {
      return _super.providerSwitchNetwork.call(this, { network, provider });
    });
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/PhantomEvm.js
var PhantomEvm = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "Phantom";
    this.overrideKey = "phantomevm";
  }
  getAddress() {
    const _super = Object.create(null, {
      getAddress: { get: () => super.getAddress }
    });
    return __awaiter2(this, void 0, void 0, function* () {
      if (this.isInstalledOnBrowser()) {
        return _super.getAddress.call(this);
      }
      if (isMobile()) {
        handleMobileWalletRedirect({
          nativeLink: "phantom://browse",
          universalLink: "https://phantom.app/ul/browse"
        });
      }
      return void 0;
    });
  }
  canGetChainAddress() {
    var _a14, _b;
    return Boolean((_b = (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.findProvider()) === null || _b === void 0 ? void 0 : _b.selectedAddress);
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/ExodusEvm.js
var ExodusEvm = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "ExodusEvm";
    this.overrideKey = "exodusevm";
    this.walletConnectorFallback = true;
  }
};

// node_modules/@dynamic-labs/ethereum/src/injected/FallbackEvmConnector.js
var FallbackEvmConnector = class extends InjectedWalletBase {
  constructor() {
    super(...arguments);
    this.name = "Fallback Connector";
    this.overrideKey = "fallbackconnector";
    this.isAvailable = false;
  }
  isInstalledOnBrowser() {
    return false;
  }
};

// node_modules/@dynamic-labs/ethereum/src/utils/getConnectorConstructorForEip6963Wallet/getConnectorConstructorForEip6963Wallet.js
var getConnectorConstructorForEip6963Wallet = (walletDetail) => {
  const { info, provider } = walletDetail;
  const sanitizedName = sanitizeName(info.name);
  return class extends InjectedWalletBase {
    constructor(props) {
      super(Object.assign(Object.assign({}, props), { metadata: {
        groupKey: sanitizedName,
        icon: info.icon,
        id: info.uuid,
        name: info.name,
        rdns: info.rdns
      } }));
      this.name = info.name;
      this.overrideKey = `${sanitizedName}evm`;
    }
    findProvider() {
      return provider;
    }
  };
};

// node_modules/@dynamic-labs/ethereum/src/utils/getConnectorConstructorInjectedWallet/getConnectorConstructorInjectedWallet.js
var getConnectorConstructorInjectedWallet = (key, wallet) => {
  const { shortName } = wallet;
  const name = shortName || wallet.name;
  const walletConnectorFallback = Boolean(wallet.walletConnect);
  return class extends InjectedWalletBase {
    constructor() {
      super(...arguments);
      this.name = name;
      this.walletConnectorFallback = walletConnectorFallback;
      this.overrideKey = key;
    }
  };
};

// node_modules/@dynamic-labs/ethereum/src/injected/fetchInjectedWalletConnectors.js
var injectedWalletOverrides = [
  PhantomEvm,
  ExodusEvm
];
var removeEip6963EventsListener;
var shouldAddEip6963Connector = (eip6963ProviderInfo, walletBook, walletsWithCustomConnectors) => {
  var _a14;
  const { rdns, name } = eip6963ProviderInfo;
  const chain6 = "evm";
  const connectorKey = `${sanitizeName(name)}${chain6}`;
  logger.logVerboseTroubleshootingMessage("[ETH shouldAddEip6963Connector]", rdns, name, chain6, connectorKey);
  const existingWallet = Object.entries((_a14 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a14 !== void 0 ? _a14 : {}).find(([key, wallet]) => {
    var _a15, _b;
    return ((_a15 = wallet.eip6963Config) === null || _a15 === void 0 ? void 0 : _a15.rdns) === rdns || key === connectorKey || walletsWithCustomConnectors.includes(connectorKey) || wallet.name === name && ((_b = wallet.injectedConfig) === null || _b === void 0 ? void 0 : _b[0].chain) === chain6;
  });
  logger.logVerboseTroubleshootingMessage("[ETH shouldAddEip6963Connector]", existingWallet);
  return !existingWallet;
};
var addEip6963Listener = (walletBook, walletsWithCustomConnectors) => {
  removeEip6963EventsListener === null || removeEip6963EventsListener === void 0 ? void 0 : removeEip6963EventsListener();
  removeEip6963EventsListener = listenToEip6963Events((event) => {
    if (!shouldAddEip6963Connector(event.detail.info, walletBook, walletsWithCustomConnectors)) {
      return;
    }
    logger.logVerboseTroubleshootingMessage("[ETH fetchInjectedWalletConnectors] listenToEip6963Events", event.detail);
    walletConnectorEvents.emit("providerInjected", {
      injectedConnectorConstructor: getConnectorConstructorForEip6963Wallet(event.detail)
    });
  });
};
var fetchInjectedWalletConnector = ({ walletBook, walletsWithCustomConnectors }) => {
  var _a14;
  addEip6963Listener(walletBook, walletsWithCustomConnectors);
  const walletBookConnectors = Object.entries((_a14 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a14 !== void 0 ? _a14 : {}).filter(([key, wallet]) => {
    var _a15;
    return ((_a15 = wallet.injectedConfig) === null || _a15 === void 0 ? void 0 : _a15.find((config2) => config2.chain === "evm")) && !walletsWithCustomConnectors.includes(key);
  }).map(([key, wallet]) => getConnectorConstructorInjectedWallet(key, wallet));
  const { providers } = Eip6963ProviderSingleton.get();
  const eip6963Connectors = providers.filter((provider) => shouldAddEip6963Connector(provider.info, walletBook, walletsWithCustomConnectors)).map((provider) => getConnectorConstructorForEip6963Wallet(provider));
  logger.logVerboseTroubleshootingMessage("[ETH fetchInjectedWalletConnectors] eip6963Connectors", eip6963Connectors);
  return [...walletBookConnectors, ...eip6963Connectors];
};

// node_modules/@dynamic-labs/ethereum/src/constants.js
var INFURA_ID = "87939db78f824920ada5c872db3e56b8";

// node_modules/@dynamic-labs/ethereum/src/utils/createInjectedConnector/createInjectedConnector.js
var createInjectedConnector = (customConnectorFn) => (props) => {
  const delegate = customConnectorFn(props);
  return [
    class extends InjectedWalletBase {
      constructor(props2) {
        super(Object.assign(Object.assign({}, props2), { metadata: delegate.metadata }));
        this.name = delegate.metadata.name;
      }
      init() {
        return __awaiter2(this, void 0, void 0, function* () {
          return delegate.init();
        });
      }
      findProvider() {
        return delegate.findProvider();
      }
      signMessage(messageToSign) {
        return __awaiter2(this, void 0, void 0, function* () {
          return delegate.signMessage(messageToSign);
        });
      }
      connect() {
        const _super = Object.create(null, {
          connect: { get: () => super.connect }
        });
        return __awaiter2(this, void 0, void 0, function* () {
          if (delegate.connect) {
            return delegate.connect();
          }
          return _super.connect.call(this);
        });
      }
      endSession() {
        const _super = Object.create(null, {
          endSession: { get: () => super.endSession }
        });
        return __awaiter2(this, void 0, void 0, function* () {
          if (delegate.disconnect) {
            yield delegate.disconnect();
          }
          return _super.endSession.call(this);
        });
      }
      getAddress() {
        const _super = Object.create(null, {
          getAddress: { get: () => super.getAddress }
        });
        return __awaiter2(this, void 0, void 0, function* () {
          if (delegate.getAddress) {
            return delegate.getAddress();
          }
          return _super.getAddress.call(this);
        });
      }
      getConnectedAccounts() {
        const _super = Object.create(null, {
          getConnectedAccounts: { get: () => super.getConnectedAccounts }
        });
        return __awaiter2(this, void 0, void 0, function* () {
          if (delegate.getConnectedAccounts) {
            return delegate.getConnectedAccounts();
          }
          return _super.getConnectedAccounts.call(this);
        });
      }
      filter() {
        if (delegate.filter) {
          return delegate.filter();
        }
        return super.filter();
      }
      supportsNetworkSwitching() {
        if (delegate.supportsNetworkSwitching) {
          return delegate.supportsNetworkSwitching();
        }
        return super.supportsNetworkSwitching();
      }
    }
  ];
};

// node_modules/@base-org/account/package.json
var package_default = {
  name: "@base-org/account",
  version: "1.1.1",
  description: "Base Account SDK",
  keywords: [
    "base",
    "account",
    "sdk",
    "web3"
  ],
  publishConfig: {
    access: "public"
  },
  type: "module",
  main: "dist/index.js",
  types: "dist/index.d.ts",
  browser: "dist/base-account.min.js",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: "./dist/index.js",
      require: "./dist/index.js"
    },
    "./payment": {
      types: "./dist/interface/payment/index.d.ts",
      import: "./dist/interface/payment/index.js",
      require: "./dist/interface/payment/index.js"
    },
    "./ui-assets": {
      types: "./dist/ui/assets/index.d.ts",
      import: "./dist/ui/assets/index.js",
      require: "./dist/ui/assets/index.js"
    }
  },
  files: [
    "dist",
    "README.md",
    "LICENSE"
  ],
  sideEffects: false,
  repository: "https://github.com/base/account-sdk.git",
  author: "Base",
  license: "Apache-2.0",
  scripts: {
    clean: "rm -rf dist && rm -rf node_modules",
    pretest: "node compile-assets.cjs",
    test: "vitest",
    "test:coverage": "vitest --coverage",
    prebuild: "rm -rf ./dist",
    build: "node compile-assets.cjs && tsc -p ./tsconfig.build.json && tsc-alias && yarn build:browser",
    "build:browser": "rollup -c rollup.config.js",
    prepublishOnly: "yarn build",
    dev: "yarn build && tsc --watch & nodemon --watch dist --delay 1 --exec tsc-alias",
    typecheck: "tsc --noEmit",
    lint: "biome lint .",
    format: "biome format . --write",
    "format:check": "biome check . --formatter-enabled=true --linter-enabled=false --organize-imports-enabled=false",
    size: "size-limit"
  },
  dependencies: {
    "@noble/hashes": "1.4.0",
    clsx: "1.2.1",
    eventemitter3: "5.0.1",
    "idb-keyval": "6.2.1",
    ox: "0.6.9",
    preact: "10.24.2",
    viem: "^2.31.7",
    zustand: "5.0.3"
  },
  devDependencies: {
    "@rollup/plugin-commonjs": "^25.0.7",
    "@rollup/plugin-json": "^6.1.0",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "@rollup/plugin-replace": "^5.0.5",
    "@rollup/plugin-typescript": "^11.1.6",
    "@size-limit/preset-big-lib": "^11.1.6",
    "@testing-library/jest-dom": "^6.5.0",
    "@testing-library/preact": "^3.2.4",
    "@types/node": "^14.18.54",
    "@vitest/coverage-v8": "2.1.2",
    "@vitest/web-worker": "3.2.1",
    "fake-indexeddb": "^6.0.0",
    glob: "^11.0.0",
    "jest-websocket-mock": "^2.4.0",
    jsdom: "^25.0.1",
    nodemon: "^3.1.0",
    rollup: "^4.9.6",
    "rollup-plugin-terser": "^7.0.2",
    sass: "^1.64.1",
    "size-limit": "^11.1.6",
    "tsc-alias": "^1.8.8",
    tslib: "^2.6.0",
    typescript: "^5.1.6",
    vitest: "^2.1.9"
  },
  "size-limit": [
    {
      path: "./dist/index.js",
      limit: "31 KB",
      import: "*"
    }
  ]
};

// node_modules/@base-org/account/dist/core/constants.js
var CB_KEYS_URL = "https://keys.coinbase.com/connect";
var CB_WALLET_RPC_URL = "https://rpc.wallet.coinbase.com";
var PACKAGE_NAME = package_default.name;
var PACKAGE_VERSION = package_default.version;

// node_modules/zustand/esm/middleware.mjs
function createJSONStorage(getStorage, options) {
  let storage3;
  try {
    storage3 = getStorage();
  } catch (e11) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a14;
      const parse6 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a14 = storage3.getItem(name)) != null ? _a14 : null;
      if (str instanceof Promise) {
        return str.then(parse6);
      }
      return parse6(str);
    },
    setItem: (name, newValue) => storage3.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage3.removeItem(name)
  };
  return persistStorage;
}
var toThenable = (fn4) => (input) => {
  try {
    const result = fn4(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e11) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e11);
      }
    };
  }
};
var persistImpl = (config2, baseOptions) => (set2, get8, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage3 = options.storage;
  if (!storage3) {
    return config2(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set2(...args);
      },
      get8,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get8() });
    return storage3.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2(
    (...args) => {
      set2(...args);
      void setItem();
    },
    get8,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a14, _b;
    if (!storage3) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a22;
      return cb((_a22 = get8()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a14 = get8()) != null ? _a14 : configResult)) || void 0;
    return toThenable(storage3.getItem.bind(storage3))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            const migration = options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
            if (migration instanceof Promise) {
              return migration.then((result) => [true, result]);
            }
            return [true, migration];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a22;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get8()) != null ? _a22 : configResult
      );
      set2(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get8();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e11) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e11);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage3 = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage3 == null ? void 0 : storage3.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
var persist = persistImpl;

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial2, replace) => {
    const nextState = typeof partial2 === "function" ? partial2(state) : partial2;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore2 = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/@base-org/account/dist/store/store.js
var createChainSlice = () => {
  return {
    chains: []
  };
};
var createKeysSlice = () => {
  return {
    keys: {}
  };
};
var createAccountSlice = () => {
  return {
    account: {}
  };
};
var createSubAccountSlice = () => {
  return {
    subAccount: void 0
  };
};
var createSubAccountConfigSlice = () => {
  return {
    subAccountConfig: {}
  };
};
var createSpendPermissionsSlice = () => {
  return {
    spendPermissions: []
  };
};
var createConfigSlice = () => {
  return {
    config: {
      version: PACKAGE_VERSION
    }
  };
};
var sdkstore = createStore2(persist((...args) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, createChainSlice(...args)), createKeysSlice(...args)), createAccountSlice(...args)), createSubAccountSlice(...args)), createSpendPermissionsSlice(...args)), createConfigSlice(...args)), createSubAccountConfigSlice(...args)), {
  name: "base-acc-sdk.store",
  storage: createJSONStorage(() => localStorage),
  partialize: (state) => {
    return {
      chains: state.chains,
      keys: state.keys,
      account: state.account,
      subAccount: state.subAccount,
      spendPermissions: state.spendPermissions,
      config: state.config
    };
  }
}));
var subAccountsConfig = {
  get: () => sdkstore.getState().subAccountConfig,
  set: (subAccountConfig) => {
    sdkstore.setState((state) => ({
      subAccountConfig: Object.assign(Object.assign({}, state.subAccountConfig), subAccountConfig)
    }));
  },
  clear: () => {
    sdkstore.setState({
      subAccountConfig: {}
    });
  }
};
var subAccounts = {
  get: () => sdkstore.getState().subAccount,
  set: (subAccount) => {
    sdkstore.setState((state) => ({
      subAccount: state.subAccount ? Object.assign(Object.assign({}, state.subAccount), subAccount) : Object.assign({ address: subAccount.address }, subAccount)
    }));
  },
  clear: () => {
    sdkstore.setState({
      subAccount: void 0
    });
  }
};
var spendPermissions = {
  get: () => sdkstore.getState().spendPermissions,
  set: (spendPermissions2) => {
    sdkstore.setState({ spendPermissions: spendPermissions2 });
  },
  clear: () => {
    sdkstore.setState({
      spendPermissions: []
    });
  }
};
var account = {
  get: () => sdkstore.getState().account,
  set: (account2) => {
    sdkstore.setState((state) => ({
      account: Object.assign(Object.assign({}, state.account), account2)
    }));
  },
  clear: () => {
    sdkstore.setState({
      account: {}
    });
  }
};
var chains = {
  get: () => sdkstore.getState().chains,
  set: (chains2) => {
    sdkstore.setState({ chains: chains2 });
  },
  clear: () => {
    sdkstore.setState({
      chains: []
    });
  }
};
var keys2 = {
  get: (key) => sdkstore.getState().keys[key],
  set: (key, value2) => {
    sdkstore.setState((state) => ({ keys: Object.assign(Object.assign({}, state.keys), { [key]: value2 }) }));
  },
  clear: () => {
    sdkstore.setState({
      keys: {}
    });
  }
};
var config = {
  get: () => sdkstore.getState().config,
  set: (config2) => {
    sdkstore.setState((state) => ({ config: Object.assign(Object.assign({}, state.config), config2) }));
  }
};
var actions = {
  subAccounts,
  subAccountsConfig,
  spendPermissions,
  account,
  chains,
  keys: keys2,
  config
};
var store = Object.assign(Object.assign({}, sdkstore), actions);

// node_modules/@base-org/account/dist/core/telemetry/telemetry-content.js
var TELEMETRY_SCRIPT_CONTENT = `!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ClientAnalytics=t():e.ClientAnalytics=t()}(this,(function(){return(()=>{var e={792:e=>{var t={utf8:{stringToBytes:function(e){return t.bin.stringToBytes(unescape(encodeURIComponent(e)))},bytesToString:function(e){return decodeURIComponent(escape(t.bin.bytesToString(e)))}},bin:{stringToBytes:function(e){for(var t=[],n=0;n<e.length;n++)t.push(255&e.charCodeAt(n));return t},bytesToString:function(e){for(var t=[],n=0;n<e.length;n++)t.push(String.fromCharCode(e[n]));return t.join("")}}};e.exports=t},562:e=>{var t,n;t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n={rotl:function(e,t){return e<<t|e>>>32-t},rotr:function(e,t){return e<<32-t|e>>>t},endian:function(e){if(e.constructor==Number)return 16711935&n.rotl(e,8)|4278255360&n.rotl(e,24);for(var t=0;t<e.length;t++)e[t]=n.endian(e[t]);return e},randomBytes:function(e){for(var t=[];e>0;e--)t.push(Math.floor(256*Math.random()));return t},bytesToWords:function(e){for(var t=[],n=0,r=0;n<e.length;n++,r+=8)t[r>>>5]|=e[n]<<24-r%32;return t},wordsToBytes:function(e){for(var t=[],n=0;n<32*e.length;n+=8)t.push(e[n>>>5]>>>24-n%32&255);return t},bytesToHex:function(e){for(var t=[],n=0;n<e.length;n++)t.push((e[n]>>>4).toString(16)),t.push((15&e[n]).toString(16));return t.join("")},hexToBytes:function(e){for(var t=[],n=0;n<e.length;n+=2)t.push(parseInt(e.substr(n,2),16));return t},bytesToBase64:function(e){for(var n=[],r=0;r<e.length;r+=3)for(var i=e[r]<<16|e[r+1]<<8|e[r+2],a=0;a<4;a++)8*r+6*a<=8*e.length?n.push(t.charAt(i>>>6*(3-a)&63)):n.push("=");return n.join("")},base64ToBytes:function(e){e=e.replace(/[^A-Z0-9+\\/]/gi,"");for(var n=[],r=0,i=0;r<e.length;i=++r%4)0!=i&&n.push((t.indexOf(e.charAt(r-1))&Math.pow(2,-2*i+8)-1)<<2*i|t.indexOf(e.charAt(r))>>>6-2*i);return n}},e.exports=n},335:e=>{function t(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}e.exports=function(e){return null!=e&&(t(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&t(e.slice(0,0))}(e)||!!e._isBuffer)}},762:(e,t,n)=>{var r,i,a,o,s;r=n(562),i=n(792).utf8,a=n(335),o=n(792).bin,(s=function(e,t){e.constructor==String?e=t&&"binary"===t.encoding?o.stringToBytes(e):i.stringToBytes(e):a(e)?e=Array.prototype.slice.call(e,0):Array.isArray(e)||e.constructor===Uint8Array||(e=e.toString());for(var n=r.bytesToWords(e),c=8*e.length,u=1732584193,l=-271733879,d=-1732584194,p=271733878,m=0;m<n.length;m++)n[m]=16711935&(n[m]<<8|n[m]>>>24)|4278255360&(n[m]<<24|n[m]>>>8);n[c>>>5]|=128<<c%32,n[14+(c+64>>>9<<4)]=c;var f=s._ff,v=s._gg,g=s._hh,b=s._ii;for(m=0;m<n.length;m+=16){var h=u,w=l,y=d,T=p;u=f(u,l,d,p,n[m+0],7,-680876936),p=f(p,u,l,d,n[m+1],12,-389564586),d=f(d,p,u,l,n[m+2],17,606105819),l=f(l,d,p,u,n[m+3],22,-1044525330),u=f(u,l,d,p,n[m+4],7,-176418897),p=f(p,u,l,d,n[m+5],12,1200080426),d=f(d,p,u,l,n[m+6],17,-1473231341),l=f(l,d,p,u,n[m+7],22,-45705983),u=f(u,l,d,p,n[m+8],7,1770035416),p=f(p,u,l,d,n[m+9],12,-1958414417),d=f(d,p,u,l,n[m+10],17,-42063),l=f(l,d,p,u,n[m+11],22,-1990404162),u=f(u,l,d,p,n[m+12],7,1804603682),p=f(p,u,l,d,n[m+13],12,-40341101),d=f(d,p,u,l,n[m+14],17,-1502002290),u=v(u,l=f(l,d,p,u,n[m+15],22,1236535329),d,p,n[m+1],5,-165796510),p=v(p,u,l,d,n[m+6],9,-1069501632),d=v(d,p,u,l,n[m+11],14,643717713),l=v(l,d,p,u,n[m+0],20,-373897302),u=v(u,l,d,p,n[m+5],5,-701558691),p=v(p,u,l,d,n[m+10],9,38016083),d=v(d,p,u,l,n[m+15],14,-660478335),l=v(l,d,p,u,n[m+4],20,-405537848),u=v(u,l,d,p,n[m+9],5,568446438),p=v(p,u,l,d,n[m+14],9,-1019803690),d=v(d,p,u,l,n[m+3],14,-187363961),l=v(l,d,p,u,n[m+8],20,1163531501),u=v(u,l,d,p,n[m+13],5,-1444681467),p=v(p,u,l,d,n[m+2],9,-51403784),d=v(d,p,u,l,n[m+7],14,1735328473),u=g(u,l=v(l,d,p,u,n[m+12],20,-1926607734),d,p,n[m+5],4,-378558),p=g(p,u,l,d,n[m+8],11,-2022574463),d=g(d,p,u,l,n[m+11],16,1839030562),l=g(l,d,p,u,n[m+14],23,-35309556),u=g(u,l,d,p,n[m+1],4,-1530992060),p=g(p,u,l,d,n[m+4],11,1272893353),d=g(d,p,u,l,n[m+7],16,-155497632),l=g(l,d,p,u,n[m+10],23,-1094730640),u=g(u,l,d,p,n[m+13],4,681279174),p=g(p,u,l,d,n[m+0],11,-358537222),d=g(d,p,u,l,n[m+3],16,-722521979),l=g(l,d,p,u,n[m+6],23,76029189),u=g(u,l,d,p,n[m+9],4,-640364487),p=g(p,u,l,d,n[m+12],11,-421815835),d=g(d,p,u,l,n[m+15],16,530742520),u=b(u,l=g(l,d,p,u,n[m+2],23,-995338651),d,p,n[m+0],6,-198630844),p=b(p,u,l,d,n[m+7],10,1126891415),d=b(d,p,u,l,n[m+14],15,-1416354905),l=b(l,d,p,u,n[m+5],21,-57434055),u=b(u,l,d,p,n[m+12],6,1700485571),p=b(p,u,l,d,n[m+3],10,-1894986606),d=b(d,p,u,l,n[m+10],15,-1051523),l=b(l,d,p,u,n[m+1],21,-2054922799),u=b(u,l,d,p,n[m+8],6,1873313359),p=b(p,u,l,d,n[m+15],10,-30611744),d=b(d,p,u,l,n[m+6],15,-1560198380),l=b(l,d,p,u,n[m+13],21,1309151649),u=b(u,l,d,p,n[m+4],6,-145523070),p=b(p,u,l,d,n[m+11],10,-1120210379),d=b(d,p,u,l,n[m+2],15,718787259),l=b(l,d,p,u,n[m+9],21,-343485551),u=u+h>>>0,l=l+w>>>0,d=d+y>>>0,p=p+T>>>0}return r.endian([u,l,d,p])})._ff=function(e,t,n,r,i,a,o){var s=e+(t&n|~t&r)+(i>>>0)+o;return(s<<a|s>>>32-a)+t},s._gg=function(e,t,n,r,i,a,o){var s=e+(t&r|n&~r)+(i>>>0)+o;return(s<<a|s>>>32-a)+t},s._hh=function(e,t,n,r,i,a,o){var s=e+(t^n^r)+(i>>>0)+o;return(s<<a|s>>>32-a)+t},s._ii=function(e,t,n,r,i,a,o){var s=e+(n^(t|~r))+(i>>>0)+o;return(s<<a|s>>>32-a)+t},s._blocksize=16,s._digestsize=16,e.exports=function(e,t){if(null==e)throw new Error("Illegal argument "+e);var n=r.wordsToBytes(s(e,t));return t&&t.asBytes?n:t&&t.asString?o.bytesToString(n):r.bytesToHex(n)}},2:(e,t,n)=>{"use strict";n.r(t),n.d(t,{Perfume:()=>ze,incrementUjNavigation:()=>Le,markStep:()=>Re,markStepOnce:()=>qe});var r,i,a={isResourceTiming:!1,isElementTiming:!1,maxTime:3e4,reportOptions:{},enableNavigationTracking:!0},o=window,s=o.console,c=o.navigator,u=o.performance,l=function(){return c.deviceMemory},d=function(){return c.hardwareConcurrency},p="mark.",m=function(){return u&&!!u.getEntriesByType&&!!u.now&&!!u.mark},f="4g",v=!1,g={},b={value:0},h={value:{beacon:0,css:0,fetch:0,img:0,other:0,script:0,total:0,xmlhttprequest:0}},w={value:0},y={value:0},T={},k={isHidden:!1,didChange:!1},_=function(){k.isHidden=!1,document.hidden&&(k.isHidden=document.hidden,k.didChange=!0)},S=function(e,t){try{var n=new PerformanceObserver((function(e){t(e.getEntries())}));return n.observe({type:e,buffered:!0}),n}catch(e){s.warn("Perfume.js:",e)}return null},E=function(){return!!(d()&&d()<=4)||!!(l()&&l()<=4)},x=function(e,t){switch(e){case"slow-2g":case"2g":case"3g":return!0;default:return E()||t}},O=function(e){return parseFloat(e.toFixed(4))},j=function(e){return"number"!=typeof e?null:O(e/Math.pow(1024,2))},N=function(e,t,n,r,i){var s,u=function(){a.analyticsTracker&&(k.isHidden&&!["CLS","INP"].includes(e)||a.analyticsTracker({attribution:r,metricName:e,data:t,navigatorInformation:c?{deviceMemory:l()||0,hardwareConcurrency:d()||0,serviceWorkerStatus:"serviceWorker"in c?c.serviceWorker.controller?"controlled":"supported":"unsupported",isLowEndDevice:E(),isLowEndExperience:x(f,v)}:{},rating:n,navigationType:i}))};["CLS","INP"].includes(e)?u():(s=u,"requestIdleCallback"in o?o.requestIdleCallback(s,{timeout:3e3}):s())},I=function(e){e.forEach((function(e){if(!("self"!==e.name||e.startTime<b.value)){var t=e.duration-50;t>0&&(w.value+=t,y.value+=t)}}))};!function(e){e.instant="instant",e.quick="quick",e.moderate="moderate",e.slow="slow",e.unavoidable="unavoidable"}(r||(r={}));var P,M,B,C,D,A=((i={})[r.instant]={vitalsThresholds:[100,200],maxOutlierThreshold:1e4},i[r.quick]={vitalsThresholds:[200,500],maxOutlierThreshold:1e4},i[r.moderate]={vitalsThresholds:[500,1e3],maxOutlierThreshold:1e4},i[r.slow]={vitalsThresholds:[1e3,2e3],maxOutlierThreshold:1e4},i[r.unavoidable]={vitalsThresholds:[2e3,5e3],maxOutlierThreshold:2e4},i),L={RT:[100,200],TBT:[200,600],NTBT:[200,600]},U=function(e,t){return L[e]?t<=L[e][0]?"good":t<=L[e][1]?"needsImprovement":"poor":null},R=function(e,t,n){Object.keys(t).forEach((function(e){"number"==typeof t[e]&&(t[e]=O(t[e]))})),N(e,t,null,n||{})},q=function(e){var t=e.attribution,n=e.name,r=e.rating,i=e.value,o=e.navigationType;"FCP"===n&&(b.value=i),["FCP","LCP"].includes(n)&&!T[0]&&(T[0]=S("longtask",I)),"FID"===n&&setTimeout((function(){k.didChange||(q({attribution:t,name:"TBT",rating:U("TBT",w.value),value:w.value,navigationType:o}),R("dataConsumption",h.value))}),1e4);var s=O(i);s<=a.maxTime&&s>=0&&N(n,s,r,t,o)},F=function(){return window.performance&&performance.getEntriesByType&&performance.getEntriesByType("navigation")[0]},z=function(e){if("loading"===document.readyState)return"loading";var t=F();if(t){if(e<t.domInteractive)return"loading";if(0===t.domContentLoadedEventStart||e<t.domContentLoadedEventStart)return"dom-interactive";if(0===t.domComplete||e<t.domComplete)return"dom-content-loaded"}return"complete"},K=function(e){var t=e.nodeName;return 1===e.nodeType?t.toLowerCase():t.toUpperCase().replace(/^#/,"")},$=function(e,t){var n="";try{for(;e&&9!==e.nodeType;){var r=e,i=r.id?"#"+r.id:K(r)+(r.className&&r.className.length?"."+r.className.replace(/\\s+/g,"."):"");if(n.length+i.length>(t||100)-1)return n||i;if(n=n?i+">"+n:i,r.id)break;e=r.parentNode}}catch(e){}return n},Q=-1,W=function(){return Q},H=function(e){addEventListener("pageshow",(function(t){t.persisted&&(Q=t.timeStamp,e(t))}),!0)},V=function(){var e=F();return e&&e.activationStart||0},J=function(e,t){var n=F(),r="navigate";return W()>=0?r="back-forward-cache":n&&(r=document.prerendering||V()>0?"prerender":document.wasDiscarded?"restore":n.type.replace(/_/g,"-")),{name:e,value:void 0===t?-1:t,rating:"good",delta:0,entries:[],id:"v3-".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12),navigationType:r}},X=function(e,t,n){try{if(PerformanceObserver.supportedEntryTypes.includes(e)){var r=new PerformanceObserver((function(e){Promise.resolve().then((function(){t(e.getEntries())}))}));return r.observe(Object.assign({type:e,buffered:!0},n||{})),r}}catch(e){}},G=function(e,t){var n=function n(r){"pagehide"!==r.type&&"hidden"!==document.visibilityState||(e(r),t&&(removeEventListener("visibilitychange",n,!0),removeEventListener("pagehide",n,!0)))};addEventListener("visibilitychange",n,!0),addEventListener("pagehide",n,!0)},Z=function(e,t,n,r){var i,a;return function(o){t.value>=0&&(o||r)&&((a=t.value-(i||0))||void 0===i)&&(i=t.value,t.delta=a,t.rating=function(e,t){return e>t[1]?"poor":e>t[0]?"needs-improvement":"good"}(t.value,n),e(t))}},Y=function(e){requestAnimationFrame((function(){return requestAnimationFrame((function(){return e()}))}))},ee=function(e){document.prerendering?addEventListener("prerenderingchange",(function(){return e()}),!0):e()},te=-1,ne=function(){return"hidden"!==document.visibilityState||document.prerendering?1/0:0},re=function(e){"hidden"===document.visibilityState&&te>-1&&(te="visibilitychange"===e.type?e.timeStamp:0,ae())},ie=function(){addEventListener("visibilitychange",re,!0),addEventListener("prerenderingchange",re,!0)},ae=function(){removeEventListener("visibilitychange",re,!0),removeEventListener("prerenderingchange",re,!0)},oe=function(){return te<0&&(te=ne(),ie(),H((function(){setTimeout((function(){te=ne(),ie()}),0)}))),{get firstHiddenTime(){return te}}},se=function(e,t){t=t||{},ee((function(){var n,r=[1800,3e3],i=oe(),a=J("FCP"),o=X("paint",(function(e){e.forEach((function(e){"first-contentful-paint"===e.name&&(o.disconnect(),e.startTime<i.firstHiddenTime&&(a.value=Math.max(e.startTime-V(),0),a.entries.push(e),n(!0)))}))}));o&&(n=Z(e,a,r,t.reportAllChanges),H((function(i){a=J("FCP"),n=Z(e,a,r,t.reportAllChanges),Y((function(){a.value=performance.now()-i.timeStamp,n(!0)}))})))}))},ce={passive:!0,capture:!0},ue=new Date,le=function(e,t){P||(P=t,M=e,B=new Date,me(removeEventListener),de())},de=function(){if(M>=0&&M<B-ue){var e={entryType:"first-input",name:P.type,target:P.target,cancelable:P.cancelable,startTime:P.timeStamp,processingStart:P.timeStamp+M};C.forEach((function(t){t(e)})),C=[]}},pe=function(e){if(e.cancelable){var t=(e.timeStamp>1e12?new Date:performance.now())-e.timeStamp;"pointerdown"==e.type?function(e,t){var n=function(){le(e,t),i()},r=function(){i()},i=function(){removeEventListener("pointerup",n,ce),removeEventListener("pointercancel",r,ce)};addEventListener("pointerup",n,ce),addEventListener("pointercancel",r,ce)}(t,e):le(t,e)}},me=function(e){["mousedown","keydown","touchstart","pointerdown"].forEach((function(t){return e(t,pe,ce)}))},fe=0,ve=1/0,ge=0,be=function(e){e.forEach((function(e){e.interactionId&&(ve=Math.min(ve,e.interactionId),ge=Math.max(ge,e.interactionId),fe=ge?(ge-ve)/7+1:0)}))},he=function(){return D?fe:performance.interactionCount||0},we=0,ye=function(){return he()-we},Te=[],ke={},_e=function(e){var t=Te[Te.length-1],n=ke[e.interactionId];if(n||Te.length<10||e.duration>t.latency){if(n)n.entries.push(e),n.latency=Math.max(n.latency,e.duration);else{var r={id:e.interactionId,latency:e.duration,entries:[e]};ke[r.id]=r,Te.push(r)}Te.sort((function(e,t){return t.latency-e.latency})),Te.splice(10).forEach((function(e){delete ke[e.id]}))}},Se={},Ee=function e(t){document.prerendering?ee((function(){return e(t)})):"complete"!==document.readyState?addEventListener("load",(function(){return e(t)}),!0):setTimeout(t,0)},xe=function(e,t){t=t||{};var n=[800,1800],r=J("TTFB"),i=Z(e,r,n,t.reportAllChanges);Ee((function(){var a=F();if(a){var o=a.responseStart;if(o<=0||o>performance.now())return;r.value=Math.max(o-V(),0),r.entries=[a],i(!0),H((function(){r=J("TTFB",0),(i=Z(e,r,n,t.reportAllChanges))(!0)}))}}))},Oe=function(e){e.forEach((function(e){e.identifier&&q({attribution:{identifier:e.identifier},name:"ET",rating:null,value:e.startTime})}))},je=function(e){e.forEach((function(e){if(a.isResourceTiming&&R("resourceTiming",e),e.decodedBodySize&&e.initiatorType){var t=e.decodedBodySize/1e3;h.value[e.initiatorType]+=t,h.value.total+=t}}))},Ne=function(){!function(e,t){xe((function(e){!function(e){if(e.entries.length){var t=e.entries[0],n=t.activationStart||0,r=Math.max(t.domainLookupStart-n,0),i=Math.max(t.connectStart-n,0),a=Math.max(t.requestStart-n,0);e.attribution={waitingTime:r,dnsTime:i-r,connectionTime:a-i,requestTime:e.value-a,navigationEntry:t}}else e.attribution={waitingTime:0,dnsTime:0,connectionTime:0,requestTime:0}}(e),function(e){e.value>0&&q(e)}(e)}),t)}(0,a.reportOptions.ttfb),function(e,t){!function(e,t){t=t||{},ee((function(){var e,n=[.1,.25],r=J("CLS"),i=-1,a=0,o=[],s=function(e){i>-1&&function(e){!function(e){if(e.entries.length){var t=e.entries.reduce((function(e,t){return e&&e.value>t.value?e:t}));if(t&&t.sources&&t.sources.length){var n=(r=t.sources).find((function(e){return e.node&&1===e.node.nodeType}))||r[0];if(n)return void(e.attribution={largestShiftTarget:$(n.node),largestShiftTime:t.startTime,largestShiftValue:t.value,largestShiftSource:n,largestShiftEntry:t,loadState:z(t.startTime)})}}var r;e.attribution={}}(e),function(e){q(e)}(e)}(e)},c=function(t){t.forEach((function(t){if(!t.hadRecentInput){var n=o[0],i=o[o.length-1];a&&t.startTime-i.startTime<1e3&&t.startTime-n.startTime<5e3?(a+=t.value,o.push(t)):(a=t.value,o=[t]),a>r.value&&(r.value=a,r.entries=o,e())}}))},u=X("layout-shift",c);u&&(e=Z(s,r,n,t.reportAllChanges),se((function(t){i=t.value,r.value<0&&(r.value=0,e())})),G((function(){c(u.takeRecords()),e(!0)})),H((function(){a=0,i=-1,r=J("CLS",0),e=Z(s,r,n,t.reportAllChanges),Y((function(){return e()}))})))}))}(0,t)}(0,a.reportOptions.cls),function(e,t){se((function(e){!function(e){if(e.entries.length){var t=F(),n=e.entries[e.entries.length-1];if(t){var r=t.activationStart||0,i=Math.max(0,t.responseStart-r);return void(e.attribution={timeToFirstByte:i,firstByteToFCP:e.value-i,loadState:z(e.entries[0].startTime),navigationEntry:t,fcpEntry:n})}}e.attribution={timeToFirstByte:0,firstByteToFCP:e.value,loadState:z(W())}}(e),function(e){q(e)}(e)}),t)}(0,a.reportOptions.fcp),function(e,t){!function(e,t){t=t||{},ee((function(){var n,r=[100,300],i=oe(),a=J("FID"),o=function(e){e.startTime<i.firstHiddenTime&&(a.value=e.processingStart-e.startTime,a.entries.push(e),n(!0))},s=function(e){e.forEach(o)},c=X("first-input",s);n=Z(e,a,r,t.reportAllChanges),c&&G((function(){s(c.takeRecords()),c.disconnect()}),!0),c&&H((function(){var i;a=J("FID"),n=Z(e,a,r,t.reportAllChanges),C=[],M=-1,P=null,me(addEventListener),i=o,C.push(i),de()}))}))}((function(e){!function(e){var t=e.entries[0];e.attribution={eventTarget:$(t.target),eventType:t.name,eventTime:t.startTime,eventEntry:t,loadState:z(t.startTime)}}(e),function(e){q(e)}(e)}),t)}(0,a.reportOptions.fid),function(e,t){!function(e,t){t=t||{},ee((function(){var n,r=[2500,4e3],i=oe(),a=J("LCP"),o=function(e){var t=e[e.length-1];if(t){var r=Math.max(t.startTime-V(),0);r<i.firstHiddenTime&&(a.value=r,a.entries=[t],n())}},s=X("largest-contentful-paint",o);if(s){n=Z(e,a,r,t.reportAllChanges);var c=function(){Se[a.id]||(o(s.takeRecords()),s.disconnect(),Se[a.id]=!0,n(!0))};["keydown","click"].forEach((function(e){addEventListener(e,c,{once:!0,capture:!0})})),G(c,!0),H((function(i){a=J("LCP"),n=Z(e,a,r,t.reportAllChanges),Y((function(){a.value=performance.now()-i.timeStamp,Se[a.id]=!0,n(!0)}))}))}}))}((function(e){!function(e){if(e.entries.length){var t=F();if(t){var n=t.activationStart||0,r=e.entries[e.entries.length-1],i=r.url&&performance.getEntriesByType("resource").filter((function(e){return e.name===r.url}))[0],a=Math.max(0,t.responseStart-n),o=Math.max(a,i?(i.requestStart||i.startTime)-n:0),s=Math.max(o,i?i.responseEnd-n:0),c=Math.max(s,r?r.startTime-n:0),u={element:$(r.element),timeToFirstByte:a,resourceLoadDelay:o-a,resourceLoadTime:s-o,elementRenderDelay:c-s,navigationEntry:t,lcpEntry:r};return r.url&&(u.url=r.url),i&&(u.lcpResourceEntry=i),void(e.attribution=u)}}e.attribution={timeToFirstByte:0,resourceLoadDelay:0,resourceLoadTime:0,elementRenderDelay:e.value}}(e),function(e){q(e)}(e)}),t)}(0,a.reportOptions.lcp),function(e,t){!function(e,t){t=t||{},ee((function(){var n=[200,500];"interactionCount"in performance||D||(D=X("event",be,{type:"event",buffered:!0,durationThreshold:0}));var r,i=J("INP"),a=function(e){e.forEach((function(e){e.interactionId&&_e(e),"first-input"===e.entryType&&!Te.some((function(t){return t.entries.some((function(t){return e.duration===t.duration&&e.startTime===t.startTime}))}))&&_e(e)}));var t,n=(t=Math.min(Te.length-1,Math.floor(ye()/50)),Te[t]);n&&n.latency!==i.value&&(i.value=n.latency,i.entries=n.entries,r())},o=X("event",a,{durationThreshold:t.durationThreshold||40});r=Z(e,i,n,t.reportAllChanges),o&&(o.observe({type:"first-input",buffered:!0}),G((function(){a(o.takeRecords()),i.value<0&&ye()>0&&(i.value=0,i.entries=[]),r(!0)})),H((function(){Te=[],we=he(),i=J("INP"),r=Z(e,i,n,t.reportAllChanges)})))}))}((function(t){!function(e){if(e.entries.length){var t=e.entries.sort((function(e,t){return t.duration-e.duration||t.processingEnd-t.processingStart-(e.processingEnd-e.processingStart)}))[0];e.attribution={eventTarget:$(t.target),eventType:t.name,eventTime:t.startTime,eventEntry:t,loadState:z(t.startTime)}}else e.attribution={}}(t),e(t)}),t)}((function(e){return q(e)}),a.reportOptions.inp),a.isResourceTiming&&S("resource",je),a.isElementTiming&&S("element",Oe)},Ie=function(e){var t="usageDetails"in e?e.usageDetails:{};R("storageEstimate",{quota:j(e.quota),usage:j(e.usage),caches:j(t.caches),indexedDB:j(t.indexedDB),serviceWorker:j(t.serviceWorkerRegistrations)})},Pe={finalMarkToStepsMap:{},startMarkToStepsMap:{},active:{},navigationSteps:{}},Me=function(e){delete Pe.active[e]},Be=function(){return Pe.navigationSteps},Ce=function(e){var t;return null!==(t=Be()[e])&&void 0!==t?t:{}},De=function(e,t,n){var r="step."+e,i=u.getEntriesByName(p+t).length>0;if(u.getEntriesByName(p+n).length>0&&a.steps){var o=A[a.steps[e].threshold],s=o.maxOutlierThreshold,c=o.vitalsThresholds;if(i){var l=u.measure(r,p+t,p+n),d=l.duration;if(d<=s){var m=function(e,t){return e<=t[0]?"good":e<=t[1]?"needsImprovement":"poor"}(d,c);d>=0&&(N("userJourneyStep",d,m,{stepName:e},void 0),u.measure("step.".concat(e,"_vitals_").concat(m),{start:l.startTime+l.duration,end:l.startTime+l.duration,detail:{type:"stepVital",duration:d}}))}}}},Ae=function(){var e=Be(),t=Pe.startMarkToStepsMap,n=Object.keys(e).length;if(0===n)return{};var r={},i=n-1,a=Ce(i);if(Object.keys(a).forEach((function(e){var n,i=null!==(n=t[e])&&void 0!==n?n:[];Object.keys(i).forEach((function(e){r[e]=!0}))})),n>1){var o=Ce(i-1);Object.keys(o).forEach((function(e){var n,i=null!==(n=t[e])&&void 0!==n?n:[];Object.keys(i).forEach((function(e){r[e]=!0}))}))}return r},Le=function(){var e,t=Object.keys(Pe.navigationSteps).length;Pe.navigationSteps[t]={};var n=Ae();null===(e=a.onMarkStep)||void 0===e||e.call(a,"",Object.keys(n))},Ue=function(e){var t,n,r,i,o,s,c;if(Pe.finalMarkToStepsMap[e]){!function(e){var t=Pe.navigationSteps,n=Pe.finalMarkToStepsMap,r=Object.keys(t).length;if(0!==r){var i=r-1,a=Ce(i);if(a&&n[e]){var o=n[e];o&&Object.keys(o).forEach((function(e){if(a[e]){var n=Ce(i)||{};n[e]=!1,t[i]=n}if(r>1){var o=i-1,s=Ce(o);s[e]&&(s[e]=!1,t[o]=s)}}))}}}(e);var u=Pe.finalMarkToStepsMap[e];Object.keys(u).forEach((function(t){var n=u[t];n.forEach(Me),Promise.all(n.map((function(n){return function(e,t,n,r){return new(n||(n=Promise))((function(e,t){function i(e){try{o(r.next(e))}catch(e){t(e)}}function a(e){try{o(r.throw(e))}catch(e){t(e)}}function o(t){var r;t.done?e(t.value):(r=t.value,r instanceof n?r:new n((function(e){e(r)}))).then(i,a)}o((r=r.apply(undefined,[])).next())}))}(0,0,void 0,(function(){return function(e,t){var n,r,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,r=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!((i=(i=o.trys).length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=t.call(e,o)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}(this,(function(r){switch(r.label){case 0:return[4,De(n,t,e)];case 1:return r.sent(),[2]}}))}))}))).catch((function(){}))}))}else r=e,i=Pe.navigationSteps,o=Object.keys(i).length,(c=Ce(s=(o>0?o:1)-1)||[])[r]=!0,i[s]=c,function(e){var t,n=null!==(t=Pe.startMarkToStepsMap[e])&&void 0!==t?t:[];Object.keys(n).forEach((function(e){Pe.active[e]||(Pe.active[e]=!0)}))}(e);if(a.enableNavigationTracking){var l=Ae();null===(t=a.onMarkStep)||void 0===t||t.call(a,e,Object.keys(l))}else null===(n=a.onMarkStep)||void 0===n||n.call(a,e,Object.keys(Pe.active))},Re=function(e){u.mark(p+e),Ue(e)},qe=function(e){0===u.getEntriesByName(p+e).length&&(u.mark(p+e),Ue(e))},Fe=0,ze=function(){function e(e){if(void 0===e&&(e={}),this.v="9.0.0-rc.3",a.analyticsTracker=e.analyticsTracker,a.isResourceTiming=!!e.resourceTiming,a.isElementTiming=!!e.elementTiming,a.maxTime=e.maxMeasureTime||a.maxTime,a.reportOptions=e.reportOptions||a.reportOptions,a.steps=e.steps,a.onMarkStep=e.onMarkStep,a.enableNavigationTracking=e.enableNavigationTracking,m()){"PerformanceObserver"in o&&Ne(),void 0!==document.hidden&&document.addEventListener("visibilitychange",_);var t=function(){if(!m())return{};var e=u.getEntriesByType("navigation")[0];if(!e)return{};var t=e.responseStart,n=e.responseEnd;return{fetchTime:n-e.fetchStart,workerTime:e.workerStart>0?n-e.workerStart:0,totalTime:n-e.requestStart,downloadTime:n-t,timeToFirstByte:t-e.requestStart,headerSize:e.transferSize-e.encodedBodySize||0,dnsLookupTime:e.domainLookupEnd-e.domainLookupStart,redirectTime:e.redirectEnd-e.redirectStart}}();R("navigationTiming",t),t.redirectTime&&q({attribution:{},name:"RT",rating:U("RT",t.redirectTime),value:t.redirectTime}),R("networkInformation",function(){if("connection"in c){var e=c.connection;return"object"!=typeof e?{}:(f=e.effectiveType,v=!!e.saveData,{downlink:e.downlink,effectiveType:e.effectiveType,rtt:e.rtt,saveData:!!e.saveData})}return{}}()),c&&c.storage&&"function"==typeof c.storage.estimate&&c.storage.estimate().then(Ie),a.steps&&a.steps&&(Pe.startMarkToStepsMap={},Pe.finalMarkToStepsMap={},Pe.active={},Pe.navigationSteps={},Object.entries(a.steps).forEach((function(e){var t,n,r=e[0],i=e[1].marks,a=i[0],o=i[1],s=null!==(n=Pe.startMarkToStepsMap[a])&&void 0!==n?n:{};if(s[r]=!0,Pe.startMarkToStepsMap[a]=s,Pe.finalMarkToStepsMap[o]){var c=Pe.finalMarkToStepsMap[o][a]||[];c.push(r),Pe.finalMarkToStepsMap[o][a]=c}else Pe.finalMarkToStepsMap[o]=((t={})[a]=[r],t)})))}}return e.prototype.start=function(e){m()&&!g[e]&&(g[e]=!0,u.mark("mark_".concat(e,"_start")))},e.prototype.end=function(e,t,n){if(void 0===t&&(t={}),void 0===n&&(n=!0),m()&&g[e]){u.mark("mark_".concat(e,"_end")),delete g[e];var r=function(e){u.measure(e,"mark_".concat(e,"_start"),"mark_".concat(e,"_end"));var t=u.getEntriesByName(e).pop();return t&&"measure"===t.entryType?t.duration:-1}(e);n&&R(e,O(r),t)}},e.prototype.endPaint=function(e,t){var n=this;setTimeout((function(){n.end(e,t)}))},e.prototype.clear=function(e){delete g[e],u.clearMarks&&(u.clearMarks("mark_".concat(e,"_start")),u.clearMarks("mark_".concat(e,"_end")))},e.prototype.markNTBT=function(){var e=this;this.start("ntbt"),y.value=0,clearTimeout(Fe),Fe=setTimeout((function(){e.end("ntbt",{},!1),q({attribution:{},name:"NTBT",rating:U("NTBT",y.value),value:y.value}),y.value=0}),2e3)},e}()},426:(e,t)=>{"use strict";Symbol.for("react.element"),Symbol.for("react.portal"),Symbol.for("react.fragment"),Symbol.for("react.strict_mode"),Symbol.for("react.profiler"),Symbol.for("react.provider"),Symbol.for("react.context"),Symbol.for("react.forward_ref"),Symbol.for("react.suspense"),Symbol.for("react.memo"),Symbol.for("react.lazy"),Symbol.iterator;var n={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},r=Object.assign,i={};function a(e,t,r){this.props=e,this.context=t,this.refs=i,this.updater=r||n}function o(){}function s(e,t,r){this.props=e,this.context=t,this.refs=i,this.updater=r||n}a.prototype.isReactComponent={},a.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},a.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},o.prototype=a.prototype;var c=s.prototype=new o;c.constructor=s,r(c,a.prototype),c.isPureReactComponent=!0;Array.isArray,Object.prototype.hasOwnProperty;var u={current:null};t.useCallback=function(e,t){return u.current.useCallback(e,t)},t.useEffect=function(e,t){return u.current.useEffect(e,t)},t.useRef=function(e){return u.current.useRef(e)}},784:(e,t,n)=>{"use strict";e.exports=n(426)},353:function(e,t,n){var r;!function(i,a){"use strict";var o="function",s="undefined",c="object",u="string",l="major",d="model",p="name",m="type",f="vendor",v="version",g="architecture",b="console",h="mobile",w="tablet",y="smarttv",T="wearable",k="embedded",_="Amazon",S="Apple",E="ASUS",x="BlackBerry",O="Browser",j="Chrome",N="Firefox",I="Google",P="Huawei",M="LG",B="Microsoft",C="Motorola",D="Opera",A="Samsung",L="Sharp",U="Sony",R="Xiaomi",q="Zebra",F="Facebook",z="Chromium OS",K="Mac OS",$=function(e){for(var t={},n=0;n<e.length;n++)t[e[n].toUpperCase()]=e[n];return t},Q=function(e,t){return typeof e===u&&-1!==W(t).indexOf(W(e))},W=function(e){return e.toLowerCase()},H=function(e,t){if(typeof e===u)return e=e.replace(/^\\s\\s*/,""),typeof t===s?e:e.substring(0,350)},V=function(e,t){for(var n,r,i,s,u,l,d=0;d<t.length&&!u;){var p=t[d],m=t[d+1];for(n=r=0;n<p.length&&!u&&p[n];)if(u=p[n++].exec(e))for(i=0;i<m.length;i++)l=u[++r],typeof(s=m[i])===c&&s.length>0?2===s.length?typeof s[1]==o?this[s[0]]=s[1].call(this,l):this[s[0]]=s[1]:3===s.length?typeof s[1]!==o||s[1].exec&&s[1].test?this[s[0]]=l?l.replace(s[1],s[2]):a:this[s[0]]=l?s[1].call(this,l,s[2]):a:4===s.length&&(this[s[0]]=l?s[3].call(this,l.replace(s[1],s[2])):a):this[s]=l||a;d+=2}},J=function(e,t){for(var n in t)if(typeof t[n]===c&&t[n].length>0){for(var r=0;r<t[n].length;r++)if(Q(t[n][r],e))return"?"===n?a:n}else if(Q(t[n],e))return"?"===n?a:n;return e},X={ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2e3:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"},G={browser:[[/\\b(?:crmo|crios)\\/([\\w\\.]+)/i],[v,[p,"Chrome"]],[/edg(?:e|ios|a)?\\/([\\w\\.]+)/i],[v,[p,"Edge"]],[/(opera mini)\\/([-\\w\\.]+)/i,/(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i,/(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i],[p,v],[/opios[\\/ ]+([\\w\\.]+)/i],[v,[p,D+" Mini"]],[/\\bopr\\/([\\w\\.]+)/i],[v,[p,D]],[/(kindle)\\/([\\w\\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i,/(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i,/(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i,/(?:ms|\\()(ie) ([\\w\\.]+)/i,/(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i,/(heytap|ovi)browser\\/([\\d\\.]+)/i,/(weibo)__([\\d\\.]+)/i],[p,v],[/(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i],[v,[p,"UC"+O]],[/microm.+\\bqbcore\\/([\\w\\.]+)/i,/\\bqbcore\\/([\\w\\.]+).+microm/i],[v,[p,"WeChat(Win) Desktop"]],[/micromessenger\\/([\\w\\.]+)/i],[v,[p,"WeChat"]],[/konqueror\\/([\\w\\.]+)/i],[v,[p,"Konqueror"]],[/trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i],[v,[p,"IE"]],[/ya(?:search)?browser\\/([\\w\\.]+)/i],[v,[p,"Yandex"]],[/(avast|avg)\\/([\\w\\.]+)/i],[[p,/(.+)/,"$1 Secure "+O],v],[/\\bfocus\\/([\\w\\.]+)/i],[v,[p,N+" Focus"]],[/\\bopt\\/([\\w\\.]+)/i],[v,[p,D+" Touch"]],[/coc_coc\\w+\\/([\\w\\.]+)/i],[v,[p,"Coc Coc"]],[/dolfin\\/([\\w\\.]+)/i],[v,[p,"Dolphin"]],[/coast\\/([\\w\\.]+)/i],[v,[p,D+" Coast"]],[/miuibrowser\\/([\\w\\.]+)/i],[v,[p,"MIUI "+O]],[/fxios\\/([-\\w\\.]+)/i],[v,[p,N]],[/\\bqihu|(qi?ho?o?|360)browser/i],[[p,"360 "+O]],[/(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i],[[p,/(.+)/,"$1 "+O],v],[/(comodo_dragon)\\/([\\w\\.]+)/i],[[p,/_/g," "],v],[/(electron)\\/([\\w\\.]+) safari/i,/(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i,/m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i],[p,v],[/(metasr)[\\/ ]?([\\w\\.]+)/i,/(lbbrowser)/i,/\\[(linkedin)app\\]/i],[p],[/((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i],[[p,F],v],[/(kakao(?:talk|story))[\\/ ]([\\w\\.]+)/i,/(naver)\\(.*?(\\d+\\.[\\w\\.]+).*\\)/i,/safari (line)\\/([\\w\\.]+)/i,/\\b(line)\\/([\\w\\.]+)\\/iab/i,/(chromium|instagram)[\\/ ]([-\\w\\.]+)/i],[p,v],[/\\bgsa\\/([\\w\\.]+) .*safari\\//i],[v,[p,"GSA"]],[/musical_ly(?:.+app_?version\\/|_)([\\w\\.]+)/i],[v,[p,"TikTok"]],[/headlesschrome(?:\\/([\\w\\.]+)| )/i],[v,[p,j+" Headless"]],[/ wv\\).+(chrome)\\/([\\w\\.]+)/i],[[p,j+" WebView"],v],[/droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i],[v,[p,"Android "+O]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i],[p,v],[/version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i],[v,[p,"Mobile Safari"]],[/version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i],[v,p],[/webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i],[p,[v,J,{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}]],[/(webkit|khtml)\\/([\\w\\.]+)/i],[p,v],[/(navigator|netscape\\d?)\\/([-\\w\\.]+)/i],[[p,"Netscape"],v],[/mobile vr; rv:([\\w\\.]+)\\).+firefox/i],[v,[p,N+" Reality"]],[/ekiohf.+(flow)\\/([\\w\\.]+)/i,/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i,/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i,/(firefox)\\/([\\w\\.]+)/i,/(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i,/(links) \\(([\\w\\.]+)/i,/panasonic;(viera)/i],[p,v],[/(cobalt)\\/([\\w\\.]+)/i],[p,[v,/master.|lts./,""]]],cpu:[[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i],[[g,"amd64"]],[/(ia32(?=;))/i],[[g,W]],[/((?:i[346]|x)86)[;\\)]/i],[[g,"ia32"]],[/\\b(aarch64|arm(v?8e?l?|_?64))\\b/i],[[g,"arm64"]],[/\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i],[[g,"armhf"]],[/windows (ce|mobile); ppc;/i],[[g,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i],[[g,/ower/,"",W]],[/(sun4\\w)[;\\)]/i],[[g,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i],[[g,W]]],device:[[/\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i],[d,[f,A],[m,w]],[/\\b((?:s[cgp]h|gt|sm)-\\w+|sc[g-]?[\\d]+a?|galaxy nexus)/i,/samsung[- ]([-\\w]+)/i,/sec-(sgh\\w+)/i],[d,[f,A],[m,h]],[/(?:\\/|\\()(ip(?:hone|od)[\\w, ]*)(?:\\/|;)/i],[d,[f,S],[m,h]],[/\\((ipad);[-\\w\\),; ]+apple/i,/applecoremedia\\/[\\w\\.]+ \\((ipad)/i,/\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i],[d,[f,S],[m,w]],[/(macintosh);/i],[d,[f,S]],[/\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i],[d,[f,L],[m,h]],[/\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i],[d,[f,P],[m,w]],[/(?:huawei|honor)([-\\w ]+)[;\\)]/i,/\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i],[d,[f,P],[m,h]],[/\\b(poco[\\w ]+)(?: bui|\\))/i,/\\b; (\\w+) build\\/hm\\1/i,/\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i,/\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i,/\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i],[[d,/_/g," "],[f,R],[m,h]],[/\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i],[[d,/_/g," "],[f,R],[m,w]],[/; (\\w+) bui.+ oppo/i,/\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i],[d,[f,"OPPO"],[m,h]],[/vivo (\\w+)(?: bui|\\))/i,/\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i],[d,[f,"Vivo"],[m,h]],[/\\b(rmx[12]\\d{3})(?: bui|;|\\))/i],[d,[f,"Realme"],[m,h]],[/\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i,/\\bmot(?:orola)?[- ](\\w*)/i,/((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i],[d,[f,C],[m,h]],[/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i],[d,[f,C],[m,w]],[/((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i],[d,[f,M],[m,w]],[/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i,/\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i,/\\blg-?([\\d\\w]+) bui/i],[d,[f,M],[m,h]],[/(ideatab[-\\w ]+)/i,/lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i],[d,[f,"Lenovo"],[m,w]],[/(?:maemo|nokia).*(n900|lumia \\d+)/i,/nokia[-_ ]?([-\\w\\.]*)/i],[[d,/_/g," "],[f,"Nokia"],[m,h]],[/(pixel c)\\b/i],[d,[f,I],[m,w]],[/droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i],[d,[f,I],[m,h]],[/droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i],[d,[f,U],[m,h]],[/sony tablet [ps]/i,/\\b(?:sony)?sgp\\w+(?: bui|\\))/i],[[d,"Xperia Tablet"],[f,U],[m,w]],[/ (kb2005|in20[12]5|be20[12][59])\\b/i,/(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i],[d,[f,"OnePlus"],[m,h]],[/(alexa)webm/i,/(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\\))/i,/(kf[a-z]+)( bui|\\)).+silk\\//i],[d,[f,_],[m,w]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i],[[d,/(.+)/g,"Fire Phone $1"],[f,_],[m,h]],[/(playbook);[-\\w\\),; ]+(rim)/i],[d,f,[m,w]],[/\\b((?:bb[a-f]|st[hv])100-\\d)/i,/\\(bb10; (\\w+)/i],[d,[f,x],[m,h]],[/(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i],[d,[f,E],[m,w]],[/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i],[d,[f,E],[m,h]],[/(nexus 9)/i],[d,[f,"HTC"],[m,w]],[/(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i,/(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\\.))|sony(?!-bra))[-_ ]?([-\\w]*)/i],[f,[d,/_/g," "],[m,h]],[/droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i],[d,[f,"Acer"],[m,w]],[/droid.+; (m[1-5] note) bui/i,/\\bmz-([-\\w]{2,})/i],[d,[f,"Meizu"],[m,h]],[/(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i,/(hp) ([\\w ]+\\w)/i,/(asus)-?(\\w+)/i,/(microsoft); (lumia[\\w ]+)/i,/(lenovo)[-_ ]?([-\\w]+)/i,/(jolla)/i,/(oppo) ?([\\w ]+) bui/i],[f,d,[m,h]],[/(kobo)\\s(ereader|touch)/i,/(archos) (gamepad2?)/i,/(hp).+(touchpad(?!.+tablet)|tablet)/i,/(kindle)\\/([\\w\\.]+)/i,/(nook)[\\w ]+build\\/(\\w+)/i,/(dell) (strea[kpr\\d ]*[\\dko])/i,/(le[- ]+pan)[- ]+(\\w{1,9}) bui/i,/(trinity)[- ]*(t\\d{3}) bui/i,/(gigaset)[- ]+(q\\w{1,9}) bui/i,/(vodafone) ([\\w ]+)(?:\\)| bui)/i],[f,d,[m,w]],[/(surface duo)/i],[d,[f,B],[m,w]],[/droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i],[d,[f,"Fairphone"],[m,h]],[/(u304aa)/i],[d,[f,"AT&T"],[m,h]],[/\\bsie-(\\w*)/i],[d,[f,"Siemens"],[m,h]],[/\\b(rct\\w+) b/i],[d,[f,"RCA"],[m,w]],[/\\b(venue[\\d ]{2,7}) b/i],[d,[f,"Dell"],[m,w]],[/\\b(q(?:mv|ta)\\w+) b/i],[d,[f,"Verizon"],[m,w]],[/\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i],[d,[f,"Barnes & Noble"],[m,w]],[/\\b(tm\\d{3}\\w+) b/i],[d,[f,"NuVision"],[m,w]],[/\\b(k88) b/i],[d,[f,"ZTE"],[m,w]],[/\\b(nx\\d{3}j) b/i],[d,[f,"ZTE"],[m,h]],[/\\b(gen\\d{3}) b.+49h/i],[d,[f,"Swiss"],[m,h]],[/\\b(zur\\d{3}) b/i],[d,[f,"Swiss"],[m,w]],[/\\b((zeki)?tb.*\\b) b/i],[d,[f,"Zeki"],[m,w]],[/\\b([yr]\\d{2}) b/i,/\\b(dragon[- ]+touch |dt)(\\w{5}) b/i],[[f,"Dragon Touch"],d,[m,w]],[/\\b(ns-?\\w{0,9}) b/i],[d,[f,"Insignia"],[m,w]],[/\\b((nxa|next)-?\\w{0,9}) b/i],[d,[f,"NextBook"],[m,w]],[/\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],[[f,"Voice"],d,[m,h]],[/\\b(lvtel\\-)?(v1[12]) b/i],[[f,"LvTel"],d,[m,h]],[/\\b(ph-1) /i],[d,[f,"Essential"],[m,h]],[/\\b(v(100md|700na|7011|917g).*\\b) b/i],[d,[f,"Envizen"],[m,w]],[/\\b(trio[-\\w\\. ]+) b/i],[d,[f,"MachSpeed"],[m,w]],[/\\btu_(1491) b/i],[d,[f,"Rotor"],[m,w]],[/(shield[\\w ]+) b/i],[d,[f,"Nvidia"],[m,w]],[/(sprint) (\\w+)/i],[f,d,[m,h]],[/(kin\\.[onetw]{3})/i],[[d,/\\./g," "],[f,B],[m,h]],[/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i],[d,[f,q],[m,w]],[/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i],[d,[f,q],[m,h]],[/smart-tv.+(samsung)/i],[f,[m,y]],[/hbbtv.+maple;(\\d+)/i],[[d,/^/,"SmartTV"],[f,A],[m,y]],[/(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i],[[f,M],[m,y]],[/(apple) ?tv/i],[f,[d,S+" TV"],[m,y]],[/crkey/i],[[d,j+"cast"],[f,I],[m,y]],[/droid.+aft(\\w)( bui|\\))/i],[d,[f,_],[m,y]],[/\\(dtv[\\);].+(aquos)/i,/(aquos-tv[\\w ]+)\\)/i],[d,[f,L],[m,y]],[/(bravia[\\w ]+)( bui|\\))/i],[d,[f,U],[m,y]],[/(mitv-\\w{5}) bui/i],[d,[f,R],[m,y]],[/Hbbtv.*(technisat) (.*);/i],[f,d,[m,y]],[/\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i,/hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w\\+ ]*; *([\\w\\d][^;]*);([^;]*)/i],[[f,H],[d,H],[m,y]],[/\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i],[[m,y]],[/(ouya)/i,/(nintendo) ([wids3utch]+)/i],[f,d,[m,b]],[/droid.+; (shield) bui/i],[d,[f,"Nvidia"],[m,b]],[/(playstation [345portablevi]+)/i],[d,[f,U],[m,b]],[/\\b(xbox(?: one)?(?!; xbox))[\\); ]/i],[d,[f,B],[m,b]],[/((pebble))app/i],[f,d,[m,T]],[/(watch)(?: ?os[,\\/]|\\d,\\d\\/)[\\d\\.]+/i],[d,[f,S],[m,T]],[/droid.+; (glass) \\d/i],[d,[f,I],[m,T]],[/droid.+; (wt63?0{2,3})\\)/i],[d,[f,q],[m,T]],[/(quest( 2| pro)?)/i],[d,[f,F],[m,T]],[/(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i],[f,[m,k]],[/(aeobc)\\b/i],[d,[f,_],[m,k]],[/droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i],[d,[m,h]],[/droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i],[d,[m,w]],[/\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i],[[m,w]],[/(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i],[[m,h]],[/(android[-\\w\\. ]{0,9});.+buil/i],[d,[f,"Generic"]]],engine:[[/windows.+ edge\\/([\\w\\.]+)/i],[v,[p,"EdgeHTML"]],[/webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i],[v,[p,"Blink"]],[/(presto)\\/([\\w\\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i,/ekioh(flow)\\/([\\w\\.]+)/i,/(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i,/(icab)[\\/ ]([23]\\.[\\d\\.]+)/i,/\\b(libweb)/i],[p,v],[/rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i],[v,p]],os:[[/microsoft (windows) (vista|xp)/i],[p,v],[/(windows) nt 6\\.2; (arm)/i,/(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i,/(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i],[p,[v,J,X]],[/(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i],[[p,"Windows"],[v,J,X]],[/ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i,/ios;fbsv\\/([\\d\\.]+)/i,/cfnetwork\\/.+darwin/i],[[v,/_/g,"."],[p,"iOS"]],[/(mac os x) ?([\\w\\. ]*)/i,/(macintosh|mac_powerpc\\b)(?!.+haiku)/i],[[p,K],[v,/_/g,"."]],[/droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i],[v,p],[/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i,/(blackberry)\\w*\\/([\\w\\.]*)/i,/(tizen|kaios)[\\/ ]([\\w\\.]+)/i,/\\((series40);/i],[p,v],[/\\(bb(10);/i],[v,[p,x]],[/(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i],[v,[p,"Symbian"]],[/mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i],[v,[p,N+" OS"]],[/web0s;.+rt(tv)/i,/\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i],[v,[p,"webOS"]],[/watch(?: ?os[,\\/]|\\d,\\d\\/)([\\d\\.]+)/i],[v,[p,"watchOS"]],[/crkey\\/([\\d\\.]+)/i],[v,[p,j+"cast"]],[/(cros) [\\w]+(?:\\)| ([\\w\\.]+)\\b)/i],[[p,z],v],[/panasonic;(viera)/i,/(netrange)mmh/i,/(nettv)\\/(\\d+\\.[\\w\\.]+)/i,/(nintendo|playstation) ([wids345portablevuch]+)/i,/(xbox); +xbox ([^\\);]+)/i,/\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i,/(mint)[\\/\\(\\) ]?(\\w*)/i,/(mageia|vectorlinux)[; ]/i,/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i,/(hurd|linux) ?([\\w\\.]*)/i,/(gnu) ?([\\w\\.]*)/i,/\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i,/(haiku) (\\w+)/i],[p,v],[/(sunos) ?([\\w\\.\\d]*)/i],[[p,"Solaris"],v],[/((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i,/(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i,/\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,/(unix) ?([\\w\\.]*)/i],[p,v]]},Z=function(e,t){if(typeof e===c&&(t=e,e=a),!(this instanceof Z))return new Z(e,t).getResult();var n=typeof i!==s&&i.navigator?i.navigator:a,r=e||(n&&n.userAgent?n.userAgent:""),b=n&&n.userAgentData?n.userAgentData:a,y=t?function(e,t){var n={};for(var r in e)t[r]&&t[r].length%2==0?n[r]=t[r].concat(e[r]):n[r]=e[r];return n}(G,t):G,T=n&&n.userAgent==r;return this.getBrowser=function(){var e,t={};return t[p]=a,t[v]=a,V.call(t,r,y.browser),t[l]=typeof(e=t[v])===u?e.replace(/[^\\d\\.]/g,"").split(".")[0]:a,T&&n&&n.brave&&typeof n.brave.isBrave==o&&(t[p]="Brave"),t},this.getCPU=function(){var e={};return e[g]=a,V.call(e,r,y.cpu),e},this.getDevice=function(){var e={};return e[f]=a,e[d]=a,e[m]=a,V.call(e,r,y.device),T&&!e[m]&&b&&b.mobile&&(e[m]=h),T&&"Macintosh"==e[d]&&n&&typeof n.standalone!==s&&n.maxTouchPoints&&n.maxTouchPoints>2&&(e[d]="iPad",e[m]=w),e},this.getEngine=function(){var e={};return e[p]=a,e[v]=a,V.call(e,r,y.engine),e},this.getOS=function(){var e={};return e[p]=a,e[v]=a,V.call(e,r,y.os),T&&!e[p]&&b&&"Unknown"!=b.platform&&(e[p]=b.platform.replace(/chrome os/i,z).replace(/macos/i,K)),e},this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}},this.getUA=function(){return r},this.setUA=function(e){return r=typeof e===u&&e.length>350?H(e,350):e,this},this.setUA(r),this};Z.VERSION="1.0.35",Z.BROWSER=$([p,v,l]),Z.CPU=$([g]),Z.DEVICE=$([d,f,m,b,h,y,w,T,k]),Z.ENGINE=Z.OS=$([p,v]),typeof t!==s?(e.exports&&(t=e.exports=Z),t.UAParser=Z):n.amdO?(r=function(){return Z}.call(t,n,t,e))===a||(e.exports=r):typeof i!==s&&(i.UAParser=Z);var Y=typeof i!==s&&(i.jQuery||i.Zepto);if(Y&&!Y.ua){var ee=new Z;Y.ua=ee.getResult(),Y.ua.get=function(){return ee.getUA()},Y.ua.set=function(e){ee.setUA(e);var t=ee.getResult();for(var n in t)Y.ua[n]=t[n]}}}("object"==typeof window?window:this)}},t={};function n(r){var i=t[r];if(void 0!==i)return i.exports;var a=t[r]={exports:{}};return e[r].call(a.exports,a,a.exports,n),a.exports}n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r={};return(()=>{"use strict";n.r(r),n.d(r,{ActionType:()=>f,AmplitudePlatformName:()=>g,AnalyticsEventImportance:()=>l,AnalyticsQueries:()=>e,AuthStatus:()=>b,ComponentType:()=>m,IThresholdTier:()=>Jt,MetricType:()=>d,PlatformName:()=>v,SessionActions:()=>h,SessionAutomatedEvents:()=>w,SessionRank:()=>y,SubjectType:()=>p,UserTypeCommerce:()=>c,UserTypeInsto:()=>i,UserTypeRetail:()=>t,UserTypeRetailBusinessBanking:()=>s,UserTypeRetailEmployeeInternal:()=>a,UserTypeRetailEmployeePersonal:()=>o,UserTypeWallet:()=>u,automatedEvents:()=>xn,automatedMappingConfig:()=>In,clearMarkEntry:()=>Vn,clearPerformanceMarkEntries:()=>Xn,config:()=>A,createEventConfig:()=>On,createNewSpan:()=>Ln,createNewTrace:()=>Un,device:()=>W,endPerfMark:()=>Jn,exposeExperiment:()=>wn,flushQueue:()=>or,generateUUID:()=>V,getAnalyticsHeaders:()=>sr,getReferrerData:()=>le,getTracingHeaders:()=>An,getTracingId:()=>Dn,getUrlHostname:()=>pe,getUrlParams:()=>me,getUrlPathname:()=>fe,getUserContext:()=>ar,identify:()=>Tn,identifyFlow:()=>xe,identity:()=>H,identityFlow:()=>Se,incrementUjNavigation:()=>an,init:()=>yn,initNextJsTrackPageview:()=>_n,initTrackPageview:()=>kn,isEventKeyFormatValid:()=>we,isSessionEnded:()=>pt,location:()=>re,logEvent:()=>$t,logMetric:()=>Ht,logPageView:()=>on,logTrace:()=>Rn,markNTBT:()=>tn,markStep:()=>nn,markStepOnce:()=>rn,onVisibilityChange:()=>ln,optIn:()=>En,optOut:()=>Sn,perfMark:()=>Wn,persistentData:()=>oe,postMessage:()=>K,recordSessionDuration:()=>pn,removeFromIdentifyFlow:()=>Ee,savePersistentData:()=>st,sendScheduledEvents:()=>Bt,setBreadcrumbs:()=>ie,setConfig:()=>U,setLocation:()=>ae,setPagePath:()=>ve,setPageview:()=>Kt,setPersistentData:()=>se,setSessionStart:()=>dt,setTime:()=>Ue,startPerfMark:()=>Hn,timeStone:()=>Le,useEventLogger:()=>Yn,useLogEventOnMount:()=>tr,usePerformanceMarks:()=>rr});let e=function(e){return e.fbclid="fbclid",e.gclid="gclid",e.msclkid="msclkid",e.ptclid="ptclid",e.ttclid="ttclid",e.utm_source="utm_source",e.utm_medium="utm_medium",e.utm_campaign="utm_campaign",e.utm_term="utm_term",e.utm_content="utm_content",e}({});const t=0,i=1,a=2,o=3,s=4,c=5,u=6;let l=function(e){return e.low="low",e.high="high",e}({}),d=function(e){return e.count="count",e.rate="rate",e.gauge="gauge",e.distribution="distribution",e.histogram="histogram",e}({}),p=function(e){return e.commerce_merchant="commerce_merchant",e.device="device",e.edp_fingerprint_id="edp_fingerprint_id",e.nft_user="nft_user",e.user="user",e.wallet_user="wallet_user",e.uuid="user_uuid",e}({}),m=function(e){return e.unknown="unknown",e.banner="banner",e.button="button",e.card="card",e.chart="chart",e.content_script="content_script",e.dropdown="dropdown",e.link="link",e.page="page",e.modal="modal",e.table="table",e.search_bar="search_bar",e.service_worker="service_worker",e.text="text",e.text_input="text_input",e.tray="tray",e.checkbox="checkbox",e.icon="icon",e}({}),f=function(e){return e.unknown="unknown",e.blur="blur",e.click="click",e.change="change",e.dismiss="dismiss",e.focus="focus",e.hover="hover",e.select="select",e.measurement="measurement",e.move="move",e.process="process",e.render="render",e.scroll="scroll",e.view="view",e.search="search",e.keyPress="keyPress",e}({}),v=function(e){return e.unknown="unknown",e.web="web",e.android="android",e.ios="ios",e.mobile_web="mobile_web",e.tablet_web="tablet_web",e.server="server",e.windows="windows",e.macos="macos",e.extension="extension",e}({}),g=function(e){return e.web="Web",e.ios="iOS",e.android="Android",e}({}),b=function(e){return e[e.notLoggedIn=0]="notLoggedIn",e[e.loggedIn=1]="loggedIn",e}({}),h=function(e){return e.ac="ac",e.af="af",e.ah="ah",e.al="al",e.am="am",e.ar="ar",e.as="as",e}({}),w=function(e){return e.pv="pv",e}({}),y=function(e){return e.xs="xs",e.s="s",e.m="m",e.l="l",e.xl="xl",e.xxl="xxl",e}({});const T="https://analytics-service-dev.cbhq.net",k=3e5,_=5e3,S="analytics-db",E="experiment-exposure-db",x="Analytics SDK:",O=Object.values(e),j="pageview",N="session_duration",I={navigationTiming:{eventName:"perf_navigation_timing"},redirectTime:{eventName:"perf_redirect_time"},RT:{eventName:"perf_redirect_time"},TTFB:{eventName:"perf_time_to_first_byte"},networkInformation:{eventName:"perf_network_information"},storageEstimate:{eventName:"perf_storage_estimate"},FCP:{eventName:"perf_first_contentful_paint"},FID:{eventName:"perf_first_input_delay"},LCP:{eventName:"perf_largest_contentful_paint"},CLS:{eventName:"perf_cumulative_layout_shift"},TBT:{eventName:"perf_total_blocking_time"},NTBT:{eventName:"perf_navigation_total_blocking_time"},INP:{eventName:"perf_interact_to_next_paint"},ET:{eventName:"perf_element_timing"},userJourneyStep:{eventName:"perf_user_journey_step"}},P="1",M="web";function B(){return B=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},B.apply(this,arguments)}const C=/^(https?:\\/\\/)/;function D(e){return{eventsEndpoint:e+"/amp",metricsEndPoint:e+"/metrics",exposureEndpoint:e+"/track-exposures",tracesEndpoint:e+"/traces"}}const A=B({authCookie:"logged_in",amplitudeApiKey:"",batchEventsPeriod:_,batchEventsThreshold:30,batchMetricsPeriod:_,batchMetricsThreshold:30,batchTracesPeriod:_,batchTracesThreshold:30,headers:{},interactionManager:null,isAlwaysAuthed:!1,isProd:!1,isInternalApplication:!1,onError:(e,t)=>{console.error(x,e,t)},platform:v.unknown,projectName:"",ricTimeoutScheduleEvent:1e3,ricTimeoutSetDevice:500,showDebugLogging:!1,trackUserId:!1,version:null,apiEndpoint:T},D(T),{steps:{}}),L=[].reduce(((e,t)=>n=>e(t(n))),(e=>{if(!e.isProd)return e.isInternalApplication?(e.apiEndpoint="https://analytics-service-internal-dev.cbhq.net",B({},e,D(e.apiEndpoint))):e;const t=(e=>e.apiEndpoint?C.test(e.apiEndpoint)?e.apiEndpoint:\`https://\${e.apiEndpoint}\`:e.isInternalApplication?"https://analytics-service-internal.cbhq.net":"https://as.coinbase.com")(e);return B({},e,{apiEndpoint:t},D(t))})),U=e=>{const{batchEventsThreshold:t,batchMetricsThreshold:n,batchTracesThreshold:r}=e,i=[t,n,r];for(const e of i)if((e||0)>30){console.warn("You are setting the threshhold for the batch limit to be greater than 30. This may cause request overload.");break}Object.assign(A,L(e))},R=[v.web,v.mobile_web,v.tablet_web];function q(){return"android"===A.platform}function F(){return"ios"===A.platform}function z(){return R.includes(A.platform)}function K(e){if(z()&&navigator&&"serviceWorker"in navigator&&navigator.serviceWorker.controller)try{navigator.serviceWorker.controller.postMessage(e)}catch(e){e instanceof Error&&A.onError(e)}}var $=n(353),Q=n.n($);const W={amplitudeOSName:null,amplitudeOSVersion:null,amplitudeDeviceModel:null,amplitudePlatform:null,browserName:null,browserMajor:null,osName:null,userAgent:null,width:null,height:null},H={countryCode:null,deviceId:null,device_os:null,isOptOut:!1,languageCode:null,locale:null,jwt:null,session_lcc_id:null,userAgent:null,userId:null},V=e=>e?(e^16*Math.random()>>e/4).toString(16):"10000000-1000-4000-8000-100000000000".replace(/[018]/g,V),J=()=>A.isAlwaysAuthed||!!H.userId,X=()=>{const e={};return H.countryCode&&(e.country_code=H.countryCode),e},G=()=>{const{platform:e}=A;if(e===v.web)switch(!0){case window.matchMedia("(max-width: 560px)").matches:return v.mobile_web;case window.matchMedia("(max-width: 1024px, min-width: 561px)").matches:return v.tablet_web}return e},Z=()=>{var e,t,n,r,i;z()?("requestIdleCallback"in window?window.requestIdleCallback(ne,{timeout:A.ricTimeoutSetDevice}):ne(),W.amplitudePlatform=g.web,W.userAgent=(null==(e=window)||null==(e=e.navigator)?void 0:e.userAgent)||null,ee({height:null!=(t=null==(n=window)?void 0:n.innerHeight)?t:null,width:null!=(r=null==(i=window)?void 0:i.innerWidth)?r:null})):F()?(W.amplitudePlatform=g.ios,W.userAgent=H.userAgent,W.userAgent&&ne()):q()&&(W.userAgent=H.userAgent,W.amplitudePlatform=g.android,W.userAgent&&ne())},Y=e=>{Object.assign(H,e),z()&&K({identity:{isAuthed:!!H.userId,locale:H.locale||null}})},ee=e=>{W.height=e.height,W.width=e.width},te=()=>{U({platform:G()}),z()&&K({config:{platform:A.platform}})},ne=()=>{var e;performance.mark&&performance.mark("ua_parser_start");const t=new(Q())(null!=(e=W.userAgent)?e:"").getResult();W.browserName=t.browser.name||null,W.browserMajor=t.browser.major||null,W.osName=t.os.name||null,W.amplitudeOSName=W.browserName,W.amplitudeOSVersion=W.browserMajor,W.amplitudeDeviceModel=W.osName,K({device:{browserName:W.browserName,osName:W.osName}}),performance.mark&&(performance.mark("ua_parser_end"),performance.measure("ua_parser","ua_parser_start","ua_parser_end"))},re={breadcrumbs:[],initialUAAData:{},pageKey:"",pageKeyRegex:{},pagePath:"",prevPageKey:"",prevPagePath:""};function ie(e){Object.assign(re,{breadcrumbs:e})}function ae(e){Object.assign(re,e)}const oe={eventId:0,sequenceNumber:0,sessionId:0,lastEventTime:0,sessionStart:0,sessionUUID:null,userId:null,ac:0,af:0,ah:0,al:0,am:0,ar:0,as:0,pv:0};function se(e){Object.assign(oe,e)}function ce(){var e,t;return null!=(e=null==(t=document)?void 0:t.referrer)?e:""}function ue(){return ue=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ue.apply(this,arguments)}const le=()=>{const e=ce();if(!e)return{};const t=new URL(e);return t.hostname===pe()?{}:{referrer:e,referring_domain:t.hostname}},de=()=>{const e=new URLSearchParams(me()),t={};return O.forEach((n=>{e.has(n)&&(t[n]=(e.get(n)||"").toLowerCase())})),t},pe=()=>{var e;return(null==(e=window)||null==(e=e.location)?void 0:e.hostname)||""},me=()=>{var e;return(null==(e=window)||null==(e=e.location)?void 0:e.search)||""},fe=()=>{var e;return(null==(e=window)||null==(e=e.location)?void 0:e.pathname)||""},ve=()=>{const e=A.overrideWindowLocation?re.pagePath:fe()+me();e&&e!==re.pagePath&&(e!==re.pagePath&&ge(),re.pagePath=e,re.pageKeyRegex&&Object.keys(re.pageKeyRegex).some((e=>{if(re.pageKeyRegex[e].test(re.pagePath))return re.pageKey=e,!0})))},ge=()=>{if(z()){const e=ce();if(!re.prevPagePath&&e){const t=new URL(e);if(t.hostname===pe())return void(re.prevPagePath=t.pathname)}}re.prevPagePath=re.pagePath,re.prevPageKey=re.pageKey},be=e=>{z()&&Object.assign(e,z()?(Object.keys(re.initialUAAData).length>0||(new URLSearchParams(me()),re.initialUAAData=ue({},(()=>{const e={};return O.forEach((t=>{oe[t]&&(e[t]=oe[t])})),e})(),de(),le())),re.initialUAAData):re.initialUAAData)},he=/^[a-zd]+(_[a-zd]+)*$/;function we(e){return he.test(e)}function ye(){return ye=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ye.apply(this,arguments)}const Te=["action","component_type","component_name","context","logging_id"],ke=["num_non_hardware_accounts","ujs"],_e="ujs_",Se={};function Ee(e){e.forEach((e=>{ke.includes(e)&&delete Se[e]}))}function xe(e){var t;const n=Object.entries(e).reduce(((e,t)=>{const[n,r]=t;return!Te.includes(n)&&ke.includes(n)?we(n)?ye({},e,{[n]:r}):(A.onError(new Error("IdentityFlow property names must have snake case format"),{[n]:r}),e):e}),{});null!=(t=n.ujs)&&t.length&&(n.ujs=n.ujs.map((e=>\`\${_e}\${e}\`))),Object.assign(Se,n)}function Oe(){return A.platform!==v.unknown||(A.onError(new Error("SDK platform not initialized")),!1)}const je={eventsQueue:[],eventsScheduled:!1,metricsQueue:[],metricsScheduled:!1,tracesQueue:[],tracesScheduled:!1};function Ne(e){Object.assign(je,e)}const Ie={ac:0,af:0,ah:0,al:0,am:0,ar:0,as:0,pv:0,sqs:0},Pe={ac:20,af:5,ah:1,al:1,am:0,ar:10,as:20},Me={pv:25},Be={xs:0,s:1,m:1,l:2,xl:2,xxl:2},Ce=e=>e<15?y.xs:e<60?y.s:e<240?y.m:e<960?y.l:e<3840?y.xl:y.xxl,De=e=>{Object.assign(Ie,e)};function Ae(){return(new Date).getTime()}const Le={timeStart:Ae(),timeOnPagePath:0,timeOnPageKey:0,prevTimeOnPagePath:0,prevTimeOnPageKey:0,sessionDuration:0,sessionEnd:0,sessionStart:0,prevSessionDuration:0};function Ue(e){Object.assign(Le,e)}const Re=(e,t)=>t.some((t=>e instanceof t));let qe,Fe;const ze=new WeakMap,Ke=new WeakMap,$e=new WeakMap,Qe=new WeakMap,We=new WeakMap;let He={get(e,t,n){if(e instanceof IDBTransaction){if("done"===t)return Ke.get(e);if("objectStoreNames"===t)return e.objectStoreNames||$e.get(e);if("store"===t)return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return Je(e[t])},set:(e,t,n)=>(e[t]=n,!0),has:(e,t)=>e instanceof IDBTransaction&&("done"===t||"store"===t)||t in e};function Ve(e){return"function"==typeof e?(t=e)!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(Fe||(Fe=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(t)?function(...e){return t.apply(Xe(this),e),Je(ze.get(this))}:function(...e){return Je(t.apply(Xe(this),e))}:function(e,...n){const r=t.call(Xe(this),e,...n);return $e.set(r,e.sort?e.sort():[e]),Je(r)}:(e instanceof IDBTransaction&&function(e){if(Ke.has(e))return;const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("complete",i),e.removeEventListener("error",a),e.removeEventListener("abort",a)},i=()=>{t(),r()},a=()=>{n(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",i),e.addEventListener("error",a),e.addEventListener("abort",a)}));Ke.set(e,t)}(e),Re(e,qe||(qe=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(e,He):e);var t}function Je(e){if(e instanceof IDBRequest)return function(e){const t=new Promise(((t,n)=>{const r=()=>{e.removeEventListener("success",i),e.removeEventListener("error",a)},i=()=>{t(Je(e.result)),r()},a=()=>{n(e.error),r()};e.addEventListener("success",i),e.addEventListener("error",a)}));return t.then((t=>{t instanceof IDBCursor&&ze.set(t,e)})).catch((()=>{})),We.set(t,e),t}(e);if(Qe.has(e))return Qe.get(e);const t=Ve(e);return t!==e&&(Qe.set(e,t),We.set(t,e)),t}const Xe=e=>We.get(e),Ge=["get","getKey","getAll","getAllKeys","count"],Ze=["put","add","delete","clear"],Ye=new Map;function et(e,t){if(!(e instanceof IDBDatabase)||t in e||"string"!=typeof t)return;if(Ye.get(t))return Ye.get(t);const n=t.replace(/FromIndex$/,""),r=t!==n,i=Ze.includes(n);if(!(n in(r?IDBIndex:IDBObjectStore).prototype)||!i&&!Ge.includes(n))return;const a=async function(e,...t){const a=this.transaction(e,i?"readwrite":"readonly");let o=a.store;return r&&(o=o.index(t.shift())),(await Promise.all([o[n](...t),i&&a.done]))[0]};return Ye.set(t,a),a}var tt;tt=He,He={...tt,get:(e,t,n)=>et(e,t)||tt.get(e,t,n),has:(e,t)=>!!et(e,t)||tt.has(e,t)};const nt={isReady:!1,idbKeyval:null};function rt(e){Object.assign(nt,e)}const it={},at=async e=>{if(!nt.idbKeyval)return Promise.resolve(null);try{return await nt.idbKeyval.get(e)}catch(e){return A.onError(new Error("IndexedDB:Get:InternalError")),Promise.resolve(null)}},ot=async(e,t)=>{if(nt.idbKeyval)try{await nt.idbKeyval.set(e,t)}catch(e){A.onError(new Error("IndexedDB:Set:InternalError"))}},st=()=>{"server"!==A.platform&&(se({sessionStart:Le.sessionStart,ac:Ie.ac,af:Ie.af,ah:Ie.ah,al:Ie.al,am:Ie.am,ar:Ie.ar,as:Ie.as,pv:Ie.pv}),H.userId&&se({userId:H.userId}),ot(S,oe))},ct="rgb(5,177,105)",ut=e=>{const{metricName:t,data:n}=e,r=e.importance||l.low;if(!A.showDebugLogging||!console)return;const i=\`%c \${x}\`,a=\`color:\${ct};font-size:11px;\`,o=\`Importance: \${r}\`;console.group(i,a,t,o),n.forEach((e=>{e.event_type?console.log(e.event_type,e):console.log(e)})),console.groupEnd()},lt=e=>{const{metricName:t,data:n}=e,r=e.importance||l.low;if(!A.showDebugLogging||!console)return;const i=\`color:\${ct};font-size:11px;\`,a=\`%c \${x}\`,o=\`Importance: \${r}\`;console.log(a,i,t,n,o)},dt=()=>{const e=Ae();oe.sessionId&&oe.lastEventTime&&oe.sessionUUID&&!pt(e)||(oe.sessionId=e,oe.sessionUUID=V(),Ue({sessionStart:e}),lt({metricName:"Started new session:",data:{persistentData:oe,timeStone:Le}})),oe.lastEventTime=e},pt=e=>e-oe.lastEventTime>18e5;function mt(){return mt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},mt.apply(this,arguments)}const ft=e=>{var t;(e=>{switch(e.action){case f.click:Ie.ac+=1;break;case f.focus:Ie.af+=1;break;case f.hover:Ie.ah+=1;break;case f.move:Ie.am+=1;break;case f.scroll:Ie.al+=1;break;case f.search:Ie.ar+=1;break;case f.select:Ie.as+=1}})(t=e),t.event_type!==j?t.event_type===N&&((e=>{if(!e.session_rank)return;const t=e.session_rank;Object.values(h).forEach((e=>{Ie.sqs+=Ie[e]*Pe[e]})),Object.values(w).forEach((e=>{Ie.sqs+=Ie[e]*Me[e]})),Ie.sqs*=Be[t]})(t),Object.assign(t,Ie),De({ac:0,af:0,ah:0,al:0,am:0,ar:0,as:0,pv:0,sqs:0})):Ie.pv+=1;const n=e.event_type;delete e.event_type;const r=e.deviceId?e.deviceId:null,i=e.timestamp;return delete e.timestamp,se({eventId:oe.eventId+1}),se({sequenceNumber:oe.sequenceNumber+1}),dt(),st(),{device_id:H.deviceId||r||null,user_id:H.userId,timestamp:i,event_id:oe.eventId,session_id:oe.sessionId||-1,event_type:n,version_name:A.version||null,platform:W.amplitudePlatform,os_name:W.amplitudeOSName,os_version:W.amplitudeOSVersion,device_model:W.amplitudeDeviceModel,language:H.languageCode,event_properties:mt({},e,{session_uuid:oe.sessionUUID,height:W.height,width:W.width}),user_properties:X(),uuid:V(),library:{name:"@cbhq/client-analytics",version:"10.6.0"},sequence_number:oe.sequenceNumber,user_agent:W.userAgent||H.userAgent}},vt=e=>e.map((e=>ft(e)));function gt(){return gt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},gt.apply(this,arguments)}const bt=e=>e.map((e=>(e=>{const t=e.tags||{},n=gt({authed:J()?"true":"false",platform:A.platform},t,{project_name:A.projectName,version_name:A.version||null});return{metric_name:e.metricName,page_path:e.pagePath||null,value:e.value,tags:n,type:e.metricType}})(e))),ht=e=>0!==je.metricsQueue.length&&(je.metricsQueue.length>=A.batchMetricsThreshold||(je.metricsScheduled||(je.metricsScheduled=!0,setTimeout((()=>{je.metricsScheduled=!1,e(bt(je.metricsQueue)),je.metricsQueue=[]}),A.batchMetricsPeriod)),!1)),wt=e=>0!==je.tracesQueue.length&&(je.tracesQueue.length>=A.batchTracesThreshold||(je.tracesScheduled||(je.tracesScheduled=!0,setTimeout((()=>{je.tracesScheduled=!1,e(je.tracesQueue),je.tracesQueue=[]}),A.batchTracesPeriod)),!1)),yt=e=>{var t;z()&&null!=(t=window)&&t.requestIdleCallback?window.requestIdleCallback(e,{timeout:A.ricTimeoutScheduleEvent}):(q()||F())&&A.interactionManager?A.interactionManager.runAfterInteractions(e):e()};function Tt(){return Tt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Tt.apply(this,arguments)}const kt="application/x-www-form-urlencoded; charset=UTF-8",_t=e=>{const{data:t,importance:n,isJSON:r,onError:i,url:a}=e,o=r?"application/json":kt,s=n||l.low,c=r?JSON.stringify(t):new URLSearchParams(t).toString();function u(){const e=new XMLHttpRequest;e.open("POST",a,!0),Object.keys(A.headers||{}).forEach((t=>{e.setRequestHeader(t,A.headers[t])})),e.setRequestHeader("Content-Type",kt),H.jwt&&e.setRequestHeader("authorization",\`Bearer \${H.jwt}\`),e.send(c)}if(!z()||r||!("sendBeacon"in navigator)||s!==l.low||A.headers&&0!==Object.keys(A.headers).length)if(z()&&!r)u();else{const e=Tt({},A.headers,{"Content-Type":o});H.jwt&&(e.Authorization=\`Bearer \${H.jwt}\`),fetch(a,{method:"POST",mode:"no-cors",headers:e,body:c}).catch((e=>{i(e,{context:"AnalyticsSDKApiError"})}))}else{const e=new Blob([c],{type:kt});try{navigator.sendBeacon.bind(navigator)(a,e)||u()}catch(e){console.error(e),u()}}};var St=n(762),Et=n.n(St);const xt=(e,t,n)=>{const r=e||"";return Et()("2"+r+t+n)};function Ot(){return Ot=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Ot.apply(this,arguments)}class jt extends Error{constructor(e){super(e),this.name="CircularJsonReference",this.message=e,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(e).stack}}class Nt extends jt{constructor(...e){super(...e),this.name="DomReferenceInAnalyticsEvent"}}function It(){return It=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},It.apply(this,arguments)}const Pt=(e,t=l.low)=>{var n;e&&je.eventsQueue.push(e),nt.isReady&&(!A.trackUserId||H.userId?(t===l.high||(n=Mt,0!==je.eventsQueue.length&&(je.eventsQueue.length>=A.batchEventsThreshold||(je.eventsScheduled||(je.eventsScheduled=!0,setTimeout((()=>{je.eventsScheduled=!1,n(vt(je.eventsQueue)),je.eventsQueue=[]}),A.batchEventsPeriod)),0))))&&Bt():je.eventsQueue.length>10&&(A.trackUserId=!1,A.onError(new Error("userId not set in Logged-in"))))},Mt=(e,t=l.low)=>{if(H.isOptOut||0===e.length)return;let n;try{n=JSON.stringify(e)}catch(t){const r=e.map((e=>e.event_type)).join(", "),[i,a]=(e=>{try{const n=[];for(const r of e){const e=Ot({},r);r.event_properties&&(e.event_properties=Ot({},e.event_properties,{currentTarget:null,target:null,relatedTarget:null,_dispatchInstances:null,_targetInst:null,view:(t=r.event_properties.view,["string","number","boolean"].includes(typeof t)?r.event_properties.view:null)})),n.push(e)}return[!0,JSON.stringify(n)]}catch(e){return[!1,""]}var t})(e);if(!i)return void A.onError(new jt(t instanceof Error?t.message:"unknown"),{listEventType:r});n=a,A.onError(new Nt("Found DOM element reference"),{listEventType:r,stringifiedEventData:n})}const r=Ae().toString(),i=It({},{e:n,v:"2",upload_time:r},{client:A.amplitudeApiKey,checksum:xt(A.amplitudeApiKey,n,r)});_t({url:A.eventsEndpoint,data:i,importance:t,onError:A.onError}),ut({metricName:"Batch Events",data:e,importance:t})},Bt=()=>{Mt(vt(je.eventsQueue)),Ne({eventsQueue:[]})};function Ct(){return Ct=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Ct.apply(this,arguments)}const Dt=Object.values(f),At=Object.values(m),Lt=e=>Dt.includes(e)?e:f.unknown,Ut=e=>At.includes(e)?e:m.unknown,Rt=(e,t,n)=>{const r={auth:J()?b.loggedIn:b.notLoggedIn,action:Lt(e),component_type:Ut(t),logging_id:n,platform:A.platform,project_name:A.projectName};return"number"==typeof H.userTypeEnum&&(r.user_type_enum=H.userTypeEnum),r},qt=e=>{const t=Ae();if(!e)return A.onError(new Error("missing logData")),Ct({},Rt(f.unknown,m.unknown),{locale:H.locale,session_lcc_id:H.session_lcc_id,timestamp:t,time_start:Le.timeStart});const n=Ct({},e,Rt(e.action,e.componentType,e.loggingId),{locale:H.locale,session_lcc_id:H.session_lcc_id,timestamp:t,time_start:Le.timeStart});return delete n.componentType,delete n.loggingId,n},Ft={blacklistRegex:[],isEnabled:!1};function zt(){return{page_key:re.pageKey,page_path:re.pagePath,prev_page_key:re.prevPageKey,prev_page_path:re.prevPagePath}}function Kt(e){Object.assign(Ft,e)}function $t(e,t,n=l.low){if(H.isOptOut)return;if(!Oe())return;const r=qt(t);!function(e){Ft.isEnabled&&(ve(),Object.assign(e,zt()))}(r),be(r),function(e){Object.keys(Se).length>0&&Object.assign(e,Se)}(r),r.has_double_fired=!1,r.event_type=e,n===l.high?Pt(r,n):yt((()=>{Pt(r)}))}function Qt(e,t=!1){t?_t({url:A.metricsEndPoint,data:{metrics:e},isJSON:!0,onError:A.onError}):yt((()=>{_t({url:A.metricsEndPoint,data:{metrics:e},isJSON:!0,onError:A.onError})})),ut({metricName:"Batch Metrics",data:e})}function Wt(){return Wt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Wt.apply(this,arguments)}function Ht(e){if(!Oe())return;v.server!==A.platform&&!e.pagePath&&re.pagePath&&(e.pagePath=re.pagePath);const t=Object.keys(Se).length?Wt({},e.tags,Se):e.tags;t&&Object.assign(e,{tags:t}),je.metricsQueue.push(e),ht(Qt)&&(Qt(bt(je.metricsQueue)),je.metricsQueue=[])}function Vt(){return Vt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Vt.apply(this,arguments)}let Jt=function(e){return e.instant="instant",e.quick="quick",e.moderate="moderate",e.slow="slow",e.unavoidable="unavoidable",e}({});function Xt(e){return e.toLowerCase()}let Gt={};const Zt=(e,t)=>{null!=A&&A.onMarkStep&&A.onMarkStep(e,t),xe({ujs:t})};let Yt;const en={Perfume:()=>{},markStep:e=>{},markStepOnce:e=>{},incrementUjNavigation:()=>{}},tn=()=>{z()&&Yt&&Yt.markNTBT&&Yt.markNTBT()},nn=e=>{z()&&Yt&&en.markStep&&en.markStep(e)},rn=e=>{z()&&Yt&&en.markStepOnce&&en.markStepOnce(e)},an=()=>{z()&&Yt&&en.incrementUjNavigation&&en.incrementUjNavigation()};function on(e={callMarkNTBT:!0}){"unknown"!==A.platform&&(Ft.blacklistRegex.some((e=>e.test(fe())))||($t(j,{action:f.render,componentType:m.page}),e.callMarkNTBT&&tn()))}let sn=!1,cn=!1;const un=e=>{sn=!e.persisted},ln=(e,t="hidden",n=!1)=>{cn||(addEventListener("pagehide",un),addEventListener("beforeunload",(()=>{})),cn=!0),addEventListener("visibilitychange",(({timeStamp:n})=>{document.visibilityState===t&&e({timeStamp:n,isUnloading:sn})}),{capture:!0,once:n})},dn=36e3;function pn(){const e=pt(Ae());if(e&&(O.forEach((e=>{oe[e]&&delete oe[e]})),st()),!oe.lastEventTime||!Le.sessionStart||!e)return;const t=Math.round((oe.lastEventTime-Le.sessionStart)/1e3);if(t<1||t>dn)return;const n=Ce(t);$t(N,{action:f.measurement,componentType:m.page,session_duration:t,session_end:oe.lastEventTime,session_start:Le.sessionStart,session_rank:n})}function mn(){return mn=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},mn.apply(this,arguments)}const fn=[],vn=[],gn=()=>{const e=fn.shift();e&&e()},bn=()=>{const e=vn.shift();e&&e()};let hn={};function wn(e){const t=function(e){return{test_name:e.testName,group_name:e.group,subject_id:e.subjectId,exposed_at:Ae(),subject_type:e.subjectType,platform:A.platform}}(e);hn[e.testName]=hn[e.testName]||0,hn[e.testName]+k>Ae()?lt({metricName:\`Event: exposeExperiment \${e.testName} not sent\`,data:t}):(hn[e.testName]=Ae(),ot(E,hn),lt({metricName:\`Event: exposeExperiment \${e.testName} sent\`,data:t}),_t({url:A.exposureEndpoint,data:[t],onError:(t,n)=>{hn[e.testName]=0,ot(E,hn),A.onError(t,n)},isJSON:!0,importance:l.high}))}const yn=e=>{var t,r,i;U(e),z()&&(H.languageCode=(null==(t=navigator)?void 0:t.languages[0])||(null==(r=navigator)?void 0:r.language)||""),te(),(()=>{var e;if(z()&&null!=(e=window)&&e.indexedDB){const e=function(e,t,{blocked:n,upgrade:r,blocking:i,terminated:a}={}){const o=indexedDB.open(e,t),s=Je(o);return r&&o.addEventListener("upgradeneeded",(e=>{r(Je(o.result),e.oldVersion,e.newVersion,Je(o.transaction),e)})),n&&o.addEventListener("blocked",(e=>n(e.oldVersion,e.newVersion,e))),s.then((e=>{a&&e.addEventListener("close",(()=>a())),i&&e.addEventListener("versionchange",(e=>i(e.oldVersion,e.newVersion,e)))})).catch((()=>{})),s}("keyval-store",1,{upgrade(e){e.createObjectStore("keyval")}});rt({idbKeyval:{get:async t=>(await e).get("keyval",t),set:async(t,n)=>(await e).put("keyval",n,t),delete:async t=>(await e).delete("keyval",t),keys:async()=>(await e).getAllKeys("keyval")}})}else rt({idbKeyval:{get:async e=>new Promise((t=>{t(it[e])})),set:async(e,t)=>new Promise((n=>{it[e]=t,n(e)})),delete:async e=>new Promise((()=>{delete it[e]})),keys:async()=>new Promise((e=>{e(Object.keys(it))}))}})})(),lt({metricName:"Initialized Analytics:",data:{deviceId:H.deviceId}}),fn.push((()=>{Pt()})),(async()=>{const e=await at(S);rt({isReady:!0}),gn(),e&&(bn(),se({eventId:e.eventId||oe.eventId,sequenceNumber:e.sequenceNumber||oe.sequenceNumber,sessionId:e.sessionId||oe.sessionId,lastEventTime:e.lastEventTime||oe.lastEventTime,sessionUUID:e.sessionUUID||oe.sessionUUID}),function(e){se(mn({},function(e){const t={};return O.forEach((n=>{e[n]&&(t[n]=e[n])})),t}(e),de()))}(e),Ue({sessionStart:e.sessionStart||oe.sessionStart}),De({ac:e.ac||Ie.ac,af:e.af||Ie.af,ah:e.ah||Ie.ah,al:e.al||Ie.al,am:e.am||Ie.am,ar:e.ar||Ie.ar,as:e.as||Ie.as,pv:e.pv||Ie.pv}),A.trackUserId&&Y({userId:e.userId||H.userId}),pn(),lt({metricName:"Initialized Analytics IndexedDB:",data:e}))})(),async function(){at(E).then((e=>{hn=null!=e?e:{}})).catch((e=>{e instanceof Error&&A.onError(e)}))}(),Z(),z()&&(ln((()=>{se({lastEventTime:Ae()}),st(),Bt()}),"hidden"),ln((()=>{pn()}),"visible")),z()&&(i=()=>{var e,t,n,r;te(),ee({width:null!=(e=null==(t=window)?void 0:t.innerWidth)?e:null,height:null!=(n=null==(r=window)?void 0:r.innerHeight)?n:null})},addEventListener("resize",(()=>{requestAnimationFrame((()=>{i()}))}))),(()=>{if(z())try{const e=n(2);en.markStep=e.markStep,en.markStepOnce=e.markStepOnce,en.incrementUjNavigation=e.incrementUjNavigation,Yt=new e.Perfume({analyticsTracker:e=>{const{data:t,attribution:n,metricName:r,navigatorInformation:i,rating:a}=e,o=I[r],s=(null==n?void 0:n.category)||null;if(!o&&!s)return;const c=(null==i?void 0:i.deviceMemory)||0,u=(null==i?void 0:i.hardwareConcurrency)||0,l=(null==i?void 0:i.isLowEndDevice)||!1,p=(null==i?void 0:i.isLowEndExperience)||!1,v=(null==i?void 0:i.serviceWorkerStatus)||"unsupported",g=Vt({deviceMemory:c,hardwareConcurrency:u,isLowEndDevice:l,isLowEndExperience:p,serviceWorkerStatus:v},Gt),b={is_low_end_device:l,is_low_end_experience:p,page_key:re.pageKey||"",save_data:t.saveData||!1,service_worker:v,is_perf_metric:!0};if("navigationTiming"===r)t&&"number"==typeof t.redirectTime&&Ht({metricName:I.redirectTime.eventName,metricType:d.histogram,tags:b,value:t.redirectTime||0});else if("TTFB"===r)$t(o.eventName,Vt({action:f.measurement,componentType:m.page,duration:t||null,vitalsScore:a||null},g)),Ht({metricName:I.TTFB.eventName,metricType:d.histogram,tags:Vt({},b),value:t}),a&&Ht({metricName:\`perf_web_vitals_ttfb_\${a}\`,metricType:d.count,tags:b,value:1});else if("networkInformation"===r)null!=t&&t.effectiveType&&(Gt=t,$t(o.eventName,{action:f.measurement,componentType:m.page,networkInformationDownlink:t.downlink,networkInformationEffectiveType:t.effectiveType,networkInformationRtt:t.rtt,networkInformationSaveData:t.saveData,navigatorDeviceMemory:c,navigatorHardwareConcurrency:u}));else if("storageEstimate"===r)$t(o.eventName,Vt({action:f.measurement,componentType:m.page},t,g)),Ht({metricName:"perf_storage_estimate_caches",metricType:d.histogram,tags:b,value:t.caches}),Ht({metricName:"perf_storage_estimate_indexed_db",metricType:d.histogram,tags:b,value:t.indexedDB});else if("CLS"===r)$t(o.eventName,Vt({action:f.measurement,componentType:m.page,score:100*t||null,vitalsScore:a||null},g)),a&&Ht({metricName:\`perf_web_vitals_cls_\${a}\`,metricType:d.count,tags:b,value:1});else if("FID"===r){const e=(null==n?void 0:n.performanceEntry)||null,r=parseInt((null==e?void 0:e.processingStart)||"");$t(o.eventName,Vt({action:f.measurement,componentType:m.page,duration:t||null,processingStart:null!=e&&e.processingStart?r:null,startTime:null!=e&&e.startTime?parseInt(e.startTime):null,vitalsScore:a||null},g)),a&&Ht({metricName:\`perf_web_vitals_fidVitals_\${a}\`,metricType:d.count,tags:b,value:1})}else"userJourneyStep"===r?($t("perf_user_journey_step",Vt({action:f.measurement,componentType:m.page,duration:t||null,rating:null!=a?a:null,step_name:(null==n?void 0:n.stepName)||""},g)),Ht({metricName:\`user_journey_step.\${A.projectName}.\${A.platform}.\${(null==n?void 0:n.stepName)||""}_vitals_\${a}\`,metricType:d.count,tags:b,value:1}),Ht({metricName:\`user_journey_step.\${A.projectName}.\${A.platform}.\${(null==n?void 0:n.stepName)||""}\`,metricType:d.distribution,tags:b,value:t||null})):I[r]&&t&&($t(o.eventName,Vt({action:f.measurement,componentType:m.page,duration:t||null,vitalsScore:a||null},g)),a&&(Ht({metricName:\`perf_web_vitals_\${Xt(r)}_\${a}\`,metricType:d.count,tags:b,value:1}),"LCP"===r&&Ht({metricName:\`perf_web_vitals_\${Xt(r)}\`,metricType:d.distribution,tags:b,value:t})))},maxMeasureTime:3e4,steps:A.steps,onMarkStep:Zt})}catch(e){e instanceof Error&&A.onError(e)}})()},Tn=e=>{Y(e),e.userAgent&&Z(),lt({metricName:"Identify:",data:{countryCode:H.countryCode,deviceId:H.deviceId,userId:H.userId}})},kn=({blacklistRegex:e,pageKeyRegex:t,browserHistory:n})=>{Kt({blacklistRegex:e||[],isEnabled:!0}),ae({pageKeyRegex:t}),on({callMarkNTBT:!1}),n.listen((()=>{on()}))},_n=({blacklistRegex:e,pageKeyRegex:t,nextJsRouter:n})=>{Kt({blacklistRegex:e||[],isEnabled:!0}),ae({pageKeyRegex:t}),on({callMarkNTBT:!1}),n.events.on("routeChangeComplete",(()=>{on()}))},Sn=()=>{Y({isOptOut:!0}),ot(S,{})},En=()=>{Y({isOptOut:!1})},xn={Button:{label:"cb_button",uuid:"e921a074-40e6-4371-8700-134d5cd633e6",componentType:m.button}};function On(e,t,n){return{componentName:e,actions:t,data:n}}function jn(){return jn=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},jn.apply(this,arguments)}function Nn(e,t,n){const{componentName:r,data:i}=n;$t(e.label,jn({componentType:e.componentType,action:t,loggingId:e.uuid,component_name:r},i))}const In={actionMapping:{onPress:f.click,onHover:f.hover},handlers:{Button:{[f.click]:e=>Nn(xn.Button,f.click,e),[f.hover]:e=>Nn(xn.Button,f.hover,e)}}};function Pn(e,t=!1){t?_t({url:A.tracesEndpoint,data:{traces:e},isJSON:!0,onError:A.onError}):yt((()=>{_t({url:A.tracesEndpoint,data:{traces:e},isJSON:!0,onError:A.onError})})),ut({metricName:"Batch Traces",data:e})}function Mn(){return Mn=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Mn.apply(this,arguments)}const Bn=1e6;function Cn(e){return e*Bn}function Dn(e=function(){var e;return null==(e=window)?void 0:e.crypto}()){const t=new Uint32Array(2);return null==e||e.getRandomValues(t),((BigInt(t[0])<<BigInt(32))+BigInt(t[1])).toString()}function An(e,t){return{"x-datadog-origin":"rum","x-datadog-parent-id":t,"x-datadog-sampling-priority":"1","x-datadog-trace-id":e}}function Ln(e){var t;const{name:n,traceId:r,spanId:i,start:a,duration:o,resource:s,meta:c}=e;return{duration:o?Cn(o):0,name:n,resource:s,service:A.projectName,span_id:null!=i?i:Dn(),start:a?Cn(a):0,trace_id:null!=r?r:Dn(),parent_id:P,type:M,meta:Mn({platform:A.platform},re.pageKey?{page_key:re.pageKey}:{},null!=(t=Se.ujs)&&t.length?{last_ujs:Se.ujs[Se.ujs.length-1]}:{},null!=c?c:{})}}function Un(e){return[Ln(e)]}function Rn(e,t){Oe()&&function(e){return e.length>0}(e)&&(t&&function(e,t){e.forEach((e=>function(e,t){const n=Mn({},e.meta,t.meta),r={start:t.start?Cn(t.start):e.start,duration:t.duration?Cn(t.duration):e.duration};Object.assign(e,t,Mn({meta:n},r))}(e,t)))}(e,t),je.tracesQueue.push(e),wt(Pn)&&(Pn(je.tracesQueue),je.tracesQueue=[]))}function qn(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,"string");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}function Fn(){return Fn=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Fn.apply(this,arguments)}function zn(){return void 0!==typeof window&&"performance"in window&&"mark"in performance&&"getEntriesByName"in performance}function Kn(e,t){return\`perf_\${e}\${null!=t&&t.label?\`_\${t.label}\`:""}\`}function $n(e,t,n){return\`\${Kn(e,n)}__\${t}\`}let Qn={};function Wn(e,t,n){if(!zn())return;const r=$n(e,t,n);if(performance.mark(r),"end"===t){const t=Kn(e,n);!function(e,t,n){try{performance.measure(e,t,n)}catch(e){A.onError(e)}}(t,$n(e,"start",n),r);const i=performance.getEntriesByName(t).pop();i&&Ht(Fn({metricName:e,metricType:d.distribution,value:i.duration},null!=n&&n.tags?{tags:n.tags}:{}))}}function Hn(e,t){if(!zn())return;const n=$n(e,"start",t);Qn[n]||(Wn(e,"start",t),Qn[n]=!0)}function Vn(e,t){const n=$n(e,"start",t),r=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(Qn,[n].map(qn));Qn=r}function Jn(e,t){if(!zn())return;const n=$n(e,"start",t);Qn[n]&&(Wn(e,"end",t),Vn(e,t))}function Xn(){zn()&&(performance.clearMarks(),Qn={})}var Gn=n(784);function Zn(){return Zn=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Zn.apply(this,arguments)}function Yn(e,t,n=l.low){const r=(0,Gn.useRef)(t);return(0,Gn.useEffect)((()=>{r.current=t}),[t]),(0,Gn.useCallback)((t=>{$t(e,Zn({},r.current,t),n)}),[e,n])}function er(){return er=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},er.apply(this,arguments)}function tr(e,t,n=l.low){(0,Gn.useEffect)((()=>{const r=er({},t,{action:f.render});$t(e,r,n)}),[])}function nr(){return nr=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},nr.apply(this,arguments)}const rr=function(e,t){return{markStartPerf:(0,Gn.useCallback)((()=>Hn(e,t)),[e,t]),markEndPerf:(0,Gn.useCallback)((n=>Jn(e,nr({},t,n))),[e,t])}};function ir(){return ir=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},ir.apply(this,arguments)}function ar(){return Object.entries(ir({},Se,zt(),{sessionUUID:oe.sessionUUID,userId:oe.userId})).reduce(((e,t)=>{return null!=(n=t[1])&&""!==n?ir({},e,{[t[0]]:t[1]}):e;var n}),{})}async function or(){return new Promise((e=>{Mt(vt(je.eventsQueue)),Qt(bt(je.metricsQueue),!0),Pn(je.tracesQueue,!0),Ne({eventsQueue:[],metricsQueue:[],tracesQueue:[]}),e()}))}function sr(){return{"X-CB-Device-ID":H.deviceId||"unknown","X-CB-Is-Logged-In":H.userId?"true":"false","X-CB-Pagekey":re.pageKey||"unknown","X-CB-UJS":(e=Se.ujs,void 0===e||0===e.length?"":e.join(",")),"X-CB-Platform":A.platform||"unknown","X-CB-Project-Name":A.projectName||"unknown","X-CB-Session-UUID":oe.sessionUUID||"unknown","X-CB-Version-Name":A.version?String(A.version):"unknown"};var e}})(),r})()}));`;

// node_modules/@base-org/account/dist/core/telemetry/initCCA.js
var loadTelemetryScript = () => {
  return new Promise((resolve, reject) => {
    if (window.ClientAnalytics) {
      return resolve();
    }
    try {
      const script = document.createElement("script");
      script.textContent = TELEMETRY_SCRIPT_CONTENT;
      script.type = "text/javascript";
      document.head.appendChild(script);
      initCCA();
      document.head.removeChild(script);
      resolve();
    } catch (_a14) {
      console.error("Failed to execute inlined telemetry script");
      reject();
    }
  });
};
var initCCA = () => {
  var _a14, _b, _c3;
  if (typeof window !== "undefined") {
    const deviceId = (_c3 = (_a14 = store.config.get().deviceId) !== null && _a14 !== void 0 ? _a14 : (_b = window.crypto) === null || _b === void 0 ? void 0 : _b.randomUUID()) !== null && _c3 !== void 0 ? _c3 : "";
    if (window.ClientAnalytics) {
      const { init: init4, identify, PlatformName } = window.ClientAnalytics;
      init4({
        isProd: true,
        amplitudeApiKey: "c66737ad47ec354ced777935b0af822e",
        platform: PlatformName.web,
        projectName: "base_account_sdk",
        showDebugLogging: false,
        version: "1.0.0",
        apiEndpoint: "https://cca-lite.coinbase.com"
      });
      identify({ deviceId });
      store.config.set({ deviceId });
    }
  }
};

// node_modules/@base-org/account/dist/sign/base-account/utils/constants.js
var factoryAddress = "0xba5ed110efdba3d005bfc882d75358acbbb85842";
var spendPermissionManagerAddress = "0xf85210B21cC50302F477BA56686d2019dC9b67Ad";
var abi = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [{ name: "owner", type: "bytes" }],
    name: "AlreadyOwner",
    type: "error"
  },
  { inputs: [], name: "Initialized", type: "error" },
  {
    inputs: [{ name: "owner", type: "bytes" }],
    name: "InvalidEthereumAddressOwner",
    type: "error"
  },
  {
    inputs: [{ name: "key", type: "uint256" }],
    name: "InvalidNonceKey",
    type: "error"
  },
  {
    inputs: [{ name: "owner", type: "bytes" }],
    name: "InvalidOwnerBytesLength",
    type: "error"
  },
  { inputs: [], name: "LastOwner", type: "error" },
  {
    inputs: [{ name: "index", type: "uint256" }],
    name: "NoOwnerAtIndex",
    type: "error"
  },
  {
    inputs: [{ name: "ownersRemaining", type: "uint256" }],
    name: "NotLastOwner",
    type: "error"
  },
  {
    inputs: [{ name: "selector", type: "bytes4" }],
    name: "SelectorNotAllowed",
    type: "error"
  },
  { inputs: [], name: "Unauthorized", type: "error" },
  { inputs: [], name: "UnauthorizedCallContext", type: "error" },
  { inputs: [], name: "UpgradeFailed", type: "error" },
  {
    inputs: [
      { name: "index", type: "uint256" },
      { name: "expectedOwner", type: "bytes" },
      { name: "actualOwner", type: "bytes" }
    ],
    name: "WrongOwnerAtIndex",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "index",
        type: "uint256"
      },
      { indexed: false, name: "owner", type: "bytes" }
    ],
    name: "AddOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "index",
        type: "uint256"
      },
      { indexed: false, name: "owner", type: "bytes" }
    ],
    name: "RemoveOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  { stateMutability: "payable", type: "fallback" },
  {
    inputs: [],
    name: "REPLAYABLE_NONCE_KEY",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "owner", type: "address" }],
    name: "addOwnerAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "x", type: "bytes32" },
      { name: "y", type: "bytes32" }
    ],
    name: "addOwnerPublicKey",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "functionSelector", type: "bytes4" }],
    name: "canSkipChainIdValidation",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "domainSeparator",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "entryPoint",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "target", type: "address" },
      { name: "value", type: "uint256" },
      { name: "data", type: "bytes" }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "target", type: "address" },
          { name: "value", type: "uint256" },
          { name: "data", type: "bytes" }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "executeBatch",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "calls", type: "bytes[]" }],
    name: "executeWithoutChainIdValidation",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHashWithoutChainId",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [{ name: "$", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "owners", type: "bytes[]" }],
    name: "initialize",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "isOwnerAddress",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "bytes" }],
    name: "isOwnerBytes",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "x", type: "bytes32" },
      { name: "y", type: "bytes32" }
    ],
    name: "isOwnerPublicKey",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "hash", type: "bytes32" },
      { name: "signature", type: "bytes" }
    ],
    name: "isValidSignature",
    outputs: [{ name: "result", type: "bytes4" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "nextOwnerIndex",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "index", type: "uint256" }],
    name: "ownerAtIndex",
    outputs: [{ name: "", type: "bytes" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ownerCount",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "index", type: "uint256" },
      { name: "owner", type: "bytes" }
    ],
    name: "removeLastOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "index", type: "uint256" },
      { name: "owner", type: "bytes" }
    ],
    name: "removeOwnerAtIndex",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "removedOwnersCount",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "hash", type: "bytes32" }],
    name: "replaySafeHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "newImplementation", type: "address" },
      { name: "data", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      },
      { name: "userOpHash", type: "bytes32" },
      { name: "missingAccountFunds", type: "uint256" }
    ],
    name: "validateUserOp",
    outputs: [{ name: "validationData", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
var factoryAbi = [
  {
    inputs: [{ name: "implementation_", type: "address" }],
    stateMutability: "payable",
    type: "constructor"
  },
  { inputs: [], name: "OwnerRequired", type: "error" },
  {
    inputs: [
      { name: "owners", type: "bytes[]" },
      { name: "nonce", type: "uint256" }
    ],
    name: "createAccount",
    outputs: [
      {
        name: "account",
        type: "address"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { name: "owners", type: "bytes[]" },
      { name: "nonce", type: "uint256" }
    ],
    name: "getAddress",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "initCodeHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@base-org/account/dist/core/error/constants.js
var standardErrorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
};
var errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  "4902": {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
};

// node_modules/@base-org/account/dist/core/error/utils.js
var FALLBACK_MESSAGE = "Unspecified error message.";
var JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {
  if (code && Number.isInteger(code)) {
    const codeString = code.toString();
    if (hasKey(errorValues, codeString)) {
      return errorValues[codeString].message;
    }
    if (isJsonRpcServerError(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE;
    }
  }
  return fallbackMessage;
}
function isValidCode(code) {
  if (!Number.isInteger(code)) {
    return false;
  }
  const codeString = code.toString();
  if (errorValues[codeString]) {
    return true;
  }
  if (isJsonRpcServerError(code)) {
    return true;
  }
  return false;
}
function serialize(error, { shouldIncludeStack = false } = {}) {
  const serialized = {};
  if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
    const _error = error;
    serialized.code = _error.code;
    if (_error.message && typeof _error.message === "string") {
      serialized.message = _error.message;
      if (hasKey(_error, "data")) {
        serialized.data = _error.data;
      }
    } else {
      serialized.message = getMessageFromCode(serialized.code);
      serialized.data = { originalError: assignOriginalError(error) };
    }
  } else {
    serialized.code = standardErrorCodes.rpc.internal;
    serialized.message = hasStringProperty(error, "message") ? error.message : FALLBACK_MESSAGE;
    serialized.data = { originalError: assignOriginalError(error) };
  }
  if (shouldIncludeStack) {
    serialized.stack = hasStringProperty(error, "stack") ? error.stack : void 0;
  }
  return serialized;
}
function isJsonRpcServerError(code) {
  return code >= -32099 && code <= -32e3;
}
function assignOriginalError(error) {
  if (error && typeof error === "object" && !Array.isArray(error)) {
    return Object.assign({}, error);
  }
  return error;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function hasStringProperty(obj, prop) {
  return typeof obj === "object" && obj !== null && prop in obj && typeof obj[prop] === "string";
}

// node_modules/@base-org/account/dist/core/error/errors.js
var standardErrors = {
  rpc: {
    parse: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.parse, arg),
    invalidRequest: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidRequest, arg),
    invalidParams: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidParams, arg),
    methodNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotFound, arg),
    internal: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.internal, arg),
    server: (opts2) => {
      if (!opts2 || typeof opts2 !== "object" || Array.isArray(opts2)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code } = opts2;
      if (!Number.isInteger(code) || code > -32005 || code < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code, opts2);
    },
    invalidInput: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.invalidInput, arg),
    resourceNotFound: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceNotFound, arg),
    resourceUnavailable: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.resourceUnavailable, arg),
    transactionRejected: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.transactionRejected, arg),
    methodNotSupported: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.methodNotSupported, arg),
    limitExceeded: (arg) => getEthJsonRpcError(standardErrorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    userRejectedRequest: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.userRejectedRequest, arg);
    },
    unauthorized: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unauthorized, arg);
    },
    unsupportedMethod: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unsupportedMethod, arg);
    },
    disconnected: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.disconnected, arg);
    },
    chainDisconnected: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.chainDisconnected, arg);
    },
    unsupportedChain: (arg) => {
      return getEthProviderError(standardErrorCodes.provider.unsupportedChain, arg);
    },
    custom: (opts2) => {
      if (!opts2 || typeof opts2 !== "object" || Array.isArray(opts2)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code, message, data } = opts2;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new EthereumProviderError(code, message, data);
    }
  }
};
function getEthJsonRpcError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumRpcError(code, message || getMessageFromCode(code), data);
}
function getEthProviderError(code, arg) {
  const [message, data] = parseOpts(arg);
  return new EthereumProviderError(code, message || getMessageFromCode(code), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    }
    if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
var EthereumRpcError = class extends Error {
  constructor(code, message, data) {
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code;
    if (data !== void 0) {
      this.data = data;
    }
  }
};
var EthereumProviderError = class extends EthereumRpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(code, message, data) {
    if (!isValidEthProviderCode(code)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code, message, data);
  }
};
function isValidEthProviderCode(code) {
  return Number.isInteger(code) && code >= 1e3 && code <= 4999;
}
function isActionableHttpRequestError(errorObject) {
  return typeof errorObject === "object" && errorObject !== null && "code" in errorObject && "data" in errorObject && errorObject.code === -32090 && typeof errorObject.data === "object" && errorObject.data !== null && "type" in errorObject.data && errorObject.data.type === "INSUFFICIENT_FUNDS";
}
function isViemError(error) {
  return typeof error === "object" && error !== null && "details" in error;
}
function viemHttpErrorToProviderError(error) {
  try {
    const details = JSON.parse(error.details);
    return new EthereumRpcError(details.code, details.message, details.data);
  } catch (_6) {
    return null;
  }
}

// node_modules/@base-org/account/dist/util/assertPresence.js
function assertPresence(value2, error, message) {
  if (value2 === null || value2 === void 0) {
    throw error !== null && error !== void 0 ? error : standardErrors.rpc.invalidParams({
      message: message !== null && message !== void 0 ? message : "value must be present",
      data: value2
    });
  }
}
function assertArrayPresence(value2, message) {
  if (!Array.isArray(value2)) {
    throw standardErrors.rpc.invalidParams({
      message: message !== null && message !== void 0 ? message : "value must be an array",
      data: value2
    });
  }
}

// node_modules/@base-org/account/dist/util/checkCrossOriginOpenerPolicy.js
var COOP_ERROR_MESSAGE = `Base Account SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Base Account app.

Please see https://docs.base.org/smart-wallet/quickstart#cross-origin-opener-policy for more information.`;
var createCoopChecker = () => {
  let crossOriginOpenerPolicy;
  return {
    getCrossOriginOpenerPolicy: () => {
      if (crossOriginOpenerPolicy === void 0) {
        return "undefined";
      }
      return crossOriginOpenerPolicy;
    },
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window === "undefined") {
        crossOriginOpenerPolicy = "non-browser-env";
        return;
      }
      try {
        const url2 = `${window.location.origin}${window.location.pathname}`;
        const response = await fetch(url2, {
          method: "HEAD"
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = response.headers.get("Cross-Origin-Opener-Policy");
        crossOriginOpenerPolicy = result !== null && result !== void 0 ? result : "null";
        if (crossOriginOpenerPolicy === "same-origin") {
          console.error(COOP_ERROR_MESSAGE);
        }
      } catch (error) {
        console.error("Error checking Cross-Origin-Opener-Policy:", error.message);
        crossOriginOpenerPolicy = "error";
      }
    }
  };
};
var { checkCrossOriginOpenerPolicy, getCrossOriginOpenerPolicy } = createCoopChecker();

// node_modules/@base-org/account/dist/util/validatePreferences.js
function validatePreferences(preference) {
  if (!preference) {
    return;
  }
  if (preference.attribution) {
    if (preference.attribution.auto !== void 0 && preference.attribution.dataSuffix !== void 0) {
      throw new Error(`Attribution cannot contain both auto and dataSuffix properties`);
    }
  }
  if (preference.telemetry) {
    if (typeof preference.telemetry !== "boolean") {
      throw new Error(`Telemetry must be a boolean`);
    }
  }
}
function validateSubAccount(toAccount2) {
  if (typeof toAccount2 !== "function") {
    throw new Error(`toAccount is not a function`);
  }
}

// node_modules/@base-org/account/dist/core/telemetry/logEvent.js
var ComponentType;
(function(ComponentType2) {
  ComponentType2["unknown"] = "unknown";
  ComponentType2["banner"] = "banner";
  ComponentType2["button"] = "button";
  ComponentType2["card"] = "card";
  ComponentType2["chart"] = "chart";
  ComponentType2["content_script"] = "content_script";
  ComponentType2["dropdown"] = "dropdown";
  ComponentType2["link"] = "link";
  ComponentType2["page"] = "page";
  ComponentType2["modal"] = "modal";
  ComponentType2["table"] = "table";
  ComponentType2["search_bar"] = "search_bar";
  ComponentType2["service_worker"] = "service_worker";
  ComponentType2["text"] = "text";
  ComponentType2["text_input"] = "text_input";
  ComponentType2["tray"] = "tray";
  ComponentType2["checkbox"] = "checkbox";
  ComponentType2["icon"] = "icon";
})(ComponentType || (ComponentType = {}));
var ActionType;
(function(ActionType2) {
  ActionType2["unknown"] = "unknown";
  ActionType2["blur"] = "blur";
  ActionType2["click"] = "click";
  ActionType2["change"] = "change";
  ActionType2["dismiss"] = "dismiss";
  ActionType2["focus"] = "focus";
  ActionType2["hover"] = "hover";
  ActionType2["select"] = "select";
  ActionType2["measurement"] = "measurement";
  ActionType2["move"] = "move";
  ActionType2["process"] = "process";
  ActionType2["render"] = "render";
  ActionType2["scroll"] = "scroll";
  ActionType2["view"] = "view";
  ActionType2["search"] = "search";
  ActionType2["keyPress"] = "keyPress";
  ActionType2["error"] = "error";
})(ActionType || (ActionType = {}));
var AnalyticsEventImportance;
(function(AnalyticsEventImportance2) {
  AnalyticsEventImportance2["low"] = "low";
  AnalyticsEventImportance2["high"] = "high";
})(AnalyticsEventImportance || (AnalyticsEventImportance = {}));
function logEvent(name, event, importance) {
  var _a14, _b, _c3;
  if (window.ClientAnalytics) {
    (_a14 = window.ClientAnalytics) === null || _a14 === void 0 ? void 0 : _a14.logEvent(name, Object.assign(Object.assign({}, event), { sdkVersion: PACKAGE_VERSION, sdkName: PACKAGE_NAME, appName: (_c3 = (_b = store.config.get().metadata) === null || _b === void 0 ? void 0 : _b.appName) !== null && _c3 !== void 0 ? _c3 : "", appOrigin: window.location.origin }), importance);
  }
}

// node_modules/@base-org/account/dist/core/telemetry/events/communicator.js
var logPopupSetupStarted = () => {
  logEvent("communicator.popup_setup.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown
  }, AnalyticsEventImportance.high);
};
var logPopupSetupCompleted = () => {
  logEvent("communicator.popup_setup.completed", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown
  }, AnalyticsEventImportance.high);
};
var logPopupUnloadReceived = () => {
  logEvent("communicator.popup_unload.received", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown
  }, AnalyticsEventImportance.high);
};

// node_modules/@base-org/account/dist/core/telemetry/events/dialog.js
var logDialogShown = ({ dialogContext }) => {
  logEvent(`dialog.${dialogContext}.shown`, {
    action: ActionType.render,
    componentType: ComponentType.modal,
    dialogContext
  }, AnalyticsEventImportance.high);
};
var logDialogDismissed = ({ dialogContext }) => {
  logEvent(`dialog.${dialogContext}.dismissed`, {
    action: ActionType.dismiss,
    componentType: ComponentType.modal,
    dialogContext
  }, AnalyticsEventImportance.high);
};
var logDialogActionClicked = ({ dialogContext, dialogAction }) => {
  logEvent(`dialog.${dialogContext}.action_clicked`, {
    action: ActionType.click,
    componentType: ComponentType.button,
    dialogContext,
    dialogAction
  }, AnalyticsEventImportance.high);
};

// node_modules/@base-org/account/dist/ui/assets/fontFaceCSS.js
var FONT_FACE_CSS = `
@font-face {
  font-family: "BaseSans-Regular";
  src: url("data:font/woff2;charset=utf-8;base64,d09GMgABAAAAAJigAA8AAAACCywAAJg8AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGoIuG4L7BhzCdAZgAJIGEQgKg+k0gv4NC4p0AAE2AiQDlWQEIAWGfgeublsIz5EGVeP2TiXfSAJ0G0LBr7Zlqf6pcAA3dwBbquuITJr6o7y2YrpNHoSyAwBKe/rZ//////+/IlmMMf8PuQcEUUitMtva1oSQhGamQkxJxpSLWVScqgQ1RW16VovNJTZ2uagkVSeuNje11QubnvZpYVB7yUGi4thNqJYBdoegR2V9jiA4dEhCOgf3Va7muEqhcRKz0dDNOVV47+hxPO9qkzFCUg5glpCZxKbOGFxehX5nYwGEBZOQwyRFIY5oljSrLwkSIj35dugPRJKk8G3GwUgw06hpknM0qqcUdO/UkzLvviWielabhCp59zPCaOnnqLtK3qXfP4Jz+vAum7Q0/NuZGXK9lUJKTpCEJ7ENfKrSzrLJy8uqLLgUD5sssqscpk8OS7HhGv36H+Ct59wJukpOmwpgFOqL6vCNd0ISNjq/nA5E/OXNVV0dR7EKTAKiB1ZvW+tSlyr7EWdJ3qxDtA8codE8WQY4xkT9EJF26FGP+iQKnwv66klyovCkLwlr8Lxu3nv/5/MNMUKMiAhhDtdkGsM0RAwRI8QYaRhCUNgOUAO4Bi0u3DhL0aZoKaLFsXHublwTFwWef9oP2rlv3sxftRCxRCOKSDVvItZINGlFPFkmbqay38SW9hmQLI2pME5qCPQ47vfu8GC3f2SvxM2MUAmZO8ThjH049p2ZcUbGnTPWOHudo8vMLNEQRUvt3y9qA6U5Uu9ZONvHHhBR/BdN1Kcsoz6KD7j59iAmJA4eESNxvpq3Y6fp1ru163hU2GRzm8rmg0BhMJKgMIaf9nO3qg2ztI6m8ncflWgaGnQInYUqlufvbIecf9zg3KdoiqIpiqLnHzctBAhpSGNI+CSBCoxSmdVel2WMzJgqpdvlRLu9sTnXnnhOLGfKTLCJOTM9UWa8ezmfeyz//739L9vet2xVfdv8v/dtfXvfXldd46q+pW+rqhpVVXVV1biGGqPGGGOMMSIiRkSEOCIiIiIiIiKOIyJEHBHHETH/+Nz8/5kozOTkkPZ9M9uZRYC0pVwIQS5XK0nOJvA8lOVX3YrZypBnvvvmw25iURRFUTRNURRFURRFURRFURRF0TRNUzRN0TRN0/zRttoUsFC40OU9euRGFjGNjc8DAIWhNhWIqEFFnL7nFu2CjlFaJxxJRqf6Ung+Jvp73GVuoRtcHv8zeSKBU33dLOlWLJ0kBS4NEvIIaJvcM3ZuaDO0PkAHB26nUXSKoiiKorCiM7PySCWqIBxaeL2g/EBoVNGFPYv0QhLD6BUFa7FVDM8hh4gg8ggWk0GkW3K9iQBYnQnPTdjg3A60rt4SpU4u7oiFDsrYvgxqdHDejpIzYZgbzk8QuuLh/8fU3Bf+KRCpqkoCWRYOgAZ6Z5rQmDGR2/bhWlmYKohLc8ntExu5JXwnk4LxI3Dc4OHi4/9eZ9m+b3l93mMfUbzJKYRFQ1QlXco0TebrSbL0JXsjyd5bw4HXPtI6YPvIcDe3DiFVQLb3iLxBgC4dNk2KLk2ZpkxREncp6io8fL/sm+2zzdT+IY9D0m6/Y4Tb+s6iqZrfMxvuf9tUfXJvk9JjSEMeYnYhCoOwOIYhfWJUUa2kkNlJpML5EP/eVKu0P5sQZjyxnCmOds/xprjWpqAZcY3TaO585D3x+jeeuj+aGBIYUWAPxDGOwjgjW4Pf//+GJyFLEJQZZ5xG63XOmMhaQ53VznlFa3y22daGl256F+cXhBeFxoYXXhZfePD8O32lcfRutrIm2gQ7oUjxl7L8lWnl5GWsjrVZocNaAAtYi4twUQmBxeWB71Q+jf0X4QkWtlmSCs9F9QVYKjgMPC1YEQfHiQ1IA75IGACGQSXDpvfmW2GhW4TDy9KXWhTKEVQViiAk0uAR7iVCIrxEwlP9Tf+zRMPFdQxv5oIEg///pmZK8yodlcqgE4BywtDq/vc9azWnlY7kGdlbOg4NZKEs8O+WPP07CTSbOoxcSiiOX6QEN+t/J+H/fye5TqG9dlWtqrVWRESMyIsRI0bEWhVH3///6xjuE3wV5isP2bQlhMJa/PCAB7e9XrJlnx4vRqoCxJEeHtsI0x9/s5owdGxp17TXIikE8RSCxh6y+31+b1Pbj1sa9nZsapXA6RS3w2leokH/w4wAP/6mRgHw09uiJICffvQeEZQY/BH8E+WJYYuQkGD11BMhJcNy5oJw5Yrlxg3hzh3LQxgiXDhWhAjEGGOw5BSISJFYUWIQsWKx4oxHJEjAmiARoaHBmqgMMc8ClDkxSGKjw2RK5iCZm1JsyrIcyYqswGZl9iDZmxNoTuYrkm/pRNNFvZHyqUC0gupnpCx1EFOHqhHBggLBgJnAPGAJFElsNCDYJGVStElG0cRmItSr1aA7AqYxnAnd7KY4NcTHPZpvggwLTE5jQFCdzRz7ZK4J0n+yOBxfPLubEYQhClMafQx9v+JB6UbImj03AQYbTS6OWrJUJhSP0p/2es1yt0Omr7Egj5366fr4ua6v3dbt9Ruc/3R947/ZvnkHjg3y7lUgoL2UBP/MNpUuiyQu8YoquufZv6iCKqyOV+sY2sKGZqwbj8bn9uvFkxPI5wJN4YqTdR3cr39S/T4cB2JUjhcpltUvgRzIldzOJ3mQJ8XXdymUZumXYxErv47qa0tRnWmroa07s59NsWk3Q2f+HEC/bJfPh/PLFdHXxHmv5nfeueJkzg3Zs+zvMTCTf967JdTaNjTKjk5xsRvd5QGPed4r3vZnH/nrwvoTeZY4lfsvixW3mtfjU+A83xeuevacM9d5qon6fOTg/79PrhPLMWMcwa3bv3J36RZlxnBgAJ2KMoyFYTREKn+ZKsvGlEcUkroTk15wKDTCoMoIwHgRFQNDXIa8HgfEacoFAzxuOQ7CC3jkglmPV3om8ky0iIPACWPlXBxA16FBIDBeeJaRPVKUYhqoHSvO1VEgVUajSwqlmlIalK25HF6e7le5QsHuVNO9EEUGvScieDTMCFZkT4wSprN3PWQynglxJhmiQBMhZVkvQGCuhy3sGznDAIAvIckysxSNLSamjH8rL/iQ6kCmCWULlOP5La5Cs7pTIL3W4dKITAHf4EO4q5DGYsYTJxAmKicRJgvAnGZ4X3BH3jdqsaKPhrAlcd9II/pGQ57oVzQUSmFQLm+lopVwjzel0YxGq1ZiNdKcpfuGqsZq1tfw2zUtj7I82jLYr2C4PWYaWZ7sU0shbvISKvr5PPYncRCxIBcTsIcjEmiZi+j6+xZjUG3QSJJkOZ0oBjriBHZXeDFRTOILE8ls/Z1QmBmC1XFrmI7FjqdMACayJ1Eg7HQJdDV0dWgN4VgRHHE5ABPlwkwJvi3SNGU/lasiDqPyamkvpWzzBjsBryYXJNXRm2tksf66FHEGdBmprXMO/1yFsdTx4ATRRPEkkcqIE5HnoBB2PKcIq8ZzlSN8HCKVJBHWJzP1NxSViSkoDNOJZpubo9BJtAXOIPRT0X9kVclq8tUZa+iMJY1nT2BPZE5i7yWMRBxEHkXREryFuA1pTeFkz16JKs2eU2cambRkOYZ51DBJkZdkdOBO1AQu0xoxEcLlwSSBqtBzWJOQp2j/YPUah4IrAyPcIIRHuRyjYm79IrehQq6t9gjOo6A5WAlDn6G/Slwapo9gn6z1M9KX/NyrefcT219m/6T9N1+VuBqwus3JnHV46zL3MhVy1okYqZS3Xcm8i7xvbUEzwFWV2XeQ5F6iBJcLUUfaS0gcx2wRFtPjKKVzUzgM0nCXr5JMDXgZL8jbNiPYm2wRUCU4+QQoQ91iwHod68TgjVRIY/cPoxKynq70EPJKDlY+WP8/iJENKyo2DdZO0RFCRWl8qYaUyVu2HuXo8nyFlO7UrXuhigi9UUMhCoNpZKOmo7sejsnhitMeFwkw4jbF6eKNCUQeE6I3hF/ZyCJFXdBcy2HclbkniyIr5XDCacLlCrDJrYNzhmcQdHmIRFtGVnnvci45/f5axEx9ZsTly7CRjYpavpZsBLBW4871xpXwuoQwsnGRf67JdGbERWSYIk+XT4QhBZrEundut/S4Oy7OUn2eBVcfMACKZwtZ7vfPkikU8liT8fgJ5pPMqQKnI5sNt3bV9WYXwYCRCmnsJx3RJ0l+6/QvNvRMxawtzC4Ve/pNF9wma6m7xmLp3uXhEaPZS1FUrC1TzWgWUWglgRYfAJF3xGHMqRcDDrmxOBMSnoPnyRB33z8pwsi4oobUmtOoPmfI6dsqlqf6FaTnHQrVMCiFey0ybwY8BcJphGVwiQEUb5+AImiIJCpVoEz+stnFThmZ5E4N86YgEtlZrpMAyaHS6KGQgEAbv7A3kKrhuJCjbuekZkO95mq0dxThTHgj4YjVXu1K1PWIIag9EYMgwH0ZijiLLKJU4NcXx1Mn0CaKJlGNAIcDCHic5Z4StDNOHDZbv7+bRDOSrhiJiqUFgdtxi51Q7pTJTgfRP3jnYS57EIs1CW8ysRQSOk7m7p9jnJzgFFd83PHxxGcIp4ThMwUXE6dU7Um6wBbQywdbvtjyw5Y/tgKwFYjFERNm1a5XNt/KwddMfBXgEfF6P19vBIZYb/EKsmGvtlsHs+XFXT+ugvmLV07hpJyoQKWFFlnspNPOvvt2rlm7l9m0J0S8iAXrI96AQ2JiYmJiYmLiEdmal3VYUVKSJGl/JWzgCM7bBzojlGUlYKF0vU265E+2EO5klB3PUFBWMSOTWolpoaFoor5MkPQ+o6HQ6Cn1jcK8p1zf/YRhp1TgHVfurATSOreWKNSiPbLa8byeBD23wXWgdW5KdhHedfE2EVhUMJNDKaHcdLor9Imh3DvtcFL4Y17E00B5ZStaY9uaXDZpgKZvEZQWWXJKPeq0IL6r24RivS9KJYVHJYSovb2ndPFvOUyxNC5yeXqLW8iJswKBh0zx3z52tby6PyMqltMpj0zteLz4NqK7DmHRrSN3WD3G46yxswltmY2NwFA2nSDKgZ0E5DEBoia2rObDAAy4OTgcRC0G2k3EcdVx6veK9H6BhqHA7y3odv5qPTAUKppb7vWymulmK8NNz9UZ5jiQJkwI7CAgGWfJEzgo9yDmmkgT4PNBHqF2vDigI4wa1Xv17/28Vbquyn7/PLcDQ2HYy7B08iq8MdA4eUgQlpf5zvZaqBf15lCE0M6cNvZpEiAZ2F45nOBqF+dUbKHUUI6ne4MAYbiTVO3lqVfKb1ayIi5FXpcDlGlyjhzkw/MZmPmoh5QQiZDYcpOgDpXi/1NnChbIDPU5wLQ8scKEcyYn50pPz42BgbtUaTxkyOAjWzZfOXL4yZXLX74iAWabrb8yZQYwMxtoo40GOeywwYlIhCGZk0WGZllWGJNV+Z4i1dkqNtuzgyY7s0tSbuYmbe7mgcmlLKUppSoVfU2oCabWxNIxlKGMMiujZsip3MpVVPmVr7gKa5aSKq1SpTW/Fiir8qowv6qqihnd6DqwsPbVo8IQKQ1qjbIrwYlZoLkRJG+6WZugMZshWKeMxCutGYpJve3Mw28xpYiLzi/bdEFwn1ZxmiUMnnpvH8aVtrQW0e6ZDVGIx3ato8cXg9yY3yVwTMWfoZlZasK15xoRJu19atJdVE3aaQooW7py90yx2b0cRnPzQLBQ9HYIGRn2cTuDUU7mqC7QMta7GWFHwDrFdMaTcOwsxz9wFp3hDa95kR4xMURdxCne5kuXVot3fK/AUBFTYyTNwCHho0m3WELrjocfdeK8R76XC8sKb0xtLZNbrPCKR+W4yRFYr8cdWSVxbPijn5fJ7dmOHZjFHoTyqEnGo/iRX/s9m7fejl9nco980fKEe9ZO25rQGIkA8mLmLDUilOb3hTSBN5ZhC0Ppw8fWDJvl6bLWs0om0vNerrzWNo7vz22ZHyX5BJRxLb61CbxsxLC/f5mvCpm9CxpgTGm0mMU2ZFnhZmZoe6P4i3wiNZ1xall2cbaXQ86Jfv1ui0W+Kk5xF7+1CfzDjUdlRyiYgjb1nopTbRc0MOZlydBSGxnHwAhJUwDznPM7XDt5mXHPiztGft91q4ufPGYV8ntnHuOxMKEus9qnCt4NAkC+2EOcjJKkrO8V9zTVQBEfQC4jeS/RQnV12bAEfNhtdUrQOHvFgfxCMpQbaavfRzKKxDFTDhQebuPIyrNyoFCxIqVGLXIygcMhw8uTcy82JZhpiA9XPjuXa+2v0tRpHrJVh8XK5SMI2G7k5DKT7ct2NPJACAlHBetq03f4yQjYWor/KH89NyFNy6aAZfcCPXd/KIF6JBZmc5T156XLzGXJ6MrrokXOWYTZ8OxwfvkjfV6609pkows0w3++aaoWq81hGOyO+h91VBj9Q4+GbwdWiL4yGuSCYyG/BJvVEvDPNPPUi95/VtmyVu0ZmtjUTqqtrR1eiucax2SM5Dze5puIrOflYNPzPKDLhEOv3R+QCE6s+kYtThtQN9QWNv4pwg7GeX2ZlZuQjUN0+tJo0EhUQYT74ymt1oWww35CO+AP+pL6ZgkTZ3Wao8595eNLZjMLXf7QO+Lga81u4TXJUfseAUH/HUsQlPWkQjsn53QV0IokfPU5gcVDN5ey+5t/vund2zM6bridM6h2XdYc2rWHOxatInPllyuGRjh9IZYZl58tA2aPqPK1Vr4jdOa288nZZpQ7JVr4H9lus4hh34OJSGzsgMM+54OzceTY8RNo+nDGutrGPteGPgeE/1zbksih71QDck2qru1lzrsO3fCRj3u9a7IvUWQeivblx00HrgguaQaOhFNG90eTaTPiE1hZsmZF3DoqkHkvm96X74dPYlNQzL1amVzbtptuuJlbeG4gNT2/YNDl+QW7XZ5fkHRZPkP5+kcReN5h0kWyvX/e6p5gc8+NRL07spHCH+2Qx+WzOq7LbDniVvfiXkpoeJQHO8Z8SBxht2BXAhj2Jzm3n1Im7V6xn69XYgk4QIRv5rxFPj8O0co68Vyf//bCf8Fdw3aZ8cS8HAX5tR4zee2G0yXLKziJFiw3a1ETRLImUkmXNb/o1KSR2LTx660Fb7pEx70N2SQQlMaVbODmgGOQwr/lRE1Naqc4ZRbi6VjvlJin37FoOqdevRtc19fpT1/qnqn9a7tHFY9UqzpDo4lLkicwxZgdbr9cQCcL1RYpOzfhViLum2j+Hnr7rNbUcezQpcv7btFZt8+vKrMfwG8XH9DENOGzsdKbtETTVWkl6BjpCUxSzIwsRFY+FBM7HQcNJx2XKLdBHj1eA2j9GG2sFk4fnkLQJKZdoRCW0eXQY6bw6Be3zWpH2S6bfVUHeKfKLuRdIdxWSx49aXgT8KHhi8rvIQzms9Wgl3JkmrVAPwXDALqp6NfGsA66abA76rEfTJLcIyD2OFRj6qpzORp7s0x9OhT37VXoWOfVutBNcpUfkaoEq8FVJ1bjYKkZTRvzQ4rFHwcVj707OBPwdhdXInSbuJNg2oJsG3U7kO2ibo9sh5H7jLb0UDpluIKgmT4x+uSJAOBQmWiNQQRgp2FnNM+socVkyhyrmnpmqXIthgZ8WW3FNxaLAtcGHLOJ0KEdPfjPSVqMTgKwC5BtUnQpWD2btmzZtGnRIsWirkXLJP2yfHL8AkYsiAL6FAAAACwAgAmAGgBkAAAQFAQAwAwgCOAAAJDmvbEQSgEE221AWyelstEKZQgqgS17Ej9CG6DoT/ltRouXPH2bsuOGbsfK9G09wEGh4y1CwT5bvHuo4CIDCMJTw/imZd1CkGbc0X+fJB8VfwstEHU8nbbw/prowT8+QDElmOTENPMhPIH9OQwAY8EO+eTC1Th7grqzUhB/I1P+/I3cdwFOBijV1cHNzpc6XwlnuwudrXY2QLDwulnjduhXzAMbOs1tlEOFU1xSlYtN8eoOA+w8CNgeIvGjEgKjpnY+hnqUGC5KXJEuF23bJdl3IFBvylAZLiNltIyViTJZpsq0zCt1ZKeNV9uDOlFOm+lumh2D4PCme846TPbB1MXXp3yFqIH4JP8RF11Bj434iCvhEOiRndy7bVvxImrlRTeGPuoGbPiNuBXvhXvfwIzyVM/q0ZzssNlH5Vcqb+SwNJ2pDLqSJ5+Hc/lXeG4XoQ7qsBXatFHt2dGdHRtzHAKuLkEVuXdjU/sV4SF9YE4eRKDEp+LMDkVJ4f1PoJ05MGcPtuP3oN9kGHGc2FGjN9Wg2Mhtt2HbxjUPPOE2DFtBYFdh27IrOa97qTg45+w4N67GmJ2NPCR+O0x/mXMr0ZNELM3b1MpG1Fl31zhRqA4lMITwfGI9ewFaNvwzZrtnHbH8exZX+Lvw9NW3LWYvzO2H9S5cCgamDlK9FTIzok2VzzHx/kQbCYZI0Mr3sN4rIdGlYuJTlb8ScvMb59MEnj7zfC6chza9q1d/Hvky/H30h3/umz/OpVwXd+FEPVKVRRliMamNSkN9LpaDbA2WRweqpS6Yy9p0D8ORZ/l/4NsJ40YQ8nSWzTI8aDIqSy659mEfsseNVcQrJJwGjBxsL0R3XUw1ejDUQYu83qwQRIIkDC4y0IGUaE8HhEIkhYM8EQRFTlPBbx+BWhn+tSyXCpUNlx+gquaWmKKCHh7suwwjoEiFYNYLUCDaN7J7C6vmUgFUnIqg4gvR349ExWJcCTbVyzSJJCiVWFoiU3CsDfPyxG/ho23WoejWZMFlH14J+MbuKdOgjMrPh+CrCtNwxfZkUXRnqkyp2wzVszCYMSfzZIud10vRzY1qXpiOvBgHn3NT64jZwVZ5kySmxqOgbzXvdVjvs+9D9aFHrHYun+nXgMm0OvpteB/2jJaVtkzUmKTw870LUPiqSwL0d1/xEAke1Q06jlw3zEYA61w2Ir3G7KQ4JYNugXpEpR2YwArLWQ/wYz8s5CkFI0leRyjairkhOrLH821NEizyjCVWLXXTMg2rPGqNh631pFTjSgMyiWUb0jqr1vurjf5sk4bNHrbHjn2ec8CaY5ac8miK4nxWFz3setysXvs7f/SrxQBdieVDKnqGnjwUOgNpC8+faj7452LYUnbKOQkPjtCu12aD/tW0ZkvOIz0TYz3ObsDK3HBpPoS7iNmi/ri4taWB5TyzXussUmqZYFm1Qqg7anpwGCzUZj0dZcruDQ4JVsGlAEy51TgJQcmj4Ofqr1kE3xzWDpkbLmGoIy7VNk0myZJqQmmhTFRBGL95ptCU7lRXEUePHfRUmJs4Q80q8dJEPGFZc3viyQyl2U7JUVJVoLS4YbPfiAMDeQiEnz1VkZEpI47g7AB5bFN4xoH3Q6JY7VTT5eIiCW0dUXXC1EAa6HOapEqqIaXVsgXLEW0lMNgEhg7WZSLepw1qXp+/G112mm4fEqbzM6q7qtPVtLfH5YrWMLdA8wJ1VJ/Gl8RJNaM0VbbIuCxTbilV1KKHEOizScXw5VxEECO1Ahq9DlxEjwwnI9hKFQQNMSa7l1xGKMryIZn1IsSRazKku35uq48KArOpuFsizFNpYXXzQpJ19VSjyiQUzYTwZk4j6VWW9YnPGhl9QjBXj12TgQ/C0i5j2iqz6Ni9YiLUoFvGVPHmZc8ygVeJvpRtBDhCQdSjgp0H5cMgPI2v5kSIhBUek11XqFDo4mFsOUigHZHDdfWsbj1mjHds0eTdhqHqvA90JAyFA2h4IdOtFuXCdGjBnBzrhytcHpxG7EPsDGq6ajZKOMgLPwvseVivwsGprWFci0EgWSNXm2D4KZPRGsxfO/qiYWLnUrWQj+1EeAb9l9Yh3vF7Jaoo60gWWsO8XVO1ZWWLqxyKmimiCkSUjt0qKmsk6MeTa+M6LvPikN21Tbur9GYGjxhqRfZ4dPHzoNRF22K37yMi2L5ybdg8LCFAgy9qGrCVgV/d+RouxrozXm+C/kTDSfpKEDRy8rpYeEC1Dnr1KgPZeDLVrjsQ+f3TtIJ0wszCrDYpJu2atbhuyr/+88fyAGJhnCK8tnBpMIkmAxw8tCQ6QWZBlEUhfygkuxi3Nj0NMv5uf8my9FrKiujULNoLEkkpuACFOsdLy0VHmPmwVjJKVMg0hWxXy60qzvgT93/zDASBgCVgtcBgG1jZnHjySL/3ZzfjYxEpJJKwKZn9XSrqMalXd3QKM0aady60NbvEV2VaqBXKCmUFs55Fe0yGh78QlMvhliIGqsuC7PVcFiqeN5opodCSHG31djSKAfni6uKLWywMFItABqchMUzVGFio2Ad6cAjHfTh5OFu4nGSv05+FeRAtSJKBLFOW0opy+kOt2rTr0Kmr6j79rh69+vTn0dO7jWE8JjCJipbnT3+3cBKLackdy7FKrLu7NmNrrataPMh4ZHZiF0/tox256Ts/+Om6v2XyN1yIm5lHWMXOVXkgyicgFJE1YkhIycjN5y0qqCqmEhyR59AWsBQrFavW5hmoA7BDyAHQmX8EzQTjmWFhZWPn4OTiHvYhpgXhhYRFRMXEJSSlpKuMfFk5eQVFJThCj97hJjQKHB1bFDunKhGNT/69RdwlJKiy7icdSERzFqFwoQizItXka1Jy8xoU1fCoRsQ0MqZRUY2OSilRvDqypmQ1bJnSkpGtdkf1i9+6QjcFS9xD0R/06q+o/i3+7w+pS3cvudth65kq91eN1shK0tQs2jPnQajzio9fYFhs3ikFDxTqI4XytRoCkEFMCCzwMwg13CKih/oycDtOgcMxcEzqwb7JaAND0R2sT1PQwgq6gtxl+/IrNLbI8cknFDopKXsILgtvOG+kcfl6LTk2Ja54rWjUqFGpRuUse0rggAr1ehnLRfDMVn0jzkfeD1Th1KJBU9fyyPD1QR8rt+xqJWtzNmh0+iOv4xqK+DDjI/nYJz6tG6f45iR2VWOPV4dxjjruZOTNDbd878dJk1Va2Q25vMYvWOUXKcLTZBWdXWnaWTMZq6t6bLhmsAS339Wo7Z2130MJPb/l3W2TtpN2bwrIHst6ab2cp0kYBRuLZbmBiIjKYDfEMONMyJPUpmBqKLVuhjALsagei2WJpZZZbkW1UmWV1dZYa70NNtpks6222W6HndU+xAGH4giOOeGUM84676LLrsZ13PSdH/w0IclskQdW+RAQqhLqUjJyVa+qfoOGjaZxHlSr1XWda8sYbnSg6FBYRYzWGooyIKVmtInOiCOGHwlngtXMLKxs7BycXNzLRflkKSPitEqURLUIzygCOj1XQragBIvj9frEeBDeD1rDdH4QxAJlV0ENCCP2lpf7BdQf3yys/2ZT8q6dcGL1B8J9l/kA8jK0xzG+YrPE61KZS74wXRyoAtQCGgBNgJZgA70hommwpiGahgKGaRqBGIkYY8tYW8ZpGm/LBE0TbZlkx2SKKXZEfaVVS8xNbfZN1fAQoJ1lhoNGPz/jyItzvCQve8WrXjvjdaBkAQAAgAZ0CNo3LDZLuqXe7RLE8hErrFqpaZXV1lj77lJFStNk6lG2UOtsWb+LDdhok822Vtvs2G6HndUu+/bM73VgnzfsTwccdGj4MOCIpqOOOe6Ek07FGWouibMW581Fl111PW5U3Ixb5jvf+8GPfrpdh8KMRVL3EEUb/uD6es39batbEeYRVrFzzbshyAObeZ2PX0BQKCLfy2P6JeyUslemwzHYL58LlIqmNOl4mLY79XsMmmGjxvOkVtMneU6jBeUle614rNr8GiXSRnViwzUzoxlXzQe+6hDyMPB4HUsdLX7koMeOgv8HQ1SZYHNmFlY2dg5OLu5hH8Jd0MZCwjmiu2hGDHEJSanhNGYZzWXl5BUUleAIPXqrPmD9BgwaMlw1HYxCn7Gly93bunW1PtWkTPOBSYdeyGO+4Js/Y8Vcgdc3g0zMAxp/aaFuK8bjtm8J2Yl8vBZKtUgmS/XXpuSHmc4Sh3Qy6tLThb8JIzBnwLC0yxn7xJ1qvy89S0echGytnerg/JiPTcSUpqGwbuNxRkzdcGygjsGu7nFMfL/DENmeLkHp1fynBiH0ynteEoxFXT9I+Vr+B5anb3EBJlGoBIZn0nV3zUtD9IatheS/H5dgdFZWEGyiMvAXCjawqQm1N73m4sVrqbPOevVinyb2eZsb09bZkZlzoutt361x6dOnz4rCezI8zIQNHxzY3u1t6nh48qaDvxdMIP8vJ6J3rUFd4aW3U6uSiOXsZFZ4Nhuac7DT6hMtx/L9LnxCcKmZgcSuLeU8q+JBSq0l8u8kfro7GwBYuk05Y6HhN7TPOsF5nAFRc2sLiWIfOTpRNJsQdqYmwRmnG4HUEUvkLmgnjF2NdbtsygZEX2AmglWeVUQBR+CSuS0PvJUeVIJa90Ku8pkJmHzUUMrG4M17auJ2czdRWGMLxcCLBJIICx5dcMChQ8N7rXTnRvwVj4dewe7Esnx+gWtUFdQfLuxjoT6r5keqifKmEJrFY0N16Aomg6XLMaD9PBy1IhGP8cmxxE6kFKMT8U90oFSHPoXPrMhaI2684f4UD6/jqfNWgiZS6lSfUdS2t0dnH7XBDTWVci2LmYQIIqiABtkywWquj6Hu0VlRv6Yu44ghDjR8Fu841TSWaBg5fmUC3iDEQoxUUoe49WfKcYxkChEYhz5xhw6zwoL7GTHSKVRV3zZtMOUq79yxmfNhOAszMrOsFo/7XR/rNa+thcgfPexJnnnquozk2OZKmdas5POZW/UdvA6oMoaNlrXMad0vW/LWcl2vkC9Sb8ZfCsYRd/mxLUp4qQICWjPJSqkk9Whi3pADZ5Rad3S7OWSTUZuLM39Tzg3dVOBBZDGHPkhuoVdQOZyi5vRKO+a1gFK7X0RQTFbxqiQ7onb0A86RzqgPVUhwrcvyk4wBISNOfIK2bKn4KC9475hNcCxRU4tRxSp+5fzwiBlEtjuxqDn8nN9hP+9MdHtV0zKBn2v7YbL5JvaafwUtKcnIitUrwtoFbrXZE2KnN9Itxs8W9/Uc07Z2/MDjfutJH5kve9dCZYXLXoyegoRZ5nZtVnIpZ7tZwhjjbnE3V2wwPQhyDhwIgTtmBEXlxRnTnDR0yB56ft1jdaYtg34ykR4qjo4FqCNMmjkUJbFiL1Q1dK+PZJSKFpSDx7p4WkhYjLq5S0uKU4ncgXZcEgLETSTAcVEzVXU3hjAolG6dNu0Ol0+65WKwinN7trbxHLdxNEnQeCDpK6eycMoLpT1QTb1patlVYlyRP+WKnbli9nOuuvYcRWIvulGSsZaT1BWPhGYYvgw+myFRcv1KfKSBAhmLk8llXmKeR4d9YIGo2jaIxkw18YrAD0GzvcbK5CHpSCYlqlhmUL7l2VySneUSBHI9PCuTospHSSLtKXer+hiKJOohWaacxc1TfwkksrENmoHAzS1mt+u4ICa+hwJW3XRVXp4h0zKcagHxR10Z38irUa6Br8uZhCdMvqZUGcu9vyEw7n30XQ3DWT73UJsRLMrClf06BSU6xDWYdFOhH8MA3d41bQziQ5Ep04pQtpehdhAd8Y6BTP85SNLDv6Y6/IwjJ15jK4XQ1ODsGRucRNsLmeXdUBQPVC3Hr2MpVXgNiobDPpOkitgn3lwaLkAx0zke6ofyp5INMlU8IGpKfOHtQmhkaruTMC7gcWfpQQwgdGOmSI2rSYAMkdmcDPzCojyQUkhxZH8QXuzxXk/FrUEvtC7PMqahRBKXZIAjPLGiC1K+srkjJY/9SwXdbiw8EccNzYR3ZM64ccyP9WVy6JTCVXycajLWzzMdODwSC3tk/LhBmzWqjZnnsQ1bQvyPvKfZ0ON5UqvDZpjJuW12mUSf61q5CnkspBdpWypdrJYEjKwK3X7ZanYjAaIo4L1UmEgqLv5P8k3GKDkjQ0Fe0jbGbDcvGqs1EEKTB9eTvkT/ZsnpiZ4Izp5YEfh8sjSXotXrE6d2GBF7tbp+e8Vp9wmXzJ4fIy9qk5Cc2NrNM3n7dIGLOrZYs1pnoK6rDLquD6NltTMrqR00iRjsVR6xZ0zyhB6wEYboNuNfXOhESlibm02RZQ+wyyY641qIpyaBMCwMBgIQyKoljZFogNeXyoAcOFIVtbu77mZyjK7kqltvHlx4FpBZ3ikDm60Cphpu6EMf26Ps+N/SYVfpy2DkmEwJx9vttsCQXqk0kk31RX+AC0vY9soc8Dsgp05VC9MzAQfa4SyCeyEeQIDOkCHyL2ZOYQCiQq0kP5iB6xDabQ9c/ZjAW+raaBa06pTAvKyPcU6iEZ+jR2ol+fmQatsfh7BmjO0xXCxYX6CD5F4yH9Dye8RFsEsCPWgvBS92iUd7Q84vm1sSGH1okwRxlPC4pUNJD2bZwEwzwd4dkbhMJaYYIbD9W2EyMxnp8BTZGMq1z7Pbi9bgYF2XaEJjvyYhFKWBxRHZuXSEmZxemyKm2f4sAyStAyKQr67qXutE11TfDvZJq+OzTk3UrQ8rWcLqWQCcIhU21QWXEtazl18N5p7IzkQZNQdSgL2BQELveSwRlOVBvxsHI0bmKPlioCYAiDDxA0jNiKxR43ZYLBEI51wqIiXK5JnevaxKOc5DtEaWbWeWkd7tRX3iSGzMinwUCUZX9+NvfnHgzotYrvykZQjMkbvFEKaiDorBLBhPa429dkDk8sqGTas9e+2IfCgJYe1gjko47PQXI6kmT13UNTv+9cFXiyEC6Y/k9fGZ8y++YYigsbSDkkVtyraImbyL2f0C9tdg71A/jOA/5K6/Z7XVw1bNlKIdcyLKaFZLtnsScr2jm6r8Epa4VgSOvK/tBsCUex7TFGXzDXazqFWbduPoHZM8xvMm/rjllPiRtMYzv1M4mbRyr1Vdk87EjrGkCmq571UZ50RWA+a3RZU0HrXaZSNLsQm5BDF3b9WKVerXfWKRXx7HswZfuIqYDWJ5qw0vLEkPrsthb5DxajQuXeOL2NPEmqQKpfyQSyTDgHcXUw4zvkW+3D6T4CCpPRJIZCOStZ3ze8lrfW+Hb5E8mRbD3FHEfPExn9GNHW1PXlj3/qSvpOk5iL/hgdMbpBYK1hE4VNzUm/qZ3wJw1xqMEVJxxGc4XtIhIfWOX8QQlfBWK7uKXyh7L7nPKxVbzpXsGn1DYW9neWF3Dk4d3aGeowbag+tWTOxtdK9qLY9dCZzjKbIgmNpUhJGRgZRv345AUnFQ03xBWkhD47i+Iu2LbmbhYeVFsTmvm8bi8EQSRoCvt/rxAt9qhrAYYVExcXlJBSlpf7areSI2HKJCUEFAY5P4EdoAA8tbTXHLodtEHDHgs7OA0AaExFMpbLQA9PQELkQS3mSeiji9GrOjRqC9L6BN6fhJ6/FABJu3RmC4DhmEAEK4RmGY3iTaYhabsUWcfjxnpWixSUcdx8rnL+AE9OAfH8yJFoJtNNNmtu7i+vBQipl3S0ZQj3SeYJI/eGyWYqatKtJVpaGCQy6r3MumX1COw1ktFr33B9TELSqLiigpmhIzZ07PnzdJtoIAfuhi1Q3XBqRJquJ0u7R8FOJJZOiIOsMoeksZGIc1cpNhMmpRRvTfnZzcPKq8xtHaAEAEuAAyQQkm7RQ21rLpYOlVc9I8Qb4MrINSAEGiDSCoU1orrVAHQSowYofxI7QBFE+KNhwtMt30BGrHFfqOqekJRsBBoeMRUod9Nnr3UMFRBhCEp4bxJKduUXHPWM1znxpeWnRLQzvqeDqNsPlrogf/+GBLSYFgkhOtWIfY2LWewyEL/EE1M9GicHnubCKIl6k5FcoyQNCZPjjcebPzsXDDRgLfc2VGwCABYoUboD/UkyLfch+z2e3mXjNZUx8l2T7Cal6k9vkVMtO6miH95X9GXFgZ/9oECBUZpHFmJCMbD56jQsqIPk5tpPZdtT8SZayFKCax0UL2SzKb+qUa2OqJUCLUCC1CjzAishC5iGJEKaIcsQSxClEN7gOPgKfAC4gGRBOSdw0kRVD/9qsAUfg94hBiCAsl7SW9N+mcToMKPiutrqb7xgsqqCH/OmYwHm1CZ5hDlO7sUOjr9YiOamWroe/T+jZ2VudCP6tLoV/WS3pVV3dNb4f+FPQXuqGbuqVPd2tfg/5N6N+H/lPov4b+x27vjkkFPDBmAMZswwHGQsNrBIyBY/gIgbHZjJmqqZnJ0wDjqGma+XMWjItgXAHjOhi3wLgLxgMwHoPxDIyXYLwB4715fJ6F8RUYX4XxbRg/hPFzGL+F8WcY/5ydi20E9+4DAAgIMBCgMMEMDDgIkKBAgwELDvyFi5AgQ4EKDRZYYbv9OhxwwoALbnjuve8E8RVwQinokIVH+EX/GBqjIyKiKKlp6RllyVWsVLlshcrVatahzwgqukVr7nscj+KfeBZvoj06hDMyjmyeL6vPiKlRyZrt0dgRo6NUY6A21ldi6LF+pIxd48A4NtLGWQk5Fa3ZPBgPx49OUhfNbuje/sDg0PDI6FduTgobn5icmp6ZnZtfWFxaXlld27IVbWhHHR3oRANdu/dMaz5/J+ffAuaMVqYXD504d+XmylErV69dv/Gsc3PxpZeffeHl1+btd+T6R6bmlhdfy9d+/LP8z+//ktvvEGD3TGxdP4lPsEl6UpiUJvVJdzKeLEIbU5dL7aeMmIpzWdVN2/XTnWlj2p6eTAfT4fRx+jr9nJrRH9rrB4KhcCTa1ByLJ5KpdCabyxeKpXKlWmtpbWuvd3Q2urp7evu6kozh3Ye/LGaIz1vOilb9atDvNLe10XY1xv4OdaTjnGyis13octe62a4We5CqmhVIc9XrnLnbMFatCzmxF3eI00YfVulA4nCWyxB/tyeWvbPabsuretVtnpu6Xxu8GZIKlFFQBf26zV0yMxMc3EHylA49G6K93h5o9vRwFhZIvYiyWYMDmDcM2zxcCUuT9kuqzk2Hw34HhwvOKf0K7Q1SNv0mh0u7eq9qEz5ZzRFh1SV66tkJxamGU489rswd2Jv49DfWCzDRAKyZRW8W6MBu27KbkH/7qaezYDMbBYK3AUttq/OwdWmYGoIaE3hgnIHoMAPGm+m1AFiRZqHweA8SHqFzjNdUlQhWSKmIwZ6ZB5YMr0c6dNspeEgQMdsNsFU1VHcDZTGHHJUx/5A+2TeAQXokjRHS0ezFzJnHAiZ69Q1f9o16MJvFz9h3Q2qi9bYivfmSA5oicO8C9w2oRHd2HpyNMsp2mzCh01OepYCrSul1am2HRpbnHhMF7oWXhafrBv1vXV1EXUgYdzyVz1C3NEBtt108GDTzgH5uqLA4Ka0l37TY2DrNNqPTz+mcvmFow+L32Dl6EYPJplvnqy7KT1XtOoy3CUtr2LJU33oH6eAZ2uRCVmClFwztmy/22GLQF+u39Zu9wcWJfFNp6KaCCDMojpVb291NCEOxTNt87m3P1P1p33gqgG0WD08jYnGChImoo7PrJBaDHDV5pPjWI/LvR6AfK66OZrCs8dQBqLzJfDXbx90Izo3GVMKgAJdgL1a1YqtqLEk36gAobM0X9wyrYmbbME1VaVV/Gt/bBGDmgTX60BP0BJKgBETtly34FrsFVW5x7HmGYKl/30YEGIA1yGBCQ40kMtpotkKEklBQkIoSo5c449hTGc/BBIkcTZTMmc4Unspt4K3GNiFq/ULuoCZqzY7ROuENvXc+WKE93bA61kRiZ6QJ91P0yXA/02PybzFUhKclpt7et82LAAAAAAAAAIIgCEB8NsTlJ51/HEK8INJLgIGGCyEXQ0UjmUE6k3yzzFNpmTXW2awWSVkD6YZwd1Mjva+Ne1GDU2aWfuvHSKPhjM94s+JtPxPoZYBo4yWa5Lqbvunwv05dDCAhlLjGPZ4JiyHTELQsdRAF04CZEJl+yHXoZzDT9eqJiDhw4ZWC/UirmNXZbs9N8hLZ8Hvqz4WIRBsnEfEH6qnnmVpi2oPalC2CJAUBUyBh2KmReMTsUf38xVCjRYiipKalZ5QlV7FS5ZZYpVqN7fao16BJi9NaETUNrV+cJtWvh12MdOH7/dbrvYmE3Qk03AcCTHjSDWysiTW4klQfVuVU3nqkJzDRzOBUSiGWmkM5YtIblVLiZ576vR6c8Tp0BqTINN8BnVmC/6Bst4YSaQ+IpLvmjkf+8cwb7TpCdxPkeFh8REhRoEabfgawEHGYUB4BgUmKZliOh4BDwSIgo2GC0ow+UZ9fIBSJJVInZ5lcoVSpNVqd3mA0mS1Wm4urm7vdw9Ph5e3j6+fl2wwwUzAiRtLsm6x5NL/Wvw1to5EhBen1IFkK0raCtDaQJgYk2SD1FWwVnuBJDI9HlkIwMezSti6IH49kPx71NTmkIP1O9npQAX6DURbPVoHlUmZMwZjWV8WjG6XUpJ9PynqVLnbV/i+yzG5QNzXSDIVZMRZQmqOdHCvlFuMtU0Vsk63s1NrLQZ1fuDiihY+TzglwywMDPfLYCC98NCpeGWBspifL+EqeCRxCSmvydL1gR3byuSPYWhqzzfPEL4Y/YE+VaC4t8MbFauyiFUp/2WYiYjIe/PRn8DuSd0yfgmf92688ROH3iENIaliQdLOJO510Qkfmwy+b9ytlefRL59XjYINDDW2jnbQHin8atR84BBwFTgCngXPAReAKcB24RaTwYuTCYRqvauAX2AfDAlL8nno8/dJzwc9RbUn0JD3UXSez6bVqF8jvjI9zQf598eMeP93BsuNeI8lfu9ZtAbsQ9/YOjQYZvlrL/UaO8gOlvr64cFCNDQ0KAG1YfBgO9Py/EegDQ/9Z2Bs8DA3zDQV7MO8L/A1cJHgbFllIgc/h/6wDHEUF4f3B76goAtt/AIGFBhIuNIiIQoOJZPwQYv+/GXALItNm9HmcdnCzxA8EUHHBCkxeRz2CoCSETzuBmWI50/t+F95POAQ4IsPZDvrbVZDdBNidnz342BPoQ9+hbLj8GYD896WANCAdA6TKUmyBZb5Xo1adQ/7zSrvOcERM7CKLV4IyNCFRRBlNdDHGlMKUpjKrsi5bsycH0piWnM2V3MkfeZZ3+VqUCqmkHDAgOYpjg0757IAIMAWoqdymisKBmlp7cB4KMnUNAjK1BQcy9UksyNRvcKCm+XzYCwdmP6w9/OJI6VG2+5JjrLj02Ivj2uPNJ2Q2+bbzY7XV2WtO3iuUbCBJdSzBgsxyFQ5k1nMWHpNv29nm4xj5lJ19GbnPzjFPcE1zrgPyXTvXNUPvIPyWv8p/7dxzlQvBg5p7qT5xm3iEkk/ZefbhMvnz1LwHgY133LK/t/A78x1HhumHEDb6EkSG+BbwEZ/ic3xJfv0X558BpB/3a/JTnDlZkMosyYqsSXVqsicNaUlr7uSfvElH8VRa9uVYLuVVfqLryeEVUhGV/JmHogId6h6Y0MAIDY2OuLiTEhmRHVoc5aH10RxZl44FNXQ2FkM34n7ceRIH8Sr0Y3wJ/RwdoSJDL4RCJYCFyqIQByqoxz8GfYwxxwoUaJxxBwOWQEIJJwYCyaSRQTb5FFNONfU000YXfYwwAQ0689xhjXts85g9DnjFWz7yhQ98pkOQlDp0SUhikhBM5yUrBSlKRerSlr6MZS4roYSWs9wPUWeChVf0lNKUoaWqjObV1CjKVPVo4H9HnhCt7xCYyCq0sSM5QgMXFRFULN+1PEdWK59mHE6ur6IXLocz61V2RzFc2Kyqe1fCFWrV083Dje1qZliEO7vVzrQMD/arm2UVntCrn20dXhzWMMemqI+aqCskISif0xm9FHKFh7GQJyJ2Fp11BnQHYiCJnuklHMIpfYYpZkdO1MbUWFhYgYlFsTLmxLwojB0xP7ZFWVlpAvlGURhiffCABRwQAStgDewLG1jhFrJwCdfoBgRACGyiB5BG77CLXtEn+oZjFpyFZKFZWHiHRziHV7iHZ/wSDXEwbCMzpkdq/BDFUVJYio4lsSyWR2UsiH3xY9TFT7EutkdNbI0thWpmjAl5jA1FREZUREdMxEZEDI8RMTJGxegIjpAIjbAIj/rYHwfi59RMLdRKbdROHdRJXdRNPUiP/CgIc1ab9uiAytm2Ylvp2fZsR9F+RelQ7GHtqY7dpM+i/+vTALtHg9TPHrD7dMvu0gVt04Io2Zt+y1cuVam6muo01Fqn/YRva7ce/e6g4TN1/xNx1px5C7alEGmcBBOoTaSVQm8qg2m+Y5QmXYZM2XLMkKvALLOVMduo1k677LbHXgcddsRRv2txyhnnPPV8oKIKSsoqmr284PNH48l0Nr9+/Ub5UNaycvMam5pbKK2LOEGqpmU7rucHYRQnaZYXXT+M07ys236cV8dD3AKIMKGMexEpSpIMHJ5AJJEpVBqXxxcIRWKJVCZXKFVqjbZsGRA1SG1SBnFJK/8ZIRLG9quuuq6sgCRi2VRkvVQs0i8bOZ1NGn4WHst23C4pef99+U9YWzt7B0cnZxc0BovDE4gkMoVKozOYLDaHy+MLhGKJVCZXKP1hCBQGRyBRaAwWhycQSWQKlUZn8NWR737645+hT1ZeUVKlRp3D5aFZXvQFQpFYIpXJFUqVqtxodbYrtcZtinZQs9Nb0jF50MasQB0EtEgTduekMlQs5fNDMh5B00WBIsYmOCEJTRiCpfFCCB4hziyZzTjGIAOoDsFy4IVCCJZ9/3eyItXfSOtsd88LDJ4NuzRjSLiHRSGH2ZhQ9rH1B4qQHRc++hsujEKcBEk5iiVxmHMUs2ybuaRUawLjEdKCCp80Cs+tM7epNCcSpCH04ymOOGKyTmcivzvaY5ZtM5eUsiM+9CMNR4zYC0S4RRuXsOKmua7CjSl5IzvEAYIzjztZPkOkoCxcK4NXpqFkNpY944MMtiYkT2DpvX7vNNZ8DDSagopWKlNjcAjhBjpMOilfGIQxUJYbpo0PjSvkRcx/DJdTSmKQpdA8hAvc+JSU4YJjY0GwYd14CDJchDgaepnyEaN5nbyxl5SFntxBGd9s39pQYWKo6aQ356ZxssVYwjHcZAy0Pisu/AwWIkqCZN4pwC33sRR1CDF5vNdyZEyx1gh79DzmIvZ+c+1xSMCxeGsIO5T+Yyuw85UbL2mWQ0HBGtH4hSFP6u6nY5ph38vKkwRVCxWXuChbMyoRxhE23sU+HRs7GQtRXS5/hdDfvZ6xIuWiUo1mZz1CsPkNkxXspcuDR1FJos+PkY+MnV7ZZ+PK0rA0O2Vvs2MszX1T3+xgXnOf1DXbm9/aO42oTXUy++2S+clsiqu0fQ76dQ74aVxgYHR+3lJn55CV/gvra9R/JU4pqhcpmK8X52Ro4QqpOSpjngXwPRjHZbI3v2EpxGipCewZ+TIMBce0HYZhZO/qXobssdyrflf3WONAULlU7v57h7Rz0kDBf24D1ZGxEmjK99wHHe+CryRr0WjG3X8E9dx0q89rJdece+7R1PdwxCYJo7X80qt77pFNNKIiW59rXntzV0c58ZiqxuO56Z0fd3XE3g194WErkbM2vralVHMt0690nqvBiWUxgG1NYfMtvNfffNQhbWUv3Llf4YyZs2bPsV+acAgfZiLDiK69R9GIZfP4CVs4Jlwz3P27yS1qz4Hyti3vr91h+w73VN3O+uy/gd/eBvXHR8Wu2+24sG1BKsoK0lzGp5VUa2sKsHuvjWXz9EN+KZJo1JbqGU2l6Km5ErHTNszylW7lV8ZNwx3Mcuv6lkMLtjuSgxduEWf1CrkOIc3FdyGG8pSlHBVRK2pNu1EBFUKp5c4l7VZ+akeTOiulYiph4yZwqeBRphyFpFIsJweAwwvw8eqikh+dOnuo8BP/2QkV9EC53qfzQMCMBkjqR35kkiAYVMJBI909PL2Y3j6+fnSGTu8G39ipSsNmzdt36sqT/wnL+6bxp11QV6IeQb3qaovGNdWPMROmzJi7xoIlQ+pa9CLqTdJHSF8GRbFHe8sqyO/TzhphQPBYQi6Gisr/hMZTi6M2iU6iGO7pIBRJIUmMBAoTqbinE288tSgqWonc8w0viYbWrMUY5UhcP2rCTCHBuYhH6qVsmdggAUY10sD+3QYKFmCtjqtUObgFwqkbDj+OZ7ebdrYP/k6mnC622X82fuAn2hc2PqFsJXiC9Us5cuNTfhixxpfvMqwsf/QiAT1ryAd1CQJM4rY4wVYgatLeTVFC1PuEI7eEeA7Jn9iPhDV54RKz32EvB4T0xD4qHFlnRWlqYiXVpNLW5EqulNLVFBQhJQOL90fpK67GlbLiS1XjK6EmlLoSUZRmAcRId3MfJqUPAON4YMMU1Nh+L6sIYKzaL0JWXe4EbRo0VjLUtBxDp8+s7Fb4w3Wo9k2wFLDx9S4uaIHJqZX/E8CUj5QRBOgEl4OFdAcDNLAc6FB/RIAp/otB9poZwptj6yR4yjyc//fe9Erjn5AkprT61rA6XGfq4YHpq5Kezb35tGGtJfzLpCBqEBKkHjIN+QbjhNnChGDiMAgMAZOGKcKUYZowY1g4LB6WBaPAemBU2DTsFlwUjoBLwy/BveBZ8Cp4F3wYPg6fgi/CjxGMCA7RAyFBiCMgCHmEOQKD8EMsnA88//78abhJalXqrkyyDFmmWJ7/gOkP7ew6/ecUAOXNwUAjwyViwJDEaH9xF+njM3dE2ENImrnaeh6iCklZHw3yFQZgfDBBmBhMAga7NCvBNGYUDUshqEcshHfCB+BjcCoRhNsSrI4JNUqt3FqMTIpMljzPAflDLv9nUsyp7rV5s+hmTv2nxm/hSdIJ7sTyxOLk2onxydUT5ROZf5dqZpdeu+9frL3o335hhRRcQP755ZNLztlnETQ+p38de3twePD6IF8HsMeFomocJzsGisj+vf2N/bX9+f25fdr+5H7vftE+YT92X+xp8t6/vXd71/bge5AncU88Abj1Dv6bpZOh1NYCEFPLDDCB/PxAqp9IbdunC999z9He6R+6hVxgnIeuLBsOg6zQG4A/Qja2u9jLBfccUHPNvMP61rSmjb3rXZv4jM/a1Dd9rzeHBlq3rSlMZSfTmM6uZjGrPSxqUXtZwlL2tro17bcfQeRAgE12fqSAoUqNjxQkWPXqBaOZFuKrb40DwAUAuHAKw4dfAkFCkogRd5MEiDQwCCTSpGVSpCiLEmXZNGjKZcxYvnDhCkSLVyhFlnIUFI169GhCRdVs2rSWvQVJKAC4ioIHrRAQ2kiT1u6SSzqgeOmUJcukQlWoOnWZN2DYojHjVlBNWbNo0cYeQ5K7AG6M4ME9zFhs4sVrCz8B28SJewgC4hF58h4zZ24HBsYTWH52dwGC3fI9WOyReQbfd9FFv7Db+5ew+Lew+Hd+5We/+M3+AZHfwZKv/O8A+T3e86nv+9znfu6L/cr8LXvM+iSQf8AP0w3kP/CfnCJ6WybA/++vAkz+3UcVyJ8OsyMYv1i4EgIEmr+vFtTj34WEeY6wLP4qFtNpZy6Ceo178DxExvMDKbmxziKH6LgxYj++AVkDd5JgqYNonl6SSbQmS5ZCZ8opA4Zj6A/+Usv9YIOtdqq1yx677fWjn9Spt9/P38HxhfGgXx3SqMlvjjridzcEPVLR+RdQCHKEWkSG01ZcoZ6UrbZH3bBrr6Di3bNti5fH4UsOYB+adH6Fexggwv3CuikzbERkVQkICsMNSZPuppSm+tBcqvlg2nZW4b3bRUGuMDvzU57FKq1QYaVlB+ls1SG6C3ccoP8yYJP3GZNoeRkbRSLNSUyiIgeZdEWBehsYp8BYGba6DDj2ewB7AZqwmt/mDAEGyacLoSEGja50GmAEKkC7SqiJ94eg5FgKOAKUsEIAHWIxYElnwgZpHrPw5mJkN59cddZcybgSRqRBCWbOEh8OWQsAE+iVymLsFldeV0L5WDC4AJmcB9S4J+UqoBduVfMuTlOc3GUmWd/jGFY0564i8uOG5hlftgDwCnNA8BZBsYhOswIQwhWF6dt8OALaYSwedKH7ODOW3cHE8IN+0E6nfF5xJfRNCE86capKMYhKsFEI3cRbBu1TKtGVrpDcceKfMJ4EBDz5VqvSlNEcgZU0Q/md2J4sBIi/OSuuRUiEeZqejHxEAabquj14d3ZCXWknVh0SBfQc/xJD0hMm2uUpMNfQBydaWoaaHrVoDJbLlPFWXvjkc7Wd1IPvAEfG1c6s2uRxV7mVjbzAxfU9vsjzwRrwV4A4Ot6873uQJcEILvfYBkDN+l7hnSLW07szHQYINAavQA2BE1DXZWI4ZMDEyGwTRAMEqQrbklKBrgoKYWB6uoCLINAYvGpq/iE+YwdBIFJdkjXpKXfNDBgEKQMZU1XrTI2YfBygIN8IzbjIvsebn2DGicziVGOSaoi8GrtJMe+yyMZ2o7DL+KUcvIXcM19CRxAT7YoNTQcEp9IrYLaD4pIR67lELxDHGlifUAER6tFtYs+phQwZ31TKbsO5SUUKVNEzySPu8Ch337aiQvNaYi1NJyDZUuPrgfjlZQjCJmOGA5ExiFi2XaniIpKhFn0eKA2ZKaOQRsVESFodpNZvmaIjP/01266JYZx/nxRjtcNKScAA8dhU8O5sdV1oa0JED/fhukPe+8t2nE5TYphEQy/WtFe19cAymvH7FXcWTt1nD4Z3Wkg3/QyoF8rSfWKmnXm6mtilee+apxT3tJYb5vn83NP23KeE6wEDbClbr6+rQuFl1AYWuPd6V8az0Mp4iEZVF0oTI9j3yijllD6kLBDKAqGMhDK2QpVBylR27vdVnLQ9KnCWe7y6msGEF3g02EWCoUYLa7RoIYFWK6ro0bZylTBCssCuwzRv6jurXd3gCvVe7NVR5nZ/Lyw0nKGxxH14F2exhmiFrkkHVRkWdh+ADs4Ca9yiUWBouV+pjZyFceDFlLRVkhcXqoXrtf9rfW998zlFsA1DST4M+snX29OUFjnYtcjD+7ZPz+31tioL3AUhPioWfFFUVXg558jr6/5aQbUejIEJO1A+d9wt5eWFVG4e+mE0QDA/P4gLzprIoA54jwWvFztN6hKJLtzs4jtsnFBLFzc05DUJ9Jf/y4xFyBBQaR/VXvanlgkl+FCUeekryLdbnJ0uIK1GOJO8EFDycBF9v1AFUJJ9xVku500rusFrT9AyZqyT6iyTbJFviRInXD2LxoOVeLDOtjj2/xFPHjKvv+AVh1IE6kHjulPayttxNgonYXwu6ra52QsOW367pzsodNYEOForJl1ozRglsFtLoDj7L+O2a+V2SW6d8z8tpbrkDVUcylydDrHHOWPa6liftrZ3glbgH4KEaWUWx89jCRG6JWyxCNbMn1jqLiphMZB2RZg0rISoOFQeuE3essXR3IKgEEl4sdzicHQ/A+vah1u6PFbooidTGW6QsoTy6qC9gyqKHJ1FQllTDPE1zN3KT3syUUa0AmD5UBI0LFbCmWJjIB1/tnyFqtAVXILLnW4FnBvhVbyCuZZW5xG967u1PyxX+LevfHthAe0/Na+0zUHAdL8epNilHrYtEHGSk72IkY2yc5y8Diut3tucMg5WY1xG5NR2mx1xQLNfzrlxr8YBmnLS0UzxMpycfF36/ZzGHJRrkIh45UpqeiAmv0eCBEL1GisPGiXB1TzU4QaMwe92I1EHZfmKrNiQJudkugYXzp+GFwU1rHOtBCIFfCqOjp0TQtGahAmIk5i0TplTUC1MX2o59XUkzhWensTqnvuWe9IKZx2KI55yDuQYhRDp6wyKeF/QByer1ebuEMoMw3iRLKV+dqKkctIejQctap+V1FC6Q4NheBhbZnapibToTUHwCCxSybqDu5za9CzoNlu7RnBnMXei4JwVZ0QTFKfWkYwnYzHiCQ9HzpiGQi9Yzs40RoWNHQWgtt4aQJkJ02oDVO5gmLBTmSPCLMjfUYUi6B6VMduod9gIywWtXAL6RIoyf3sgBvqTNj1eFtDC43sf/hoZc3KjhdNGtDQ6eVcwlSgfRyvgzcQGhSqBawnm6Mm5tKAxV8geHMvqNtuEXC3MAlbzKQMwkNVCuRiijnWqJNap45HQx5LUrq+HKQIGmWJZMLjOtQIZmtjI+wiDQrEKFqfcH9GANAl3TRNwb0vL70oz+w61y+M/mp+7qWlqieSrGTNIVdCCRI2zdTVw3OPyaJR7A3N8LUQZvtE0aPuk+0m+qaQ3EvmXCm7ogk1C1lljIKOsMMM0HmSjUdHdf3CsstIBtziejYltarbw8ajuS6Jik6xWxHj6XLYegYSkRn32bAuOtEV5SCvhzfDrNSrIMLQU52qGhABmgGGRwwp6+G34m68OvUhV9L2v/0HTb1Zu5BR9ZEoj3/O6708zMs0flqpMclIxEE7xB0f5ZUq1ZWyPmKCQMZhBxgpTLYeE/PinUCa/JnHXrqYYCHBelC0hCqPNtR5eYEAvj1XUGuHqXTPuGXpNuMBJ0EEes8ZJx5OZjtYx2chAuzwrSqH/Rs9LXElbfXf+2opglvwHzE1P/wJh6qd9fTYyuAbef20xw61zfs99S3u7Fb8U6pa56FXLLumMBZOqUBztxx0eq8cwJZDRuGwXk6pByv3EvctSeiNee/TA6W7aN+8gR4S6J84LAgo/kyaIxEs4+4ophRL+Pwwk7uPQp5wcPVcCh6Mr7MEAX5hi+yBg8otaHjsFBIgn9YnlBtjFqEj4LbV9dWtVK14vgbWp6cJvhWWRk6I81oWWxNxUJvkYsfVvhkiWnMJi0jgdcNLnu0DMQh9/Bpx56OCEDQaCgdCpWb//xFlsKuluyldPj1r9t3+r/NuRk4ym7Mi9f3jNu7ZbXPc+R41mW8+ctfQWJ6UUnUvMLQp/F1f0nRuqEG36cfnvWPMixWtYkeWVV/JR/f8fnNl4CYsWtzarHpSEGKldP443V0NjOM2JMAkanKIfczMQOGURiuDt1iPhX0j1fxx737DP8PIAD8hpwYEG8/fUlAvt7wMgsbU4Bg46jcskoIEZmKSZJZkIqdeT4Hnpn4/Dv6hBP0wHUZIG/SSvsE/RBthg7vZwoYkcDhdf4mw9LovKTCagCBOeqGH6E0iLkcTeo1bA4jN4VRMg7JqWFn/QupgY/AAW2TOmcw2A3wlhDANfkEGZCakZ0vSQzneKuNO8TlGCT+f0OGL7uleP8ia+10EUFQK1kHZcURuaBZfEu8FBDEEa9DE/1RD4pUksRnek0V/xHvZxcjKAkA55QDFICoSdkXjSg4j/9ybe4MMw2oTR+h29wF/f+jcNCzstcBouomHJOv6nkP6n8fTa9M9JRDp6wJ+Pfp8OrUV1Yi5+h9JRhf3e4vuR/ro9kyYCTC4SNaAEEkpiR3EgOoADIRpRiL1gEpMk6F1Ny+GV0tlNqtkwtcrgHVvZuYyQP121Bp7CKyU8fbY8lodukc+RSIl8BWBt7wL8rEC01uAsl2Qje96JRAWfDIsgp6PQoMKL204CU5ISXjVkuIAGlXJ2mwNfZvNESeLshKPE5NNTS/3ZIh9IcLwQ7sLaqgdUk+ERxiyPBNOUlnBklrJZC/63WcRcPBGFuc66xM0MQ2PrQUqW3xDB9cQuN7ivwdUY89bf9mMq1mcwPQDfKU6vCNN6xGpZIXM1+ZADMClVZfIT54NkbgerD3r1keGXYYVVy1Q/IqYR8dWdKWKf4UjNhJ3iYxJ0fyFCduRmBp4DbIlu3UkLcEAMALiU0wF/KlVPgXu/BDI8sMTeRRJiD9tY2gZr/RuyubYhYUIpl87wUhBkCk0HXiTP+HBHieZ5Yk4IP/BZxtj+RPMHRdGPLXXWaDYSUxJ4MD7Ej0ST+d6zyRS5WQBRA3ObPkYmGz041CS8OXEEvpGqgDohwIBKjgr7JsK0nsemHRQj6VOskHPEy8iLFuLLJomavW8JdHmKo0x5xGtZGWqJy7IlhDqRNBU+Xi+F4nyjagJXFoddRj16yNj9Oy/L7rGG+ecPjA0ZGETn+SKgshQ7V0246IgZetQ7PGb2zBLCgMQcdAElMSX5lbeGTnzJSQKbT3JNK+8Tpv/9wpCA+HICNr9KHEUfTiZt9CsAaEl4fBtJQzKlF+OGQjMTQqeD4MQ2ygYd2eCGAasoPpexzoKgXIpJpG4ClCAKNQI23hMLOPgmkaB3SivgF5AFKqJ6LRBEjTfhUJENX/2S+wFT0Y14VrNn9t3cxFJVmDMx33knNwIqM97hvhiC/nN5fHjLk6ZHBk9RuvU47LPloMGLP9ikja5/04UKEWXi3PkxVZM1R4/DHdMI8h4AAi5BPoRdBxvx4IcUcIk6CIjc4cVsRY62PkroGG5KuwNAxXTIJpCLqTPUEgdcORx1ew4W8vrQVo8fvAr5NN2/Y5FNuOsBB63WBotLqKShinMJbJGmp8jqJ6Rc+RLSoo7M3JCymzXFXux9gSm6FapRfcbY0wdeKMX5aYhMWYjnJVIezYlVVtMC8YZ3A4QsQ77Tz8QbUFADDQBArPXNvFJI9o0cS4xGd6BbV6UM1rr6bzw3Ptspzdh8sCSrxRwpfIeUSNntozq8ZxBmPdkRVZ6cI1KcTfC9pBz2pKGTj5vOiz827EhwfP4iPzeiZDX+2Cdmks5X7fM2JLd8nbgShuoujeX9Rv8l8Waodi4GM2+fTTMr7HREX+KkRCklv41dTpIWpyUHKtmSAdHDNEmKJadKknxpl8iZga1Oki770+LMVK3uM+6geBWZYMLn2PvfD+ZV8KR9xFqw7e342fQ4jy9992OonFNxh5djiymPhXCfOms9OISUtpCpPe1R7iFGQiNhitQwksIOgDmaZYrzAvNShO8Y31KEBE7PS1zzrCLxdEDRCeYdn5q8zx02yKQ9OiDD9U0oYT9GgXMHthQMQfnv7+JWGtUimMiz5eRiz8kdp6MFq3sKT88HTr3oyPLjLkciLxuehPm7nGlN9iDtXWNL46FkTPU9uuHtGIjqe4mUCWq9cngqdw1JfXhEQg2fljC9GmwleeiCbKq3bpVcBOdXMHzEfjIEH/NNTFhsqmfP99g6O83G/5RmI4U+0xe4gg1vMzQk/slp0AdpUz88PfYHZHU8HETHR2GKDV7SpMHRSZTwRS+Nu9cTO5LL1xrrt7Aa02OhTmifbM8FOI7CUzyP3qIOqWM+YKuRKZ6o4AguQmPjPe4N0sAHmagmQtXIdC4EKozQbfNCDMARQ+J+8sSzHQj8G5KWIPsd6zPu7Ci23OuGUNr3EnNtleF0AI6C/kACzEZTFgmyf5VcF73JQhJaYSdheeaLFGJqkSkhBCW0fo+jdi3z30UaFBMGStvMW4HTT5OQsWtHMBKjO9lNSvquTX6YJhIlKwsrbrPFXYlQPuOuPC699mSUljyqwrlQNLnAZzqOuFMce95rhSwoUYQKKCfl5i2cjHFXw2gIng56kgNCsT/8S/Qqei2cKPo8fkHY+lxGGn02PfOtVxyFlCkfLZl9q8gPpFRDNVRANxCcqUOiKm56mBtFhIJrbEwajuL4AlwfgPq+Og9TrRHvYbyIFzDXMvSk8r468F86rbl8dbiwWsLOfb18Wtwb3S+q3soLQTPKUcizoPjSVE+uF/NW9o79QWk8KN8u2VLz1KhciCZ7U48QYWjqY2Pl4PwYhagGk7z/rIX1Ao7t88el3Xrad3PfmdJaXo71n9HMqOjj3bBV560dHppOD6VuQk3SdmbiXYRESIR8mYYYT8RoGPJkTLkmiF5w4fRqvsC2vIjORQR8qdei27yoWOSqUmvF2Oo0KkqxWSdF5PykQLFv9Ro3R3lWb3Mc02WUZpdwgALXuD5k757oK9ZhSFGl7FnG+xJWmaaa0kSfVlpwka9cnOLR0+4K8goTOEqAENi55IAAv1gurQ9/YT99BpRpvkBPBBks58t8sHw4ON6cBVUHmoh1JhGjLpK0iX3ioZ6ySJt7d1nbae2SoOVtC3XYCYssL9ZDSJlcD1+NrHKnJxUnEDqJnWXUvPJ4KHFWwUD+lcI7ECApRbUnStANoSbvEZWmIzPOC4HgUcWzrCrX1tRPAPdmoQLQqmKwIWLQIvu8wJIjc3aeOGaeel5Lt5BbfDxF7J2cqgxgF5SSBpS+0KBSTfF7kwsrRGWOfEgVElWQZuEw2x/twehokNrhb4wxnmNiIuwZt6Jo60bbIsiSfGldKCu0K7iPyoWOtArE/pxz9CyOCkTiQjtTqC223x8lXNZHKUbIsorGibLFmfCmYXFyZcrDsz0qItomoK+yLXdo15hzhEauTMjybjuf20dvopwMJObw+pPTapzTxwsCiuusVXoZwSjs19WuCXhWNDdN72FTFw+eg8kR+O+Y08kHgd52cpY3li+W901elrebiiXCVbe8/ZiWt52flsivuiU97OcrUN07Vqasu2zFyvrwqZJlA/CucFk8tcpX8adOCbL+kSpk3f2lEBUy6tRSTle453C5l8dlOyJd0V8xUUaVdLmdI9Dl5jqZwhzBLq+VHCnnSlfSQNxp7Nf6J6EAvaKUf6+u9grsTMt0Wlw4agFipWqlVm1HF/JYWCsPy3B746Xgs1GCEG+8gu5S/PhNZmXdtZWK6yqdYAlwdPkvKAR7FZne3H9v7s9W+JV23bn1g/nxErr89MLnZeryBzsYHZnLLaPxuwC16INVBghGoUTMZAcza3OtgiIgcwDR+OgIPwhADvRwgh+/5/1jeygkVoPVldogNTUdwdbH5sYCQ0uE8uvtEAvZD42qxMUFmjY73HinqqI5q7FcIKMsbH2Gpn6QWy1nJlpnmTdRRpZ76NuJFZU+5E7J9yeU8NqhkhXediXcbHsD02DRQMVS7tSN7QQ1sqFsVm2hr/ra3RGe7sSxlPxMXT0oFmsaknOVL3zHIkLTa7YAX5OFy0u324kSc9O3dc3lyCXLk7BaWdyiLey5ggx7yL25o99XtqZR7XUeChfD1gFR1du1PucsU7Ep4I92Rj7+d1lH3iWUBjLBL5mE83gfqwoOfuEGHiL5SnRTj+hmH5yMhZO9eK6UniRSH7q0W51UdGMIm3spyBoO8Xqoh11UPiizgCKtTazeG1wtbfBTeJD7VORDsAevVQYoKypulqKogKQiHiZ4IahuBEGHrab+HM5gCScGuhtv0F+hGBg4T8MuMsr/QiE/GAhE1JqqDK/QrsOtprsxi+6XAMxnHS06XUGWCZgRP+INmgCW9xvaDBUHhvuOABapBjhRdFozTUw+kRkTY4tMw8yyg/kmRsG/fzK8//tJ08nfTrBFxXNbXxZzHszXdrk7J0B8NLoczTqayW0Hk5EKy3mEbaJoADQ96B/F4vEyj64VQxuqoMG/yQa60PuHQk3rwu4pQe68NzMineXqnj8c52smUfr5NxYkapevdDVKzqwY8GbJBhiaouXirnX+d7DAWSdsvGLvjQ2F1GO4snHCRov+nLOjHV2D/OIQoOWwfZpx7SKNoaNtEmysTTK2Vri4thcUuba5uLu1FRXKgj4my5tEjMpLRaiEC7XTGNic7dvE0Fr+EgQ2kKIXmHRaMpDOhhqZmmfalj9Y6B6Ym88KJzYWm0pKnJcJmlxl41b3QhD8Gdmdnaeb6T4EAjHoij/R1a8pK/heyMXAUGMLVzdLC2/Pa6q62DG719BiYhJ1ho4N3+2YqV5+/6n6Tgcd8PpRjCOZGHnYbkRq6VUtROWnqqpnzHXujZHPeG1ddUaNEoW8Zvi9TZI1h+1dnwlW4mfOg7cVOeQhctZ0FmmIlAPCRVJEElgoN08EBMzT7eggiYVykOiWZkHNcv8hAaUUqN0xLd6IEm94PGV3NBVnSIkzUmdQ3Sjxo0n/XR45sKZO8vg7nKOQrBXrJtM0wOwPgh9Qk/MJ0T3egWlJ2JDym1x5+4ILIv8tz/95e0sPFqXm7RXs62qhLfAa0nwbuEG2IPfObbwRi6wPioquTArBZ0fFpfeEhBOCvX1T4/ywxcFCfgcSVP5Hc3d+bvZu3bdB3BDN6SDfzJx65g6+a1EOpc6YSBEeDD7QGvtw2AKfTwG+kHWWbZfB52JO+Th8YjUl+WZJcyo+K0r0+kNWxioN09lSwRaYvFmLU/jcR46Nm+f4QBwkfNgyLtV2FLkWbS+X85t2SD/XtiNoEeXuWXKbnfGj+wXsAC6KuJ6E205bFxV6OBNT00ZIqm6Mja9pTCLUtYG7SJV0+NZs1yP4dgEIgHwRftafUkiJRyJ9YQmVEU0nT/fwozoxgfrZ1yMIlVgYMhZe2JbSL/zs8wypKTUA20wipjeSsIENKekxNwoSaYXJ0VH5ybT8RHD+NSl82CIuFdUvyO32+jbn4XTjNlYhJvhwOqbWXdPkrm6C2oybLJQjXz4WiHdjbMr5FzvT8EuldpEPE/y9X//B7P7pDCJfDC8Oa3unDi0OgbSKjeMz7h+ZL46O8GFCON3frtBRC9vzkiBqIu+bFhvgXxbO77d/dkLoYGnh98G46floY4fv3cZWKhrutjt8DSe/O6H+ZWvgYtjuauKlseE0jaePLyZ2VLPYTueTbhnsxcYYzOISsgyv2flacsrhcKMca9eejd9ThMCN0Vi8faLRBMyHEuZobhM/1pDh8LKx8zemNvc4qH8cC0rudF6Ub7i9W+djFE2NOyceQq4j3MioCQxJqYkl3KwBAhASSU9ylPQy0s/1ht8wZP9xixQYAswkzOqnid43e5ZwdjXp6K/lZc7p8PQbgVhSJL5x1C8Knx62SAzDRQElPuiS8RTV9n4dToA2yxJWdjrzrNK7Q7n8z73Nj7guP6uMPXqal9/wvvEy+a3GQTCP2tvCSOHwHxz3OqlcazEymtmRph/z9H3zHyfbZ8qS2vk8K5zdRe8aQ869fqwfzZ5kl8+Wx4IrX6BlLLgpeih/Q32oAG2WDV/5y41t2F9vLpEf19Y+5r38rDLuaD+vYO54h7NnfKI86fbohat14vaO413HXWfsLu4u7p0AiwDC8z+VZhQD92jeYTjvqkW4Sym4sSwZbr93VtVLCvMxNPuqF/nxIkx9SBFsH47aS30yIkQAY72vIRICn/fZKrn5wfCjPqk+oBQOrWQPm74dKlC3RUWZ0lYr2PHTdJxAfR3RE3p6HZCL4vsF8Uflh3zKPfzKh+XxRyqefqkLP3YJv17MdVgBI64NYemR2KD0uLBqoDbo7oz1cSFzndeUIurxAtN0dnx5GRv+Fh0vUA+1LWGXHmdlWd3jcOZ6T9VX5YTj/Tyx/byE4/IyCu4XKP0nd3P+Db336IUlPFTE5wZjGnfLffYKRizWPaDWFRgJkSLSov380yPDSSAZ8p/8c+jUU0QUNTQlrTnOE5PmXwBtl7bkS9IIddHOchwUfD/EfM9rclf37vuUkmgX53jPLGirrD5PpkyggZm9PMGCKvEJsMw9nx2a/TgHHkJYLw7i8dm1Hul50t3VuztsvevD4zcIvJQgkT6IqszKiJbOvpR4QAKBAsyklzzRszK8lFlrPuysFA96dk/AgeTFx9R1nhfbBbj+XToYZXHhh3vw/3zW++Mha5giMk4RfD9yTi/66dWLdOt9B7UvOgLWX5WiRpDctJOvA42GkMozjrjK9a6/gLn8bxdItNc956VFjgGXolRONKoJeH80/hCsMqu6s6rCYZuURQLi50m/TvnaT6HDkOrVjgJ73dhoU5KUM1s/FzWXmIAQ30RHAetlgbIPU9OL+7MjR5F1TGsSNFLOgmLx28gK7+RMamrDO36QSOFOuQ5WIP4dDgpOiIJNwEzalEQouPS7B22zKTz7JKTxm5rdt1xd1b+SRR5Y1ExWDtwg+5cUXj0G+1Psax79dyFuhb5BGUO3GlsG6eTgkkCI5yZigGsLcpAt1otPaxL/PsvPCmx3vugME1M8XRHsskO/iwpV0cuYnN2zrNK7DFwgnyQUjj7DL72qepV/46gGeZm5ZHCIvKpf+EC+kHHkfaYrd1F9YVxsZy54iaE2Uh85eHqieWr7pJVka382fseAb8QeNV0jLXmkgtegZ8gjdvg/hxKKO9gmJwUXZMl8dVRcbAzPyEXDtxWHb2Xm9s2WVYgFaofySLAhAm2qbL0aaMu9HfcCw3CZ4fjMIv9AUAs2AbfKrv0H+8Ce2Eaxsi7aXHfyxjgx7JKPS2KL0EEUjP989Ok//pOmacQMEgAv7st0hIJ1pZ03tsJB1kYqqHWzc2G9v3kThw8ihoVkZ2JiNwPxIVlhwRn5PmG0u2cAad6Qw4vKD0fv4evLKtsre0XLHl5U9Wbn9S+on2ngIho6wSqS9qxZ/hGsBRs0pDSGGkrgfcxcXtbX3vQZcEN+/9krUnZX2DrbyssjydpI30/HlydfsE6sMzs9/3nvSPdBFbRw+XLGoCveMsbxqi9vnpAlZ54cxkQJZ17+YRhksqKcXO2p9MZ5oSWhv42/E6T5ZAfagBFk/cO7TewmJiomPwIfnR+F2cTef/MWRAgbg6d8SDSc7wz6kTARAE+eeWxxItVIzm9qPWBIuso1XhUYcp6geNkAoZjTkNP//gHwzwGv/H8QWN92hSP/hQMDYkefZq8bzE2MIrrHh2RE2JQw7sjO7yA8oq+HAutH1zzgql3IB9e8oN49gGhi7uJuibQwc6Q7mplLWTm5WVxpmzA1XTHQcafD6DpuRstV/kQbGCQCVo77aCxEWin0xNxlPmDSxHTV4bYyd6M7piaTT5RaUQ8qWs24g1+yCnbNxgfNJ0IRlGjtm8i1u6F+NbPHRPaymQ3GXlCwTUyktXcChHowMn9/Yvgbfv+JEZ9smBc7DVFPffNiDaS6Vr7DO7DGu+LWERhbzmY77gLfs7ab0Kb3dzv46iKnstPGgsVHgs6mjwIsVRCXGRKkxHJ2wrMBygnED5WaOrvsdeP2ySOhuR3B4LRIbwW0xDV1BV99Q2FzEZOEAWMbfv2rBCd9eDkVPGkICMjN9E1G+SbnZgYEZufedGtozsAUFgUGlhS6JjY3uSaWFAUGFBYSvSgNN90gLkmdgyedg0mJHYMnHYPgo7wKSSVHJfNtXPOnK7YwDdunic3vMpVzlEnK8mDwgLJL4R7xt16VQIk4ftQr0bSk2LTuFe9qaepjnyQTLV3sKu2mrW0mhdXx9i5yFYcbSlkQ3UpezI72v2qXbKJfqplzD3exMvFGJ8rGSDc7S7traZpJBejO0w2gJbYTZe9mozauR7tY24Y7pV4g7cCvxzra2kc6pF1wYIcURbeZOZQFyl+gtYIR83MR/CpszM9ON7/2Lpo+Z1s7Z4emJ+BdJSkt0L50zJvW1kNMaq9kSzPUHW+ZLcjg16/NU0df95c+pkCzetSKu4Pzqj/n1QS36eZ3QEiPKEB3zTsV5zH2S5guAFU01NJWM7vSXcPpW5OYlFqaFKNjlcy2yVRUzWV5W27/ipWbh558OrcFW6Q8UDwIhPfBm1/JNsv2ZT/dAqBmK9DFPbXkB0Ln6bZ0IMuw1J3z1GkujrMQPn2Ka85Pqdl6UFd/f7sWPXz1dfcf8BesPTe20NWysxARMOKk4WcWBTIUyGv6DrEFiX84K/pBPAjwoGcoVhQAK9H5OzKafHNk+C/P92ay0jl9N1c9fVdXAz0XV300HxA7tDikL4YmDZFQNJTwKkQDppfCDtbHyZYoP00dMzMNbXtzlvBhPvJkFTm9vfqmG64o2rOKIFJaDMqOjW9AMfq6eJboSfG0PEO0qbaWtYGpy01zAzMdvLmRuoatXu2YYNp4YQa5lYzLTFcSMeOd6I9OnskDfERS+yn94xRsJNqrt3hgWFAmLoRU7Be4KSoHk9dqi7F3NGWLRiha1rq5xRup1QOxtZMn3J8PT3N9vP8csNhlAeZHlwHzIyQ/Y2Hk4EYcFG+zFQfc34RHRNoxtfcTq24AvRXZpYXyisVFucXFivJOhVovnIOTZ1i9Z5iTA7APkOuTa36JaEQMzD1lgl9/mkXbvcp+xatv+P6RN4kYkZeKgM51tcZyXQ/MJGXODZsJpov+CWXZ588Jc6OvbcMQX+aqREuLQPthvYHO+ifW57w+u1Vk4shpSqLgd/Jb+TyH/SFxPJlEnhs5tBbdKEBbK5wHnf440dRZ5/UA466wP0fY4TrPfAjKPQg7CcZw7H4jf5wKKX+NMRvZ7pEPdxgeFVdFVbFuPW3+kQrpyBgUDVEyuySPCspiNZSOCrS6fslMUsnikhwqkMxqKBUVYCXx8qVQP9TRMVtmMBGHMRfpAwMTfj4UG9YVGzEUE9F1DKy+SEn/b8Xg5cm+bWD8di/y8muSxeyjbDwdP/ZmjhbxcSFcVjarWiqaSHZMW2MeKUMSOTZlXlVJqbbR8kJ7KI9N0kkVVUVX1c86u/gpMWZIcrZJxnc29xJoNKKjnGtje0I+jjtIM2v6GTLkEPNvZPAZ10xvdma8HzbYorZW6cVy4DYHjpICnf06AbpAT0yxgjCW+fI77rhO88/f/3XK33bK5/LeuHbmfqMahtp7U+S36J7QkZWR0OQ2kexvc87Nf5ulW9Hg67K1RdmmpKDuevpUcoo1XR9Q+gJ9PZbsEfRp4UXnxrlo7AbY8GUfRpLdgj4vbptWJetA9vdaZYt5BwUJx2WDrgVygkzxTtbioy7ZckjGRKfK3P08wnFidA0J+1/4dcrffkpyRR0vjLkUqpHKkJlWKYo0p7/FWXqnT9Vct/Rkzo5UR0w6JFN2+OPnmyfBP+a6pJSKzPibGSkxhc0BiTF4TwwhJpSc093YvDKRZEEnRnVoYJc+3q3DReW5SiDj4eTxXH+L+nTfXqXAZMo9U07Zd/Vcgpi4ymc1LnM+5dONsYgRqhGkNNvZtcs+p5P2pZAjv/aSBQR+7fKFPb52Id+cu0iz5C+YtrXLZZ+q6KmwsrOHYsK6YsKHYsO7vlt87f+6nHO31T4Ta5C2e+2FRhcCTIwDL+PPGrMECTtHBwRjEj4dlb+jTiV3OUqjkKrWI87hJU/y8Uc1SB7mHzoH0qk6hQ9kCv6OduRsxV4MQCoFrsdoG2Zxx1QURUQ15QomdBtb4Z0c0xracY5vJRJb8iOJdg67EZX42OXDUnblQFI8TlaidwXQFD0doQxUAyM2792VMy0mkmbBLmjzwKFWaaTXLmcpacjGq5240aS2xh8150rTuzE+DDBEh+q/OhoAqf2en/GjMj/h215Rhi1ZFQt3JlamCbpJx93SddKylN5RuX6pi9lBOpqm21y2dOP2qZTum4lc6nJ13eRKXv70am319HLSvUpiKkmbfAebwEyVxHyfM1ttPy2CCo3L8K1tt6ugA7nsX+/qsQrbWuXf2u/5HO5tfpy/aSIRQ4tDbb3RKJSmBsom2tpGQ8u6/c0dg6zOYXzR/AcF5cORDJ9r11f1a+EKFz5c1EbXbXo9rTVn+E5NiJz1wqGV6mNf9xpafGWhHpQzdCfmTwow2VIpUlLwyD5KoWoEk82TopjFJmRfFDIDB7Dt4miLPm6CleOSE1LBZdA9KOey7ychjftHKcdACl2F5fRmTrQ+rU9eXlwIbnmFpguztstbLFvgWKlA1F8jd9X4jp5SLCnIqCqT5hlafweB9FW6t5IhuS3BxtzEzM7MncKQjFQJ7a4+R3mupLpSyOed36gFvC8kMzwwJcUz3I139npz86O2YZf2r8j8yOlWjlr/16dmy3RUnC+pykPAWvpIBJ+y5Cwt5X7H/kL364TdfxfaT6nvp+Y5KZnfiv52Ue3RHgj50VK1K5P59fmszpvT5s+fPv9hzTH668dYW/ZWvIfYza+Mq3z0mGGLnmjEV5LF1FiPNXv0Uch8Hbh8ButAnM8gznNEZL808HCt5ErYTKguqE4g7jVL678ifT8r9Y3Hk9x+SrGiuNj3i14EMsKkr9J9DYygdFslcrWM6Fx83W65omuIp6QyLmyz4nDhAuaeP3veovH0RTfa7AvNDPI2QGGrkHBicDc23b0i+42QAJ70hmYFeevouS1CX4NzsntBaxf1/vU8EndOKUTLYS6jfbUV6bd88bHki/HEN+THxHZmCybF1ZVmYSt/PVYpwfnbNSuvc8SSC7ldNWyxwfqudKjh8l3vx3MRgzqM5fwVq7X4noz6/FvjrDsX8ekXKGcrvscgxfDyVaVchPnluMrboGn/g90Dv+lwv7gZz1x+7DcTFTzjty+P7WeoFr5od0mxvKxoiXNjfJU73eLKGcpZ2lm6u7S7lDeUx0Xma8flu0/vglr/ysLKgs0CnkKedy/Ik5nFGCNMKdOGgwAD4rmMpUmXLAd6HcqyC54OPB8ZcJ3gUcS+G7dYtfhJiL0S+d6oeG8oORRLzMYA5qTcD0Q6/7ht2MUDRSm1nG7wpzc0C+ebWeb+cxOMda1wT45jP4QWOSW4Y1oNCA4vkw+Z5dfaLsFnqdFmcOa7P6/qruVV8BTi3k7Etg5WbU3DVPNJ57BQJZ4cY6UCzV+kmssEsWZOB9AIvCucsEdlelJrjGOGkrwkt+PQD13jOkHg0dqJ0igR43iyr4ADcSGD+Ggz/4fMH3R0ocl+a7y3rB0xWOnWgz96OQc+Xmx32hom3TvX7uyUruSvJfmkhR6yExaXTU1yFvsdOLXcI5LHOLHwxMdq3jaGK/v+2mH9YN5l2MurjMPZYG61VUiL//7dff8W8IdI/an2XDlQntgjFd68zohvNCnaOmDZ324YPgB4E7uK5VTkv91YuBnkeX3DxcvTWaCWYkrkugwqM6EUOwV2TfwmXB+6TWXQShO3pb+82xr7nqV5vr/ffortXX12tUrWrqxlfN+0n1o9aiiw4G+MBeNpqt3m/Sk7k6mlwkOshRuyueO9+n/bkNaeH/1SFzU6DucBeamg/HD84eR16v1gHS+Ehtfd4JSX3FdeIi8zFw8OZ6zrFz6QKzwzMkDeClXxQGh4boXcTMiXscJVN57ipoKY+E5wiMvBCQfpVdhjLRGh1NplEKrAUSJVzV5Zu1ck41uAs0rThxR/E3YYdFNcUZYL929ulexJwRHOzmRIUo2UqcxwJbcxq4a/mr9MhsQlX/mJyHKarFcUk35D4q224lVZlSHDBHNrVAupDGIRxOQEqTMlYBWJg0QXxKzhUeUpVgZ/nezzJgfSQgYJnMN63Pao/1hqoQ/17rfdsaAOdz6BucY5tttbF/CN/Gn8xfZp648taVBFipufZo2BK0ME4xNEMiKaFWQSEjdLRZlCPPS92aWI9kOjeSVyyV26I//USYrIMs684oBIkUxzPIT6safgBNFSZF1WdALuWxE+FBPedSyX3WOUX2g/xTY2LpftPhVKgSn7V8/Azb6QzGCMuj76O+Irp3QAY5CLPLwl2as0YI0f/bndIHMu98Wgbuj4HTYocOc1PejFGjMfJF/otgue+alB56qZ/Md0auCeGtYbZpmot2qo+hyLbFlBADfAXBmmKJAB8F256qmzl5RR7XC8dIaScHT/IsBlIqNjL6tPhZIgsHrLO5+6j3cYvMdH+ppN4vFDv8vbkezpu3fgP32cJf923IhsJv5snCxzGnA4HZDyw/wbAKJlpBThBFZqZU8I2LHp1dkvzlQAgTz3wgiu0RW0NtAE91GxuvLb7o3GU+UzCOJ6+YuHtf0XEKM4pTmgGyga8/tlZ1vjeIQqGhYCMFFHhY+pOjkTfCOdDg6kJJUh73jxRTTI+6piitsUNIOdhwVrFdriv7+xOX4LsLx2sHUAVuYFqB0jUTw/nIuMN5IbAQv2e0FsAfDb3oKJbwGNAzY7J1f7ClOdTR3K3OW5Fncpfhnr5pk0Ow1HegZt57ri9Mm+eoYndg8ptSOGBgThV2IgSTZ1qakRS7Ifzv3UUJIl9d5XQwPCi4J/peMcAeO2FuiHX01WmmFKASEqIv9GqnBXXCiSww4dtjPhFYzz9Pxgbwm/6lZ7JdbLqNon+FpzGrZHOUB4WOEiOENNmEhlv0I+A6IBPgHemjc7TXL8p5+iwJKTHJXVR5eymF8xWT7ozsTqxMX5wcAEECExhjGsUYFLIZqjRX41X15wDv5Ns/a5AI8eiAa1zeDPDY08xnUE+QdSPjQf0g7Jl+YrBbYPSD4zPi8uaCQ0mKkBGBV7paXNpKV6eaakzqSkAVI51gkRVSPA36ZFSWO0Giucl6cyrLdSwU0tfBJwRTMD5rmSOM6Lqzl/GMOxdpdVnCAgADxYAmQLgq2wvVcjQOcxMHqmQAesc4zewiKXVlfSOot2ABHkmNvXFsepR9YwbCaQLvInoOI4qz9fILpn315X19zR3czc3uOaro3BXgubeA+ZqkbOT/bTfsoGyWXd6Tmj/aD12DXLzC5ZtsFrd+lP282qNH5cx4qh0lV0VCkjWXQpRNs4vaErhTQ5+KA4083D2NzFzdjUzd3MGLApC53WhGklwSXXn4OK44aR/AiUU5CFiMh3C2/T4I7ckoLuvCBzK+8jEUtRxyCbiOH82mwL5+s6Wi7W1yzcbDR13a1YK9NszENRFvoGqGtqqiD5OKUqVQDf1YWGO0aVgEyoTxCpQ7lx7JV0obFc+ZyZq7uZsYuHqZFkG5s7uoFOs5xSqkmpUsWYrg08U6KJtHvBCi/vulIH6+MUSxssPJIP6pmL1tzU045ycr6uC/XbusxM6thgmF+DpqRv0Ew+OFCa7WqL47oeRCaRZ4dNBYgVM8WsA53XYhW3kSkNfmzIbTTTG0PJ1el1z3kGmXcbelCimxG33dOU+N6FaKXBpdcPgmaaKMGQPC3/MEuMvpAoasjRNTu11szC0wi5vVYgucP5b7QsqiCOHBIkfO4qWfBi1msyVdjBKDV19o6ec1jqTWsLmueTfeWy1MlnRQUOWtmnGS069AgvqfVuKWNAREFcZ4i0rPMGJ/n/b6OAyqtd+bwPvU3NXwdVKkIVic46YqI6MkqkRyplX4eaG9/UXyI9VXuCZYOyxYZl3sjKvx4udB0RnpEPrex3c/PCyY+2/3CwFy4zFPp+He3lwlDAyUl1V3lB+UD5zS8LP3enaT/3F+BZoV2hJ59FIlIi/ILT4sJEwBBg9me6aF7PZFmv2M2VbBgghYRVBiOQN8VyWtJKbs3XiD8gr+euk9Zh0+HpEf7exOAwFAWNDCOGeGNIwXgkUIEI3/vmVkPd5oMzH/cvDBys9E3dzS2DB9jw4n+U/ojjweKHqv/jxAVjxd9XJYgLEc4uJZ8VEFeS2E+yTtqXABE0CclsVD5X1zLNyHK0Er+ynzFa7ixgz0VLQmkJd4fPH0Dn9s5d6BO/sDe/LzF6fhNchUEr+aJm5yP5Kqsi+ebmeCMV+SLn5yL5qoREmjucHN54ptf9jXMINdXyIcAzZez582ucnT/6koiHHk4OerR5A3RX6odTrVK4UBMnkbqI3hDPa4sKFhFx1ZyEpOJlTXqFjASZtURsrkqhkHvxVf80dow+78U0MzDXVVU7aCIxDQi63+sPE1nECoXV0DE3V4cMI5pXEYI2sDU3rq/UgyVF/WE1jcpfba9IHIgND7kuHH+jSLslTLimnM3qD3Jyz0d7sm3dmpCz99HA9bHPNNYqR9rYyHgnVWuyHQIHhEilvSI5pZvA0ZiX6u8gRXrm6/CenU7y1Z9WNhRIzqBdYFp4zrWoV5pyY9LFxTukQhfqekrd6SEDwTtMDD4MOF/qoOwwc6AgWi13P4FDeYeoSKF5D4iRsEcmrhIJTyoKMf9tAy1JO+lpsNKsGgKn1mVbuBBX4trgpqGILbHJdalCMjQ+fbgjiwbL1WxWrn3KSY6OKF8eELcO3W+34Y/TmtB0aUjp9QOGwm2nX2DZvwqRFBpg/dOOYckNgdbDYY3kcLXXoRUTrueAIyK5N2LMw/n+8vrCKGYm5WlGQrYVg4cGQ6pktzmPpFHMw/L0Jjy4MZUZl8eZoRLm61v6Yfh4sFXMdah5pkoUU4GvYnr8DzChc7oHqjqTVc4N5HNKavi2QJ3LuCnmibXLuKeM4g3t6IKRsArL00dJWz9XwgDYTU5DTVdqUz05xNPUDO7YFuXTaBDHlqHKyepe8PanZiRNd0bU/tnV+9thII/EPyuYmoKyPWtVT1Z68Q/yqai7v7s3OW58GHqZUFXxsaqSsLA4t83HdeccH/t2IGR8EBinSCYmjg9CLm/zsJ87y8t1/cTiHKG68mN1BeEydHw4Ma63F+QgJ6Djg8mJAamEOA8o6Q3ArrwhQScGEwm9fbg/MRHp0CmgPiqwfqJK/ggnx3XTPPuTE8aHJCaAiIkAYhIyMbSU/HITNVi0oG6WtBASKijJD6D9o4Tk3hwjMTnWBt15wMZ57So71w31OsCtordZua5eDxl3Jc+FPLW7bz82eWhU4kFyOSUhvpQCCHhY6GoDg6r00boL2c6EuiCDsJ20DQGh1WVewcsvajKRZxANrn497xgkW6bP0vtUrw4AFX3oLUenh5kucYt27j1DD9Z1iAHhWk1+eZdb8MIKn9BGGm4n0IBQl+1cd2GUPqiqNgCYZdeUFhclJjbUiLPc5iS3VD47yLx11edY6MamKsynqAz40yQGhwmE/t7uXittWJKm/EVypsfp/aPitHWapHtWERKBGWSbW+xuRsjjzdSchOEgWQxSiMlzjDxwg1Cpd5K6/CgicSyhqTsnt6knIa6uJzenrhuowKCHw4m5DcTwwpbueYl1qoXJxOKbi5WTIgua2hfO3ixL48mFxdxnWfGfS/pdsmu+xdtacza4ZdYcx9pXH90z2YT/gAXkKgkFuUHSC7/9VESI7zyQIwIW0+V5B30wvwJYTJ8A4Xk4QDjx02HVYdknPpoU8r+W/9qRUjTgixhaGgL/iN+Om7tQrz7IQE0dV5BqHODen4qVfUMuWzEfPaWPtIubpJWvrSluXrlfqYuutzXM2gBb6OjUjrNNVHVRdUKl4a1DkkcS/+dvhjVut6xqThou1xOBPbGxUUZIFjCHObp7oJm2LDgpcJsBqAvU2karKS9L5Lwd5/raR6s5UFzrkZX/2OM8wZ2g/B+vhyzjNuaH5fO/j4zhN8PXKbw4dPEoDxjd+67tfUEM0leOdhBHD+dQeREkHq8fP0Qc76xoRyRbkdAimYfT/1o2KG11FCraGqWuTecKdDFQxbEkiZgnf1VlJN/8fJtAP7ytXXp4BGXhrf3E994dHT6fycOrbESb38K0WOvKL6jYiwg0xy2s4jp+5mbqa9/2KuJVpgaNo6He+rp41k5QLxi9gS04mvqmyGNmpNaZNpLGRSHjMlPQYMqbFGC/V0XYvLcwz1eWjO1VQS24dzCzL18ouu+enY6emaOHqdnoKmFjONUqIFjh+3rOj3akEib2spxqO5jPak2pShPEDfo3XLWpsHiAHzAe8O9VITYhFqYfYLMXEbD6Bzt0h+25iOgLW/gINIgVCXugLS1dW1yt2DW70boadXXl4Bypa1FNS3/KNJcWE2f3HIWYdhy05jk9Q+3U0+M/72AX946CQrc2Vzf3tsKC+ZhgCqLIFzVPtGl+jq+JN3Kuge/UzM5b1t96J4METW191UZVLX3NAk2tn5r2yQGO18Jr8wZKqChbK6s4Ktue/N7B76rZqtuMPdVXUCXDMrI8st1l/LhTqZIKlbcB1yE2pYK14glDrEiFwNgM1LMbFaLL2BxiKSreV1ZzPdtQS1VOWIPaGzZ/FayxptQ3cRXyY5NX34zfL8wLkgtUaP9wXGJ3b39vYmLvMOS7J0AvuX+TPJidmDygZ3fHJce9oFRg+cpddD8yAv0aZObETwKJDi/nHZb85g7UdHQyxj6SrmXr/jEbMHNmGjyC2bsrtegU4OwmD4DvjHTposMBop8+wwHlAeiCY5lULAACEmCUCrJptHTbAHLvP/FrMb4uKu/Lzqrsf1/aLV7abap4WLnWnW+vFRdmnibtwBYg0zAOtPVwDjaV/C5Q8f/04vJ7+tiSgd/yj92VztsSi+hxBZUBygfiwZzTjA113U0twm/PngwLV/y1ide3sQ7QU1NxveTBO52/6VxnIbHs3QB16GUdtPC7TFD5dU8txcsW8s7c0/mtuYoVfMyV8eaN/41HfIJe+PG/t/ybd9xX317kYptdU4zvUg1n8V7DPmFRwuObH+0TUBbJ71c0Y6IPsqYFztAoyK5ZYiRFCqflc+24WyvOUvwlBrO6X8uRrMEmhmGsSku8lYuTJfFbEFT5bFoKDVgyfarLbt+4aL2i8s2rRNr7c0o2gda+NhG4c9pV1/SueHTPDH+Q9vp3Q33BrS04iX8313D4voMr+OcrzUvhUjj6d3KZWz5I4vyzBlm3PaTZg3rwPljxvhml7jleSgX6zgIaj9WKWUVMzGc/KxH3sWJWrOSlbJOqot+bJDE7J1eHRgcnV7vwYVl+aTZpW9n2Svsv2j+UkxsadY9JBjJ5Vvrehf6WEJPXIRc6smwF+ALsvigHR1c7SgzuFLXJJG0rE2+1aRUvyy/NdM/hoe2d3G0u2Di7268GkZVfTfZS0VuQ9BVXgQrIuVdLt2Epcsd4om6x3Gk1PYWSSuB4bsSuYnkV+QIfWWQOlXTx9nQuHDd75KyT53nS2lhL2tNuCeEryPJc/YMBe+cgNad5UfeYpG1ljWUZXpS3eTXpR8xFKbel+4Q2fDm86v70la9yGHtMb72j5VyT1sSmK2UlHhEhYDv1t52WyGH0/TV9mkHnS8u4iIY2vlnIF662yo8dfC+H7ilKywWzbL1bI5XDHQhIpAUp8IygA7Gj/iD2SRlEb3IyK5gIjBc9dSpvbb/0TVqBTUw8ZhVzE6MtpHPhB0FnoZ/KXScncCko0JFiUNjUM5CFAfmQ9k/j0YaPd6INPo52tEuPf8Z2rvEu/jlTXnzuZ7P22wyyX0XJuR8/MRd8prmOb+f5KMbT010mNDBG0hvLiHBnf8ML+95WkIasUHB4QiDtTd2XmOJ72MSn1XbjSBMk4dHgI63RD29aEF9azRTWUFhiFSl+fdnRolYaPNCsiXdrS9BRm2/MbywIEvQbU+OrsFBS0E6INJFGEh0seJLKlIlnpfuqYkWswSKCySzx6IpHRgbNeOTs3FCrFLvWOYtl3G2ImAvnhGKfdRRGROaCBD0tUGJi7qV5xjlg4bVdksTeauW3ReZ+mgOoXkSIVGjjErFfslRkzkcqPbU+EBGXoKNEYGnIPKNKZnlsDuK8Mo5E5njEuUsuYrL15YgisBUSvAsblMUeq6Eo+JsClQMYgp85pEdl3NUXFDykTmUya0fa9zetKpOeQDbqkHKVb1pTUum/6Vg9nWNi9Juqld80MaRx9dSNdctvileOZO2cV/5N/xV2gjby9nW3iljvbtdwrX0mPVUuiBBxyHm+PxuvVVexIIQAUXcI5qfrbTUKdhKIknKtVsEaJUFAnYrcGVDwTwuw/IOwEhmkHypVihiVeqbpwYEBlI1pdIiVAij8T/cfkkPBe2U0XnT45T8B+Lok93LB367IUcu3+zhY1FhBCKPxar9uP8OAhXK4fuCVmjaTqjF7JJitNAtqbr9jO/lnwzxL2aWRNeDeVKT3bbvbIMZvcnXy6y35wcAkaBk0iTpDNtGfcmcLf7UCFpMsJYiDO7I+4DUzx9uOZmbNE6YmDL6JKzHZB4i0qXkKISzMp5g/5qQJbN2aGRwELO/2ZCZl4+DSan9yiXLXTczd3C0Bc7Wls8u50jVmbg6YWdKisS4gckwxd72+HitnNwulrnEz02y8hHPQVQVmXVgju35Xc1WJCNHcFZ+fg/fCW17Jtsj2Zv+cO7ARl+uVa3mJaEL0zz0cNwgQdz0FUP8Ssa/7sJ1Lie3rf+q02ggbJ/5thFylhdRUh2/pJj0ThX5Pa7xJPakm1Xm1YHAWsHLehyQ4kbVbv5KAXAAbV9U20ADMoMULRRVNB6oz2hrVbfn5IWl2wgZwhEmutXN0b4zzPGHqFXOHbaLRBNKnSSM/XlP3msVzZeUQZeUiFWU7PtCgOAtCsusIMZnVQXvJf9MBD8ih5Mf7ZZOrZNGW63bmZOey/r5qcmljCyli2dHIxFrP0dTc0lhByv6hULdDXr1sSN8KG1tCj4SsYFqm1fUDl661lOaikkksIaXUWyCcCC6t/eXIjIzF5eMibwR/2GFUg/dT+1LQd6WpRV65onOlZ8rWDVI+3zjw/9fmqa9f95c9pkCyelSK+zaMTaGjLc4ZPd+n4JMsRAj+AMoAfa5r8MRAV9uJezH3Ta7F3FFnRW6Kns3Erz03ttTVsrMUETDe0NURBD7OwHggoP933QbKebjVF4MK/4sJ+6Iq8ekKAzCHwnfab5SNnfe15LmK2EulSJlr9NQTbvhK++kTSOW19Q4CPhduk6cZsqbIkwxBjDNMRpLDKVpeU5+2BGd3+AJjwtyVHSDmBtIxDCqGxAJy3pmsLDKZxxLpBoX/pgI31YEpphXiTUeSwlsdT/q6KTtOeuZQ6UAhYyn2Yn5Rlak8tj5BwOfMfjAHnd3YZJLTCQo2LkQUAVy2XIaTjTwB+6HYs6h7jggSpIq5wwGebZpsFBXNay8udCFQWlwIxYcnoAjt72t/LYXr25TvXIYhH5Q7Q0z3M7i5I7rvyeIcem3UVvk5oX6Nqk+KxF1YM3SpzqtZC/XNqb2cGgfNVAFcJqh6qwUU1pe2Mg0hyzyyT381sti+2elEQxiEQdhGhHU6l/Xfwq+9uF9mT1wXziV60omCgv2sF3hBXpmknKOc+Sau+bOiLVx9Q+q692NBApWHVnvSyTQPlTyhUB35WLezOxFEu6lndtuHgoaUDBQwcL+d3sHHv3q9SoihO0MeDn9/dnz6ZJaBG4wpLD4xqi4qSYQNhMX9hLgKts//hhESouqjCCkET1F7bELY9WKbGhO0SY3NWcs9Y7TxnqV5xF+b7ljfbhux0Tr3CnT+7AIMUw6hKcU/Et13PPouqt8rCX3U8v8xWj3E5pBA8V/b6J1wKE13t1NiK38VEbNBktvY571aNpvRERsB9uXHeSHofjG8NKwdkUpGP9VEAivHwspGC76/HbaGJSjY5/i/S5loiqnUTvUCXKn178zu7WfQq5MUM/3y/YwqdeWQFsbDuX1kCXRJfoOdsp3TR0xNSbfKYVPXtmd5/NADmnCBLq6pRT+gdmVrea37r0q4Au0I9QcRPTCvdl5COrWqOm0yITF9srpqrpSQi126g/W+s8TpHctRSR9PTEgbV7kr3sucX12eXwbctRU6+y8PeSpBleV6rXJxtpdHu7ig0uPXkQta3t7FGaWZcsVf/qlCwBWeS0UKT+ViL50XvOGl5768v6mokTrkqAjUh3alBGQioOODiYm9/b29iTqS2lP1SJbaKvBfU1PHVNuFTgwmE7p7u/uToZLJCBkG6ddLoYZ2drPd1ZmkF4s4jQJfVSm4TARkYigxgZxr4l1YARevCji4O6EEZOKfQo8Mn4zwIkAvCUnzyXYpxg0B1FvdQTlOLwh/6XsK4mEYOthDQQmoyWfskuWTFloCXNubxCzAL5SeTwcsWC6LCx0MrbR017h8b/r53i69DTZq8pPHu3oyROSRF+/oj2zWPP4fRuWdYP797K3HmnoRXnbIsaL8++62AjDXNR/uL4tjgphWWW/3/yx61zNC+d7jV742tH14KZk3jGqz4O2G0LlTUlqU1Hq6Wq9v2wvt5Qx5bebwkJ5v5g4dp/7GWP8KbDN1H6DsfyV0vZw+zdhi9OsrDH2aoYALS4iytjB2nby2MLeM58YjaQaSzCSWJaGd11imEJY+yrJ8aGcbSwWz1GuS/sTSi1m2QSzzIcsaRzvdFtDdK32bvNv0nXttn1J9N4uo6UXUj+6LPktZJ1nwCkRCO7qWO4RmPLans1jHBO7rpZSVduq1VHWUb38b6dvUFI8NSnTVtQ9Q3NsI3Ev0SUoX98R9OGRqxv9Cq41rV1jaYjitfCPakbQpJKONsl5TVGgcqRHTS0naO7KIqt5E06elTqm83sHb/JpoLV0P0LZKJY1+kjuSok9KH4GyO566W/077CV1g6IhxIjhZsi4HZ69raYtBuR/Zd2c5KJwHUlUHUm95hu1WozadKLaxoiU79Yjua3ewzxwQgVu85kKnni29Oz3mGI6xOUgqn7rObKXXlQexgD4bQaztEVNypPq4BaIIgdjapZLXU3eWzdssPd/dyuligP0uvOSbx7aCrA8VzROQkUX4iZ0J2X0vDOHKvY7wE5UXeVaDZWhUweVV3ptR7ft3FwUD7EVPB4V31VNr97z+CDvQ+B6lrImhbeF2FAWj4vt2lMa0NMe5WJzvW7Jqobm3eetEqqOPGekLapzNeve5JA0RpeDB/UHt/uUG5R3VZSUHvTvpChLKw1Xv02JfgNYlRLkZSqKkqasAGBQ2pRXdImGJUXw16NuVa0jp8b7M93qceR+qlQU7Bb+BE9BpgLckXr1M/BpP7jlLyC3gh9t/d8Rthv+ImQ/yOWmwZyWI9TYbjIit0peGmti2NVl/GxQRxclvqkBUwHlrqdJrSJ7wJhvQf+BAHsA8DM+VtZbZG5ey5D79DmvKB8VjBlyhmHUjzn6J95elryqYFgs5h4eIDQPJY8xNrC2Udwydc7uJvEUY5hhw1HcGEBRBziPfuSmyfeRYxQO2j02j2A/p11baPpPqf239P7G0un0a4RBa7WZa6O89daoddeIgz5GrEYjth/ErdOZv5NyWy9ia/iC+6vYdohZD1n9ynaOVb42ql+KuWUR8y3djCef76XOCRTbJ8lzMf0ErlfDAdNHdsOeFSmhYWa/pg9sWOx1y04BK2xfBgUpvbx1tK7kG5fZ7Fkv5iti6D/PIiulzu0rV7KcMZZ6DjGfdyJNirT9mFsHXFxb5LRfsJ6zrMfq+yP9luw+gFsgb9pLniKok8SlR833vp6Wxn1qwn1BY2X9A9/eUQRM/SVDOGuPwmq6RU3vBdbaufc0m5vq3gGBKlCgRz1vTN/ucWj4wnc9hMc+rOYMxeOoYgWvbGWWaZfVDlk8y08KjYQFdnG9L5RGm2Yew6xRNuwgZgwirD7po8xaZ8vIS4yFtV72yOVq7zPnYjEf/v8IM0xeNyraQhXJrn3qLYVcAOkS8dbQaravN3jZu8dQ0KqqjRS2Sk5FUcuHWi3d5qif9bR9XBSl9h2Hzc2Uiz5J7+eSp6MTqFZksYXymFVYKdXsKxeUxd2u/zrGtoP2UBttv9hmHzTNulen0Wb1zZ6tvKYa1BVJJ5d4f2rs13Sl6K3px/rWBlq3gC/LdYS79U9g3oN/gUC9bR0eUCAI2AgAc8ULAbCYmDcfVAFfiDl8E+ge39GI+aF7AodPwSYpawjMUNF80Lt68gVxbpBWt7t6B595GKR3A+KSgSdYOTxFFfMMrVKexYbnBRxiO5zjklFrIMB85c8TBOVvnsIxhwhTt7h2FjYxSWTyojIpZxjnIXIhhW3oCbt9B1LefcM/DAU5BWWDLj4dFS/KXAwWGoThHdLC6GQxUN7mCZHxRWRAWk46KBErrVTOIStnGcHjUx+lADnYnOeJFbOfJTkqIZBnmbmgKq0iLZsGzmypFOaONJQyOV+daXLDHlpZs02FeGuhmq6khWsrlL54JGIFz4wZ8qLgrwB47wtfyeS4EYIp6w0zNVEfLuvMTA4GbCdHGhTmKzHDd6AiW1Tcmw3samYlXGNbmYmOymaQww8mXWXO3G4YTXk8T8l5ObKcjehz4ZZBgJWlZ9mZKcsdFeR9aEi5pLd7sveY9uTWDEIXk8EkTVaNLP8Fs0ronlOBX1iDH7zMVKD8fNMmYRZK1tufwr9DhxIGDJbcz75hsYNu7kMeUe2JSiv+/rzJXrURYIl7zKrCESssD49FTniUbthsn48+aLfdT845o57BNKukuuA7Z513WauLLnnK6LorrtovzRur3XLDTemee2mxTBmmy5bFZKscM82QK0+BfIWKPFNslhKzzTVHo23KlJpnvhdeafoIDWMd1+tfnYKdg7MfQ+XmQfhoDBaHJxBJfPwCHX1xKSQsIiomLiEpJS0jK9fVbaigqKSsoqpGVtfQ1CrK/lhEj6JPP2GgvQ0bET56xozHlnaZNGXajFlz5u/T98dfr7zOgSMnWvKOG8G1z3xeMLz58IXlx1+AQEGCmypEKBx8h94UJlyESFGie+y5XXueOrBjvxtixIoTjyBBIimizE0pUqkRrZ+IJANZZjVlyZazGZevgAzfN4lyFSpVqVajVp16DYSPDYJHZOxz77wRoxakmUXWbbE27c24hVaHTl269ejVp9+AQUOGjRg1ZtyESVRTaKbNlNstdLfNmjNvgRbd9w0rVq1Zt+Guezbdt2XbAw898phucl+VwvfMd1Wr8p9WxWq1K1CqrPc++OgTHeVkk5uPQbfH6zM5AFGSFVXTjfCmmJb99R8YhPRu3sXNw4vGYCnohQTiEX38AoISCX/JRsXEJSSlpGn5CQneLcONCp6QNpyQcNx6PABEmGRT1GYeFTugbZeKJS+WEaoDSnZurSFod3O9wWgyW+jupdKkv0qT6DiDcWkWK1GqjJozJcYXJc2Ha900DlHE+3Njxk2YRDWFZtqMW+g+f7qfc/yci0+Wxt4RBFjS2yQYvVHba6TtmT0MT2CGWmu3B7h0NxsJz34tgTeuVhfa2bGiBWe1qnCerixYGhQz8mJLLC9hSVheaf1fDjm+gYbx2iDhhmoVXko7ufdBBCEHX1lJ/+vVtUB5J7dudxqtPkEi61uevxXMuU8WbhBVwVXehdvSCy0Cb5PYreziuXWQS7yf5m4/cp5fvasw5/sGE5t15IuAI7+gAZi/EfAAIjUE4TLExzTWuhvfYhNW8JQtHyfRxZqRN0y8Vn1QMPDn4uuJS3keO3mSxJ5Fj/IlkGcjz+vPbnrv/v0ijUJMTV16Knhr1CgH34hRFbyHlPp/vfp+BJbUycg65iY/8HOWR4tdwz/qrUcSyDFBPJZWAnM8bgZXRrvm8b+rIpB80XGyg5cqHr+b89HXp06+lcsrq905U9So/fZaojghbITFohKSPezfZ5ZnpNAzJGS0KVdYmI3oNc42pt3+IhDFwnAKQUpnke7xghOjpMHPSoxUEgQlViMkGb5xPJBAtEADR978daOC3UPz+0iZ3Y/lb/Zo5uXsl3c7X6Sqw5PNxfESfnOX/w9FRMGlYliAEIygGE6hEpIWocKGAcQmqMHQIzkAQTE8NICnAgAhGEExnPJ0vQo9hQWlT/tAygC9GYcR/YxsqppEj6QAEIIRFMMp1HsxlTEpNHHPrSkN0TsLump727KmLMWwCkWClG+VOoVcyR3XhyU7HKVJZb2h0vqYQg2IflGwiBjLaSorzh+reFQqdTMsCZsAQjCGE5KxSzoadcLA4pEms9omODzkxLDR2MCJGFggBCMohkvpGeJ4HMsMOB5t5D5wQwMbXTrxd83uiEZ/M+J45t4iSDp6M/QmyGgRWjHyjyAcDr+24qsVHF8uAS/f2sLld2UOfYA7DNjChs1d32q+6yvoGzwbPYBQL05R3KXh23B5Bv2+p6bHFC43+P84NW4xncptt3AzzpuvXgxmSltF/7O4mo+wKtKeRhWj6TUUZ+z10CDBLZrIfpmZ5dV85JSjJ8XtrbLKjfAsXYA2P6dpVSlbwGbajXkuWjhyuFo4TrNKxVsiv7q0LbsIV/68zaUw71X59WXD5jnGZ9/PIGNaHjWNLEsDQC4XjFFIFgwCJB3T3t527K03IHYWlrvsV6U3c3HwLqfxS3JoOBFCM1GUp0bjZnGUIfGARIkqkS8OkzYRZrInSqUjcSzadAtfvW5T8KozAYu2LVH+0IXgc/FDcZc8IAgdAkHeUIKLGlBOpeSbmRiW+qc9coGyIpCZZVkSOyCCstC0wWqVbY0pFfUYVD3f7wTQHgAHpsBBAEBZBODgEQhlQ9M02rp3srA5pxUvYzSOoIlKTVvxlCFQdXmtrIU6M23TVHXnxpybFR2q0n0oGtxUtrZLDQrx9VX8xWL2MQ1TqQ/dLnEbObO+tMox40BUNWblCpOi7bKmbV0AFHbZirNFCzOtBwGZTd32dTB53RcxFFjyCLV2PEsIu915+ZmaNkSyxlHXLzOkKfTNxHHI38JVhtawdFurteI9E7eSVO9nK4gSUgx3msEz1qCOpAhB0ZjbF6w5z7RVvThX0nYhtKQon2eZu1hmrcOB8RrPzrLotXhZc9RU2dTMaVVWSycJnKNhUUqOPNeC2PX6ployg2P53yvWtdRW18JNkgT08wtzVXM2OBXqyg9VnhwPGOw07JshDKrapPfl/JZ9U1UQv8muyogzfjq3zcXfBk5dUaandemo1Lpu+gfxRS0quGhm0MTixgxyGUTXdZZIb8fSeJ5iIbyL6xxlDU1z1Ondoq5WK/TiBmGFViZDOT9TXHjq9J/1n/df9F/2X2XX2eLqMYT6Bda7m7tPU7tesjePu86yzG/3v77fxWK6k+sviyhq2vJhA9bGk3/X5eN/AAAA")
    format("woff2");
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
`;

// node_modules/@base-org/account/dist/ui/assets/injectFontStyle.js
var FONT_NAME = "BaseSans-Regular";
function injectFontStyle() {
  const existing = document.head.querySelector(`style[base-sdk-font="${FONT_NAME}"]`);
  if (existing)
    return;
  const style = document.createElement("style");
  style.setAttribute("base-sdk-font", FONT_NAME);
  style.textContent = FONT_FACE_CSS;
  document.head.appendChild(style);
}

// node_modules/@base-org/account/node_modules/preact/dist/preact.module.js
var n2;
var l4;
var u3;
var t;
var i3;
var o2;
var r2;
var f8;
var e;
var c4;
var s;
var a2;
var h4 = {};
var v4 = [];
var p4 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var y6 = Array.isArray;
function d2(n5, l9) {
  for (var u10 in l9) n5[u10] = l9[u10];
  return n5;
}
function w3(n5) {
  n5 && n5.parentNode && n5.parentNode.removeChild(n5);
}
function _3(l9, u10, t6) {
  var i9, o6, r8, f16 = {};
  for (r8 in u10) "key" == r8 ? i9 = u10[r8] : "ref" == r8 ? o6 = u10[r8] : f16[r8] = u10[r8];
  if (arguments.length > 2 && (f16.children = arguments.length > 3 ? n2.call(arguments, 2) : t6), "function" == typeof l9 && null != l9.defaultProps) for (r8 in l9.defaultProps) void 0 === f16[r8] && (f16[r8] = l9.defaultProps[r8]);
  return g(l9, f16, i9, o6, null);
}
function g(n5, t6, i9, o6, r8) {
  var f16 = { type: n5, props: t6, key: i9, ref: o6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r8 ? ++u3 : r8, __i: -1, __u: 0 };
  return null == r8 && null != l4.vnode && l4.vnode(f16), f16;
}
function b4(n5) {
  return n5.children;
}
function k6(n5, l9) {
  this.props = n5, this.context = l9;
}
function x4(n5, l9) {
  if (null == l9) return n5.__ ? x4(n5.__, n5.__i + 1) : null;
  for (var u10; l9 < n5.__k.length; l9++) if (null != (u10 = n5.__k[l9]) && null != u10.__e) return u10.__e;
  return "function" == typeof n5.type ? x4(n5) : null;
}
function C5(n5) {
  var l9, u10;
  if (null != (n5 = n5.__) && null != n5.__c) {
    for (n5.__e = n5.__c.base = null, l9 = 0; l9 < n5.__k.length; l9++) if (null != (u10 = n5.__k[l9]) && null != u10.__e) {
      n5.__e = n5.__c.base = u10.__e;
      break;
    }
    return C5(n5);
  }
}
function M5(n5) {
  (!n5.__d && (n5.__d = true) && i3.push(n5) && !P4.__r++ || o2 !== l4.debounceRendering) && ((o2 = l4.debounceRendering) || r2)(P4);
}
function P4() {
  var n5, u10, t6, o6, r8, e11, c9, s5;
  for (i3.sort(f8); n5 = i3.shift(); ) n5.__d && (u10 = i3.length, o6 = void 0, e11 = (r8 = (t6 = n5).__v).__e, c9 = [], s5 = [], t6.__P && ((o6 = d2({}, r8)).__v = r8.__v + 1, l4.vnode && l4.vnode(o6), O5(t6.__P, o6, r8, t6.__n, t6.__P.namespaceURI, 32 & r8.__u ? [e11] : null, c9, null == e11 ? x4(r8) : e11, !!(32 & r8.__u), s5), o6.__v = r8.__v, o6.__.__k[o6.__i] = o6, j4(c9, o6, s5), o6.__e != e11 && C5(o6)), i3.length > u10 && i3.sort(f8));
  P4.__r = 0;
}
function S5(n5, l9, u10, t6, i9, o6, r8, f16, e11, c9, s5) {
  var a6, p9, y11, d7, w8, _6 = t6 && t6.__k || v4, g4 = l9.length;
  for (u10.__d = e11, $5(u10, l9, _6), e11 = u10.__d, a6 = 0; a6 < g4; a6++) null != (y11 = u10.__k[a6]) && (p9 = -1 === y11.__i ? h4 : _6[y11.__i] || h4, y11.__i = a6, O5(n5, y11, p9, i9, o6, r8, f16, e11, c9, s5), d7 = y11.__e, y11.ref && p9.ref != y11.ref && (p9.ref && N5(p9.ref, null, y11), s5.push(y11.ref, y11.__c || d7, y11)), null == w8 && null != d7 && (w8 = d7), 65536 & y11.__u || p9.__k === y11.__k ? e11 = I5(y11, e11, n5) : "function" == typeof y11.type && void 0 !== y11.__d ? e11 = y11.__d : d7 && (e11 = d7.nextSibling), y11.__d = void 0, y11.__u &= -196609);
  u10.__d = e11, u10.__e = w8;
}
function $5(n5, l9, u10) {
  var t6, i9, o6, r8, f16, e11 = l9.length, c9 = u10.length, s5 = c9, a6 = 0;
  for (n5.__k = [], t6 = 0; t6 < e11; t6++) null != (i9 = l9[t6]) && "boolean" != typeof i9 && "function" != typeof i9 ? (r8 = t6 + a6, (i9 = n5.__k[t6] = "string" == typeof i9 || "number" == typeof i9 || "bigint" == typeof i9 || i9.constructor == String ? g(null, i9, null, null, null) : y6(i9) ? g(b4, { children: i9 }, null, null, null) : void 0 === i9.constructor && i9.__b > 0 ? g(i9.type, i9.props, i9.key, i9.ref ? i9.ref : null, i9.__v) : i9).__ = n5, i9.__b = n5.__b + 1, o6 = null, -1 !== (f16 = i9.__i = L4(i9, u10, r8, s5)) && (s5--, (o6 = u10[f16]) && (o6.__u |= 131072)), null == o6 || null === o6.__v ? (-1 == f16 && a6--, "function" != typeof i9.type && (i9.__u |= 65536)) : f16 !== r8 && (f16 == r8 - 1 ? a6-- : f16 == r8 + 1 ? a6++ : (f16 > r8 ? a6-- : a6++, i9.__u |= 65536))) : i9 = n5.__k[t6] = null;
  if (s5) for (t6 = 0; t6 < c9; t6++) null != (o6 = u10[t6]) && 0 == (131072 & o6.__u) && (o6.__e == n5.__d && (n5.__d = x4(o6)), V5(o6, o6));
}
function I5(n5, l9, u10) {
  var t6, i9;
  if ("function" == typeof n5.type) {
    for (t6 = n5.__k, i9 = 0; t6 && i9 < t6.length; i9++) t6[i9] && (t6[i9].__ = n5, l9 = I5(t6[i9], l9, u10));
    return l9;
  }
  n5.__e != l9 && (l9 && n5.type && !u10.contains(l9) && (l9 = x4(n5)), u10.insertBefore(n5.__e, l9 || null), l9 = n5.__e);
  do {
    l9 = l9 && l9.nextSibling;
  } while (null != l9 && 8 === l9.nodeType);
  return l9;
}
function L4(n5, l9, u10, t6) {
  var i9 = n5.key, o6 = n5.type, r8 = u10 - 1, f16 = u10 + 1, e11 = l9[u10];
  if (null === e11 || e11 && i9 == e11.key && o6 === e11.type && 0 == (131072 & e11.__u)) return u10;
  if (t6 > (null != e11 && 0 == (131072 & e11.__u) ? 1 : 0)) for (; r8 >= 0 || f16 < l9.length; ) {
    if (r8 >= 0) {
      if ((e11 = l9[r8]) && 0 == (131072 & e11.__u) && i9 == e11.key && o6 === e11.type) return r8;
      r8--;
    }
    if (f16 < l9.length) {
      if ((e11 = l9[f16]) && 0 == (131072 & e11.__u) && i9 == e11.key && o6 === e11.type) return f16;
      f16++;
    }
  }
  return -1;
}
function T4(n5, l9, u10) {
  "-" === l9[0] ? n5.setProperty(l9, null == u10 ? "" : u10) : n5[l9] = null == u10 ? "" : "number" != typeof u10 || p4.test(l9) ? u10 : u10 + "px";
}
function A6(n5, l9, u10, t6, i9) {
  var o6;
  n: if ("style" === l9) if ("string" == typeof u10) n5.style.cssText = u10;
  else {
    if ("string" == typeof t6 && (n5.style.cssText = t6 = ""), t6) for (l9 in t6) u10 && l9 in u10 || T4(n5.style, l9, "");
    if (u10) for (l9 in u10) t6 && u10[l9] === t6[l9] || T4(n5.style, l9, u10[l9]);
  }
  else if ("o" === l9[0] && "n" === l9[1]) o6 = l9 !== (l9 = l9.replace(/(PointerCapture)$|Capture$/i, "$1")), l9 = l9.toLowerCase() in n5 || "onFocusOut" === l9 || "onFocusIn" === l9 ? l9.toLowerCase().slice(2) : l9.slice(2), n5.l || (n5.l = {}), n5.l[l9 + o6] = u10, u10 ? t6 ? u10.u = t6.u : (u10.u = e, n5.addEventListener(l9, o6 ? s : c4, o6)) : n5.removeEventListener(l9, o6 ? s : c4, o6);
  else {
    if ("http://www.w3.org/2000/svg" == i9) l9 = l9.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l9 && "height" != l9 && "href" != l9 && "list" != l9 && "form" != l9 && "tabIndex" != l9 && "download" != l9 && "rowSpan" != l9 && "colSpan" != l9 && "role" != l9 && "popover" != l9 && l9 in n5) try {
      n5[l9] = null == u10 ? "" : u10;
      break n;
    } catch (n6) {
    }
    "function" == typeof u10 || (null == u10 || false === u10 && "-" !== l9[4] ? n5.removeAttribute(l9) : n5.setAttribute(l9, "popover" == l9 && 1 == u10 ? "" : u10));
  }
}
function F4(n5) {
  return function(u10) {
    if (this.l) {
      var t6 = this.l[u10.type + n5];
      if (null == u10.t) u10.t = e++;
      else if (u10.t < t6.u) return;
      return t6(l4.event ? l4.event(u10) : u10);
    }
  };
}
function O5(n5, u10, t6, i9, o6, r8, f16, e11, c9, s5) {
  var a6, h9, v9, p9, w8, _6, g4, m6, x7, C10, M8, P7, $8, I8, H4, L7, T8 = u10.type;
  if (void 0 !== u10.constructor) return null;
  128 & t6.__u && (c9 = !!(32 & t6.__u), r8 = [e11 = u10.__e = t6.__e]), (a6 = l4.__b) && a6(u10);
  n: if ("function" == typeof T8) try {
    if (m6 = u10.props, x7 = "prototype" in T8 && T8.prototype.render, C10 = (a6 = T8.contextType) && i9[a6.__c], M8 = a6 ? C10 ? C10.props.value : a6.__ : i9, t6.__c ? g4 = (h9 = u10.__c = t6.__c).__ = h9.__E : (x7 ? u10.__c = h9 = new T8(m6, M8) : (u10.__c = h9 = new k6(m6, M8), h9.constructor = T8, h9.render = q3), C10 && C10.sub(h9), h9.props = m6, h9.state || (h9.state = {}), h9.context = M8, h9.__n = i9, v9 = h9.__d = true, h9.__h = [], h9._sb = []), x7 && null == h9.__s && (h9.__s = h9.state), x7 && null != T8.getDerivedStateFromProps && (h9.__s == h9.state && (h9.__s = d2({}, h9.__s)), d2(h9.__s, T8.getDerivedStateFromProps(m6, h9.__s))), p9 = h9.props, w8 = h9.state, h9.__v = u10, v9) x7 && null == T8.getDerivedStateFromProps && null != h9.componentWillMount && h9.componentWillMount(), x7 && null != h9.componentDidMount && h9.__h.push(h9.componentDidMount);
    else {
      if (x7 && null == T8.getDerivedStateFromProps && m6 !== p9 && null != h9.componentWillReceiveProps && h9.componentWillReceiveProps(m6, M8), !h9.__e && (null != h9.shouldComponentUpdate && false === h9.shouldComponentUpdate(m6, h9.__s, M8) || u10.__v === t6.__v)) {
        for (u10.__v !== t6.__v && (h9.props = m6, h9.state = h9.__s, h9.__d = false), u10.__e = t6.__e, u10.__k = t6.__k, u10.__k.some(function(n6) {
          n6 && (n6.__ = u10);
        }), P7 = 0; P7 < h9._sb.length; P7++) h9.__h.push(h9._sb[P7]);
        h9._sb = [], h9.__h.length && f16.push(h9);
        break n;
      }
      null != h9.componentWillUpdate && h9.componentWillUpdate(m6, h9.__s, M8), x7 && null != h9.componentDidUpdate && h9.__h.push(function() {
        h9.componentDidUpdate(p9, w8, _6);
      });
    }
    if (h9.context = M8, h9.props = m6, h9.__P = n5, h9.__e = false, $8 = l4.__r, I8 = 0, x7) {
      for (h9.state = h9.__s, h9.__d = false, $8 && $8(u10), a6 = h9.render(h9.props, h9.state, h9.context), H4 = 0; H4 < h9._sb.length; H4++) h9.__h.push(h9._sb[H4]);
      h9._sb = [];
    } else do {
      h9.__d = false, $8 && $8(u10), a6 = h9.render(h9.props, h9.state, h9.context), h9.state = h9.__s;
    } while (h9.__d && ++I8 < 25);
    h9.state = h9.__s, null != h9.getChildContext && (i9 = d2(d2({}, i9), h9.getChildContext())), x7 && !v9 && null != h9.getSnapshotBeforeUpdate && (_6 = h9.getSnapshotBeforeUpdate(p9, w8)), S5(n5, y6(L7 = null != a6 && a6.type === b4 && null == a6.key ? a6.props.children : a6) ? L7 : [L7], u10, t6, i9, o6, r8, f16, e11, c9, s5), h9.base = u10.__e, u10.__u &= -161, h9.__h.length && f16.push(h9), g4 && (h9.__E = h9.__ = null);
  } catch (n6) {
    if (u10.__v = null, c9 || null != r8) {
      for (u10.__u |= c9 ? 160 : 32; e11 && 8 === e11.nodeType && e11.nextSibling; ) e11 = e11.nextSibling;
      r8[r8.indexOf(e11)] = null, u10.__e = e11;
    } else u10.__e = t6.__e, u10.__k = t6.__k;
    l4.__e(n6, u10, t6);
  }
  else null == r8 && u10.__v === t6.__v ? (u10.__k = t6.__k, u10.__e = t6.__e) : u10.__e = z4(t6.__e, u10, t6, i9, o6, r8, f16, c9, s5);
  (a6 = l4.diffed) && a6(u10);
}
function j4(n5, u10, t6) {
  u10.__d = void 0;
  for (var i9 = 0; i9 < t6.length; i9++) N5(t6[i9], t6[++i9], t6[++i9]);
  l4.__c && l4.__c(u10, n5), n5.some(function(u11) {
    try {
      n5 = u11.__h, u11.__h = [], n5.some(function(n6) {
        n6.call(u11);
      });
    } catch (n6) {
      l4.__e(n6, u11.__v);
    }
  });
}
function z4(u10, t6, i9, o6, r8, f16, e11, c9, s5) {
  var a6, v9, p9, d7, _6, g4, m6, b6 = i9.props, k11 = t6.props, C10 = t6.type;
  if ("svg" === C10 ? r8 = "http://www.w3.org/2000/svg" : "math" === C10 ? r8 = "http://www.w3.org/1998/Math/MathML" : r8 || (r8 = "http://www.w3.org/1999/xhtml"), null != f16) {
    for (a6 = 0; a6 < f16.length; a6++) if ((_6 = f16[a6]) && "setAttribute" in _6 == !!C10 && (C10 ? _6.localName === C10 : 3 === _6.nodeType)) {
      u10 = _6, f16[a6] = null;
      break;
    }
  }
  if (null == u10) {
    if (null === C10) return document.createTextNode(k11);
    u10 = document.createElementNS(r8, C10, k11.is && k11), c9 && (l4.__m && l4.__m(t6, f16), c9 = false), f16 = null;
  }
  if (null === C10) b6 === k11 || c9 && u10.data === k11 || (u10.data = k11);
  else {
    if (f16 = f16 && n2.call(u10.childNodes), b6 = i9.props || h4, !c9 && null != f16) for (b6 = {}, a6 = 0; a6 < u10.attributes.length; a6++) b6[(_6 = u10.attributes[a6]).name] = _6.value;
    for (a6 in b6) if (_6 = b6[a6], "children" == a6) ;
    else if ("dangerouslySetInnerHTML" == a6) p9 = _6;
    else if (!(a6 in k11)) {
      if ("value" == a6 && "defaultValue" in k11 || "checked" == a6 && "defaultChecked" in k11) continue;
      A6(u10, a6, null, _6, r8);
    }
    for (a6 in k11) _6 = k11[a6], "children" == a6 ? d7 = _6 : "dangerouslySetInnerHTML" == a6 ? v9 = _6 : "value" == a6 ? g4 = _6 : "checked" == a6 ? m6 = _6 : c9 && "function" != typeof _6 || b6[a6] === _6 || A6(u10, a6, _6, b6[a6], r8);
    if (v9) c9 || p9 && (v9.__html === p9.__html || v9.__html === u10.innerHTML) || (u10.innerHTML = v9.__html), t6.__k = [];
    else if (p9 && (u10.innerHTML = ""), S5(u10, y6(d7) ? d7 : [d7], t6, i9, o6, "foreignObject" === C10 ? "http://www.w3.org/1999/xhtml" : r8, f16, e11, f16 ? f16[0] : i9.__k && x4(i9, 0), c9, s5), null != f16) for (a6 = f16.length; a6--; ) w3(f16[a6]);
    c9 || (a6 = "value", "progress" === C10 && null == g4 ? u10.removeAttribute("value") : void 0 !== g4 && (g4 !== u10[a6] || "progress" === C10 && !g4 || "option" === C10 && g4 !== b6[a6]) && A6(u10, a6, g4, b6[a6], r8), a6 = "checked", void 0 !== m6 && m6 !== u10[a6] && A6(u10, a6, m6, b6[a6], r8));
  }
  return u10;
}
function N5(n5, u10, t6) {
  try {
    if ("function" == typeof n5) {
      var i9 = "function" == typeof n5.__u;
      i9 && n5.__u(), i9 && null == u10 || (n5.__u = n5(u10));
    } else n5.current = u10;
  } catch (n6) {
    l4.__e(n6, t6);
  }
}
function V5(n5, u10, t6) {
  var i9, o6;
  if (l4.unmount && l4.unmount(n5), (i9 = n5.ref) && (i9.current && i9.current !== n5.__e || N5(i9, null, u10)), null != (i9 = n5.__c)) {
    if (i9.componentWillUnmount) try {
      i9.componentWillUnmount();
    } catch (n6) {
      l4.__e(n6, u10);
    }
    i9.base = i9.__P = null;
  }
  if (i9 = n5.__k) for (o6 = 0; o6 < i9.length; o6++) i9[o6] && V5(i9[o6], u10, t6 || "function" != typeof n5.type);
  t6 || w3(n5.__e), n5.__c = n5.__ = n5.__e = n5.__d = void 0;
}
function q3(n5, l9, u10) {
  return this.constructor(n5, u10);
}
function B4(u10, t6, i9) {
  var o6, r8, f16, e11;
  l4.__ && l4.__(u10, t6), r8 = (o6 = "function" == typeof i9) ? null : i9 && i9.__k || t6.__k, f16 = [], e11 = [], O5(t6, u10 = (!o6 && i9 || t6).__k = _3(b4, null, [u10]), r8 || h4, h4, t6.namespaceURI, !o6 && i9 ? [i9] : r8 ? null : t6.firstChild ? n2.call(t6.childNodes) : null, f16, !o6 && i9 ? i9 : r8 ? r8.__e : t6.firstChild, o6, e11), j4(f16, u10, e11);
}
n2 = v4.slice, l4 = { __e: function(n5, l9, u10, t6) {
  for (var i9, o6, r8; l9 = l9.__; ) if ((i9 = l9.__c) && !i9.__) try {
    if ((o6 = i9.constructor) && null != o6.getDerivedStateFromError && (i9.setState(o6.getDerivedStateFromError(n5)), r8 = i9.__d), null != i9.componentDidCatch && (i9.componentDidCatch(n5, t6 || {}), r8 = i9.__d), r8) return i9.__E = i9;
  } catch (l10) {
    n5 = l10;
  }
  throw n5;
} }, u3 = 0, t = function(n5) {
  return null != n5 && null == n5.constructor;
}, k6.prototype.setState = function(n5, l9) {
  var u10;
  u10 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = d2({}, this.state), "function" == typeof n5 && (n5 = n5(d2({}, u10), this.props)), n5 && d2(u10, n5), null != n5 && this.__v && (l9 && this._sb.push(l9), M5(this));
}, k6.prototype.forceUpdate = function(n5) {
  this.__v && (this.__e = true, n5 && this.__h.push(n5), M5(this));
}, k6.prototype.render = b4, i3 = [], r2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f8 = function(n5, l9) {
  return n5.__v.__b - l9.__v.__b;
}, P4.__r = 0, e = 0, c4 = F4(false), s = F4(true), a2 = 0;

// node_modules/@base-org/account/node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
var f9 = 0;
var i4 = Array.isArray;
function u4(e11, t6, n5, o6, i9, u10) {
  t6 || (t6 = {});
  var a6, c9, l9 = t6;
  "ref" in t6 && (a6 = t6.ref, delete t6.ref);
  var p9 = { type: e11, props: l9, key: n5, ref: a6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f9, __i: -1, __u: 0, __source: i9, __self: u10 };
  if ("function" == typeof e11 && (a6 = e11.defaultProps)) for (c9 in a6) void 0 === l9[c9] && (l9[c9] = a6[c9]);
  return l4.vnode && l4.vnode(p9), p9;
}

// node_modules/clsx/dist/clsx.m.js
function r3(e11) {
  var t6, f16, n5 = "";
  if ("string" == typeof e11 || "number" == typeof e11) n5 += e11;
  else if ("object" == typeof e11) if (Array.isArray(e11)) for (t6 = 0; t6 < e11.length; t6++) e11[t6] && (f16 = r3(e11[t6])) && (n5 && (n5 += " "), n5 += f16);
  else for (t6 in e11) e11[t6] && (n5 && (n5 += " "), n5 += t6);
  return n5;
}
function clsx() {
  for (var e11, t6, f16 = 0, n5 = ""; f16 < arguments.length; ) (e11 = arguments[f16++]) && (t6 = r3(e11)) && (n5 && (n5 += " "), n5 += t6);
  return n5;
}

// node_modules/@base-org/account/dist/core/username/getDisplayableUsername.js
async function getDisplayableUsername(address) {
  return truncateAddress(address);
}
function truncateAddress(address, length = 4) {
  return `${address.slice(0, 2 + length)}...${address.slice(-length)}`;
}

// node_modules/@base-org/account/dist/ui/assets/colors.js
var WHITE = "#FFF";
var BRAND_BLUE = "#0000FF";

// node_modules/@base-org/account/dist/ui/assets/BaseLogo.js
var BaseLogo = ({ fill }) => {
  const fillColor = fill === "blue" ? BRAND_BLUE : WHITE;
  return u4("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: u4("path", { d: "M0 2.014C0 1.58105 0 1.36457 0.0815779 1.19805C0.159686 1.03861 0.288611 0.909686 0.448049 0.831578C0.61457 0.75 0.831047 0.75 1.264 0.75H14.736C15.169 0.75 15.3854 0.75 15.552 0.831578C15.7114 0.909686 15.8403 1.03861 15.9184 1.19805C16 1.36457 16 1.58105 16 2.014V15.486C16 15.919 16 16.1354 15.9184 16.302C15.8403 16.4614 15.7114 16.5903 15.552 16.6684C15.3854 16.75 15.169 16.75 14.736 16.75H1.264C0.831047 16.75 0.61457 16.75 0.448049 16.6684C0.288611 16.5903 0.159686 16.4614 0.0815779 16.302C0 16.1354 0 15.919 0 15.486V2.014Z", fill: fillColor }) });
};

// node_modules/@base-org/account/node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r4;
var u5;
var i5;
var o3 = 0;
var f10 = [];
var c5 = l4;
var e2 = c5.__b;
var a3 = c5.__r;
var v5 = c5.diffed;
var l5 = c5.__c;
var m2 = c5.unmount;
var s2 = c5.__;
function d3(n5, t6) {
  c5.__h && c5.__h(r4, n5, o3 || t6), o3 = 0;
  var u10 = r4.__H || (r4.__H = { __: [], __h: [] });
  return n5 >= u10.__.length && u10.__.push({}), u10.__[n5];
}
function h5(n5) {
  return o3 = 1, p5(D5, n5);
}
function p5(n5, u10, i9) {
  var o6 = d3(t2++, 2);
  if (o6.t = n5, !o6.__c && (o6.__ = [i9 ? i9(u10) : D5(void 0, u10), function(n6) {
    var t6 = o6.__N ? o6.__N[0] : o6.__[0], r8 = o6.t(t6, n6);
    t6 !== r8 && (o6.__N = [r8, o6.__[1]], o6.__c.setState({}));
  }], o6.__c = r4, !r4.u)) {
    var f16 = function(n6, t6, r8) {
      if (!o6.__c.__H) return true;
      var u11 = o6.__c.__H.__.filter(function(n7) {
        return !!n7.__c;
      });
      if (u11.every(function(n7) {
        return !n7.__N;
      })) return !c9 || c9.call(this, n6, t6, r8);
      var i10 = false;
      return u11.forEach(function(n7) {
        if (n7.__N) {
          var t7 = n7.__[0];
          n7.__ = n7.__N, n7.__N = void 0, t7 !== n7.__[0] && (i10 = true);
        }
      }), !(!i10 && o6.__c.props === n6) && (!c9 || c9.call(this, n6, t6, r8));
    };
    r4.u = true;
    var c9 = r4.shouldComponentUpdate, e11 = r4.componentWillUpdate;
    r4.componentWillUpdate = function(n6, t6, r8) {
      if (this.__e) {
        var u11 = c9;
        c9 = void 0, f16(n6, t6, r8), c9 = u11;
      }
      e11 && e11.call(this, n6, t6, r8);
    }, r4.shouldComponentUpdate = f16;
  }
  return o6.__N || o6.__;
}
function y7(n5, u10) {
  var i9 = d3(t2++, 3);
  !c5.__s && C6(i9.__H, u10) && (i9.__ = n5, i9.i = u10, r4.__H.__h.push(i9));
}
function T5(n5, r8) {
  var u10 = d3(t2++, 7);
  return C6(u10.__H, r8) && (u10.__ = n5(), u10.__H = r8, u10.__h = n5), u10.__;
}
function j5() {
  for (var n5; n5 = f10.shift(); ) if (n5.__P && n5.__H) try {
    n5.__H.__h.forEach(z5), n5.__H.__h.forEach(B5), n5.__H.__h = [];
  } catch (t6) {
    n5.__H.__h = [], c5.__e(t6, n5.__v);
  }
}
c5.__b = function(n5) {
  r4 = null, e2 && e2(n5);
}, c5.__ = function(n5, t6) {
  n5 && t6.__k && t6.__k.__m && (n5.__m = t6.__k.__m), s2 && s2(n5, t6);
}, c5.__r = function(n5) {
  a3 && a3(n5), t2 = 0;
  var i9 = (r4 = n5.__c).__H;
  i9 && (u5 === r4 ? (i9.__h = [], r4.__h = [], i9.__.forEach(function(n6) {
    n6.__N && (n6.__ = n6.__N), n6.i = n6.__N = void 0;
  })) : (i9.__h.forEach(z5), i9.__h.forEach(B5), i9.__h = [], t2 = 0)), u5 = r4;
}, c5.diffed = function(n5) {
  v5 && v5(n5);
  var t6 = n5.__c;
  t6 && t6.__H && (t6.__H.__h.length && (1 !== f10.push(t6) && i5 === c5.requestAnimationFrame || ((i5 = c5.requestAnimationFrame) || w4)(j5)), t6.__H.__.forEach(function(n6) {
    n6.i && (n6.__H = n6.i), n6.i = void 0;
  })), u5 = r4 = null;
}, c5.__c = function(n5, t6) {
  t6.some(function(n6) {
    try {
      n6.__h.forEach(z5), n6.__h = n6.__h.filter(function(n7) {
        return !n7.__ || B5(n7);
      });
    } catch (r8) {
      t6.some(function(n7) {
        n7.__h && (n7.__h = []);
      }), t6 = [], c5.__e(r8, n6.__v);
    }
  }), l5 && l5(n5, t6);
}, c5.unmount = function(n5) {
  m2 && m2(n5);
  var t6, r8 = n5.__c;
  r8 && r8.__H && (r8.__H.__.forEach(function(n6) {
    try {
      z5(n6);
    } catch (n7) {
      t6 = n7;
    }
  }), r8.__H = void 0, t6 && c5.__e(t6, r8.__v));
};
var k7 = "function" == typeof requestAnimationFrame;
function w4(n5) {
  var t6, r8 = function() {
    clearTimeout(u10), k7 && cancelAnimationFrame(t6), setTimeout(n5);
  }, u10 = setTimeout(r8, 100);
  k7 && (t6 = requestAnimationFrame(r8));
}
function z5(n5) {
  var t6 = r4, u10 = n5.__c;
  "function" == typeof u10 && (n5.__c = void 0, u10()), r4 = t6;
}
function B5(n5) {
  var t6 = r4;
  n5.__c = n5.__(), r4 = t6;
}
function C6(n5, t6) {
  return !n5 || n5.length !== t6.length || t6.some(function(t7, r8) {
    return t7 !== n5[r8];
  });
}
function D5(n5, t6) {
  return "function" == typeof t6 ? t6(n5) : t6;
}

// node_modules/@base-org/account/dist/ui/Dialog/Dialog-css.js
var Dialog_css_default = /* @__PURE__ */ (() => `.-base-acc-sdk-css-reset{-webkit-font-smoothing:antialiased;pointer-events:auto !important}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:2147483647}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-container *{user-select:none;box-sizing:border-box}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-backdrop{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;padding:20px}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-backdrop{align-items:flex-end;justify-content:stretch;padding:0}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog{position:relative;z-index:2147483648}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog{width:100%}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance{background:#fff;border-radius:12px;box-shadow:0 20px 25px -5px rgba(0,0,0,.1),0 10px 10px -5px rgba(0,0,0,.04);width:380px;max-height:90vh;overflow:hidden;transform:scale(0.95);opacity:0;transition:all .2s ease-in-out}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance{touch-action:pan-y;user-select:none}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-hidden{transform:scale(0.9);opacity:0}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-hidden{transform:translateY(100%)}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance:not(.-base-acc-sdk-dialog-instance-hidden){transform:scale(1);opacity:1}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance:not(.-base-acc-sdk-dialog-instance-hidden){transform:translateY(0)}}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance{width:100%;max-width:100%;border-radius:20px 20px 0 0;box-shadow:0 -10px 25px rgba(0,0,0,.15);max-height:80vh;transform:translateY(0)}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-hidden{transform:translateY(100%);opacity:1}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance:not(.-base-acc-sdk-dialog-instance-hidden){transform:translateY(0);opacity:1}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header{display:flex;align-items:center;justify-content:space-between;padding:16px 20px 0 20px}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header{padding:16px 20px 12px 20px}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-icon-and-title{display:flex;align-items:center;gap:8px}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-icon-and-title-title{font-family:"BaseSans-Regular",sans-serif;font-size:14px;font-weight:400;color:#5b616e}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-cblogo{width:32px;height:32px}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-close{display:flex;align-items:center;justify-content:center;width:32px;height:32px;cursor:pointer;border-radius:6px;transition:background-color .2s}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-close:hover{background-color:#f5f7f8}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-close-icon{width:14px;height:14px}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-header-close-icon{display:none}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-content{padding:20px 20px 16px 20px;font-family:"BaseSans-Regular",sans-serif}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-content{padding:8px 20px 12px 20px}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-content-title{font-size:20px;font-weight:600;line-height:28px;color:#0a0b0d;margin-bottom:10px}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-content-message{font-size:16px;font-weight:400;line-height:24px;color:#5b616e;margin-bottom:0}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-actions{display:flex;padding:16px 20px 20px 20px;flex-direction:column}@media(max-width: 600px)and (orientation: portrait){.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-actions{padding:16px 20px calc(20px + env(safe-area-inset-bottom)) 20px;gap:6px}}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button{font-family:"BaseSans-Regular",sans-serif;font-size:16px;font-weight:500;line-height:24px;border:none;border-radius:12px;padding:16px 24px;cursor:pointer;transition:all .2s ease-in-out;width:100%;margin:4px 0}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button:disabled{opacity:.5;cursor:not-allowed}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button-primary{background-color:#0a0b0d;color:#fff}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button-primary:hover:not(:disabled){background-color:#1c1e20}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button-primary:active:not(:disabled){background-color:#2a2d31}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button-secondary{background-color:#eef0f3;color:#0a0b0d}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button-secondary:hover:not(:disabled){background-color:#e1e4e8}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-instance-button-secondary:active:not(:disabled){background-color:#d4d8dd}.-base-acc-sdk-css-reset .-base-acc-sdk-dialog-handle-bar{position:absolute;top:-16px;left:50%;transform:translateX(-50%);width:64px;height:4px;background-color:#d1d5db;border-radius:2px;opacity:0;animation:handleBarFadeIn .2s ease-in-out .2s forwards}@keyframes handleBarFadeIn{from{opacity:0}to{opacity:1}}`)();

// node_modules/@base-org/account/dist/ui/Dialog/Dialog.js
var closeIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEzIDFMMSAxM20wLTEyTDEzIDEzIiBzdHJva2U9IiM5Q0EzQUYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+PC9zdmc+`;
function isPhonePortrait() {
  return window.innerWidth <= 600 && window.innerHeight > window.innerWidth;
}
var DialogHandleBar = () => {
  const [showHandleBar, setShowHandleBar] = h5(false);
  y7(() => {
    const checkOrientation = () => {
      setShowHandleBar(isPhonePortrait());
    };
    checkOrientation();
    window.addEventListener("resize", checkOrientation);
    window.addEventListener("orientationchange", checkOrientation);
    return () => {
      window.removeEventListener("resize", checkOrientation);
      window.removeEventListener("orientationchange", checkOrientation);
    };
  }, []);
  if (!showHandleBar) {
    return null;
  }
  return u4("div", { class: "-base-acc-sdk-dialog-handle-bar" });
};
var Dialog = class {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.nextItemKey = 0;
    this.root = null;
  }
  attach(el2) {
    this.root = document.createElement("div");
    this.root.className = "-base-acc-sdk-dialog-root";
    el2.appendChild(this.root);
    this.render();
  }
  presentItem(itemProps) {
    const key = this.nextItemKey++;
    this.items.set(key, itemProps);
    this.render();
  }
  clear() {
    this.items.clear();
    if (this.root) {
      B4(null, this.root);
    }
  }
  render() {
    if (this.root) {
      B4(u4("div", { children: u4(DialogContainer, { children: Array.from(this.items.entries()).map(([key, itemProps]) => _3(DialogInstance, Object.assign({}, itemProps, { key, handleClose: () => {
        var _a14;
        this.clear();
        (_a14 = itemProps.onClose) === null || _a14 === void 0 ? void 0 : _a14.call(itemProps);
      } }))) }) }), this.root);
    }
  }
};
var DialogContainer = (props) => {
  const [dragY, setDragY] = h5(0);
  const [isDragging, setIsDragging] = h5(false);
  const [startY, setStartY] = h5(0);
  const handleTouchStart = (e11) => {
    if (!isPhonePortrait())
      return;
    const touch = e11.touches[0];
    setStartY(touch.clientY);
    setIsDragging(true);
  };
  const handleTouchMove = (e11) => {
    if (!isDragging)
      return;
    const touch = e11.touches[0];
    const deltaY = touch.clientY - startY;
    if (deltaY > 0) {
      setDragY(deltaY);
      e11.preventDefault();
    }
  };
  const handleTouchEnd = () => {
    if (!isDragging)
      return;
    setIsDragging(false);
    if (dragY > 100) {
      const closeButton = document.querySelector(".-base-acc-sdk-dialog-instance-header-close");
      if (closeButton) {
        closeButton.click();
      }
    } else {
      setDragY(0);
    }
  };
  return u4("div", { class: clsx("-base-acc-sdk-dialog-container"), children: [u4("style", { children: Dialog_css_default }), u4("div", { class: "-base-acc-sdk-dialog-backdrop", onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd, children: u4("div", { class: "-base-acc-sdk-dialog", style: {
    transform: `translateY(${dragY}px)`,
    transition: isDragging ? "none" : "transform 0.2s ease-out"
  }, children: [u4(DialogHandleBar, {}), props.children] }) })] });
};
var DialogInstance = ({ title, message, actionItems, handleClose }) => {
  const [hidden, setHidden] = h5(true);
  const [isLoadingUsername, setIsLoadingUsername] = h5(true);
  const [username, setUsername] = h5(null);
  y7(() => {
    const timer = window.setTimeout(() => {
      setHidden(false);
    }, 1);
    return () => {
      window.clearTimeout(timer);
    };
  }, []);
  y7(() => {
    const fetchEnsName = async () => {
      var _a14;
      const address = (_a14 = store.account.get().accounts) === null || _a14 === void 0 ? void 0 : _a14[0];
      if (address) {
        const username2 = await getDisplayableUsername(address);
        setUsername(username2);
      }
      setIsLoadingUsername(false);
    };
    fetchEnsName();
  }, []);
  const headerTitle = T5(() => {
    return username ? `Signed in as ${username}` : "Base Account";
  }, [username]);
  const shouldShowHeaderTitle = !isLoadingUsername;
  return u4("div", { class: clsx("-base-acc-sdk-dialog-instance", hidden && "-base-acc-sdk-dialog-instance-hidden"), children: [u4("div", { class: "-base-acc-sdk-dialog-instance-header", children: [u4("div", { class: "-base-acc-sdk-dialog-instance-header-icon-and-title", children: [u4(BaseLogo, { fill: "blue" }), shouldShowHeaderTitle && u4("div", { class: "-base-acc-sdk-dialog-instance-header-icon-and-title-title", children: headerTitle })] }), u4("div", { class: "-base-acc-sdk-dialog-instance-header-close", onClick: handleClose, children: u4("img", { src: closeIcon, class: "-base-acc-sdk-dialog-instance-header-close-icon" }) })] }), u4("div", { class: "-base-acc-sdk-dialog-instance-content", children: [u4("div", { class: "-base-acc-sdk-dialog-instance-content-title", children: title }), u4("div", { class: "-base-acc-sdk-dialog-instance-content-message", children: message })] }), actionItems && actionItems.length > 0 && u4("div", { class: "-base-acc-sdk-dialog-instance-actions", children: actionItems.map((action, i9) => u4("button", { class: clsx("-base-acc-sdk-dialog-instance-button", action.variant === "primary" && "-base-acc-sdk-dialog-instance-button-primary", action.variant === "secondary" && "-base-acc-sdk-dialog-instance-button-secondary"), onClick: action.onClick, children: action.text }, i9)) })] });
};

// node_modules/@base-org/account/dist/ui/Dialog/index.js
var dialog = null;
function initDialog() {
  if (!dialog) {
    const root = document.createElement("div");
    root.className = "-base-acc-sdk-css-reset";
    document.body.appendChild(root);
    dialog = new Dialog();
    dialog.attach(root);
  }
  injectFontStyle();
  return dialog;
}

// node_modules/@base-org/account/dist/util/web.js
var POPUP_WIDTH = 420;
var POPUP_HEIGHT = 700;
var POPUP_BLOCKED_TITLE = "{app} wants to continue in Base Account";
var POPUP_BLOCKED_MESSAGE = "This action requires your permission to open a new window.";
function openPopup(url2) {
  const left13 = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;
  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;
  appendAppInfoQueryParams(url2);
  function tryOpenPopup() {
    const popupId = `wallet_${crypto.randomUUID()}`;
    const popup2 = window.open(url2, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left13}, top=${top}`);
    popup2 === null || popup2 === void 0 ? void 0 : popup2.focus();
    if (!popup2) {
      return null;
    }
    return popup2;
  }
  const popup = tryOpenPopup();
  if (!popup) {
    return openPopupWithDialog(tryOpenPopup);
  }
  return Promise.resolve(popup);
}
function closePopup(popup) {
  if (popup && !popup.closed) {
    popup.close();
  }
}
function appendAppInfoQueryParams(url2) {
  const params = {
    sdkName: PACKAGE_NAME,
    sdkVersion: PACKAGE_VERSION,
    origin: window.location.origin,
    coop: getCrossOriginOpenerPolicy()
  };
  for (const [key, value2] of Object.entries(params)) {
    if (!url2.searchParams.has(key)) {
      url2.searchParams.append(key, value2.toString());
    }
  }
}
function openPopupWithDialog(tryOpenPopup) {
  var _a14, _b;
  const dappName = (_b = (_a14 = store.config.get().metadata) === null || _a14 === void 0 ? void 0 : _a14.appName) !== null && _b !== void 0 ? _b : "App";
  const dialog2 = initDialog();
  return new Promise((resolve, reject) => {
    logDialogShown({ dialogContext: "popup_blocked" });
    dialog2.presentItem({
      title: POPUP_BLOCKED_TITLE.replace("{app}", dappName),
      message: POPUP_BLOCKED_MESSAGE,
      onClose: () => {
        logDialogActionClicked({
          dialogContext: "popup_blocked",
          dialogAction: "cancel"
        });
        reject(standardErrors.rpc.internal("Popup window was blocked"));
      },
      actionItems: [
        {
          text: "Try again",
          variant: "primary",
          onClick: () => {
            logDialogActionClicked({
              dialogContext: "popup_blocked",
              dialogAction: "confirm"
            });
            const popup = tryOpenPopup();
            if (popup) {
              resolve(popup);
            } else {
              reject(standardErrors.rpc.internal("Popup window was blocked"));
            }
            dialog2.clear();
          }
        },
        {
          text: "Cancel",
          variant: "secondary",
          onClick: () => {
            logDialogActionClicked({
              dialogContext: "popup_blocked",
              dialogAction: "cancel"
            });
            reject(standardErrors.rpc.internal("Popup window was blocked"));
            dialog2.clear();
          }
        }
      ]
    });
  });
}

// node_modules/@base-org/account/dist/core/communicator/Communicator.js
var Communicator = class {
  constructor({ url: url2 = CB_KEYS_URL, metadata, preference }) {
    this.popup = null;
    this.listeners = /* @__PURE__ */ new Map();
    this.postMessage = async (message) => {
      const popup = await this.waitForPopupLoaded();
      popup.postMessage(message, this.url.origin);
    };
    this.postRequestAndWaitForResponse = async (request2) => {
      const responsePromise = this.onMessage(({ requestId }) => requestId === request2.id);
      this.postMessage(request2);
      return await responsePromise;
    };
    this.onMessage = async (predicate) => {
      return new Promise((resolve, reject) => {
        const listener = (event) => {
          if (event.origin !== this.url.origin)
            return;
          const message = event.data;
          if (predicate(message)) {
            resolve(message);
            window.removeEventListener("message", listener);
            this.listeners.delete(listener);
          }
        };
        window.addEventListener("message", listener);
        this.listeners.set(listener, { reject });
      });
    };
    this.disconnect = () => {
      closePopup(this.popup);
      this.popup = null;
      this.listeners.forEach(({ reject }, listener) => {
        reject(standardErrors.provider.userRejectedRequest("Request rejected"));
        window.removeEventListener("message", listener);
      });
      this.listeners.clear();
    };
    this.waitForPopupLoaded = async () => {
      if (this.popup && !this.popup.closed) {
        this.popup.focus();
        return this.popup;
      }
      logPopupSetupStarted();
      this.popup = await openPopup(this.url);
      this.onMessage(({ event }) => event === "PopupUnload").then(() => {
        this.disconnect();
        logPopupUnloadReceived();
      }).catch(() => {
      });
      return this.onMessage(({ event }) => event === "PopupLoaded").then((message) => {
        this.postMessage({
          requestId: message.id,
          data: {
            version: PACKAGE_VERSION,
            sdkName: PACKAGE_NAME,
            metadata: this.metadata,
            preference: this.preference,
            location: window.location.toString()
          }
        });
      }).then(() => {
        if (!this.popup)
          throw standardErrors.rpc.internal();
        logPopupSetupCompleted();
        return this.popup;
      });
    };
    this.url = new URL(url2);
    this.metadata = metadata;
    this.preference = preference;
  }
};

// node_modules/@base-org/account/dist/core/error/serialize.js
function serializeError(error) {
  const serialized = serialize(getErrorObject(error), {
    shouldIncludeStack: true
  });
  const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  docUrl.searchParams.set("version", PACKAGE_VERSION);
  docUrl.searchParams.set("code", serialized.code.toString());
  docUrl.searchParams.set("message", serialized.message);
  return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
}
function isErrorResponse(response) {
  return response.errorMessage !== void 0;
}
function getErrorObject(error) {
  var _a14;
  if (typeof error === "string") {
    return {
      message: error,
      code: standardErrorCodes.rpc.internal
    };
  }
  if (isErrorResponse(error)) {
    const message = error.errorMessage;
    const code = (_a14 = error.errorCode) !== null && _a14 !== void 0 ? _a14 : message.match(/(denied|rejected)/i) ? standardErrorCodes.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, error), {
      message,
      code,
      data: { method: error.method }
    });
  }
  return error;
}

// node_modules/@base-org/account/dist/core/provider/interface.js
var ProviderEventEmitter = class extends import_index.default {
};

// node_modules/@base-org/account/dist/core/telemetry/events/provider.js
var logRequestStarted = ({ method, correlationId }) => {
  logEvent("provider.request.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    signerType: "base-account",
    correlationId
  }, AnalyticsEventImportance.high);
};
var logRequestError = ({ method, correlationId, errorMessage }) => {
  logEvent("provider.request.error", {
    action: ActionType.error,
    componentType: ComponentType.unknown,
    method,
    signerType: "base-account",
    correlationId,
    errorMessage
  }, AnalyticsEventImportance.high);
};
var logRequestResponded = ({ method, correlationId }) => {
  logEvent("provider.request.responded", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    signerType: "base-account",
    correlationId
  }, AnalyticsEventImportance.high);
};

// node_modules/@base-org/account/dist/core/type/index.js
function OpaqueType() {
  return (value2) => value2;
}
var HexString = OpaqueType();
var BigIntString = OpaqueType();
function IntNumber(num3) {
  return Math.floor(num3);
}
var RegExpString = OpaqueType();

// node_modules/@base-org/account/dist/core/type/util.js
var INT_STRING_REGEX = /^[0-9]*$/;
var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
function uint8ArrayToHex(value2) {
  return [...value2].map((b6) => b6.toString(16).padStart(2, "0")).join("");
}
function hexStringToUint8Array(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => Number.parseInt(byte, 16)));
}
function hexStringFromNumber(num3) {
  return HexString(`0x${BigInt(num3).toString(16)}`);
}
function has0xPrefix(str) {
  return str.startsWith("0x") || str.startsWith("0X");
}
function strip0x(hex2) {
  if (has0xPrefix(hex2)) {
    return hex2.slice(2);
  }
  return hex2;
}
function isHexString(hex2) {
  if (typeof hex2 !== "string") {
    return false;
  }
  const s5 = strip0x(hex2).toLowerCase();
  return HEXADECIMAL_STRING_REGEX.test(s5);
}
function ensureHexString(hex2, includePrefix = false) {
  if (typeof hex2 === "string") {
    const s5 = strip0x(hex2).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX.test(s5)) {
      return HexString(includePrefix ? `0x${s5}` : s5);
    }
  }
  throw standardErrors.rpc.invalidParams(`"${String(hex2)}" is not a hexadecimal string`);
}
function ensureEvenLengthHexString(hex2, includePrefix = false) {
  let h9 = ensureHexString(hex2, false);
  if (h9.length % 2 === 1) {
    h9 = HexString(`0${h9}`);
  }
  return includePrefix ? HexString(`0x${h9}`) : h9;
}
function ensureIntNumber(num3) {
  if (typeof num3 === "number" && Number.isInteger(num3)) {
    return IntNumber(num3);
  }
  if (typeof num3 === "string") {
    if (INT_STRING_REGEX.test(num3)) {
      return IntNumber(Number(num3));
    }
    if (isHexString(num3)) {
      return IntNumber(Number(BigInt(ensureEvenLengthHexString(num3, true))));
    }
  }
  throw standardErrors.rpc.invalidParams(`Not an integer: ${String(num3)}`);
}

// node_modules/@base-org/account/dist/core/telemetry/events/scw-signer.js
var logHandshakeStarted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_signer.handshake.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logHandshakeError = ({ method, correlationId, errorMessage }) => {
  var _a14;
  logEvent("scw_signer.handshake.error", {
    action: ActionType.error,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    errorMessage,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logHandshakeCompleted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_signer.handshake.completed", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logRequestStarted2 = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_signer.request.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logRequestError2 = ({ method, correlationId, errorMessage }) => {
  var _a14;
  logEvent("scw_signer.request.error", {
    action: ActionType.error,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    errorMessage,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logRequestCompleted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_signer.request.completed", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};

// node_modules/@base-org/account/dist/core/telemetry/events/scw-sub-account.js
var logSubAccountRequestStarted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_sub_account.request.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logSubAccountRequestCompleted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_sub_account.request.completed", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logSubAccountRequestError = ({ method, correlationId, errorMessage }) => {
  var _a14;
  logEvent("scw_sub_account.request.error", {
    action: ActionType.error,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    errorMessage,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logAddOwnerStarted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_sub_account.add_owner.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logAddOwnerCompleted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_sub_account.add_owner.completed", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logAddOwnerError = ({ method, correlationId, errorMessage }) => {
  var _a14;
  logEvent("scw_sub_account.add_owner.error", {
    action: ActionType.error,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    errorMessage,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logInsufficientBalanceErrorHandlingStarted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_sub_account.insufficient_balance.error_handling.started", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logInsufficientBalanceErrorHandlingCompleted = ({ method, correlationId }) => {
  var _a14;
  logEvent("scw_sub_account.insufficient_balance.error_handling.completed", {
    action: ActionType.unknown,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};
var logInsufficientBalanceErrorHandlingError = ({ method, correlationId, errorMessage }) => {
  var _a14;
  logEvent("scw_sub_account.insufficient_balance.error_handling.error", {
    action: ActionType.error,
    componentType: ComponentType.unknown,
    method,
    correlationId,
    errorMessage,
    enableAutoSubAccounts: (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.enableAutoSubAccounts
  }, AnalyticsEventImportance.high);
};

// node_modules/@base-org/account/dist/core/telemetry/utils.js
var parseErrorMessageFromAny = (errorOrAny) => {
  return "message" in errorOrAny && typeof errorOrAny.message === "string" ? errorOrAny.message : "";
};

// node_modules/viem/node_modules/ox/_esm/core/Base64.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var integerToCharacter = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a6, i9) => [i9, a6.charCodeAt(0)]));
var characterToInteger = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a6, i9) => [a6.charCodeAt(0), i9])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};

// node_modules/viem/node_modules/@noble/curves/esm/nist.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var p256_a = Fp256.create(BigInt("-3"));
var p256_b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p2562 = createCurve({
  a: p256_a,
  b: p256_b,
  Fp: Fp256,
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r12 = p2562;
var p256_mapSWU = (() => mapToCurveSimpleSWU(Fp256, {
  A: p256_a,
  B: p256_b,
  Z: Fp256.create(BigInt("-10"))
}))();
var p256_hasher = (() => createHasher(secp256r12.ProjectivePoint, (scalars) => p256_mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var Fp384 = Field(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"));
var p384_a = Fp384.create(BigInt("-3"));
var p384_b = BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");
var p384 = createCurve({
  a: p384_a,
  b: p384_b,
  Fp: Fp384,
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),
  h: BigInt(1),
  lowS: false
}, sha384);
var secp384r1 = p384;
var p384_mapSWU = (() => mapToCurveSimpleSWU(Fp384, {
  A: p384_a,
  B: p384_b,
  Z: Fp384.create(BigInt("-12"))
}))();
var p384_hasher = (() => createHasher(secp384r1.ProjectivePoint, (scalars) => p384_mapSWU(scalars[0]), {
  DST: "P384_XMD:SHA-384_SSWU_RO_",
  encodeDST: "P384_XMD:SHA-384_SSWU_NU_",
  p: Fp384.ORDER,
  m: 1,
  k: 192,
  expand: "xmd",
  hash: sha384
}))();
var Fp521 = Field(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
var p521_a = Fp521.create(BigInt("-3"));
var p521_b = BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");
var p521 = createCurve({
  a: p521_a,
  b: p521_b,
  Fp: Fp521,
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),
  h: BigInt(1),
  lowS: false,
  allowedPrivateKeyLengths: [130, 131, 132]
  // P521 keys are variable-length. Normalize to 132b
}, sha512);
var secp521r1 = p521;
var p521_mapSWU = (() => mapToCurveSimpleSWU(Fp521, {
  A: p521_a,
  B: p521_b,
  Z: Fp521.create(BigInt("-4"))
}))();
var p521_hasher = (() => createHasher(secp521r1.ProjectivePoint, (scalars) => p521_mapSWU(scalars[0]), {
  DST: "P521_XMD:SHA-512_SSWU_RO_",
  encodeDST: "P521_XMD:SHA-512_SSWU_NU_",
  p: Fp521.ORDER,
  m: 1,
  k: 256,
  expand: "xmd",
  hash: sha512
}))();

// node_modules/viem/node_modules/@noble/curves/esm/p256.js
var hashToCurve2 = (() => p256_hasher.hashToCurve)();
var encodeToCurve2 = (() => p256_hasher.encodeToCurve)();

// node_modules/viem/node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);

// node_modules/viem/_esm/account-abstraction/constants/abis.js
var entryPoint06Abi = [
  {
    inputs: [
      { name: "preOpGas", type: "uint256" },
      { name: "paid", type: "uint256" },
      { name: "validAfter", type: "uint48" },
      { name: "validUntil", type: "uint48" },
      { name: "targetSuccess", type: "bool" },
      { name: "targetResult", type: "bytes" }
    ],
    name: "ExecutionResult",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResult",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "aggregator", type: "address" },
          {
            components: [
              { name: "stake", type: "uint256" },
              {
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            name: "stakeInfo",
            type: "tuple"
          }
        ],
        name: "aggregatorInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResultWithAggregation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, name: "success", type: "bool" },
      {
        indexed: false,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "SIG_VALIDATION_FAILED",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "initCode", type: "bytes" },
      { name: "sender", type: "address" },
      { name: "paymasterAndData", type: "bytes" }
    ],
    name: "_validateSenderAndPaymaster",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint112" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint112" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "op",
        type: "tuple"
      },
      { name: "target", type: "address" },
      { name: "targetCallData", type: "bytes" }
    ],
    name: "simulateHandleOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "simulateValidation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/viem/_esm/account-abstraction/utils/userOperation/getInitCode.js
function getInitCode(userOperation) {
  const { authorization, factory: factory2, factoryData } = userOperation;
  if (factory2 === "0x7702" || factory2 === "0x7702000000000000000000000000000000000000") {
    if (!authorization)
      return "0x7702000000000000000000000000000000000000";
    const delegation = authorization.address;
    return concat([delegation, factoryData ?? "0x"]);
  }
  if (!factory2)
    return "0x";
  return concat([factory2, factoryData ?? "0x"]);
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/toPackedUserOperation.js
function toPackedUserOperation(userOperation) {
  const { callGasLimit, callData, maxPriorityFeePerGas, maxFeePerGas, paymaster, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, sender, signature = "0x", verificationGasLimit } = userOperation;
  const accountGasLimits = concat([
    pad(numberToHex(verificationGasLimit || 0n), { size: 16 }),
    pad(numberToHex(callGasLimit || 0n), { size: 16 })
  ]);
  const initCode = getInitCode(userOperation);
  const gasFees = concat([
    pad(numberToHex(maxPriorityFeePerGas || 0n), { size: 16 }),
    pad(numberToHex(maxFeePerGas || 0n), { size: 16 })
  ]);
  const nonce = userOperation.nonce ?? 0n;
  const paymasterAndData = paymaster ? concat([
    paymaster,
    pad(numberToHex(paymasterVerificationGasLimit || 0n), {
      size: 16
    }),
    pad(numberToHex(paymasterPostOpGasLimit || 0n), {
      size: 16
    }),
    paymasterData || "0x"
  ]) : "0x";
  const preVerificationGas = userOperation.preVerificationGas ?? 0n;
  return {
    accountGasLimits,
    callData,
    initCode,
    gasFees,
    nonce,
    paymasterAndData,
    preVerificationGas,
    sender,
    signature
  };
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/getUserOperationTypedData.js
var types = {
  PackedUserOperation: [
    { type: "address", name: "sender" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "bytes32", name: "accountGasLimits" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "bytes32", name: "gasFees" },
    { type: "bytes", name: "paymasterAndData" }
  ]
};
function getUserOperationTypedData(parameters) {
  const { chainId, entryPointAddress, userOperation } = parameters;
  const packedUserOp = toPackedUserOperation(userOperation);
  return {
    types,
    primaryType: "PackedUserOperation",
    domain: {
      name: "ERC4337",
      version: "1",
      chainId,
      verifyingContract: entryPointAddress
    },
    message: packedUserOp
  };
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/getUserOperationHash.js
function getUserOperationHash(parameters) {
  const { chainId, entryPointAddress, entryPointVersion } = parameters;
  const userOperation = parameters.userOperation;
  const { authorization, callData = "0x", callGasLimit, maxFeePerGas, maxPriorityFeePerGas, nonce, paymasterAndData = "0x", preVerificationGas, sender, verificationGasLimit } = userOperation;
  if (entryPointVersion === "0.8")
    return hashTypedData(getUserOperationTypedData({
      chainId,
      entryPointAddress,
      userOperation
    }));
  const packedUserOp = (() => {
    var _a14, _b;
    if (entryPointVersion === "0.6") {
      const factory2 = (_a14 = userOperation.initCode) == null ? void 0 : _a14.slice(0, 42);
      const factoryData = (_b = userOperation.initCode) == null ? void 0 : _b.slice(42);
      const initCode = getInitCode({
        authorization,
        factory: factory2,
        factoryData
      });
      return encodeAbiParameters([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" }
      ], [
        sender,
        nonce,
        keccak256(initCode),
        keccak256(callData),
        callGasLimit,
        verificationGasLimit,
        preVerificationGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        keccak256(paymasterAndData)
      ]);
    }
    if (entryPointVersion === "0.7") {
      const packedUserOp2 = toPackedUserOperation(userOperation);
      return encodeAbiParameters([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
      ], [
        packedUserOp2.sender,
        packedUserOp2.nonce,
        keccak256(packedUserOp2.initCode),
        keccak256(packedUserOp2.callData),
        packedUserOp2.accountGasLimits,
        packedUserOp2.preVerificationGas,
        packedUserOp2.gasFees,
        keccak256(packedUserOp2.paymasterAndData)
      ]);
    }
    throw new Error(`entryPointVersion "${entryPointVersion}" not supported.`);
  })();
  return keccak256(encodeAbiParameters([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [keccak256(packedUserOp), entryPointAddress, BigInt(chainId)]));
}

// node_modules/viem/_esm/account-abstraction/accounts/toSmartAccount.js
async function toSmartAccount(implementation) {
  const { extend: extend15, nonceKeyManager = createNonceManager({
    source: {
      get() {
        return Date.now();
      },
      set() {
      }
    }
  }), ...rest } = implementation;
  let deployed = false;
  const address = await implementation.getAddress();
  return {
    ...extend15,
    ...rest,
    address,
    async getFactoryArgs() {
      if ("isDeployed" in this && await this.isDeployed())
        return { factory: void 0, factoryData: void 0 };
      return implementation.getFactoryArgs();
    },
    async getNonce(parameters) {
      const key = (parameters == null ? void 0 : parameters.key) ?? BigInt(await nonceKeyManager.consume({
        address,
        chainId: implementation.client.chain.id,
        client: implementation.client
      }));
      if (implementation.getNonce)
        return await implementation.getNonce({ ...parameters, key });
      const nonce = await readContract(implementation.client, {
        abi: parseAbi([
          "function getNonce(address, uint192) pure returns (uint256)"
        ]),
        address: implementation.entryPoint.address,
        functionName: "getNonce",
        args: [address, key]
      });
      return nonce;
    },
    async isDeployed() {
      if (deployed)
        return true;
      const code = await getAction(implementation.client, getCode, "getCode")({
        address
      });
      deployed = Boolean(code);
      return deployed;
    },
    ...implementation.sign ? {
      async sign(parameters) {
        const [{ factory: factory2, factoryData }, signature] = await Promise.all([
          this.getFactoryArgs(),
          implementation.sign(parameters)
        ]);
        if (factory2 && factoryData)
          return serializeErc6492Signature({
            address: factory2,
            data: factoryData,
            signature
          });
        return signature;
      }
    } : {},
    async signMessage(parameters) {
      const [{ factory: factory2, factoryData }, signature] = await Promise.all([
        this.getFactoryArgs(),
        implementation.signMessage(parameters)
      ]);
      if (factory2 && factoryData && factory2 !== "0x7702")
        return serializeErc6492Signature({
          address: factory2,
          data: factoryData,
          signature
        });
      return signature;
    },
    async signTypedData(parameters) {
      const [{ factory: factory2, factoryData }, signature] = await Promise.all([
        this.getFactoryArgs(),
        implementation.signTypedData(parameters)
      ]);
      if (factory2 && factoryData && factory2 !== "0x7702")
        return serializeErc6492Signature({
          address: factory2,
          data: factoryData,
          signature
        });
      return signature;
    },
    type: "smart"
  };
}

// node_modules/viem/_esm/account-abstraction/errors/bundler.js
var AccountNotDeployedError = class extends BaseError {
  constructor({ cause }) {
    super("Smart Account is not deployed.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.",
        "- An incorrect `sender` address is provided."
      ],
      name: "AccountNotDeployedError"
    });
  }
};
Object.defineProperty(AccountNotDeployedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa20/
});
var ExecutionRevertedError2 = class extends BaseError {
  constructor({ cause, data, message } = {}) {
    var _a14;
    const reason = (_a14 = message == null ? void 0 : message.replace("execution reverted: ", "")) == null ? void 0 : _a14.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause,
      name: "ExecutionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data;
  }
};
Object.defineProperty(ExecutionRevertedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32521
});
Object.defineProperty(ExecutionRevertedError2, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
var FailedToSendToBeneficiaryError = class extends BaseError {
  constructor({ cause }) {
    super("Failed to send funds to beneficiary.", {
      cause,
      name: "FailedToSendToBeneficiaryError"
    });
  }
};
Object.defineProperty(FailedToSendToBeneficiaryError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa91/
});
var GasValuesOverflowError = class extends BaseError {
  constructor({ cause }) {
    super("Gas value overflowed.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- one of the gas values exceeded 2**120 (uint120)"
      ].filter(Boolean),
      name: "GasValuesOverflowError"
    });
  }
};
Object.defineProperty(GasValuesOverflowError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa94/
});
var HandleOpsOutOfGasError = class extends BaseError {
  constructor({ cause }) {
    super("The `handleOps` function was called by the Bundler with a gas limit too low.", {
      cause,
      name: "HandleOpsOutOfGasError"
    });
  }
};
Object.defineProperty(HandleOpsOutOfGasError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa95/
});
var InitCodeFailedError = class extends BaseError {
  constructor({ cause, factory: factory2, factoryData, initCode }) {
    super("Failed to simulate deployment for Smart Account.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- Invalid `factory`/`factoryData` or `initCode` properties are present",
        "- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)",
        "- Smart Account deployment execution reverted with an error\n",
        factory2 && `factory: ${factory2}`,
        factoryData && `factoryData: ${factoryData}`,
        initCode && `initCode: ${initCode}`
      ].filter(Boolean),
      name: "InitCodeFailedError"
    });
  }
};
Object.defineProperty(InitCodeFailedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa13/
});
var InitCodeMustCreateSenderError = class extends BaseError {
  constructor({ cause, factory: factory2, factoryData, initCode }) {
    super("Smart Account initialization implementation did not create an account.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- `factory`/`factoryData` or `initCode` properties are invalid",
        "- Smart Account initialization implementation is incorrect\n",
        factory2 && `factory: ${factory2}`,
        factoryData && `factoryData: ${factoryData}`,
        initCode && `initCode: ${initCode}`
      ].filter(Boolean),
      name: "InitCodeMustCreateSenderError"
    });
  }
};
Object.defineProperty(InitCodeMustCreateSenderError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa15/
});
var InitCodeMustReturnSenderError = class extends BaseError {
  constructor({ cause, factory: factory2, factoryData, initCode, sender }) {
    super("Smart Account initialization implementation does not return the expected sender.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "Smart Account initialization implementation does not return a sender address\n",
        factory2 && `factory: ${factory2}`,
        factoryData && `factoryData: ${factoryData}`,
        initCode && `initCode: ${initCode}`,
        sender && `sender: ${sender}`
      ].filter(Boolean),
      name: "InitCodeMustReturnSenderError"
    });
  }
};
Object.defineProperty(InitCodeMustReturnSenderError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa14/
});
var InsufficientPrefundError = class extends BaseError {
  constructor({ cause }) {
    super("Smart Account does not have sufficient funds to execute the User Operation.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the Smart Account does not have sufficient funds to cover the required prefund, or",
        "- a Paymaster was not provided"
      ].filter(Boolean),
      name: "InsufficientPrefundError"
    });
  }
};
Object.defineProperty(InsufficientPrefundError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa21/
});
var InternalCallOnlyError = class extends BaseError {
  constructor({ cause }) {
    super("Bundler attempted to call an invalid function on the EntryPoint.", {
      cause,
      name: "InternalCallOnlyError"
    });
  }
};
Object.defineProperty(InternalCallOnlyError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa92/
});
var InvalidAggregatorError = class extends BaseError {
  constructor({ cause }) {
    super("Bundler used an invalid aggregator for handling aggregated User Operations.", {
      cause,
      name: "InvalidAggregatorError"
    });
  }
};
Object.defineProperty(InvalidAggregatorError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa96/
});
var InvalidAccountNonceError = class extends BaseError {
  constructor({ cause, nonce }) {
    super("Invalid Smart Account nonce used for User Operation.", {
      cause,
      metaMessages: [nonce && `nonce: ${nonce}`].filter(Boolean),
      name: "InvalidAccountNonceError"
    });
  }
};
Object.defineProperty(InvalidAccountNonceError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa25/
});
var InvalidBeneficiaryError = class extends BaseError {
  constructor({ cause }) {
    super("Bundler has not set a beneficiary address.", {
      cause,
      name: "InvalidBeneficiaryError"
    });
  }
};
Object.defineProperty(InvalidBeneficiaryError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa90/
});
var InvalidFieldsError = class extends BaseError {
  constructor({ cause }) {
    super("Invalid fields set on User Operation.", {
      cause,
      name: "InvalidFieldsError"
    });
  }
};
Object.defineProperty(InvalidFieldsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InvalidPaymasterAndDataError = class extends BaseError {
  constructor({ cause, paymasterAndData }) {
    super("Paymaster properties provided are invalid.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the `paymasterAndData` property is of an incorrect length\n",
        paymasterAndData && `paymasterAndData: ${paymasterAndData}`
      ].filter(Boolean),
      name: "InvalidPaymasterAndDataError"
    });
  }
};
Object.defineProperty(InvalidPaymasterAndDataError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa93/
});
var PaymasterDepositTooLowError = class extends BaseError {
  constructor({ cause }) {
    super("Paymaster deposit for the User Operation is too low.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the Paymaster has deposited less than the expected amount via the `deposit` function"
      ].filter(Boolean),
      name: "PaymasterDepositTooLowError"
    });
  }
};
Object.defineProperty(PaymasterDepositTooLowError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32508
});
Object.defineProperty(PaymasterDepositTooLowError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa31/
});
var PaymasterFunctionRevertedError = class extends BaseError {
  constructor({ cause }) {
    super("The `validatePaymasterUserOp` function on the Paymaster reverted.", {
      cause,
      name: "PaymasterFunctionRevertedError"
    });
  }
};
Object.defineProperty(PaymasterFunctionRevertedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa33/
});
var PaymasterNotDeployedError = class extends BaseError {
  constructor({ cause }) {
    super("The Paymaster contract has not been deployed.", {
      cause,
      name: "PaymasterNotDeployedError"
    });
  }
};
Object.defineProperty(PaymasterNotDeployedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa30/
});
var PaymasterRateLimitError = class extends BaseError {
  constructor({ cause }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause,
      name: "PaymasterRateLimitError"
    });
  }
};
Object.defineProperty(PaymasterRateLimitError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32504
});
var PaymasterStakeTooLowError = class extends BaseError {
  constructor({ cause }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause,
      name: "PaymasterStakeTooLowError"
    });
  }
};
Object.defineProperty(PaymasterStakeTooLowError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32505
});
var PaymasterPostOpFunctionRevertedError = class extends BaseError {
  constructor({ cause }) {
    super("Paymaster `postOp` function reverted.", {
      cause,
      name: "PaymasterPostOpFunctionRevertedError"
    });
  }
};
Object.defineProperty(PaymasterPostOpFunctionRevertedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa50/
});
var SenderAlreadyConstructedError = class extends BaseError {
  constructor({ cause, factory: factory2, factoryData, initCode }) {
    super("Smart Account has already been deployed.", {
      cause,
      metaMessages: [
        "Remove the following properties and try again:",
        factory2 && "`factory`",
        factoryData && "`factoryData`",
        initCode && "`initCode`"
      ].filter(Boolean),
      name: "SenderAlreadyConstructedError"
    });
  }
};
Object.defineProperty(SenderAlreadyConstructedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa10/
});
var SignatureCheckFailedError = class extends BaseError {
  constructor({ cause }) {
    super("UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).", {
      cause,
      name: "SignatureCheckFailedError"
    });
  }
};
Object.defineProperty(SignatureCheckFailedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32507
});
var SmartAccountFunctionRevertedError = class extends BaseError {
  constructor({ cause }) {
    super("The `validateUserOp` function on the Smart Account reverted.", {
      cause,
      name: "SmartAccountFunctionRevertedError"
    });
  }
};
Object.defineProperty(SmartAccountFunctionRevertedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa23/
});
var UnsupportedSignatureAggregatorError = class extends BaseError {
  constructor({ cause }) {
    super("UserOperation rejected because account specified unsupported signature aggregator.", {
      cause,
      name: "UnsupportedSignatureAggregatorError"
    });
  }
};
Object.defineProperty(UnsupportedSignatureAggregatorError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32506
});
var UserOperationExpiredError = class extends BaseError {
  constructor({ cause }) {
    super("User Operation expired.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied"
      ].filter(Boolean),
      name: "UserOperationExpiredError"
    });
  }
};
Object.defineProperty(UserOperationExpiredError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa22/
});
var UserOperationPaymasterExpiredError = class extends BaseError {
  constructor({ cause }) {
    super("Paymaster for User Operation expired.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied"
      ].filter(Boolean),
      name: "UserOperationPaymasterExpiredError"
    });
  }
};
Object.defineProperty(UserOperationPaymasterExpiredError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa32/
});
var UserOperationSignatureError = class extends BaseError {
  constructor({ cause }) {
    super("Signature provided for the User Operation is invalid.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account"
      ].filter(Boolean),
      name: "UserOperationSignatureError"
    });
  }
};
Object.defineProperty(UserOperationSignatureError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa24/
});
var UserOperationPaymasterSignatureError = class extends BaseError {
  constructor({ cause }) {
    super("Signature provided for the User Operation is invalid.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster"
      ].filter(Boolean),
      name: "UserOperationPaymasterSignatureError"
    });
  }
};
Object.defineProperty(UserOperationPaymasterSignatureError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa34/
});
var UserOperationRejectedByEntryPointError = class extends BaseError {
  constructor({ cause }) {
    super("User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.", {
      cause,
      name: "UserOperationRejectedByEntryPointError"
    });
  }
};
Object.defineProperty(UserOperationRejectedByEntryPointError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32500
});
var UserOperationRejectedByPaymasterError = class extends BaseError {
  constructor({ cause }) {
    super("User Operation rejected by Paymaster's `validatePaymasterUserOp`.", {
      cause,
      name: "UserOperationRejectedByPaymasterError"
    });
  }
};
Object.defineProperty(UserOperationRejectedByPaymasterError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32501
});
var UserOperationRejectedByOpCodeError = class extends BaseError {
  constructor({ cause }) {
    super("User Operation rejected with op code validation error.", {
      cause,
      name: "UserOperationRejectedByOpCodeError"
    });
  }
};
Object.defineProperty(UserOperationRejectedByOpCodeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32502
});
var UserOperationOutOfTimeRangeError = class extends BaseError {
  constructor({ cause }) {
    super("UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).", {
      cause,
      name: "UserOperationOutOfTimeRangeError"
    });
  }
};
Object.defineProperty(UserOperationOutOfTimeRangeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32503
});
var UnknownBundlerError = class extends BaseError {
  constructor({ cause }) {
    super(`An error occurred while executing user operation: ${cause == null ? void 0 : cause.shortMessage}`, {
      cause,
      name: "UnknownBundlerError"
    });
  }
};
var VerificationGasLimitExceededError = class extends BaseError {
  constructor({ cause }) {
    super("User Operation verification gas limit exceeded.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the gas used for verification exceeded the `verificationGasLimit`"
      ].filter(Boolean),
      name: "VerificationGasLimitExceededError"
    });
  }
};
Object.defineProperty(VerificationGasLimitExceededError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa40/
});
var VerificationGasLimitTooLowError = class extends BaseError {
  constructor({ cause }) {
    super("User Operation verification gas limit is too low.", {
      cause,
      metaMessages: [
        "This could arise when:",
        "- the `verificationGasLimit` is too low to verify the User Operation"
      ].filter(Boolean),
      name: "VerificationGasLimitTooLowError"
    });
  }
};
Object.defineProperty(VerificationGasLimitTooLowError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa41/
});

// node_modules/viem/_esm/account-abstraction/errors/userOperation.js
var UserOperationExecutionError = class extends BaseError {
  constructor(cause, { callData, callGasLimit, docsPath, factory: factory2, factoryData, initCode, maxFeePerGas, maxPriorityFeePerGas, nonce, paymaster, paymasterAndData, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, preVerificationGas, sender, signature, verificationGasLimit }) {
    const prettyArgs = prettyPrint({
      callData,
      callGasLimit,
      factory: factory2,
      factoryData,
      initCode,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce,
      paymaster,
      paymasterAndData,
      paymasterData,
      paymasterPostOpGasLimit,
      paymasterVerificationGasLimit,
      preVerificationGas,
      sender,
      signature,
      verificationGasLimit
    });
    super(cause.shortMessage, {
      cause,
      docsPath,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "UserOperationExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
};
var UserOperationReceiptNotFoundError = class extends BaseError {
  constructor({ hash: hash9 }) {
    super(`User Operation receipt with hash "${hash9}" could not be found. The User Operation may not have been processed yet.`, { name: "UserOperationReceiptNotFoundError" });
  }
};
var UserOperationNotFoundError = class extends BaseError {
  constructor({ hash: hash9 }) {
    super(`User Operation with hash "${hash9}" could not be found.`, {
      name: "UserOperationNotFoundError"
    });
  }
};
var WaitForUserOperationReceiptTimeoutError = class extends BaseError {
  constructor({ hash: hash9 }) {
    super(`Timed out while waiting for User Operation with hash "${hash9}" to be confirmed.`, { name: "WaitForUserOperationReceiptTimeoutError" });
  }
};

// node_modules/viem/_esm/account-abstraction/utils/errors/getBundlerError.js
var bundlerErrors = [
  ExecutionRevertedError2,
  InvalidFieldsError,
  PaymasterDepositTooLowError,
  PaymasterRateLimitError,
  PaymasterStakeTooLowError,
  SignatureCheckFailedError,
  UnsupportedSignatureAggregatorError,
  UserOperationOutOfTimeRangeError,
  UserOperationRejectedByEntryPointError,
  UserOperationRejectedByPaymasterError,
  UserOperationRejectedByOpCodeError
];
function getBundlerError(err, args) {
  const message = (err.details || "").toLowerCase();
  if (AccountNotDeployedError.message.test(message))
    return new AccountNotDeployedError({
      cause: err
    });
  if (FailedToSendToBeneficiaryError.message.test(message))
    return new FailedToSendToBeneficiaryError({
      cause: err
    });
  if (GasValuesOverflowError.message.test(message))
    return new GasValuesOverflowError({
      cause: err
    });
  if (HandleOpsOutOfGasError.message.test(message))
    return new HandleOpsOutOfGasError({
      cause: err
    });
  if (InitCodeFailedError.message.test(message))
    return new InitCodeFailedError({
      cause: err,
      factory: args.factory,
      factoryData: args.factoryData,
      initCode: args.initCode
    });
  if (InitCodeMustCreateSenderError.message.test(message))
    return new InitCodeMustCreateSenderError({
      cause: err,
      factory: args.factory,
      factoryData: args.factoryData,
      initCode: args.initCode
    });
  if (InitCodeMustReturnSenderError.message.test(message))
    return new InitCodeMustReturnSenderError({
      cause: err,
      factory: args.factory,
      factoryData: args.factoryData,
      initCode: args.initCode,
      sender: args.sender
    });
  if (InsufficientPrefundError.message.test(message))
    return new InsufficientPrefundError({
      cause: err
    });
  if (InternalCallOnlyError.message.test(message))
    return new InternalCallOnlyError({
      cause: err
    });
  if (InvalidAccountNonceError.message.test(message))
    return new InvalidAccountNonceError({
      cause: err,
      nonce: args.nonce
    });
  if (InvalidAggregatorError.message.test(message))
    return new InvalidAggregatorError({
      cause: err
    });
  if (InvalidBeneficiaryError.message.test(message))
    return new InvalidBeneficiaryError({
      cause: err
    });
  if (InvalidPaymasterAndDataError.message.test(message))
    return new InvalidPaymasterAndDataError({
      cause: err
    });
  if (PaymasterDepositTooLowError.message.test(message))
    return new PaymasterDepositTooLowError({
      cause: err
    });
  if (PaymasterFunctionRevertedError.message.test(message))
    return new PaymasterFunctionRevertedError({
      cause: err
    });
  if (PaymasterNotDeployedError.message.test(message))
    return new PaymasterNotDeployedError({
      cause: err
    });
  if (PaymasterPostOpFunctionRevertedError.message.test(message))
    return new PaymasterPostOpFunctionRevertedError({
      cause: err
    });
  if (SmartAccountFunctionRevertedError.message.test(message))
    return new SmartAccountFunctionRevertedError({
      cause: err
    });
  if (SenderAlreadyConstructedError.message.test(message))
    return new SenderAlreadyConstructedError({
      cause: err,
      factory: args.factory,
      factoryData: args.factoryData,
      initCode: args.initCode
    });
  if (UserOperationExpiredError.message.test(message))
    return new UserOperationExpiredError({
      cause: err
    });
  if (UserOperationPaymasterExpiredError.message.test(message))
    return new UserOperationPaymasterExpiredError({
      cause: err
    });
  if (UserOperationPaymasterSignatureError.message.test(message))
    return new UserOperationPaymasterSignatureError({
      cause: err
    });
  if (UserOperationSignatureError.message.test(message))
    return new UserOperationSignatureError({
      cause: err
    });
  if (VerificationGasLimitExceededError.message.test(message))
    return new VerificationGasLimitExceededError({
      cause: err
    });
  if (VerificationGasLimitTooLowError.message.test(message))
    return new VerificationGasLimitTooLowError({
      cause: err
    });
  const error = err.walk((e11) => bundlerErrors.some((error2) => error2.code === e11.code));
  if (error) {
    if (error.code === ExecutionRevertedError2.code)
      return new ExecutionRevertedError2({
        cause: err,
        data: error.data,
        message: error.details
      });
    if (error.code === InvalidFieldsError.code)
      return new InvalidFieldsError({
        cause: err
      });
    if (error.code === PaymasterDepositTooLowError.code)
      return new PaymasterDepositTooLowError({
        cause: err
      });
    if (error.code === PaymasterRateLimitError.code)
      return new PaymasterRateLimitError({
        cause: err
      });
    if (error.code === PaymasterStakeTooLowError.code)
      return new PaymasterStakeTooLowError({
        cause: err
      });
    if (error.code === SignatureCheckFailedError.code)
      return new SignatureCheckFailedError({
        cause: err
      });
    if (error.code === UnsupportedSignatureAggregatorError.code)
      return new UnsupportedSignatureAggregatorError({
        cause: err
      });
    if (error.code === UserOperationOutOfTimeRangeError.code)
      return new UserOperationOutOfTimeRangeError({
        cause: err
      });
    if (error.code === UserOperationRejectedByEntryPointError.code)
      return new UserOperationRejectedByEntryPointError({
        cause: err
      });
    if (error.code === UserOperationRejectedByPaymasterError.code)
      return new UserOperationRejectedByPaymasterError({
        cause: err
      });
    if (error.code === UserOperationRejectedByOpCodeError.code)
      return new UserOperationRejectedByOpCodeError({
        cause: err
      });
  }
  return new UnknownBundlerError({
    cause: err
  });
}

// node_modules/viem/_esm/account-abstraction/utils/errors/getUserOperationError.js
function getUserOperationError(err, { calls, docsPath, ...args }) {
  const cause = (() => {
    const cause2 = getBundlerError(err, args);
    if (calls && cause2 instanceof ExecutionRevertedError2) {
      const revertData = getRevertData(cause2);
      const contractCalls = calls == null ? void 0 : calls.filter((call3) => call3.abi);
      if (revertData && contractCalls.length > 0)
        return getContractError2({ calls: contractCalls, revertData });
    }
    return cause2;
  })();
  return new UserOperationExecutionError(cause, {
    docsPath,
    ...args
  });
}
function getRevertData(error) {
  let revertData;
  error.walk((e11) => {
    var _a14, _b, _c3, _d2;
    const error2 = e11;
    if (typeof error2.data === "string" || typeof ((_a14 = error2.data) == null ? void 0 : _a14.revertData) === "string" || !(error2 instanceof BaseError) && typeof error2.message === "string") {
      const match14 = (_d2 = (_c3 = ((_b = error2.data) == null ? void 0 : _b.revertData) || error2.data || error2.message).match) == null ? void 0 : _d2.call(_c3, /(0x[A-Za-z0-9]*)/);
      if (match14) {
        revertData = match14[1];
        return true;
      }
    }
    return false;
  });
  return revertData;
}
function getContractError2(parameters) {
  const { calls, revertData } = parameters;
  const { abi: abi3, functionName, args, to: to6 } = (() => {
    const contractCalls = calls == null ? void 0 : calls.filter((call3) => Boolean(call3.abi));
    if (contractCalls.length === 1)
      return contractCalls[0];
    const compatContractCalls = contractCalls.filter((call3) => {
      try {
        return Boolean(decodeErrorResult({
          abi: call3.abi,
          data: revertData
        }));
      } catch {
        return false;
      }
    });
    if (compatContractCalls.length === 1)
      return compatContractCalls[0];
    return {
      abi: [],
      functionName: contractCalls.reduce((acc, call3) => `${acc ? `${acc} | ` : ""}${call3.functionName}`, ""),
      args: void 0,
      to: void 0
    };
  })();
  const cause = (() => {
    if (revertData === "0x")
      return new ContractFunctionZeroDataError({ functionName });
    return new ContractFunctionRevertedError({
      abi: abi3,
      data: revertData,
      functionName
    });
  })();
  return new ContractFunctionExecutionError(cause, {
    abi: abi3,
    args,
    contractAddress: to6,
    functionName
  });
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperationGas.js
function formatUserOperationGas(parameters) {
  const gas = {};
  if (parameters.callGasLimit)
    gas.callGasLimit = BigInt(parameters.callGasLimit);
  if (parameters.preVerificationGas)
    gas.preVerificationGas = BigInt(parameters.preVerificationGas);
  if (parameters.verificationGasLimit)
    gas.verificationGasLimit = BigInt(parameters.verificationGasLimit);
  if (parameters.paymasterPostOpGasLimit)
    gas.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit);
  if (parameters.paymasterVerificationGasLimit)
    gas.paymasterVerificationGasLimit = BigInt(parameters.paymasterVerificationGasLimit);
  return gas;
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperationRequest.js
function formatUserOperationRequest(request2) {
  const rpcRequest = {};
  if (typeof request2.callData !== "undefined")
    rpcRequest.callData = request2.callData;
  if (typeof request2.callGasLimit !== "undefined")
    rpcRequest.callGasLimit = numberToHex(request2.callGasLimit);
  if (typeof request2.factory !== "undefined")
    rpcRequest.factory = request2.factory;
  if (typeof request2.factoryData !== "undefined")
    rpcRequest.factoryData = request2.factoryData;
  if (typeof request2.initCode !== "undefined")
    rpcRequest.initCode = request2.initCode;
  if (typeof request2.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request2.maxFeePerGas);
  if (typeof request2.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request2.maxPriorityFeePerGas);
  if (typeof request2.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request2.nonce);
  if (typeof request2.paymaster !== "undefined")
    rpcRequest.paymaster = request2.paymaster;
  if (typeof request2.paymasterAndData !== "undefined")
    rpcRequest.paymasterAndData = request2.paymasterAndData || "0x";
  if (typeof request2.paymasterData !== "undefined")
    rpcRequest.paymasterData = request2.paymasterData;
  if (typeof request2.paymasterPostOpGasLimit !== "undefined")
    rpcRequest.paymasterPostOpGasLimit = numberToHex(request2.paymasterPostOpGasLimit);
  if (typeof request2.paymasterVerificationGasLimit !== "undefined")
    rpcRequest.paymasterVerificationGasLimit = numberToHex(request2.paymasterVerificationGasLimit);
  if (typeof request2.preVerificationGas !== "undefined")
    rpcRequest.preVerificationGas = numberToHex(request2.preVerificationGas);
  if (typeof request2.sender !== "undefined")
    rpcRequest.sender = request2.sender;
  if (typeof request2.signature !== "undefined")
    rpcRequest.signature = request2.signature;
  if (typeof request2.verificationGasLimit !== "undefined")
    rpcRequest.verificationGasLimit = numberToHex(request2.verificationGasLimit);
  if (typeof request2.authorization !== "undefined")
    rpcRequest.eip7702Auth = formatAuthorization(request2.authorization);
  return rpcRequest;
}
function formatAuthorization(authorization) {
  return {
    address: authorization.address,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    r: authorization.r ? numberToHex(BigInt(authorization.r), { size: 32 }) : pad("0x", { size: 32 }),
    s: authorization.s ? numberToHex(BigInt(authorization.s), { size: 32 }) : pad("0x", { size: 32 }),
    yParity: authorization.yParity ? numberToHex(authorization.yParity, { size: 1 }) : pad("0x", { size: 32 })
  };
}

// node_modules/viem/_esm/account-abstraction/actions/paymaster/getPaymasterData.js
async function getPaymasterData(client, parameters) {
  const { chainId, entryPointAddress, context, ...userOperation } = parameters;
  const request2 = formatUserOperationRequest(userOperation);
  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } = await client.request({
    method: "pm_getPaymasterData",
    params: [
      {
        ...request2,
        callGasLimit: request2.callGasLimit ?? "0x0",
        verificationGasLimit: request2.verificationGasLimit ?? "0x0",
        preVerificationGas: request2.preVerificationGas ?? "0x0"
      },
      entryPointAddress,
      numberToHex(chainId),
      context
    ]
  });
  return {
    ...rest,
    ...paymasterPostOpGasLimit && {
      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit)
    },
    ...paymasterVerificationGasLimit && {
      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit)
    }
  };
}

// node_modules/viem/_esm/account-abstraction/actions/paymaster/getPaymasterStubData.js
async function getPaymasterStubData(client, parameters) {
  const { chainId, entryPointAddress, context, ...userOperation } = parameters;
  const request2 = formatUserOperationRequest(userOperation);
  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } = await client.request({
    method: "pm_getPaymasterStubData",
    params: [
      {
        ...request2,
        callGasLimit: request2.callGasLimit ?? "0x0",
        verificationGasLimit: request2.verificationGasLimit ?? "0x0",
        preVerificationGas: request2.preVerificationGas ?? "0x0"
      },
      entryPointAddress,
      numberToHex(chainId),
      context
    ]
  });
  return {
    ...rest,
    ...paymasterPostOpGasLimit && {
      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit)
    },
    ...paymasterVerificationGasLimit && {
      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit)
    }
  };
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/prepareUserOperation.js
var defaultParameters3 = [
  "factory",
  "fees",
  "gas",
  "paymaster",
  "nonce",
  "signature",
  "authorization"
];
async function prepareUserOperation(client, parameters_) {
  var _a14;
  const parameters = parameters_;
  const { account: account_ = client.account, parameters: properties = defaultParameters3, stateOverride } = parameters;
  if (!account_)
    throw new AccountNotFoundError();
  const account2 = parseAccount(account_);
  const bundlerClient = client;
  const paymaster = parameters.paymaster ?? (bundlerClient == null ? void 0 : bundlerClient.paymaster);
  const paymasterAddress = typeof paymaster === "string" ? paymaster : void 0;
  const { getPaymasterStubData: getPaymasterStubData2, getPaymasterData: getPaymasterData2 } = (() => {
    if (paymaster === true)
      return {
        getPaymasterStubData: (parameters2) => getAction(bundlerClient, getPaymasterStubData, "getPaymasterStubData")(parameters2),
        getPaymasterData: (parameters2) => getAction(bundlerClient, getPaymasterData, "getPaymasterData")(parameters2)
      };
    if (typeof paymaster === "object") {
      const { getPaymasterStubData: getPaymasterStubData3, getPaymasterData: getPaymasterData3 } = paymaster;
      return {
        getPaymasterStubData: getPaymasterData3 && getPaymasterStubData3 ? getPaymasterStubData3 : getPaymasterData3,
        getPaymasterData: getPaymasterData3 && getPaymasterStubData3 ? getPaymasterData3 : void 0
      };
    }
    return {
      getPaymasterStubData: void 0,
      getPaymasterData: void 0
    };
  })();
  const paymasterContext = parameters.paymasterContext ? parameters.paymasterContext : bundlerClient == null ? void 0 : bundlerClient.paymasterContext;
  let request2 = {
    ...parameters,
    paymaster: paymasterAddress,
    sender: account2.address
  };
  const [callData, factory2, fees, nonce, authorization] = await Promise.all([
    (async () => {
      if (parameters.calls)
        return account2.encodeCalls(parameters.calls.map((call_) => {
          const call3 = call_;
          if (call3.abi)
            return {
              data: encodeFunctionData(call3),
              to: call3.to,
              value: call3.value
            };
          return call3;
        }));
      return parameters.callData;
    })(),
    (async () => {
      if (!properties.includes("factory"))
        return void 0;
      if (parameters.initCode)
        return { initCode: parameters.initCode };
      if (parameters.factory && parameters.factoryData) {
        return {
          factory: parameters.factory,
          factoryData: parameters.factoryData
        };
      }
      const { factory: factory3, factoryData } = await account2.getFactoryArgs();
      if (account2.entryPoint.version === "0.6")
        return {
          initCode: factory3 && factoryData ? concat([factory3, factoryData]) : void 0
        };
      return {
        factory: factory3,
        factoryData
      };
    })(),
    (async () => {
      var _a15;
      if (!properties.includes("fees"))
        return void 0;
      if (typeof parameters.maxFeePerGas === "bigint" && typeof parameters.maxPriorityFeePerGas === "bigint")
        return request2;
      if ((_a15 = bundlerClient == null ? void 0 : bundlerClient.userOperation) == null ? void 0 : _a15.estimateFeesPerGas) {
        const fees2 = await bundlerClient.userOperation.estimateFeesPerGas({
          account: account2,
          bundlerClient,
          userOperation: request2
        });
        return {
          ...request2,
          ...fees2
        };
      }
      try {
        const client_ = bundlerClient.client ?? client;
        const fees2 = await getAction(client_, estimateFeesPerGas, "estimateFeesPerGas")({
          chain: client_.chain,
          type: "eip1559"
        });
        return {
          maxFeePerGas: typeof parameters.maxFeePerGas === "bigint" ? parameters.maxFeePerGas : BigInt(
            // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
            2n * fees2.maxFeePerGas
          ),
          maxPriorityFeePerGas: typeof parameters.maxPriorityFeePerGas === "bigint" ? parameters.maxPriorityFeePerGas : BigInt(
            // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
            2n * fees2.maxPriorityFeePerGas
          )
        };
      } catch {
        return void 0;
      }
    })(),
    (async () => {
      if (!properties.includes("nonce"))
        return void 0;
      if (typeof parameters.nonce === "bigint")
        return parameters.nonce;
      return account2.getNonce();
    })(),
    (async () => {
      if (!properties.includes("authorization"))
        return void 0;
      if (typeof parameters.authorization === "object")
        return parameters.authorization;
      if (account2.authorization && !await account2.isDeployed()) {
        const authorization2 = await prepareAuthorization(account2.client, account2.authorization);
        return {
          ...authorization2,
          r: "0xfffffffffffffffffffffffffffffff000000000000000000000000000000000",
          s: "0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
          yParity: 1
        };
      }
      return void 0;
    })()
  ]);
  if (typeof callData !== "undefined")
    request2.callData = callData;
  if (typeof factory2 !== "undefined")
    request2 = { ...request2, ...factory2 };
  if (typeof fees !== "undefined")
    request2 = { ...request2, ...fees };
  if (typeof nonce !== "undefined")
    request2.nonce = nonce;
  if (typeof authorization !== "undefined")
    request2.authorization = authorization;
  if (properties.includes("signature")) {
    if (typeof parameters.signature !== "undefined")
      request2.signature = parameters.signature;
    else
      request2.signature = await account2.getStubSignature(request2);
  }
  if (account2.entryPoint.version === "0.6" && !request2.initCode)
    request2.initCode = "0x";
  let chainId;
  async function getChainId3() {
    if (chainId)
      return chainId;
    if (client.chain)
      return client.chain.id;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  let isPaymasterPopulated = false;
  if (properties.includes("paymaster") && getPaymasterStubData2 && !paymasterAddress && !parameters.paymasterAndData) {
    const { isFinal = false, sponsor: _6, ...paymasterArgs } = await getPaymasterStubData2({
      chainId: await getChainId3(),
      entryPointAddress: account2.entryPoint.address,
      context: paymasterContext,
      ...request2
    });
    isPaymasterPopulated = isFinal;
    request2 = {
      ...request2,
      ...paymasterArgs
    };
  }
  if (account2.entryPoint.version === "0.6" && !request2.paymasterAndData)
    request2.paymasterAndData = "0x";
  if (properties.includes("gas")) {
    if ((_a14 = account2.userOperation) == null ? void 0 : _a14.estimateGas) {
      const gas = await account2.userOperation.estimateGas(request2);
      request2 = {
        ...request2,
        ...gas
      };
    }
    if (typeof request2.callGasLimit === "undefined" || typeof request2.preVerificationGas === "undefined" || typeof request2.verificationGasLimit === "undefined" || request2.paymaster && typeof request2.paymasterPostOpGasLimit === "undefined" || request2.paymaster && typeof request2.paymasterVerificationGasLimit === "undefined") {
      const gas = await getAction(bundlerClient, estimateUserOperationGas, "estimateUserOperationGas")({
        account: account2,
        // Some Bundlers fail if nullish gas values are provided for gas estimation :') 
        // so we will need to set a default zeroish value.
        callGasLimit: 0n,
        preVerificationGas: 0n,
        verificationGasLimit: 0n,
        stateOverride,
        ...request2.paymaster ? {
          paymasterPostOpGasLimit: 0n,
          paymasterVerificationGasLimit: 0n
        } : {},
        ...request2
      });
      request2 = {
        ...request2,
        callGasLimit: request2.callGasLimit ?? gas.callGasLimit,
        preVerificationGas: request2.preVerificationGas ?? gas.preVerificationGas,
        verificationGasLimit: request2.verificationGasLimit ?? gas.verificationGasLimit,
        paymasterPostOpGasLimit: request2.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,
        paymasterVerificationGasLimit: request2.paymasterVerificationGasLimit ?? gas.paymasterVerificationGasLimit
      };
    }
  }
  if (properties.includes("paymaster") && getPaymasterData2 && !paymasterAddress && !parameters.paymasterAndData && !isPaymasterPopulated) {
    const paymaster2 = await getPaymasterData2({
      chainId: await getChainId3(),
      entryPointAddress: account2.entryPoint.address,
      context: paymasterContext,
      ...request2
    });
    request2 = {
      ...request2,
      ...paymaster2
    };
  }
  delete request2.calls;
  delete request2.parameters;
  delete request2.paymasterContext;
  if (typeof request2.paymaster !== "string")
    delete request2.paymaster;
  return request2;
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/estimateUserOperationGas.js
async function estimateUserOperationGas(client, parameters) {
  var _a14;
  const { account: account_ = client.account, entryPointAddress, stateOverride } = parameters;
  if (!account_ && !parameters.sender)
    throw new AccountNotFoundError();
  const account2 = account_ ? parseAccount(account_) : void 0;
  const rpcStateOverride = serializeStateOverride(stateOverride);
  const request2 = account2 ? await getAction(client, prepareUserOperation, "prepareUserOperation")({
    ...parameters,
    parameters: [
      "authorization",
      "factory",
      "nonce",
      "paymaster",
      "signature"
    ]
  }) : parameters;
  try {
    const params = [
      formatUserOperationRequest(request2),
      entryPointAddress ?? ((_a14 = account2 == null ? void 0 : account2.entryPoint) == null ? void 0 : _a14.address)
    ];
    const result = await client.request({
      method: "eth_estimateUserOperationGas",
      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params]
    });
    return formatUserOperationGas(result);
  } catch (error) {
    const calls = parameters.calls;
    throw getUserOperationError(error, {
      ...request2,
      ...calls ? { calls } : {}
    });
  }
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/getSupportedEntryPoints.js
function getSupportedEntryPoints(client) {
  return client.request({ method: "eth_supportedEntryPoints" });
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperation.js
function formatUserOperation(parameters) {
  const userOperation = { ...parameters };
  if (parameters.callGasLimit)
    userOperation.callGasLimit = BigInt(parameters.callGasLimit);
  if (parameters.maxFeePerGas)
    userOperation.maxFeePerGas = BigInt(parameters.maxFeePerGas);
  if (parameters.maxPriorityFeePerGas)
    userOperation.maxPriorityFeePerGas = BigInt(parameters.maxPriorityFeePerGas);
  if (parameters.nonce)
    userOperation.nonce = BigInt(parameters.nonce);
  if (parameters.paymasterPostOpGasLimit)
    userOperation.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit);
  if (parameters.paymasterVerificationGasLimit)
    userOperation.paymasterVerificationGasLimit = BigInt(parameters.paymasterVerificationGasLimit);
  if (parameters.preVerificationGas)
    userOperation.preVerificationGas = BigInt(parameters.preVerificationGas);
  if (parameters.verificationGasLimit)
    userOperation.verificationGasLimit = BigInt(parameters.verificationGasLimit);
  return userOperation;
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/getUserOperation.js
async function getUserOperation(client, { hash: hash9 }) {
  const result = await client.request({
    method: "eth_getUserOperationByHash",
    params: [hash9]
  }, { dedupe: true });
  if (!result)
    throw new UserOperationNotFoundError({ hash: hash9 });
  const { blockHash, blockNumber, entryPoint, transactionHash, userOperation } = result;
  return {
    blockHash,
    blockNumber: BigInt(blockNumber),
    entryPoint,
    transactionHash,
    userOperation: formatUserOperation(userOperation)
  };
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperationReceipt.js
function formatUserOperationReceipt(parameters) {
  const receipt = { ...parameters };
  if (parameters.actualGasCost)
    receipt.actualGasCost = BigInt(parameters.actualGasCost);
  if (parameters.actualGasUsed)
    receipt.actualGasUsed = BigInt(parameters.actualGasUsed);
  if (parameters.logs)
    receipt.logs = parameters.logs.map((log) => formatLog(log));
  if (parameters.receipt)
    receipt.receipt = formatTransactionReceipt(receipt.receipt);
  return receipt;
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/getUserOperationReceipt.js
async function getUserOperationReceipt(client, { hash: hash9 }) {
  const receipt = await client.request({
    method: "eth_getUserOperationReceipt",
    params: [hash9]
  }, { dedupe: true });
  if (!receipt)
    throw new UserOperationReceiptNotFoundError({ hash: hash9 });
  return formatUserOperationReceipt(receipt);
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/sendUserOperation.js
async function sendUserOperation(client, parameters) {
  var _a14, _b;
  const { account: account_ = client.account, entryPointAddress } = parameters;
  if (!account_ && !parameters.sender)
    throw new AccountNotFoundError();
  const account2 = account_ ? parseAccount(account_) : void 0;
  const request2 = account2 ? await getAction(client, prepareUserOperation, "prepareUserOperation")(parameters) : parameters;
  const signature = parameters.signature || await ((_a14 = account2 == null ? void 0 : account2.signUserOperation) == null ? void 0 : _a14.call(account2, request2));
  const rpcParameters = formatUserOperationRequest({
    ...request2,
    signature
  });
  try {
    return await client.request({
      method: "eth_sendUserOperation",
      params: [
        rpcParameters,
        entryPointAddress ?? ((_b = account2 == null ? void 0 : account2.entryPoint) == null ? void 0 : _b.address)
      ]
    }, { retryCount: 0 });
  } catch (error) {
    const calls = parameters.calls;
    throw getUserOperationError(error, {
      ...request2,
      ...calls ? { calls } : {},
      signature
    });
  }
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/waitForUserOperationReceipt.js
function waitForUserOperationReceipt(client, parameters) {
  const { hash: hash9, pollingInterval = client.pollingInterval, retryCount, timeout = 12e4 } = parameters;
  let count = 0;
  const observerId = stringify([
    "waitForUserOperationReceipt",
    client.uid,
    hash9
  ]);
  return new Promise((resolve, reject) => {
    const unobserve = observe(observerId, { resolve, reject }, (emit) => {
      const done = (fn4) => {
        unpoll();
        fn4();
        unobserve();
      };
      const unpoll = poll(async () => {
        if (retryCount && count >= retryCount)
          done(() => emit.reject(new WaitForUserOperationReceiptTimeoutError({ hash: hash9 })));
        try {
          const receipt = await getAction(client, getUserOperationReceipt, "getUserOperationReceipt")({ hash: hash9 });
          done(() => emit.resolve(receipt));
        } catch (err) {
          const error = err;
          if (error.name !== "UserOperationReceiptNotFoundError")
            done(() => emit.reject(error));
        }
        count++;
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      if (timeout)
        setTimeout(() => done(() => emit.reject(new WaitForUserOperationReceiptTimeoutError({ hash: hash9 }))), timeout);
      return unpoll;
    });
  });
}

// node_modules/viem/_esm/account-abstraction/clients/decorators/bundler.js
function bundlerActions(client) {
  return {
    estimateUserOperationGas: (parameters) => estimateUserOperationGas(client, parameters),
    getChainId: () => getChainId(client),
    getSupportedEntryPoints: () => getSupportedEntryPoints(client),
    getUserOperation: (parameters) => getUserOperation(client, parameters),
    getUserOperationReceipt: (parameters) => getUserOperationReceipt(client, parameters),
    prepareUserOperation: (parameters) => prepareUserOperation(client, parameters),
    sendUserOperation: (parameters) => sendUserOperation(client, parameters),
    waitForUserOperationReceipt: (parameters) => waitForUserOperationReceipt(client, parameters)
  };
}

// node_modules/viem/_esm/account-abstraction/clients/createBundlerClient.js
function createBundlerClient(parameters) {
  const { client: client_, key = "bundler", name = "Bundler Client", paymaster, paymasterContext, transport, userOperation } = parameters;
  const client = Object.assign(createClient({
    ...parameters,
    chain: parameters.chain ?? (client_ == null ? void 0 : client_.chain),
    key,
    name,
    transport,
    type: "bundlerClient"
  }), { client: client_, paymaster, paymasterContext, userOperation });
  return client.extend(bundlerActions);
}

// node_modules/viem/_esm/account-abstraction/constants/address.js
var entryPoint06Address2 = "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789";

// node_modules/viem/node_modules/ox/_esm/erc4337/EntryPoint.js
var EntryPoint_exports = {};
__export(EntryPoint_exports, {
  abiV06: () => abiV06,
  abiV07: () => abiV07,
  abiV08: () => abiV08,
  addressV06: () => addressV06,
  addressV07: () => addressV07,
  addressV08: () => addressV08
});
var abiV06 = [
  {
    inputs: [
      { name: "preOpGas", type: "uint256" },
      { name: "paid", type: "uint256" },
      { name: "validAfter", type: "uint48" },
      { name: "validUntil", type: "uint48" },
      { name: "targetSuccess", type: "bool" },
      { name: "targetResult", type: "bytes" }
    ],
    name: "ExecutionResult",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResult",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "aggregator", type: "address" },
          {
            components: [
              { name: "stake", type: "uint256" },
              {
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            name: "stakeInfo",
            type: "tuple"
          }
        ],
        name: "aggregatorInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResultWithAggregation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, name: "success", type: "bool" },
      {
        indexed: false,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "SIG_VALIDATION_FAILED",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "initCode", type: "bytes" },
      { name: "sender", type: "address" },
      { name: "paymasterAndData", type: "bytes" }
    ],
    name: "_validateSenderAndPaymaster",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint112" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint112" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "op",
        type: "tuple"
      },
      { name: "target", type: "address" },
      { name: "targetCallData", type: "bytes" }
    ],
    name: "simulateHandleOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "simulateValidation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
var abiV07 = [
  {
    inputs: [
      { name: "success", type: "bool" },
      { name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" },
      { name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [{ name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, name: "success", type: "bool" },
      {
        indexed: false,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "target", type: "address" },
      { name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint256" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint256" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "gasFees", type: "bytes32" },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
var abiV08 = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    inputs: [
      { internalType: "bool", name: "success", type: "bool" },
      { internalType: "bytes", name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "opIndex", type: "uint256" },
      { internalType: "string", name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "opIndex", type: "uint256" },
      { internalType: "string", name: "reason", type: "string" },
      { internalType: "bytes", name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  { inputs: [], name: "InvalidShortString", type: "error" },
  {
    inputs: [{ internalType: "bytes", name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "str", type: "string" }],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "EIP712DomainChanged", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, internalType: "bool", name: "success", type: "bool" },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [
      { internalType: "uint32", name: "unstakeDelaySec", type: "uint32" }
    ],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "target", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { internalType: "bytes1", name: "fields", type: "bytes1" },
      { internalType: "string", name: "name", type: "string" },
      { internalType: "string", name: "version", type: "string" },
      { internalType: "uint256", name: "chainId", type: "uint256" },
      { internalType: "address", name: "verifyingContract", type: "address" },
      { internalType: "bytes32", name: "salt", type: "bytes32" },
      { internalType: "uint256[]", name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "deposit", type: "uint256" },
          { internalType: "bool", name: "staked", type: "bool" },
          { internalType: "uint112", name: "stake", type: "uint112" },
          { internalType: "uint32", name: "unstakeDelaySec", type: "uint32" },
          { internalType: "uint48", name: "withdrawTime", type: "uint48" }
        ],
        internalType: "struct IStakeManager.DepositInfo",
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getDomainSeparatorV4",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint192", name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ internalType: "uint256", name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPackedUserOpTypeHash",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { internalType: "address", name: "sender", type: "address" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              { internalType: "bytes", name: "initCode", type: "bytes" },
              { internalType: "bytes", name: "callData", type: "bytes" },
              {
                internalType: "bytes32",
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              { internalType: "bytes32", name: "gasFees", type: "bytes32" },
              {
                internalType: "bytes",
                name: "paymasterAndData",
                type: "bytes"
              },
              { internalType: "bytes", name: "signature", type: "bytes" }
            ],
            internalType: "struct PackedUserOperation[]",
            name: "userOps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAggregator",
            name: "aggregator",
            type: "address"
          },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct IEntryPoint.UserOpsPerAggregator[]",
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { internalType: "address payable", name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          { internalType: "bytes", name: "callData", type: "bytes" },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          { internalType: "bytes", name: "paymasterAndData", type: "bytes" },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation[]",
        name: "ops",
        type: "tuple[]"
      },
      { internalType: "address payable", name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint192", name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes", name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { internalType: "address", name: "sender", type: "address" },
              { internalType: "uint256", name: "nonce", type: "uint256" },
              {
                internalType: "uint256",
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "callGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "preVerificationGas",
                type: "uint256"
              },
              { internalType: "address", name: "paymaster", type: "address" },
              {
                internalType: "uint256",
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            internalType: "struct EntryPoint.MemoryUserOp",
            name: "mUserOp",
            type: "tuple"
          },
          { internalType: "bytes32", name: "userOpHash", type: "bytes32" },
          { internalType: "uint256", name: "prefund", type: "uint256" },
          { internalType: "uint256", name: "contextOffset", type: "uint256" },
          { internalType: "uint256", name: "preOpGas", type: "uint256" }
        ],
        internalType: "struct EntryPoint.UserOpInfo",
        name: "opInfo",
        type: "tuple"
      },
      { internalType: "bytes", name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [
      { internalType: "uint256", name: "actualGasCost", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint192", name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "senderCreator",
    outputs: [
      { internalType: "contract ISenderCreator", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address payable",
        name: "withdrawAddress",
        type: "address"
      },
      { internalType: "uint256", name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
var addressV06 = "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789";
var addressV07 = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";
var addressV08 = "0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108";

// node_modules/viem/node_modules/ox/_esm/erc4337/RpcSchema.js
var RpcSchema_exports = {};

// node_modules/viem/node_modules/ox/_esm/erc4337/UserOperation.js
var UserOperation_exports = {};
__export(UserOperation_exports, {
  from: () => from9,
  fromPacked: () => fromPacked,
  fromRpc: () => fromRpc,
  getSignPayload: () => getSignPayload2,
  hash: () => hash,
  toInitCode: () => toInitCode,
  toPacked: () => toPacked,
  toRpc: () => toRpc2,
  toTypedData: () => toTypedData
});

// node_modules/viem/node_modules/ox/_esm/core/TypedData.js
function assert2(value2) {
  const { domain, message, primaryType, types: types2 } = value2;
  const validateData = (struct2, data) => {
    for (const param of struct2) {
      const { name, type: type7 } = param;
      const value3 = data[name];
      const integerMatch = type7.match(integerRegex);
      if (integerMatch && (typeof value3 === "number" || typeof value3 === "bigint")) {
        const [, base4, size_] = integerMatch;
        fromNumber(value3, {
          signed: base4 === "int",
          size: Number.parseInt(size_ ?? "", 10) / 8
        });
      }
      if (type7 === "address" && typeof value3 === "string" && !validate(value3))
        throw new InvalidAddressError2({
          address: value3,
          cause: new InvalidInputError()
        });
      const bytesMatch = type7.match(bytesRegex);
      if (bytesMatch) {
        const [, size11] = bytesMatch;
        if (size11 && size2(value3) !== Number.parseInt(size11, 10))
          throw new BytesSizeMismatchError3({
            expectedSize: Number.parseInt(size11, 10),
            givenSize: size2(value3)
          });
      }
      const struct3 = types2[type7];
      if (struct3) {
        validateReference(type7);
        validateData(struct3, value3);
      }
    }
  };
  if (types2.EIP712Domain && domain) {
    if (typeof domain !== "object")
      throw new InvalidDomainError2({ domain });
    validateData(types2.EIP712Domain, domain);
  }
  if (primaryType !== "EIP712Domain") {
    if (types2[primaryType])
      validateData(types2[primaryType], message);
    else
      throw new InvalidPrimaryTypeError2({ primaryType, types: types2 });
  }
}
function encode6(value2) {
  const { domain = {}, message, primaryType } = value2;
  const types2 = {
    EIP712Domain: extractEip712DomainTypes(domain),
    ...value2.types
  };
  assert2({
    domain,
    message,
    primaryType,
    types: types2
  });
  const parts2 = ["0x19", "0x01"];
  if (domain)
    parts2.push(hashDomain2({
      domain,
      types: types2
    }));
  if (primaryType !== "EIP712Domain")
    parts2.push(hashStruct3({
      data: message,
      primaryType,
      types: types2
    }));
  return concat2(...parts2);
}
function encodeType2(value2) {
  const { primaryType, types: types2 } = value2;
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types2 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type7 of deps) {
    result += `${type7}(${(types2[type7] ?? []).map(({ name, type: t6 }) => `${t6} ${name}`).join(",")})`;
  }
  return result;
}
function extractEip712DomainTypes(domain) {
  return [
    typeof (domain == null ? void 0 : domain.name) === "string" && { name: "name", type: "string" },
    (domain == null ? void 0 : domain.version) && { name: "version", type: "string" },
    (typeof (domain == null ? void 0 : domain.chainId) === "number" || typeof (domain == null ? void 0 : domain.chainId) === "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    (domain == null ? void 0 : domain.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain == null ? void 0 : domain.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function getSignPayload(value2) {
  return keccak2562(encode6(value2));
}
function hashDomain2(value2) {
  const { domain, types: types2 } = value2;
  return hashStruct3({
    data: domain,
    primaryType: "EIP712Domain",
    types: {
      ...types2,
      EIP712Domain: (types2 == null ? void 0 : types2.EIP712Domain) || extractEip712DomainTypes(domain)
    }
  });
}
function hashStruct3(value2) {
  const { data, primaryType, types: types2 } = value2;
  const encoded = encodeData2({
    data,
    primaryType,
    types: types2
  });
  return keccak2562(encoded);
}
var BytesSizeMismatchError3 = class extends BaseError2 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.BytesSizeMismatchError"
    });
  }
};
var InvalidDomainError2 = class extends BaseError2 {
  constructor({ domain }) {
    super(`Invalid domain "${stringify2(domain)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidDomainError"
    });
  }
};
var InvalidPrimaryTypeError2 = class extends BaseError2 {
  constructor({ primaryType, types: types2 }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types2))}\`.`, {
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidPrimaryTypeError"
    });
  }
};
var InvalidStructTypeError2 = class extends BaseError2 {
  constructor({ type: type7 }) {
    super(`Struct type "${type7}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidStructTypeError"
    });
  }
};
function encodeData2(value2) {
  const { data, primaryType, types: types2 } = value2;
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types2 })];
  for (const field of types2[primaryType] ?? []) {
    const [type7, value3] = encodeField({
      types: types2,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type7);
    encodedValues.push(value3);
  }
  return encode(encodedTypes, encodedValues);
}
function hashType(value2) {
  const { primaryType, types: types2 } = value2;
  const encodedHashType = fromString2(encodeType2({ primaryType, types: types2 }));
  return keccak2562(encodedHashType);
}
function encodeField(properties) {
  let { types: types2, name, type: type7, value: value2 } = properties;
  if (types2[type7] !== void 0)
    return [
      { type: "bytes32" },
      keccak2562(encodeData2({ data: value2, primaryType: type7, types: types2 }))
    ];
  if (type7 === "bytes") {
    const prepend3 = value2.length % 2 ? "0" : "";
    value2 = `0x${prepend3 + value2.slice(2)}`;
    return [{ type: "bytes32" }, keccak2562(value2, { as: "Hex" })];
  }
  if (type7 === "string")
    return [
      { type: "bytes32" },
      keccak2562(fromString(value2), { as: "Hex" })
    ];
  if (type7.lastIndexOf("]") === type7.length - 1) {
    const parsedType = type7.slice(0, type7.lastIndexOf("["));
    const typeValuePairs = value2.map((item) => encodeField({
      name,
      type: parsedType,
      types: types2,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak2562(encode(typeValuePairs.map(([t6]) => t6), typeValuePairs.map(([, v9]) => v9)))
    ];
  }
  return [{ type: type7 }, value2];
}
function findTypeDependencies(value2, results = /* @__PURE__ */ new Set()) {
  const { primaryType: primaryType_, types: types2 } = value2;
  const match14 = primaryType_.match(/^\w*/u);
  const primaryType = match14 == null ? void 0 : match14[0];
  if (results.has(primaryType) || types2[primaryType] === void 0)
    return results;
  results.add(primaryType);
  for (const field of types2[primaryType])
    findTypeDependencies({ primaryType: field.type, types: types2 }, results);
  return results;
}
function validateReference(type7) {
  if (type7 === "address" || type7 === "bool" || type7 === "string" || type7.startsWith("bytes") || type7.startsWith("uint") || type7.startsWith("int"))
    throw new InvalidStructTypeError2({ type: type7 });
}

// node_modules/viem/node_modules/ox/_esm/erc4337/UserOperation.js
function from9(userOperation, options = {}) {
  const signature = (() => {
    if (typeof options.signature === "string")
      return options.signature;
    if (typeof options.signature === "object")
      return toHex2(options.signature);
    if (userOperation.signature)
      return userOperation.signature;
    return void 0;
  })();
  const packed = "accountGasLimits" in userOperation && "gasFees" in userOperation;
  const userOp = packed ? fromPacked(userOperation) : userOperation;
  return { ...userOp, signature };
}
function fromRpc(rpc2) {
  return {
    ...rpc2,
    callGasLimit: BigInt(rpc2.callGasLimit),
    maxFeePerGas: BigInt(rpc2.maxFeePerGas),
    maxPriorityFeePerGas: BigInt(rpc2.maxPriorityFeePerGas),
    nonce: BigInt(rpc2.nonce),
    preVerificationGas: BigInt(rpc2.preVerificationGas),
    verificationGasLimit: BigInt(rpc2.verificationGasLimit),
    ...rpc2.paymasterPostOpGasLimit && {
      paymasterPostOpGasLimit: BigInt(rpc2.paymasterPostOpGasLimit)
    },
    ...rpc2.paymasterVerificationGasLimit && {
      paymasterVerificationGasLimit: BigInt(rpc2.paymasterVerificationGasLimit)
    }
  };
}
function getSignPayload2(userOperation, options) {
  return hash(userOperation, options);
}
function hash(userOperation, options) {
  const { chainId, entryPointAddress, entryPointVersion } = options;
  const { callData, callGasLimit, initCode, factory: factory2, factoryData, maxFeePerGas, maxPriorityFeePerGas, nonce, paymaster, paymasterAndData, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, preVerificationGas, sender, verificationGasLimit } = userOperation;
  if (entryPointVersion === "0.8") {
    const typedData = toTypedData(userOperation, {
      chainId,
      entryPointAddress
    });
    return getSignPayload(typedData);
  }
  const packedUserOp = (() => {
    if (entryPointVersion === "0.6") {
      return encode([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" }
      ], [
        sender,
        nonce,
        keccak2562(initCode ?? "0x"),
        keccak2562(callData),
        callGasLimit,
        verificationGasLimit,
        preVerificationGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        keccak2562(paymasterAndData ?? "0x")
      ]);
    }
    if (entryPointVersion === "0.7") {
      const accountGasLimits = concat2(padLeft(fromNumber(verificationGasLimit), 16), padLeft(fromNumber(callGasLimit), 16));
      const gasFees = concat2(padLeft(fromNumber(maxPriorityFeePerGas), 16), padLeft(fromNumber(maxFeePerGas), 16));
      const initCode_hashed = keccak2562(factory2 && factoryData ? concat2(factory2, factoryData) : "0x");
      const paymasterAndData_hashed = keccak2562(paymaster ? concat2(paymaster, padLeft(fromNumber(paymasterVerificationGasLimit || 0), 16), padLeft(fromNumber(paymasterPostOpGasLimit || 0), 16), paymasterData || "0x") : "0x");
      return encode([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
      ], [
        sender,
        nonce,
        initCode_hashed,
        keccak2562(callData),
        accountGasLimits,
        preVerificationGas,
        gasFees,
        paymasterAndData_hashed
      ]);
    }
    throw new Error(`entryPointVersion "${entryPointVersion}" not supported.`);
  })();
  return keccak2562(encode([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [keccak2562(packedUserOp), entryPointAddress, BigInt(chainId)]));
}
function toInitCode(userOperation) {
  const { authorization, factory: factory2, factoryData } = userOperation;
  if (factory2 === "0x7702" || factory2 === "0x7702000000000000000000000000000000000000") {
    if (!authorization)
      return "0x7702000000000000000000000000000000000000";
    const delegation = authorization.address;
    return concat2(delegation, factoryData ?? "0x");
  }
  if (!factory2)
    return "0x";
  return concat2(factory2, factoryData ?? "0x");
}
function toPacked(userOperation) {
  const { callGasLimit, callData, maxPriorityFeePerGas, maxFeePerGas, nonce, paymaster, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, sender, signature, verificationGasLimit } = userOperation;
  const accountGasLimits = concat2(padLeft(fromNumber(verificationGasLimit || 0n), 16), padLeft(fromNumber(callGasLimit || 0n), 16));
  const initCode = toInitCode(userOperation);
  const gasFees = concat2(padLeft(fromNumber(maxPriorityFeePerGas || 0n), 16), padLeft(fromNumber(maxFeePerGas || 0n), 16));
  const paymasterAndData = paymaster ? concat2(paymaster, padLeft(fromNumber(paymasterVerificationGasLimit || 0n), 16), padLeft(fromNumber(paymasterPostOpGasLimit || 0n), 16), paymasterData || "0x") : "0x";
  const preVerificationGas = userOperation.preVerificationGas ?? 0n;
  return {
    accountGasLimits,
    callData,
    initCode,
    gasFees,
    nonce,
    paymasterAndData,
    preVerificationGas,
    sender,
    signature
  };
}
function fromPacked(packed) {
  const { accountGasLimits, callData, initCode, gasFees, nonce, paymasterAndData, preVerificationGas, sender, signature } = packed;
  const verificationGasLimit = BigInt(slice2(accountGasLimits, 0, 16));
  const callGasLimit = BigInt(slice2(accountGasLimits, 16, 32));
  const { factory: factory2, factoryData } = (() => {
    if (initCode === "0x")
      return { factory: void 0, factoryData: void 0 };
    const factory3 = slice2(initCode, 0, 20);
    const factoryData2 = size2(initCode) > 20 ? slice2(initCode, 20) : void 0;
    return { factory: factory3, factoryData: factoryData2 };
  })();
  const maxPriorityFeePerGas = BigInt(slice2(gasFees, 0, 16));
  const maxFeePerGas = BigInt(slice2(gasFees, 16, 32));
  const { paymaster, paymasterVerificationGasLimit, paymasterPostOpGasLimit, paymasterData } = (() => {
    if (paymasterAndData === "0x")
      return {
        paymaster: void 0,
        paymasterVerificationGasLimit: void 0,
        paymasterPostOpGasLimit: void 0,
        paymasterData: void 0
      };
    const paymaster2 = slice2(paymasterAndData, 0, 20);
    const paymasterVerificationGasLimit2 = BigInt(slice2(paymasterAndData, 20, 36));
    const paymasterPostOpGasLimit2 = BigInt(slice2(paymasterAndData, 36, 52));
    const paymasterData2 = size2(paymasterAndData) > 52 ? slice2(paymasterAndData, 52) : void 0;
    return {
      paymaster: paymaster2,
      paymasterVerificationGasLimit: paymasterVerificationGasLimit2,
      paymasterPostOpGasLimit: paymasterPostOpGasLimit2,
      paymasterData: paymasterData2
    };
  })();
  return {
    callData,
    callGasLimit,
    ...factory2 && { factory: factory2 },
    ...factoryData && { factoryData },
    maxFeePerGas,
    maxPriorityFeePerGas,
    nonce,
    ...paymaster && { paymaster },
    ...paymasterData && { paymasterData },
    ...typeof paymasterPostOpGasLimit === "bigint" && {
      paymasterPostOpGasLimit
    },
    ...typeof paymasterVerificationGasLimit === "bigint" && {
      paymasterVerificationGasLimit
    },
    preVerificationGas,
    sender,
    signature,
    verificationGasLimit
  };
}
function toRpc2(userOperation) {
  const rpc2 = {};
  rpc2.callData = userOperation.callData;
  rpc2.callGasLimit = fromNumber(userOperation.callGasLimit);
  rpc2.maxFeePerGas = fromNumber(userOperation.maxFeePerGas);
  rpc2.maxPriorityFeePerGas = fromNumber(userOperation.maxPriorityFeePerGas);
  rpc2.nonce = fromNumber(userOperation.nonce);
  rpc2.preVerificationGas = fromNumber(userOperation.preVerificationGas);
  rpc2.sender = userOperation.sender;
  rpc2.verificationGasLimit = fromNumber(userOperation.verificationGasLimit);
  if (userOperation.factory)
    rpc2.factory = userOperation.factory;
  if (userOperation.factoryData)
    rpc2.factoryData = userOperation.factoryData;
  if (userOperation.initCode)
    rpc2.initCode = userOperation.initCode;
  if (userOperation.paymaster)
    rpc2.paymaster = userOperation.paymaster;
  if (userOperation.paymasterData)
    rpc2.paymasterData = userOperation.paymasterData;
  if (typeof userOperation.paymasterPostOpGasLimit === "bigint")
    rpc2.paymasterPostOpGasLimit = fromNumber(userOperation.paymasterPostOpGasLimit);
  if (typeof userOperation.paymasterVerificationGasLimit === "bigint")
    rpc2.paymasterVerificationGasLimit = fromNumber(userOperation.paymasterVerificationGasLimit);
  if (userOperation.signature)
    rpc2.signature = userOperation.signature;
  return rpc2;
}
function toTypedData(userOperation, options) {
  const { chainId, entryPointAddress } = options;
  const packedUserOp = toPacked(userOperation);
  return {
    domain: {
      name: "ERC4337",
      version: "1",
      chainId,
      verifyingContract: entryPointAddress
    },
    message: packedUserOp,
    primaryType: "PackedUserOperation",
    types: toTypedData.types
  };
}
(function(toTypedData2) {
  toTypedData2.types = {
    PackedUserOperation: [
      { type: "address", name: "sender" },
      { type: "uint256", name: "nonce" },
      { type: "bytes", name: "initCode" },
      { type: "bytes", name: "callData" },
      { type: "bytes32", name: "accountGasLimits" },
      { type: "uint256", name: "preVerificationGas" },
      { type: "bytes32", name: "gasFees" },
      { type: "bytes", name: "paymasterAndData" }
    ]
  };
})(toTypedData || (toTypedData = {}));

// node_modules/viem/node_modules/ox/_esm/erc4337/UserOperationGas.js
var UserOperationGas_exports = {};
__export(UserOperationGas_exports, {
  fromRpc: () => fromRpc2,
  toRpc: () => toRpc3
});
function fromRpc2(rpc2) {
  return {
    ...rpc2,
    callGasLimit: BigInt(rpc2.callGasLimit),
    preVerificationGas: BigInt(rpc2.preVerificationGas),
    verificationGasLimit: BigInt(rpc2.verificationGasLimit),
    ...rpc2.paymasterVerificationGasLimit && {
      paymasterVerificationGasLimit: BigInt(rpc2.paymasterVerificationGasLimit)
    },
    ...rpc2.paymasterPostOpGasLimit && {
      paymasterPostOpGasLimit: BigInt(rpc2.paymasterPostOpGasLimit)
    }
  };
}
function toRpc3(userOperationGas) {
  const rpc2 = {};
  rpc2.callGasLimit = fromNumber(userOperationGas.callGasLimit);
  rpc2.preVerificationGas = fromNumber(userOperationGas.preVerificationGas);
  rpc2.verificationGasLimit = fromNumber(userOperationGas.verificationGasLimit);
  if (typeof userOperationGas.paymasterVerificationGasLimit === "bigint")
    rpc2.paymasterVerificationGasLimit = fromNumber(userOperationGas.paymasterVerificationGasLimit);
  if (typeof userOperationGas.paymasterPostOpGasLimit === "bigint")
    rpc2.paymasterPostOpGasLimit = fromNumber(userOperationGas.paymasterPostOpGasLimit);
  return rpc2;
}

// node_modules/viem/node_modules/ox/_esm/erc4337/UserOperationReceipt.js
var UserOperationReceipt_exports = {};
__export(UserOperationReceipt_exports, {
  fromRpc: () => fromRpc5,
  toRpc: () => toRpc6
});

// node_modules/viem/node_modules/ox/_esm/core/Log.js
function fromRpc3(log, _options = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null
  };
}
function toRpc4(log, _options = {}) {
  return {
    address: log.address,
    blockHash: log.blockHash,
    blockNumber: typeof log.blockNumber === "bigint" ? fromNumber(log.blockNumber) : null,
    data: log.data,
    logIndex: typeof log.logIndex === "number" ? fromNumber(log.logIndex) : null,
    topics: log.topics,
    transactionHash: log.transactionHash,
    transactionIndex: typeof log.transactionIndex === "number" ? fromNumber(log.transactionIndex) : null,
    removed: log.removed
  };
}

// node_modules/viem/node_modules/ox/_esm/core/TransactionReceipt.js
var fromRpcStatus = {
  "0x0": "reverted",
  "0x1": "success"
};
var toRpcStatus = {
  reverted: "0x0",
  success: "0x1"
};
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function fromRpc4(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log) => fromRpc3(log, { pending: false })),
    status: fromRpcStatus[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType[receipt.type] || receipt.type
  };
}
function toRpc5(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber(receipt.gasUsed),
    logs: receipt.logs.map(toRpc4),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber(receipt.transactionIndex),
    type: toRpcType[receipt.type] ?? receipt.type
  };
}

// node_modules/viem/node_modules/ox/_esm/erc4337/UserOperationReceipt.js
function fromRpc5(rpc2) {
  return {
    ...rpc2,
    actualGasCost: BigInt(rpc2.actualGasCost),
    actualGasUsed: BigInt(rpc2.actualGasUsed),
    logs: rpc2.logs.map((log) => fromRpc3(log)),
    nonce: BigInt(rpc2.nonce),
    receipt: fromRpc4(rpc2.receipt)
  };
}
function toRpc6(userOperationReceipt) {
  const rpc2 = {};
  rpc2.actualGasCost = fromNumber(userOperationReceipt.actualGasCost);
  rpc2.actualGasUsed = fromNumber(userOperationReceipt.actualGasUsed);
  rpc2.entryPoint = userOperationReceipt.entryPoint;
  rpc2.logs = userOperationReceipt.logs.map((log) => toRpc4(log));
  rpc2.nonce = fromNumber(userOperationReceipt.nonce);
  rpc2.receipt = toRpc5(userOperationReceipt.receipt);
  rpc2.sender = userOperationReceipt.sender;
  rpc2.success = userOperationReceipt.success;
  rpc2.userOpHash = userOperationReceipt.userOpHash;
  if (userOperationReceipt.paymaster)
    rpc2.paymaster = userOperationReceipt.paymaster;
  if (userOperationReceipt.reason)
    rpc2.reason = userOperationReceipt.reason;
  return rpc2;
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/toUserOperation.js
var toUserOperation = UserOperation_exports.from;

// node_modules/@base-org/account/dist/store/chain-clients/store.js
var ChainClients = createStore2(() => ({}));

// node_modules/@base-org/account/dist/store/chain-clients/utils.js
function createClients(chains2) {
  chains2.forEach((c9) => {
    var _a14, _b, _c3, _d2, _e6, _f3, _g, _h2;
    if (!c9.rpcUrl) {
      return;
    }
    const viemchain = defineChain({
      id: c9.id,
      rpcUrls: {
        default: {
          http: [c9.rpcUrl]
        }
      },
      name: (_b = (_a14 = c9.nativeCurrency) === null || _a14 === void 0 ? void 0 : _a14.name) !== null && _b !== void 0 ? _b : "",
      nativeCurrency: {
        name: (_d2 = (_c3 = c9.nativeCurrency) === null || _c3 === void 0 ? void 0 : _c3.name) !== null && _d2 !== void 0 ? _d2 : "",
        symbol: (_f3 = (_e6 = c9.nativeCurrency) === null || _e6 === void 0 ? void 0 : _e6.symbol) !== null && _f3 !== void 0 ? _f3 : "",
        decimals: (_h2 = (_g = c9.nativeCurrency) === null || _g === void 0 ? void 0 : _g.decimal) !== null && _h2 !== void 0 ? _h2 : 18
      }
    });
    const client = createPublicClient({
      chain: viemchain,
      transport: http(c9.rpcUrl)
    });
    const bundlerClient = createBundlerClient({
      client,
      transport: http(c9.rpcUrl)
    });
    ChainClients.setState({
      [c9.id]: {
        client,
        bundlerClient
      }
    });
  });
}
function getClient(chainId) {
  var _a14;
  return (_a14 = ChainClients.getState()[chainId]) === null || _a14 === void 0 ? void 0 : _a14.client;
}

// node_modules/@base-org/account/dist/store/correlation-ids/store.js
var correlationIdsStore = createStore2(() => ({
  correlationIds: /* @__PURE__ */ new Map()
}));
var correlationIds = {
  get: (key) => {
    const correlationId = correlationIdsStore.getState().correlationIds.get(key);
    return correlationId;
  },
  set: (key, correlationId) => {
    correlationIdsStore.setState((state) => {
      const newMap = new Map(state.correlationIds);
      newMap.set(key, correlationId);
      return { correlationIds: newMap };
    });
  },
  delete: (key) => {
    correlationIdsStore.setState((state) => {
      const newMap = new Map(state.correlationIds);
      newMap.delete(key);
      return { correlationIds: newMap };
    });
  },
  clear: () => {
    correlationIdsStore.setState({
      correlationIds: /* @__PURE__ */ new Map()
    });
  }
};

// node_modules/@base-org/account/dist/util/assertSubAccount.js
function assertSubAccount(info) {
  if (typeof info !== "object" || info === null) {
    throw standardErrors.rpc.internal("sub account info is not an object");
  }
  if (!("address" in info)) {
    throw standardErrors.rpc.internal("sub account is invalid");
  }
  if ("address" in info && typeof info.address === "string" && !isAddress(info.address)) {
    throw standardErrors.rpc.internal("sub account address is invalid");
  }
  if ("factory" in info && typeof info.factory === "string" && !isAddress(info.factory)) {
    throw standardErrors.rpc.internal("sub account factory address is invalid");
  }
  if ("factoryData" in info && typeof info.factoryData === "string" && !isHex(info.factoryData)) {
    throw standardErrors.rpc.internal("sub account factory data is invalid");
  }
}

// node_modules/@base-org/account/dist/util/cipher.js
async function generateKeyPair() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, true, ["deriveKey"]);
}
async function deriveSharedSecret(ownPrivateKey, peerPublicKey) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: peerPublicKey
  }, ownPrivateKey, {
    name: "AES-GCM",
    length: 256
  }, false, ["encrypt", "decrypt"]);
}
async function encrypt(sharedSecret, plainText) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const cipherText = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, new TextEncoder().encode(plainText));
  return { iv, cipherText };
}
async function decrypt(sharedSecret, { iv, cipherText }) {
  const plainText = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, cipherText);
  return new TextDecoder().decode(plainText);
}
function getFormat(keyType) {
  switch (keyType) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function exportKeyToHexString(type7, key) {
  const format9 = getFormat(type7);
  const exported = await crypto.subtle.exportKey(format9, key);
  return uint8ArrayToHex(new Uint8Array(exported));
}
async function importKeyFromHexString(type7, hexString) {
  const format9 = getFormat(type7);
  const arrayBuffer = hexStringToUint8Array(hexString).buffer;
  return await crypto.subtle.importKey(format9, new Uint8Array(arrayBuffer), {
    name: "ECDH",
    namedCurve: "P-256"
  }, true, type7 === "private" ? ["deriveKey"] : []);
}
async function encryptContent(content, sharedSecret) {
  const serialized = JSON.stringify(content, (_6, value2) => {
    if (!(value2 instanceof Error))
      return value2;
    const error = value2;
    return Object.assign(Object.assign({}, error.code ? { code: error.code } : {}), { message: error.message });
  });
  return encrypt(sharedSecret, serialized);
}
async function decryptContent(encryptedData, sharedSecret) {
  return JSON.parse(await decrypt(sharedSecret, encryptedData));
}

// node_modules/@base-org/account/dist/util/provider.js
async function fetchRPCRequest(request2, rpcUrl) {
  const requestBody = Object.assign(Object.assign({}, request2), { jsonrpc: "2.0", id: crypto.randomUUID() });
  const res = await window.fetch(rpcUrl, {
    method: "POST",
    body: JSON.stringify(requestBody),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": PACKAGE_VERSION,
      "X-Cbw-Sdk-Platform": PACKAGE_NAME
    }
  });
  const { result, error } = await res.json();
  if (error)
    throw error;
  return result;
}
function checkErrorForInvalidRequestArgs(args) {
  if (!args || typeof args !== "object" || Array.isArray(args)) {
    throw standardErrors.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: args
    });
  }
  const { method, params } = args;
  if (typeof method !== "string" || method.length === 0) {
    throw standardErrors.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: args
    });
  }
  if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
    throw standardErrors.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: args
    });
  }
  switch (method) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw standardErrors.provider.unsupportedMethod();
  }
}

// node_modules/ox/_esm/core/Abi.js
var Abi_exports = {};
__export(Abi_exports, {
  format: () => format,
  from: () => from10
});

// node_modules/abitype/dist/esm/version.js
var version3 = "1.1.1";

// node_modules/abitype/dist/esm/errors.js
var BaseError5 = class _BaseError extends Error {
  constructor(shortMessage, args = {}) {
    var _a14;
    const details = args.cause instanceof _BaseError ? args.cause.details : ((_a14 = args.cause) == null ? void 0 : _a14.message) ? args.cause.message : args.details;
    const docsPath = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: abitype@${version3}`
    ].join("\n");
    super(message);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiTypeError"
    });
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};

// node_modules/abitype/dist/esm/regex.js
function execTyped(regex, string3) {
  const match14 = regex.exec(string3);
  return match14 == null ? void 0 : match14.groups;
}
var bytesRegex4 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex4 = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var isTupleRegex = /^\(.+?\).*?$/;

// node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js
var tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
  let type7 = abiParameter.type;
  if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
    type7 = "(";
    const length = abiParameter.components.length;
    for (let i9 = 0; i9 < length; i9++) {
      const component = abiParameter.components[i9];
      type7 += formatAbiParameter(component);
      if (i9 < length - 1)
        type7 += ", ";
    }
    const result = execTyped(tupleRegex, abiParameter.type);
    type7 += `)${(result == null ? void 0 : result.array) ?? ""}`;
    return formatAbiParameter({
      ...abiParameter,
      type: type7
    });
  }
  if ("indexed" in abiParameter && abiParameter.indexed)
    type7 = `${type7} indexed`;
  if (abiParameter.name)
    return `${type7} ${abiParameter.name}`;
  return type7;
}

// node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js
function formatAbiParameters2(abiParameters) {
  let params = "";
  const length = abiParameters.length;
  for (let i9 = 0; i9 < length; i9++) {
    const abiParameter = abiParameters[i9];
    params += formatAbiParameter(abiParameter);
    if (i9 !== length - 1)
      params += ", ";
  }
  return params;
}

// node_modules/abitype/dist/esm/human-readable/formatAbiItem.js
function formatAbiItem3(abiItem) {
  var _a14;
  if (abiItem.type === "function")
    return `function ${abiItem.name}(${formatAbiParameters2(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${((_a14 = abiItem.outputs) == null ? void 0 : _a14.length) ? ` returns (${formatAbiParameters2(abiItem.outputs)})` : ""}`;
  if (abiItem.type === "event")
    return `event ${abiItem.name}(${formatAbiParameters2(abiItem.inputs)})`;
  if (abiItem.type === "error")
    return `error ${abiItem.name}(${formatAbiParameters2(abiItem.inputs)})`;
  if (abiItem.type === "constructor")
    return `constructor(${formatAbiParameters2(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  if (abiItem.type === "fallback")
    return `fallback() external${abiItem.stateMutability === "payable" ? " payable" : ""}`;
  return "receive() external payable";
}

// node_modules/abitype/dist/esm/human-readable/formatAbi.js
function formatAbi(abi3) {
  const signatures = [];
  const length = abi3.length;
  for (let i9 = 0; i9 < length; i9++) {
    const abiItem = abi3[i9];
    const signature = formatAbiItem3(abiItem);
    signatures.push(signature);
  }
  return signatures;
}

// node_modules/abitype/dist/esm/human-readable/runtime/signatures.js
var errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature) {
  return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
  return execTyped(errorSignatureRegex, signature);
}
var eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature) {
  return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
  return execTyped(eventSignatureRegex, signature);
}
var functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature) {
  return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
  return execTyped(functionSignatureRegex, signature);
}
var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
  return execTyped(structSignatureRegex, signature);
}
var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature) {
  return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
  return execTyped(constructorSignatureRegex, signature);
}
var fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature) {
  return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
  return execTyped(fallbackSignatureRegex, signature);
}
var receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature) {
  return receiveSignatureRegex.test(signature);
}
var modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]);
var eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
var functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);

// node_modules/abitype/dist/esm/human-readable/errors/abiItem.js
var InvalidAbiItemError2 = class extends BaseError5 {
  constructor({ signature }) {
    super("Failed to parse ABI item.", {
      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
      docsPath: "/api/human#parseabiitem-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiItemError"
    });
  }
};
var UnknownTypeError2 = class extends BaseError5 {
  constructor({ type: type7 }) {
    super("Unknown type.", {
      metaMessages: [
        `Type "${type7}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownTypeError"
    });
  }
};
var UnknownSolidityTypeError = class extends BaseError5 {
  constructor({ type: type7 }) {
    super("Unknown type.", {
      metaMessages: [`Type "${type7}" is not a valid ABI type.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSolidityTypeError"
    });
  }
};

// node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js
var InvalidAbiParametersError2 = class extends BaseError5 {
  constructor({ params }) {
    super("Failed to parse ABI parameters.", {
      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
      docsPath: "/api/human#parseabiparameters-1"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiParametersError"
    });
  }
};
var InvalidParameterError2 = class extends BaseError5 {
  constructor({ param }) {
    super("Invalid ABI parameter.", {
      details: param
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParameterError"
    });
  }
};
var SolidityProtectedKeywordError2 = class extends BaseError5 {
  constructor({ param, name }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SolidityProtectedKeywordError"
    });
  }
};
var InvalidModifierError2 = class extends BaseError5 {
  constructor({ param, type: type7, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type7 ? ` in "${type7}" type` : ""}.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidModifierError"
    });
  }
};
var InvalidFunctionModifierError2 = class extends BaseError5 {
  constructor({ param, type: type7, modifier }) {
    super("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `Modifier "${modifier}" not allowed${type7 ? ` in "${type7}" type` : ""}.`,
        `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidFunctionModifierError"
    });
  }
};
var InvalidAbiTypeParameterError2 = class extends BaseError5 {
  constructor({ abiParameter }) {
    super("Invalid ABI parameter.", {
      details: JSON.stringify(abiParameter, null, 2),
      metaMessages: ["ABI parameter type is invalid."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidAbiTypeParameterError"
    });
  }
};

// node_modules/abitype/dist/esm/human-readable/errors/signature.js
var InvalidSignatureError2 = class extends BaseError5 {
  constructor({ signature, type: type7 }) {
    super(`Invalid ${type7} signature.`, {
      details: signature
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidSignatureError"
    });
  }
};
var UnknownSignatureError2 = class extends BaseError5 {
  constructor({ signature }) {
    super("Unknown signature.", {
      details: signature
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "UnknownSignatureError"
    });
  }
};
var InvalidStructSignatureError2 = class extends BaseError5 {
  constructor({ signature }) {
    super("Invalid struct signature.", {
      details: signature,
      metaMessages: ["No properties exist."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidStructSignatureError"
    });
  }
};

// node_modules/abitype/dist/esm/human-readable/errors/struct.js
var CircularReferenceError2 = class extends BaseError5 {
  constructor({ type: type7 }) {
    super("Circular reference detected.", {
      metaMessages: [`Struct "${type7}" is a circular reference.`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "CircularReferenceError"
    });
  }
};

// node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js
var InvalidParenthesisError2 = class extends BaseError5 {
  constructor({ current, depth }) {
    super("Unbalanced parentheses.", {
      metaMessages: [
        `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
      ],
      details: `Depth "${depth}"`
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "InvalidParenthesisError"
    });
  }
};

// node_modules/abitype/dist/esm/human-readable/runtime/cache.js
function getParameterCacheKey(param, type7, structs) {
  let structKey = "";
  if (structs)
    for (const struct2 of Object.entries(structs)) {
      if (!struct2)
        continue;
      let propertyKey = "";
      for (const property of struct2[1]) {
        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ""}]`;
      }
      structKey += `(${struct2[0]}{${propertyKey}})`;
    }
  if (type7)
    return `${type7}:${param}${structKey}`;
  return param;
}
var parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: true }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: true }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ]
]);

// node_modules/abitype/dist/esm/human-readable/runtime/utils.js
function parseSignature3(signature, structs = {}) {
  if (isFunctionSignature(signature))
    return parseFunctionSignature(signature, structs);
  if (isEventSignature(signature))
    return parseEventSignature(signature, structs);
  if (isErrorSignature(signature))
    return parseErrorSignature(signature, structs);
  if (isConstructorSignature(signature))
    return parseConstructorSignature(signature, structs);
  if (isFallbackSignature(signature))
    return parseFallbackSignature(signature);
  if (isReceiveSignature(signature))
    return {
      type: "receive",
      stateMutability: "payable"
    };
  throw new UnknownSignatureError2({ signature });
}
function parseFunctionSignature(signature, structs = {}) {
  const match14 = execFunctionSignature(signature);
  if (!match14)
    throw new InvalidSignatureError2({ signature, type: "function" });
  const inputParams = splitParameters(match14.parameters);
  const inputs = [];
  const inputLength = inputParams.length;
  for (let i9 = 0; i9 < inputLength; i9++) {
    inputs.push(parseAbiParameter2(inputParams[i9], {
      modifiers: functionModifiers,
      structs,
      type: "function"
    }));
  }
  const outputs = [];
  if (match14.returns) {
    const outputParams = splitParameters(match14.returns);
    const outputLength = outputParams.length;
    for (let i9 = 0; i9 < outputLength; i9++) {
      outputs.push(parseAbiParameter2(outputParams[i9], {
        modifiers: functionModifiers,
        structs,
        type: "function"
      }));
    }
  }
  return {
    name: match14.name,
    type: "function",
    stateMutability: match14.stateMutability ?? "nonpayable",
    inputs,
    outputs
  };
}
function parseEventSignature(signature, structs = {}) {
  const match14 = execEventSignature(signature);
  if (!match14)
    throw new InvalidSignatureError2({ signature, type: "event" });
  const params = splitParameters(match14.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i9 = 0; i9 < length; i9++)
    abiParameters.push(parseAbiParameter2(params[i9], {
      modifiers: eventModifiers,
      structs,
      type: "event"
    }));
  return { name: match14.name, type: "event", inputs: abiParameters };
}
function parseErrorSignature(signature, structs = {}) {
  const match14 = execErrorSignature(signature);
  if (!match14)
    throw new InvalidSignatureError2({ signature, type: "error" });
  const params = splitParameters(match14.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i9 = 0; i9 < length; i9++)
    abiParameters.push(parseAbiParameter2(params[i9], { structs, type: "error" }));
  return { name: match14.name, type: "error", inputs: abiParameters };
}
function parseConstructorSignature(signature, structs = {}) {
  const match14 = execConstructorSignature(signature);
  if (!match14)
    throw new InvalidSignatureError2({ signature, type: "constructor" });
  const params = splitParameters(match14.parameters);
  const abiParameters = [];
  const length = params.length;
  for (let i9 = 0; i9 < length; i9++)
    abiParameters.push(parseAbiParameter2(params[i9], { structs, type: "constructor" }));
  return {
    type: "constructor",
    stateMutability: match14.stateMutability ?? "nonpayable",
    inputs: abiParameters
  };
}
function parseFallbackSignature(signature) {
  const match14 = execFallbackSignature(signature);
  if (!match14)
    throw new InvalidSignatureError2({ signature, type: "fallback" });
  return {
    type: "fallback",
    stateMutability: match14.stateMutability ?? "nonpayable"
  };
}
var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\spayable)?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
var dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter2(param, options) {
  var _a14, _b;
  const parameterCacheKey = getParameterCacheKey(param, options == null ? void 0 : options.type, options == null ? void 0 : options.structs);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match14 = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
  if (!match14)
    throw new InvalidParameterError2({ param });
  if (match14.name && isSolidityKeyword(match14.name))
    throw new SolidityProtectedKeywordError2({ param, name: match14.name });
  const name = match14.name ? { name: match14.name } : {};
  const indexed = match14.modifier === "indexed" ? { indexed: true } : {};
  const structs = (options == null ? void 0 : options.structs) ?? {};
  let type7;
  let components = {};
  if (isTuple) {
    type7 = "tuple";
    const params = splitParameters(match14.type);
    const components_ = [];
    const length = params.length;
    for (let i9 = 0; i9 < length; i9++) {
      components_.push(parseAbiParameter2(params[i9], { structs }));
    }
    components = { components: components_ };
  } else if (match14.type in structs) {
    type7 = "tuple";
    components = { components: structs[match14.type] };
  } else if (dynamicIntegerRegex.test(match14.type)) {
    type7 = `${match14.type}256`;
  } else if (match14.type === "address payable") {
    type7 = "address";
  } else {
    type7 = match14.type;
    if (!((options == null ? void 0 : options.type) === "struct") && !isSolidityType(type7))
      throw new UnknownSolidityTypeError({ type: type7 });
  }
  if (match14.modifier) {
    if (!((_b = (_a14 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a14.has) == null ? void 0 : _b.call(_a14, match14.modifier)))
      throw new InvalidModifierError2({
        param,
        type: options == null ? void 0 : options.type,
        modifier: match14.modifier
      });
    if (functionModifiers.has(match14.modifier) && !isValidDataLocation(type7, !!match14.array))
      throw new InvalidFunctionModifierError2({
        param,
        type: options == null ? void 0 : options.type,
        modifier: match14.modifier
      });
  }
  const abiParameter = {
    type: `${type7}${match14.array ?? ""}`,
    ...name,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  const length = params.trim().length;
  for (let i9 = 0; i9 < length; i9++) {
    const char = params[i9];
    const tail4 = params.slice(i9 + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail4, [...result, current.trim()]) : splitParameters(tail4, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail4, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail4, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail4, result, `${current}${char}`, depth);
    }
  }
  if (current === "")
    return result;
  if (depth !== 0)
    throw new InvalidParenthesisError2({ current, depth });
  result.push(current.trim());
  return result;
}
function isSolidityType(type7) {
  return type7 === "address" || type7 === "bool" || type7 === "function" || type7 === "string" || bytesRegex4.test(type7) || integerRegex4.test(type7);
}
var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name) {
  return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || bytesRegex4.test(name) || integerRegex4.test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type7, isArray4) {
  return isArray4 || type7 === "bytes" || type7 === "string" || type7 === "tuple";
}

// node_modules/abitype/dist/esm/human-readable/runtime/structs.js
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i9 = 0; i9 < signaturesLength; i9++) {
    const signature = signatures[i9];
    if (!isStructSignature(signature))
      continue;
    const match14 = execStructSignature(signature);
    if (!match14)
      throw new InvalidSignatureError2({ signature, type: "struct" });
    const properties = match14.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k11 = 0; k11 < propertiesLength; k11++) {
      const property = properties[k11];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter2(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new InvalidStructSignatureError2({ signature });
    shallowStructs[match14.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i9 = 0; i9 < entriesLength; i9++) {
    const [name, parameters] = entries[i9];
    resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
  const components = [];
  const length = abiParameters.length;
  for (let i9 = 0; i9 < length; i9++) {
    const abiParameter = abiParameters[i9];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match14 = execTyped(typeWithoutTupleRegex, abiParameter.type);
      if (!(match14 == null ? void 0 : match14.type))
        throw new InvalidAbiTypeParameterError2({ abiParameter });
      const { array, type: type7 } = match14;
      if (type7 in structs) {
        if (ancestors.has(type7))
          throw new CircularReferenceError2({ type: type7 });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(structs[type7] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type7]))
        });
      } else {
        if (isSolidityType(type7))
          components.push(abiParameter);
        else
          throw new UnknownTypeError2({ type: type7 });
      }
    }
  }
  return components;
}

// node_modules/abitype/dist/esm/human-readable/parseAbi.js
function parseAbi3(signatures) {
  const structs = parseStructs(signatures);
  const abi3 = [];
  const length = signatures.length;
  for (let i9 = 0; i9 < length; i9++) {
    const signature = signatures[i9];
    if (isStructSignature(signature))
      continue;
    abi3.push(parseSignature3(signature, structs));
  }
  return abi3;
}

// node_modules/abitype/dist/esm/human-readable/parseAbiItem.js
function parseAbiItem2(signature) {
  let abiItem;
  if (typeof signature === "string")
    abiItem = parseSignature3(signature);
  else {
    const structs = parseStructs(signature);
    const length = signature.length;
    for (let i9 = 0; i9 < length; i9++) {
      const signature_ = signature[i9];
      if (isStructSignature(signature_))
        continue;
      abiItem = parseSignature3(signature_, structs);
      break;
    }
  }
  if (!abiItem)
    throw new InvalidAbiItemError2({ signature });
  return abiItem;
}

// node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js
function parseAbiParameters2(params) {
  const abiParameters = [];
  if (typeof params === "string") {
    const parameters = splitParameters(params);
    const length = parameters.length;
    for (let i9 = 0; i9 < length; i9++) {
      abiParameters.push(parseAbiParameter2(parameters[i9], { modifiers }));
    }
  } else {
    const structs = parseStructs(params);
    const length = params.length;
    for (let i9 = 0; i9 < length; i9++) {
      const signature = params[i9];
      if (isStructSignature(signature))
        continue;
      const parameters = splitParameters(signature);
      const length2 = parameters.length;
      for (let k11 = 0; k11 < length2; k11++) {
        abiParameters.push(parseAbiParameter2(parameters[k11], { modifiers, structs }));
      }
    }
  }
  if (abiParameters.length === 0)
    throw new InvalidAbiParametersError2({ params });
  return abiParameters;
}

// node_modules/ox/_esm/core/internal/abi.js
function isSignatures(value2) {
  for (const item of value2) {
    if (typeof item !== "string")
      return false;
  }
  return true;
}

// node_modules/ox/_esm/core/Abi.js
function format(abi3) {
  return formatAbi(abi3);
}
function from10(abi3) {
  if (isSignatures(abi3))
    return parseAbi3(abi3);
  return abi3;
}

// node_modules/ox/_esm/core/AbiConstructor.js
var AbiConstructor_exports2 = {};
__export(AbiConstructor_exports2, {
  decode: () => decode4,
  encode: () => encode9,
  format: () => format4,
  from: () => from17,
  fromAbi: () => fromAbi3
});

// node_modules/ox/_esm/core/AbiItem.js
var AbiItem_exports2 = {};
__export(AbiItem_exports2, {
  AmbiguityError: () => AmbiguityError,
  InvalidSelectorSizeError: () => InvalidSelectorSizeError2,
  NotFoundError: () => NotFoundError2,
  format: () => format2,
  from: () => from15,
  fromAbi: () => fromAbi2,
  getSelector: () => getSelector2,
  getSignature: () => getSignature,
  getSignatureHash: () => getSignatureHash
});

// node_modules/ox/_esm/core/Errors.js
var Errors_exports3 = {};
__export(Errors_exports3, {
  BaseError: () => BaseError6
});

// node_modules/ox/_esm/core/version.js
var version4 = "0.1.1";

// node_modules/ox/_esm/core/internal/errors.js
function getUrl(url2) {
  return url2;
}
function getVersion() {
  return version4;
}
function prettyPrint3(args) {
  if (!args)
    return "";
  const entries = Object.entries(args).map(([key, value2]) => {
    if (value2 === void 0 || value2 === false)
      return null;
    return [key, value2];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value2]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value2}`).join("\n");
}

// node_modules/ox/_esm/core/Errors.js
var BaseError6 = class _BaseError extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      var _a14;
      if (options.cause instanceof _BaseError) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if ((_a14 = options.cause) == null ? void 0 : _a14.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath = (() => {
      if (options.cause instanceof _BaseError)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath ? `See: ${docs}` : void 0
      ] : []
    ].filter((x7) => typeof x7 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath;
    this.shortMessage = shortMessage;
  }
  walk(fn4) {
    return walk(this, fn4);
  }
};
function walk(err, fn4) {
  if (fn4 == null ? void 0 : fn4(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn4);
  return fn4 ? null : err;
}

// node_modules/ox/_esm/core/Hash.js
var Hash_exports3 = {};
__export(Hash_exports3, {
  keccak256: () => keccak2565,
  ripemd160: () => ripemd1604,
  sha256: () => sha2565,
  validate: () => validate7
});

// node_modules/ox/_esm/core/Bytes.js
var Bytes_exports3 = {};
__export(Bytes_exports3, {
  InvalidBytesBooleanError: () => InvalidBytesBooleanError2,
  InvalidBytesTypeError: () => InvalidBytesTypeError,
  SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError2,
  SizeOverflowError: () => SizeOverflowError2,
  SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError2,
  assert: () => assert4,
  concat: () => concat8,
  from: () => from12,
  fromArray: () => fromArray,
  fromBoolean: () => fromBoolean3,
  fromHex: () => fromHex7,
  fromNumber: () => fromNumber4,
  fromString: () => fromString7,
  isEqual: () => isEqual2,
  padLeft: () => padLeft4,
  padRight: () => padRight3,
  random: () => random,
  size: () => size6,
  slice: () => slice7,
  toBigInt: () => toBigInt3,
  toBoolean: () => toBoolean3,
  toHex: () => toHex6,
  toNumber: () => toNumber3,
  toString: () => toString5,
  trimLeft: () => trimLeft3,
  trimRight: () => trimRight,
  validate: () => validate6
});

// node_modules/@noble/curves/esm/abstract/utils.js
var equalBytes2 = equalBytes;

// node_modules/ox/_esm/core/Hex.js
var Hex_exports3 = {};
__export(Hex_exports3, {
  IntegerOutOfRangeError: () => IntegerOutOfRangeError3,
  InvalidHexBooleanError: () => InvalidHexBooleanError2,
  InvalidHexTypeError: () => InvalidHexTypeError,
  InvalidHexValueError: () => InvalidHexValueError2,
  InvalidLengthError: () => InvalidLengthError,
  SizeExceedsPaddingSizeError: () => SizeExceedsPaddingSizeError3,
  SizeOverflowError: () => SizeOverflowError3,
  SliceOffsetOutOfBoundsError: () => SliceOffsetOutOfBoundsError3,
  assert: () => assert3,
  concat: () => concat7,
  from: () => from11,
  fromBoolean: () => fromBoolean2,
  fromBytes: () => fromBytes4,
  fromNumber: () => fromNumber3,
  fromString: () => fromString6,
  isEqual: () => isEqual,
  padLeft: () => padLeft3,
  padRight: () => padRight2,
  random: () => random2,
  size: () => size7,
  slice: () => slice6,
  toBigInt: () => toBigInt2,
  toBoolean: () => toBoolean2,
  toBytes: () => toBytes5,
  toNumber: () => toNumber2,
  toString: () => toString4,
  trimLeft: () => trimLeft2,
  trimRight: () => trimRight2,
  validate: () => validate5
});

// node_modules/ox/_esm/core/Json.js
var Json_exports3 = {};
__export(Json_exports3, {
  parse: () => parse,
  stringify: () => stringify6
});
var bigIntSuffix = "#__bigint";
function parse(string3, reviver) {
  return JSON.parse(string3, (key, value_) => {
    const value2 = value_;
    if (typeof value2 === "string" && value2.endsWith(bigIntSuffix))
      return BigInt(value2.slice(0, -bigIntSuffix.length));
    return typeof reviver === "function" ? reviver(key, value2) : value2;
  });
}
function stringify6(value2, replacer, space) {
  return JSON.stringify(value2, (key, value3) => {
    if (typeof replacer === "function")
      return replacer(key, value3);
    if (typeof value3 === "bigint")
      return value3.toString() + bigIntSuffix;
    return value3;
  }, space);
}

// node_modules/ox/_esm/core/internal/bytes.js
function assertSize(bytes2, size_) {
  if (size6(bytes2) > size_)
    throw new SizeOverflowError2({
      givenSize: size6(bytes2),
      maxSize: size_
    });
}
function assertStartOffset(value2, start) {
  if (typeof start === "number" && start > 0 && start > size6(value2) - 1)
    throw new SliceOffsetOutOfBoundsError2({
      offset: start,
      position: "start",
      size: size6(value2)
    });
}
function assertEndOffset(value2, start, end) {
  if (typeof start === "number" && typeof end === "number" && size6(value2) !== end - start) {
    throw new SliceOffsetOutOfBoundsError2({
      offset: end,
      position: "end",
      size: size6(value2)
    });
  }
}
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function pad3(bytes2, options = {}) {
  const { dir, size: size11 = 32 } = options;
  if (size11 === 0)
    return bytes2;
  if (bytes2.length > size11)
    throw new SizeExceedsPaddingSizeError2({
      size: bytes2.length,
      targetSize: size11,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size11);
  for (let i9 = 0; i9 < size11; i9++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i9 : size11 - i9 - 1] = bytes2[padEnd ? i9 : bytes2.length - i9 - 1];
  }
  return paddedBytes;
}
function trim3(value2, options = {}) {
  const { dir = "left" } = options;
  let data = value2;
  let sliceLength = 0;
  for (let i9 = 0; i9 < data.length - 1; i9++) {
    if (data[dir === "left" ? i9 : data.length - i9 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  return data;
}

// node_modules/ox/_esm/core/internal/hex.js
function assertSize2(hex2, size_) {
  if (size7(hex2) > size_)
    throw new SizeOverflowError3({
      givenSize: size7(hex2),
      maxSize: size_
    });
}
function assertStartOffset2(value2, start) {
  if (typeof start === "number" && start > 0 && start > size7(value2) - 1)
    throw new SliceOffsetOutOfBoundsError3({
      offset: start,
      position: "start",
      size: size7(value2)
    });
}
function assertEndOffset2(value2, start, end) {
  if (typeof start === "number" && typeof end === "number" && size7(value2) !== end - start) {
    throw new SliceOffsetOutOfBoundsError3({
      offset: end,
      position: "end",
      size: size7(value2)
    });
  }
}
function pad4(hex_, options = {}) {
  const { dir, size: size11 = 32 } = options;
  if (size11 === 0)
    return hex_;
  const hex2 = hex_.replace("0x", "");
  if (hex2.length > size11 * 2)
    throw new SizeExceedsPaddingSizeError3({
      size: Math.ceil(hex2.length / 2),
      targetSize: size11,
      type: "Hex"
    });
  return `0x${hex2[dir === "right" ? "padEnd" : "padStart"](size11 * 2, "0")}`;
}
function trim4(value2, options = {}) {
  const { dir = "left" } = options;
  let data = value2.replace("0x", "");
  let sliceLength = 0;
  for (let i9 = 0; i9 < data.length - 1; i9++) {
    if (data[dir === "left" ? i9 : data.length - i9 - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (data === "0")
    return "0x";
  if (dir === "right" && data.length % 2 === 1)
    return `0x${data}0`;
  return `0x${data}`;
}

// node_modules/ox/_esm/core/Hex.js
var encoder2 = new TextEncoder();
var hexes = Array.from({ length: 256 }, (_v, i9) => i9.toString(16).padStart(2, "0"));
function assert3(value2, options = {}) {
  const { strict = false } = options;
  if (!value2)
    throw new InvalidHexTypeError(value2);
  if (typeof value2 !== "string")
    throw new InvalidHexTypeError(value2);
  if (strict) {
    if (!/^0x[0-9a-fA-F]*$/.test(value2))
      throw new InvalidHexValueError2(value2);
  }
  if (!value2.startsWith("0x"))
    throw new InvalidHexValueError2(value2);
}
function concat7(...values) {
  return `0x${values.reduce((acc, x7) => acc + x7.replace("0x", ""), "")}`;
}
function from11(value2) {
  if (value2 instanceof Uint8Array)
    return fromBytes4(value2);
  if (Array.isArray(value2))
    return fromBytes4(new Uint8Array(value2));
  return value2;
}
function fromBoolean2(value2, options = {}) {
  const hex2 = `0x${Number(value2)}`;
  if (typeof options.size === "number") {
    assertSize2(hex2, options.size);
    return padLeft3(hex2, options.size);
  }
  return hex2;
}
function fromBytes4(value2, options = {}) {
  let string3 = "";
  for (let i9 = 0; i9 < value2.length; i9++)
    string3 += hexes[value2[i9]];
  const hex2 = `0x${string3}`;
  if (typeof options.size === "number") {
    assertSize2(hex2, options.size);
    return padRight2(hex2, options.size);
  }
  return hex2;
}
function fromNumber3(value2, options = {}) {
  const { signed, size: size11 } = options;
  const value_ = BigInt(value2);
  let maxValue;
  if (size11) {
    if (signed)
      maxValue = (1n << BigInt(size11) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size11) * 8n) - 1n;
  } else if (typeof value2 === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value2 === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError3({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size11,
      value: `${value2}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size11 * 8)) + BigInt(value_) : value_).toString(16);
  const hex2 = `0x${stringValue}`;
  if (size11)
    return padLeft3(hex2, size11);
  return hex2;
}
function fromString6(value2, options = {}) {
  return fromBytes4(encoder2.encode(value2), options);
}
function isEqual(hexA, hexB) {
  return equalBytes2(fromHex7(hexA), fromHex7(hexB));
}
function padLeft3(value2, size11) {
  return pad4(value2, { dir: "left", size: size11 });
}
function padRight2(value2, size11) {
  return pad4(value2, { dir: "right", size: size11 });
}
function random2(length) {
  return fromBytes4(random(length));
}
function slice6(value2, start, end, options = {}) {
  const { strict } = options;
  assertStartOffset2(value2, start);
  const value_ = `0x${value2.replace("0x", "").slice((start ?? 0) * 2, (end ?? value2.length) * 2)}`;
  if (strict)
    assertEndOffset2(value_, start, end);
  return value_;
}
function size7(value2) {
  return Math.ceil((value2.length - 2) / 2);
}
function trimLeft2(value2) {
  return trim4(value2, { dir: "left" });
}
function trimRight2(value2) {
  return trim4(value2, { dir: "right" });
}
function toBigInt2(hex2, options = {}) {
  const { signed } = options;
  if (options.size)
    assertSize2(hex2, options.size);
  const value2 = BigInt(hex2);
  if (!signed)
    return value2;
  const size11 = (hex2.length - 2) / 2;
  const max_unsigned = (1n << BigInt(size11) * 8n) - 1n;
  const max_signed = max_unsigned >> 1n;
  if (value2 <= max_signed)
    return value2;
  return value2 - max_unsigned - 1n;
}
function toBoolean2(hex2, options = {}) {
  if (options.size)
    assertSize2(hex2, options.size);
  const hex_ = trimLeft2(hex2);
  if (hex_ === "0x")
    return false;
  if (hex_ === "0x1")
    return true;
  throw new InvalidHexBooleanError2(hex2);
}
function toBytes5(hex2, options = {}) {
  return fromHex7(hex2, options);
}
function toNumber2(hex2, options = {}) {
  const { signed, size: size11 } = options;
  if (!signed && !size11)
    return Number(hex2);
  return Number(toBigInt2(hex2, options));
}
function toString4(hex2, options = {}) {
  const { size: size11 } = options;
  let bytes2 = fromHex7(hex2);
  if (size11) {
    assertSize(bytes2, size11);
    bytes2 = trimRight(bytes2);
  }
  return new TextDecoder().decode(bytes2);
}
function validate5(value2, options = {}) {
  const { strict = false } = options;
  try {
    assert3(value2, { strict });
    return true;
  } catch {
    return false;
  }
}
var IntegerOutOfRangeError3 = class extends BaseError6 {
  constructor({ max: max4, min: min4, signed, size: size11, value: value2 }) {
    super(`Number \`${value2}\` is not in safe${size11 ? ` ${size11 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max4 ? `(\`${min4}\` to \`${max4}\`)` : `(above \`${min4}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var InvalidHexBooleanError2 = class extends BaseError6 {
  constructor(hex2) {
    super(`Hex value \`"${hex2}"\` is not a valid boolean.`, {
      metaMessages: [
        'The hex value must be `"0x0"` (false) or `"0x1"` (true).'
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexBooleanError"
    });
  }
};
var InvalidHexTypeError = class extends BaseError6 {
  constructor(value2) {
    super(`Value \`${typeof value2 === "object" ? stringify6(value2) : value2}\` of type \`${typeof value2}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexTypeError"
    });
  }
};
var InvalidHexValueError2 = class extends BaseError6 {
  constructor(value2) {
    super(`Value \`${value2}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexValueError"
    });
  }
};
var InvalidLengthError = class extends BaseError6 {
  constructor(value2) {
    super(`Hex value \`"${value2}"\` is an odd length (${value2.length - 2} nibbles).`, {
      metaMessages: ["It must be an even length."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidLengthError"
    });
  }
};
var SizeOverflowError3 = class extends BaseError6 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var SliceOffsetOutOfBoundsError3 = class extends BaseError6 {
  constructor({ offset, position, size: size11 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size11}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
};
var SizeExceedsPaddingSizeError3 = class extends BaseError6 {
  constructor({ size: size11, targetSize, type: type7 }) {
    super(`${type7.charAt(0).toUpperCase()}${type7.slice(1).toLowerCase()} size (\`${size11}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/ox/_esm/core/Bytes.js
var decoder2 = new TextDecoder();
var encoder3 = new TextEncoder();
function assert4(value2) {
  if (value2 instanceof Uint8Array)
    return;
  if (!value2)
    throw new InvalidBytesTypeError(value2);
  if (typeof value2 !== "object")
    throw new InvalidBytesTypeError(value2);
  if (!("BYTES_PER_ELEMENT" in value2))
    throw new InvalidBytesTypeError(value2);
  if (value2.BYTES_PER_ELEMENT !== 1 || value2.constructor.name !== "Uint8Array")
    throw new InvalidBytesTypeError(value2);
}
function concat8(...values) {
  let length = 0;
  for (const arr of values) {
    length += arr.length;
  }
  const result = new Uint8Array(length);
  for (let i9 = 0, index2 = 0; i9 < values.length; i9++) {
    const arr = values[i9];
    result.set(arr, index2);
    index2 += arr.length;
  }
  return result;
}
function from12(value2) {
  if (value2 instanceof Uint8Array)
    return value2;
  if (typeof value2 === "string")
    return fromHex7(value2);
  return fromArray(value2);
}
function fromArray(value2) {
  return value2 instanceof Uint8Array ? value2 : new Uint8Array(value2);
}
function fromBoolean3(value2, options = {}) {
  const { size: size11 } = options;
  const bytes2 = new Uint8Array(1);
  bytes2[0] = Number(value2);
  if (typeof size11 === "number") {
    assertSize(bytes2, size11);
    return padLeft4(bytes2, size11);
  }
  return bytes2;
}
function fromHex7(value2, options = {}) {
  const { size: size11 } = options;
  let hex2 = value2;
  if (size11) {
    assertSize2(value2, size11);
    hex2 = padRight2(value2, size11);
  }
  let hexString = hex2.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes2 = new Uint8Array(length);
  for (let index2 = 0, j9 = 0; index2 < length; index2++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j9++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j9++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError6(`Invalid byte sequence ("${hexString[j9 - 2]}${hexString[j9 - 1]}" in "${hexString}").`);
    }
    bytes2[index2] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function fromNumber4(value2, options) {
  const hex2 = fromNumber3(value2, options);
  return fromHex7(hex2);
}
function fromString7(value2, options = {}) {
  const { size: size11 } = options;
  const bytes2 = encoder3.encode(value2);
  if (typeof size11 === "number") {
    assertSize(bytes2, size11);
    return padRight3(bytes2, size11);
  }
  return bytes2;
}
function isEqual2(bytesA, bytesB) {
  return equalBytes2(bytesA, bytesB);
}
function padLeft4(value2, size11) {
  return pad3(value2, { dir: "left", size: size11 });
}
function padRight3(value2, size11) {
  return pad3(value2, { dir: "right", size: size11 });
}
function random(length) {
  return crypto.getRandomValues(new Uint8Array(length));
}
function size6(value2) {
  return value2.length;
}
function slice7(value2, start, end, options = {}) {
  const { strict } = options;
  assertStartOffset(value2, start);
  const value_ = value2.slice(start, end);
  if (strict)
    assertEndOffset(value_, start, end);
  return value_;
}
function toBigInt3(bytes2, options = {}) {
  const { size: size11 } = options;
  if (typeof size11 !== "undefined")
    assertSize(bytes2, size11);
  const hex2 = fromBytes4(bytes2, options);
  return toBigInt2(hex2, options);
}
function toBoolean3(bytes2, options = {}) {
  const { size: size11 } = options;
  let bytes_ = bytes2;
  if (typeof size11 !== "undefined") {
    assertSize(bytes_, size11);
    bytes_ = trimLeft3(bytes_);
  }
  if (bytes_.length > 1 || bytes_[0] > 1)
    throw new InvalidBytesBooleanError2(bytes_);
  return Boolean(bytes_[0]);
}
function toHex6(value2, options = {}) {
  return fromBytes4(value2, options);
}
function toNumber3(bytes2, options = {}) {
  const { size: size11 } = options;
  if (typeof size11 !== "undefined")
    assertSize(bytes2, size11);
  const hex2 = fromBytes4(bytes2, options);
  return toNumber2(hex2, options);
}
function toString5(bytes2, options = {}) {
  const { size: size11 } = options;
  let bytes_ = bytes2;
  if (typeof size11 !== "undefined") {
    assertSize(bytes_, size11);
    bytes_ = trimRight(bytes_);
  }
  return decoder2.decode(bytes_);
}
function trimLeft3(value2) {
  return trim3(value2, { dir: "left" });
}
function trimRight(value2) {
  return trim3(value2, { dir: "right" });
}
function validate6(value2) {
  try {
    assert4(value2);
    return true;
  } catch {
    return false;
  }
}
var InvalidBytesBooleanError2 = class extends BaseError6 {
  constructor(bytes2) {
    super(`Bytes value \`${bytes2}\` is not a valid boolean.`, {
      metaMessages: [
        "The bytes array must contain a single byte of either a `0` or `1` value."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.InvalidBytesBooleanError"
    });
  }
};
var InvalidBytesTypeError = class extends BaseError6 {
  constructor(value2) {
    super(`Value \`${typeof value2 === "object" ? stringify6(value2) : value2}\` of type \`${typeof value2}\` is an invalid Bytes value.`, {
      metaMessages: ["Bytes values must be of type `Bytes`."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.InvalidBytesTypeError"
    });
  }
};
var SizeOverflowError2 = class extends BaseError6 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var SliceOffsetOutOfBoundsError2 = class extends BaseError6 {
  constructor({ offset, position, size: size11 }) {
    super(`Slice ${position === "start" ? "starting" : "ending"} at offset \`${offset}\` is out-of-bounds (size: \`${size11}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SliceOffsetOutOfBoundsError"
    });
  }
};
var SizeExceedsPaddingSizeError2 = class extends BaseError6 {
  constructor({ size: size11, targetSize, type: type7 }) {
    super(`${type7.charAt(0).toUpperCase()}${type7.slice(1).toLowerCase()} size (\`${size11}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/ox/_esm/core/Hash.js
function keccak2565(value2, options = {}) {
  const { as: as17 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes2 = keccak_256(from12(value2));
  if (as17 === "Bytes")
    return bytes2;
  return fromBytes4(bytes2);
}
function ripemd1604(value2, options = {}) {
  const { as: as17 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes2 = ripemd1602(from12(value2));
  if (as17 === "Bytes")
    return bytes2;
  return fromBytes4(bytes2);
}
function sha2565(value2, options = {}) {
  const { as: as17 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const bytes2 = sha2562(from12(value2));
  if (as17 === "Bytes")
    return bytes2;
  return fromBytes4(bytes2);
}
function validate7(value2) {
  return validate5(value2) && size7(value2) === 32;
}

// node_modules/ox/_esm/core/Address.js
var Address_exports3 = {};
__export(Address_exports3, {
  InvalidAddressError: () => InvalidAddressError5,
  InvalidChecksumError: () => InvalidChecksumError2,
  InvalidInputError: () => InvalidInputError3,
  assert: () => assert6,
  checksum: () => checksum5,
  from: () => from14,
  fromPublicKey: () => fromPublicKey,
  isEqual: () => isEqual3,
  validate: () => validate9
});

// node_modules/ox/_esm/core/Caches.js
var Caches_exports2 = {};
__export(Caches_exports2, {
  checksum: () => checksum4,
  clear: () => clear2
});

// node_modules/ox/_esm/core/internal/lru.js
var LruMap3 = class extends Map {
  constructor(size11) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size11;
  }
  get(key) {
    const value2 = super.get(key);
    if (super.has(key) && value2 !== void 0) {
      this.delete(key);
      super.set(key, value2);
    }
    return value2;
  }
  set(key, value2) {
    super.set(key, value2);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/ox/_esm/core/Caches.js
var caches2 = {
  checksum: new LruMap3(8192)
};
var checksum4 = caches2.checksum;
function clear2() {
  for (const cache2 of Object.values(caches2))
    cache2.clear();
}

// node_modules/ox/_esm/core/PublicKey.js
var PublicKey_exports3 = {};
__export(PublicKey_exports3, {
  InvalidCompressedPrefixError: () => InvalidCompressedPrefixError,
  InvalidError: () => InvalidError,
  InvalidPrefixError: () => InvalidPrefixError,
  InvalidSerializedSizeError: () => InvalidSerializedSizeError,
  InvalidUncompressedPrefixError: () => InvalidUncompressedPrefixError,
  assert: () => assert5,
  compress: () => compress,
  from: () => from13,
  fromBytes: () => fromBytes5,
  fromHex: () => fromHex8,
  toBytes: () => toBytes6,
  toHex: () => toHex7,
  validate: () => validate8
});
function assert5(publicKey, options = {}) {
  const { compressed } = options;
  const { prefix, x: x7, y: y11 } = publicKey;
  if (compressed === false || typeof x7 === "bigint" && typeof y11 === "bigint") {
    if (prefix !== 4)
      throw new InvalidPrefixError({
        prefix,
        cause: new InvalidUncompressedPrefixError()
      });
    return;
  }
  if (compressed === true || typeof x7 === "bigint" && typeof y11 === "undefined") {
    if (prefix !== 3 && prefix !== 2)
      throw new InvalidPrefixError({
        prefix,
        cause: new InvalidCompressedPrefixError()
      });
    return;
  }
  throw new InvalidError({ publicKey });
}
function compress(publicKey) {
  const { x: x7, y: y11 } = publicKey;
  return {
    prefix: y11 % 2n === 0n ? 2 : 3,
    x: x7
  };
}
function from13(value2) {
  const publicKey = (() => {
    if (validate5(value2))
      return fromHex8(value2);
    if (validate6(value2))
      return fromBytes5(value2);
    const { prefix, x: x7, y: y11 } = value2;
    if (typeof x7 === "bigint" && typeof y11 === "bigint")
      return { prefix: prefix ?? 4, x: x7, y: y11 };
    return { prefix, x: x7 };
  })();
  assert5(publicKey);
  return publicKey;
}
function fromBytes5(publicKey) {
  return fromHex8(fromBytes4(publicKey));
}
function fromHex8(publicKey) {
  if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68)
    throw new InvalidSerializedSizeError({ publicKey });
  if (publicKey.length === 130) {
    const x8 = BigInt(slice6(publicKey, 0, 32));
    const y11 = BigInt(slice6(publicKey, 32, 64));
    return {
      prefix: 4,
      x: x8,
      y: y11
    };
  }
  if (publicKey.length === 132) {
    const prefix2 = Number(slice6(publicKey, 0, 1));
    const x8 = BigInt(slice6(publicKey, 1, 33));
    const y11 = BigInt(slice6(publicKey, 33, 65));
    return {
      prefix: prefix2,
      x: x8,
      y: y11
    };
  }
  const prefix = Number(slice6(publicKey, 0, 1));
  const x7 = BigInt(slice6(publicKey, 1, 33));
  return {
    prefix,
    x: x7
  };
}
function toBytes6(publicKey, options = {}) {
  return fromHex7(toHex7(publicKey, options));
}
function toHex7(publicKey, options = {}) {
  assert5(publicKey);
  const { prefix, x: x7, y: y11 } = publicKey;
  const { includePrefix = true } = options;
  const publicKey_ = concat7(
    includePrefix ? fromNumber3(prefix, { size: 1 }) : "0x",
    fromNumber3(x7, { size: 32 }),
    // If the public key is not compressed, add the y coordinate.
    typeof y11 === "bigint" ? fromNumber3(y11, { size: 32 }) : "0x"
  );
  return publicKey_;
}
function validate8(publicKey, options = {}) {
  try {
    assert5(publicKey, options);
    return true;
  } catch (error) {
    return false;
  }
}
var InvalidError = class extends BaseError6 {
  constructor({ publicKey }) {
    super(`Value \`${stringify6(publicKey)}\` is not a valid public key.`, {
      metaMessages: [
        "Public key must contain:",
        "- an `x` and `prefix` value (compressed)",
        "- an `x`, `y`, and `prefix` value (uncompressed)"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidError"
    });
  }
};
var InvalidPrefixError = class extends BaseError6 {
  constructor({ prefix, cause }) {
    super(`Prefix "${prefix}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidPrefixError"
    });
  }
};
var InvalidCompressedPrefixError = class extends BaseError6 {
  constructor() {
    super("Prefix must be 2 or 3 for compressed public keys.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidCompressedPrefixError"
    });
  }
};
var InvalidUncompressedPrefixError = class extends BaseError6 {
  constructor() {
    super("Prefix must be 4 for uncompressed public keys.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidUncompressedPrefixError"
    });
  }
};
var InvalidSerializedSizeError = class extends BaseError6 {
  constructor({ publicKey }) {
    super(`Value \`${publicKey}\` is an invalid public key size.`, {
      metaMessages: [
        "Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",
        `Received ${size7(from11(publicKey))} bytes.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidSerializedSizeError"
    });
  }
};

// node_modules/ox/_esm/core/Address.js
var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;
function assert6(value2, options = {}) {
  const { strict = true } = options;
  if (!addressRegex2.test(value2))
    throw new InvalidAddressError5({
      address: value2,
      cause: new InvalidInputError3()
    });
  if (strict) {
    if (value2.toLowerCase() === value2)
      return;
    if (checksum5(value2) !== value2)
      throw new InvalidAddressError5({
        address: value2,
        cause: new InvalidChecksumError2()
      });
  }
}
function checksum5(address) {
  if (checksum4.has(address))
    return checksum4.get(address);
  assert6(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash9 = keccak2565(fromString7(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i9 = 0; i9 < 40; i9 += 2) {
    if (hash9[i9 >> 1] >> 4 >= 8 && characters[i9]) {
      characters[i9] = characters[i9].toUpperCase();
    }
    if ((hash9[i9 >> 1] & 15) >= 8 && characters[i9 + 1]) {
      characters[i9 + 1] = characters[i9 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum4.set(address, result);
  return result;
}
function from14(address, options = {}) {
  const { checksum: checksumVal = false } = options;
  assert6(address);
  if (checksumVal)
    return checksum5(address);
  return address;
}
function fromPublicKey(publicKey, options = {}) {
  const address = keccak2565(`0x${toHex7(publicKey).slice(4)}`).substring(26);
  return from14(`0x${address}`, options);
}
function isEqual3(addressA, addressB) {
  assert6(addressA, { strict: false });
  assert6(addressB, { strict: false });
  return addressA.toLowerCase() === addressB.toLowerCase();
}
function validate9(address, options = {}) {
  const { strict = true } = options ?? {};
  try {
    assert6(address, { strict });
    return true;
  } catch {
    return false;
  }
}
var InvalidAddressError5 = class extends BaseError6 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError3 = class extends BaseError6 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError2 = class extends BaseError6 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/ox/_esm/core/internal/abiItem.js
function normalizeSignature2(signature) {
  let active = true;
  let current = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i9 = 0; i9 < signature.length; i9++) {
    const char = signature[i9];
    if (["(", ")", ","].includes(char))
      active = true;
    if (char === "(")
      level++;
    if (char === ")")
      level--;
    if (!active)
      continue;
    if (level === 0) {
      if (char === " " && ["event", "function", "error", ""].includes(result))
        result = "";
      else {
        result += char;
        if (char === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char === " ") {
      if (signature[i9 - 1] !== "," && current !== "," && current !== ",(") {
        current = "";
        active = false;
      }
      continue;
    }
    result += char;
    current += char;
  }
  if (!valid)
    throw new BaseError6("Unable to normalize signature.");
  return result;
}
function isArgOfType2(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return validate9(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index2) => {
          return isArgOfType2(Object.values(arg)[index2], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x7) => isArgOfType2(x7, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes2(sourceParameters, targetParameters, args) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, args[parameterIndex]);
    const types2 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types2.includes("address") && types2.includes("bytes20"))
        return true;
      if (types2.includes("address") && types2.includes("string"))
        return validate9(args[parameterIndex], {
          strict: false
        });
      if (types2.includes("address") && types2.includes("bytes"))
        return validate9(args[parameterIndex], {
          strict: false
        });
      return false;
    })();
    if (ambiguous)
      return types2;
  }
  return;
}

// node_modules/ox/_esm/core/AbiItem.js
function format2(abiItem) {
  return formatAbiItem3(abiItem);
}
function from15(abiItem, options = {}) {
  const { prepare = true } = options;
  const item = (() => {
    if (Array.isArray(abiItem))
      return parseAbiItem2(abiItem);
    if (typeof abiItem === "string")
      return parseAbiItem2(abiItem);
    return abiItem;
  })();
  return {
    ...item,
    ...prepare ? { hash: getSignatureHash(item) } : {}
  };
}
function fromAbi2(abi3, name, options) {
  const { args = [], prepare = true } = options ?? {};
  const isSelector = validate5(name, { strict: false });
  const abiItems = abi3.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function" || abiItem2.type === "error")
        return getSelector2(abiItem2) === slice6(name, 0, 4);
      if (abiItem2.type === "event")
        return getSignatureHash(abiItem2) === name;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name;
  });
  if (abiItems.length === 0)
    throw new NotFoundError2({ name });
  if (abiItems.length === 1)
    return {
      ...abiItems[0],
      ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
    };
  let matchedAbiItem = void 0;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!args || args.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return {
          ...abiItem2,
          ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
        };
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== args.length)
      continue;
    const matched = args.every((arg, index2) => {
      const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index2];
      if (!abiParameter)
        return false;
      return isArgOfType2(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes2(abiItem2.inputs, matchedAbiItem.inputs, args);
        if (ambiguousTypes)
          throw new AmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  const abiItem = (() => {
    if (matchedAbiItem)
      return matchedAbiItem;
    const [abiItem2, ...overloads] = abiItems;
    return { ...abiItem2, overloads };
  })();
  if (!abiItem)
    throw new NotFoundError2({ name });
  return {
    ...abiItem,
    ...prepare ? { hash: getSignatureHash(abiItem) } : {}
  };
}
function getSelector2(abiItem) {
  return slice6(getSignatureHash(abiItem), 0, 4);
}
function getSignature(abiItem) {
  const signature = (() => {
    if (typeof abiItem === "string")
      return abiItem;
    return formatAbiItem3(abiItem);
  })();
  return normalizeSignature2(signature);
}
function getSignatureHash(abiItem) {
  if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
    return abiItem.hash;
  return keccak2565(fromString6(getSignature(abiItem)));
}
var AmbiguityError = class extends BaseError6 {
  constructor(x7, y11) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${x7.type}\` in \`${normalizeSignature2(formatAbiItem3(x7.abiItem))}\`, and`,
        `\`${y11.type}\` in \`${normalizeSignature2(formatAbiItem3(y11.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.AmbiguityError"
    });
  }
};
var NotFoundError2 = class extends BaseError6 {
  constructor({ name, data, type: type7 = "item" }) {
    const selector = (() => {
      if (name)
        return ` with name "${name}"`;
      if (data)
        return ` with data "${data}"`;
      return "";
    })();
    super(`ABI ${type7}${selector} not found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.NotFoundError"
    });
  }
};
var InvalidSelectorSizeError2 = class extends BaseError6 {
  constructor({ data }) {
    super(`Selector size is invalid. Expected 4 bytes. Received ${size7(data)} bytes ("${data}").`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.InvalidSelectorSizeError"
    });
  }
};

// node_modules/ox/_esm/core/AbiParameters.js
var AbiParameters_exports3 = {};
__export(AbiParameters_exports3, {
  ArrayLengthMismatchError: () => ArrayLengthMismatchError2,
  BytesSizeMismatchError: () => BytesSizeMismatchError4,
  DataSizeTooSmallError: () => DataSizeTooSmallError,
  InvalidArrayError: () => InvalidArrayError3,
  InvalidTypeError: () => InvalidTypeError2,
  LengthMismatchError: () => LengthMismatchError2,
  ZeroDataError: () => ZeroDataError,
  decode: () => decode3,
  encode: () => encode8,
  encodePacked: () => encodePacked4,
  format: () => format3,
  from: () => from16
});

// node_modules/ox/_esm/core/Solidity.js
var Solidity_exports3 = {};
__export(Solidity_exports3, {
  arrayRegex: () => arrayRegex3,
  bytesRegex: () => bytesRegex5,
  integerRegex: () => integerRegex5,
  maxInt104: () => maxInt1043,
  maxInt112: () => maxInt1123,
  maxInt120: () => maxInt1203,
  maxInt128: () => maxInt1283,
  maxInt136: () => maxInt1363,
  maxInt144: () => maxInt1443,
  maxInt152: () => maxInt1523,
  maxInt16: () => maxInt163,
  maxInt160: () => maxInt1603,
  maxInt168: () => maxInt1683,
  maxInt176: () => maxInt1763,
  maxInt184: () => maxInt1843,
  maxInt192: () => maxInt1923,
  maxInt200: () => maxInt2003,
  maxInt208: () => maxInt2083,
  maxInt216: () => maxInt2163,
  maxInt224: () => maxInt2243,
  maxInt232: () => maxInt2323,
  maxInt24: () => maxInt243,
  maxInt240: () => maxInt2403,
  maxInt248: () => maxInt2483,
  maxInt256: () => maxInt2563,
  maxInt32: () => maxInt323,
  maxInt40: () => maxInt403,
  maxInt48: () => maxInt483,
  maxInt56: () => maxInt563,
  maxInt64: () => maxInt643,
  maxInt72: () => maxInt723,
  maxInt8: () => maxInt83,
  maxInt80: () => maxInt803,
  maxInt88: () => maxInt883,
  maxInt96: () => maxInt963,
  maxUint104: () => maxUint1043,
  maxUint112: () => maxUint1123,
  maxUint120: () => maxUint1203,
  maxUint128: () => maxUint1283,
  maxUint136: () => maxUint1363,
  maxUint144: () => maxUint1443,
  maxUint152: () => maxUint1523,
  maxUint16: () => maxUint163,
  maxUint160: () => maxUint1603,
  maxUint168: () => maxUint1683,
  maxUint176: () => maxUint1763,
  maxUint184: () => maxUint1843,
  maxUint192: () => maxUint1923,
  maxUint200: () => maxUint2003,
  maxUint208: () => maxUint2083,
  maxUint216: () => maxUint2163,
  maxUint224: () => maxUint2243,
  maxUint232: () => maxUint2323,
  maxUint24: () => maxUint243,
  maxUint240: () => maxUint2403,
  maxUint248: () => maxUint2483,
  maxUint256: () => maxUint2563,
  maxUint32: () => maxUint323,
  maxUint40: () => maxUint403,
  maxUint48: () => maxUint483,
  maxUint56: () => maxUint563,
  maxUint64: () => maxUint643,
  maxUint72: () => maxUint723,
  maxUint8: () => maxUint83,
  maxUint80: () => maxUint803,
  maxUint88: () => maxUint883,
  maxUint96: () => maxUint963,
  minInt104: () => minInt1043,
  minInt112: () => minInt1123,
  minInt120: () => minInt1203,
  minInt128: () => minInt1283,
  minInt136: () => minInt1363,
  minInt144: () => minInt1443,
  minInt152: () => minInt1523,
  minInt16: () => minInt163,
  minInt160: () => minInt1603,
  minInt168: () => minInt1683,
  minInt176: () => minInt1763,
  minInt184: () => minInt1843,
  minInt192: () => minInt1923,
  minInt200: () => minInt2003,
  minInt208: () => minInt2083,
  minInt216: () => minInt2163,
  minInt224: () => minInt2243,
  minInt232: () => minInt2323,
  minInt24: () => minInt243,
  minInt240: () => minInt2403,
  minInt248: () => minInt2483,
  minInt256: () => minInt2563,
  minInt32: () => minInt323,
  minInt40: () => minInt403,
  minInt48: () => minInt483,
  minInt56: () => minInt563,
  minInt64: () => minInt643,
  minInt72: () => minInt723,
  minInt8: () => minInt83,
  minInt80: () => minInt803,
  minInt88: () => minInt883,
  minInt96: () => minInt963
});
var arrayRegex3 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex5 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex5 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt83 = 2n ** (8n - 1n) - 1n;
var maxInt163 = 2n ** (16n - 1n) - 1n;
var maxInt243 = 2n ** (24n - 1n) - 1n;
var maxInt323 = 2n ** (32n - 1n) - 1n;
var maxInt403 = 2n ** (40n - 1n) - 1n;
var maxInt483 = 2n ** (48n - 1n) - 1n;
var maxInt563 = 2n ** (56n - 1n) - 1n;
var maxInt643 = 2n ** (64n - 1n) - 1n;
var maxInt723 = 2n ** (72n - 1n) - 1n;
var maxInt803 = 2n ** (80n - 1n) - 1n;
var maxInt883 = 2n ** (88n - 1n) - 1n;
var maxInt963 = 2n ** (96n - 1n) - 1n;
var maxInt1043 = 2n ** (104n - 1n) - 1n;
var maxInt1123 = 2n ** (112n - 1n) - 1n;
var maxInt1203 = 2n ** (120n - 1n) - 1n;
var maxInt1283 = 2n ** (128n - 1n) - 1n;
var maxInt1363 = 2n ** (136n - 1n) - 1n;
var maxInt1443 = 2n ** (144n - 1n) - 1n;
var maxInt1523 = 2n ** (152n - 1n) - 1n;
var maxInt1603 = 2n ** (160n - 1n) - 1n;
var maxInt1683 = 2n ** (168n - 1n) - 1n;
var maxInt1763 = 2n ** (176n - 1n) - 1n;
var maxInt1843 = 2n ** (184n - 1n) - 1n;
var maxInt1923 = 2n ** (192n - 1n) - 1n;
var maxInt2003 = 2n ** (200n - 1n) - 1n;
var maxInt2083 = 2n ** (208n - 1n) - 1n;
var maxInt2163 = 2n ** (216n - 1n) - 1n;
var maxInt2243 = 2n ** (224n - 1n) - 1n;
var maxInt2323 = 2n ** (232n - 1n) - 1n;
var maxInt2403 = 2n ** (240n - 1n) - 1n;
var maxInt2483 = 2n ** (248n - 1n) - 1n;
var maxInt2563 = 2n ** (256n - 1n) - 1n;
var minInt83 = -(2n ** (8n - 1n));
var minInt163 = -(2n ** (16n - 1n));
var minInt243 = -(2n ** (24n - 1n));
var minInt323 = -(2n ** (32n - 1n));
var minInt403 = -(2n ** (40n - 1n));
var minInt483 = -(2n ** (48n - 1n));
var minInt563 = -(2n ** (56n - 1n));
var minInt643 = -(2n ** (64n - 1n));
var minInt723 = -(2n ** (72n - 1n));
var minInt803 = -(2n ** (80n - 1n));
var minInt883 = -(2n ** (88n - 1n));
var minInt963 = -(2n ** (96n - 1n));
var minInt1043 = -(2n ** (104n - 1n));
var minInt1123 = -(2n ** (112n - 1n));
var minInt1203 = -(2n ** (120n - 1n));
var minInt1283 = -(2n ** (128n - 1n));
var minInt1363 = -(2n ** (136n - 1n));
var minInt1443 = -(2n ** (144n - 1n));
var minInt1523 = -(2n ** (152n - 1n));
var minInt1603 = -(2n ** (160n - 1n));
var minInt1683 = -(2n ** (168n - 1n));
var minInt1763 = -(2n ** (176n - 1n));
var minInt1843 = -(2n ** (184n - 1n));
var minInt1923 = -(2n ** (192n - 1n));
var minInt2003 = -(2n ** (200n - 1n));
var minInt2083 = -(2n ** (208n - 1n));
var minInt2163 = -(2n ** (216n - 1n));
var minInt2243 = -(2n ** (224n - 1n));
var minInt2323 = -(2n ** (232n - 1n));
var minInt2403 = -(2n ** (240n - 1n));
var minInt2483 = -(2n ** (248n - 1n));
var minInt2563 = -(2n ** (256n - 1n));
var maxUint83 = 2n ** 8n - 1n;
var maxUint163 = 2n ** 16n - 1n;
var maxUint243 = 2n ** 24n - 1n;
var maxUint323 = 2n ** 32n - 1n;
var maxUint403 = 2n ** 40n - 1n;
var maxUint483 = 2n ** 48n - 1n;
var maxUint563 = 2n ** 56n - 1n;
var maxUint643 = 2n ** 64n - 1n;
var maxUint723 = 2n ** 72n - 1n;
var maxUint803 = 2n ** 80n - 1n;
var maxUint883 = 2n ** 88n - 1n;
var maxUint963 = 2n ** 96n - 1n;
var maxUint1043 = 2n ** 104n - 1n;
var maxUint1123 = 2n ** 112n - 1n;
var maxUint1203 = 2n ** 120n - 1n;
var maxUint1283 = 2n ** 128n - 1n;
var maxUint1363 = 2n ** 136n - 1n;
var maxUint1443 = 2n ** 144n - 1n;
var maxUint1523 = 2n ** 152n - 1n;
var maxUint1603 = 2n ** 160n - 1n;
var maxUint1683 = 2n ** 168n - 1n;
var maxUint1763 = 2n ** 176n - 1n;
var maxUint1843 = 2n ** 184n - 1n;
var maxUint1923 = 2n ** 192n - 1n;
var maxUint2003 = 2n ** 200n - 1n;
var maxUint2083 = 2n ** 208n - 1n;
var maxUint2163 = 2n ** 216n - 1n;
var maxUint2243 = 2n ** 224n - 1n;
var maxUint2323 = 2n ** 232n - 1n;
var maxUint2403 = 2n ** 240n - 1n;
var maxUint2483 = 2n ** 248n - 1n;
var maxUint2563 = 2n ** 256n - 1n;

// node_modules/ox/_esm/core/internal/abiParameters.js
function decodeParameter2(cursor, param, options) {
  const { checksumAddress: checksumAddress2, staticPosition } = options;
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length, type7] = arrayComponents;
    return decodeArray(cursor, { ...param, type: type7 }, { checksumAddress: checksumAddress2, length, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, {
      checksumAddress: checksumAddress2,
      staticPosition
    });
  if (param.type === "address")
    return decodeAddress(cursor, { checksum: checksumAddress2 });
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidTypeError2(param.type);
}
var sizeOfLength = 32;
var sizeOfOffset = 32;
function decodeAddress(cursor, options = {}) {
  const { checksum: checksum6 = false } = options;
  const value2 = cursor.readBytes(32);
  const wrap = (address) => checksum6 ? checksum5(address) : address;
  return [wrap(fromBytes4(slice7(value2, -20))), 32];
}
function decodeArray(cursor, param, options) {
  const { checksumAddress: checksumAddress2, length, staticPosition } = options;
  if (!length) {
    const offset = toNumber3(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const startOfData = start + sizeOfLength;
    cursor.setPosition(start);
    const length2 = toNumber3(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value3 = [];
    for (let i9 = 0; i9 < length2; ++i9) {
      cursor.setPosition(startOfData + (dynamicChild ? i9 * 32 : consumed2));
      const [data, consumed_] = decodeParameter2(cursor, param, {
        checksumAddress: checksumAddress2,
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value3.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value3, 32];
  }
  if (hasDynamicChild(param)) {
    const offset = toNumber3(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    const value3 = [];
    for (let i9 = 0; i9 < length; ++i9) {
      cursor.setPosition(start + i9 * 32);
      const [data] = decodeParameter2(cursor, param, {
        checksumAddress: checksumAddress2,
        staticPosition: start
      });
      value3.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value3, 32];
  }
  let consumed = 0;
  const value2 = [];
  for (let i9 = 0; i9 < length; ++i9) {
    const [data, consumed_] = decodeParameter2(cursor, param, {
      checksumAddress: checksumAddress2,
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value2.push(data);
  }
  return [value2, consumed];
}
function decodeBool(cursor) {
  return [toBoolean3(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_6, size11] = param.type.split("bytes");
  if (!size11) {
    const offset = toNumber3(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length = toNumber3(cursor.readBytes(32));
    if (length === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length);
    cursor.setPosition(staticPosition + 32);
    return [fromBytes4(data), 32];
  }
  const value2 = fromBytes4(cursor.readBytes(Number.parseInt(size11), 32));
  return [value2, 32];
}
function decodeNumber(cursor, param) {
  const signed = param.type.startsWith("int");
  const size11 = Number.parseInt(param.type.split("int")[1] || "256");
  const value2 = cursor.readBytes(32);
  return [
    size11 > 48 ? toBigInt3(value2, { signed }) : toNumber3(value2, { signed }),
    32
  ];
}
function decodeTuple(cursor, param, options) {
  const { checksumAddress: checksumAddress2, staticPosition } = options;
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value2 = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = toNumber3(cursor.readBytes(sizeOfOffset));
    const start = staticPosition + offset;
    for (let i9 = 0; i9 < param.components.length; ++i9) {
      const component = param.components[i9];
      cursor.setPosition(start + consumed);
      const [data, consumed_] = decodeParameter2(cursor, component, {
        checksumAddress: checksumAddress2,
        staticPosition: start
      });
      consumed += consumed_;
      value2[hasUnnamedChild ? i9 : component == null ? void 0 : component.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value2, 32];
  }
  for (let i9 = 0; i9 < param.components.length; ++i9) {
    const component = param.components[i9];
    const [data, consumed_] = decodeParameter2(cursor, component, {
      checksumAddress: checksumAddress2,
      staticPosition
    });
    value2[hasUnnamedChild ? i9 : component == null ? void 0 : component.name] = data;
    consumed += consumed_;
  }
  return [value2, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset = toNumber3(cursor.readBytes(32));
  const start = staticPosition + offset;
  cursor.setPosition(start);
  const length = toNumber3(cursor.readBytes(32));
  if (length === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length, 32);
  const value2 = toString5(trimLeft3(data));
  cursor.setPosition(staticPosition + 32);
  return [value2, 32];
}
function prepareParameters2({ checksumAddress: checksumAddress2, parameters, values }) {
  const preparedParameters = [];
  for (let i9 = 0; i9 < parameters.length; i9++) {
    preparedParameters.push(prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: parameters[i9],
      value: values[i9]
    }));
  }
  return preparedParameters;
}
function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value: value2 }) {
  const parameter = parameter_;
  const arrayComponents = getArrayComponents(parameter.type);
  if (arrayComponents) {
    const [length, type7] = arrayComponents;
    return encodeArray(value2, {
      checksumAddress: checksumAddress2,
      length,
      parameter: {
        ...parameter,
        type: type7
      }
    });
  }
  if (parameter.type === "tuple") {
    return encodeTuple(value2, {
      checksumAddress: checksumAddress2,
      parameter
    });
  }
  if (parameter.type === "address") {
    return encodeAddress(value2, {
      checksum: checksumAddress2
    });
  }
  if (parameter.type === "bool") {
    return encodeBoolean(value2);
  }
  if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
    const signed = parameter.type.startsWith("int");
    const [, , size11 = "256"] = integerRegex5.exec(parameter.type) ?? [];
    return encodeNumber(value2, {
      signed,
      size: Number(size11)
    });
  }
  if (parameter.type.startsWith("bytes")) {
    return encodeBytes(value2, { type: parameter.type });
  }
  if (parameter.type === "string") {
    return encodeString(value2);
  }
  throw new InvalidTypeError2(parameter.type);
}
function encode7(preparedParameters) {
  let staticSize = 0;
  for (let i9 = 0; i9 < preparedParameters.length; i9++) {
    const { dynamic, encoded } = preparedParameters[i9];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size7(encoded);
  }
  const staticParameters = [];
  const dynamicParameters = [];
  let dynamicSize = 0;
  for (let i9 = 0; i9 < preparedParameters.length; i9++) {
    const { dynamic, encoded } = preparedParameters[i9];
    if (dynamic) {
      staticParameters.push(fromNumber3(staticSize + dynamicSize, { size: 32 }));
      dynamicParameters.push(encoded);
      dynamicSize += size7(encoded);
    } else {
      staticParameters.push(encoded);
    }
  }
  return concat7(...staticParameters, ...dynamicParameters);
}
function encodeAddress(value2, options) {
  const { checksum: checksum6 = false } = options;
  assert6(value2, { strict: checksum6 });
  return {
    dynamic: false,
    encoded: padLeft3(value2.toLowerCase())
  };
}
function encodeArray(value2, options) {
  const { checksumAddress: checksumAddress2, length, parameter } = options;
  const dynamic = length === null;
  if (!Array.isArray(value2))
    throw new InvalidArrayError3(value2);
  if (!dynamic && value2.length !== length)
    throw new ArrayLengthMismatchError2({
      expectedLength: length,
      givenLength: value2.length,
      type: `${parameter.type}[${length}]`
    });
  let dynamicChild = false;
  const preparedParameters = [];
  for (let i9 = 0; i9 < value2.length; i9++) {
    const preparedParam = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter,
      value: value2[i9]
    });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParameters.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encode7(preparedParameters);
    if (dynamic) {
      const length2 = fromNumber3(preparedParameters.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParameters.length > 0 ? concat7(length2, data) : length2
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat7(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value2, { type: type7 }) {
  const [, parametersize] = type7.split("bytes");
  const bytesSize = size7(value2);
  if (!parametersize) {
    let value_ = value2;
    if (bytesSize % 32 !== 0)
      value_ = padRight2(value_, Math.ceil((value2.length - 2) / 2 / 32) * 32);
    return {
      dynamic: true,
      encoded: concat7(padLeft3(fromNumber3(bytesSize, { size: 32 })), value_)
    };
  }
  if (bytesSize !== Number.parseInt(parametersize))
    throw new BytesSizeMismatchError4({
      expectedSize: Number.parseInt(parametersize),
      value: value2
    });
  return { dynamic: false, encoded: padRight2(value2) };
}
function encodeBoolean(value2) {
  if (typeof value2 !== "boolean")
    throw new BaseError6(`Invalid boolean value: "${value2}" (type: ${typeof value2}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padLeft3(fromBoolean2(value2)) };
}
function encodeNumber(value2, { signed, size: size11 }) {
  if (typeof size11 === "number") {
    const max4 = 2n ** (BigInt(size11) - (signed ? 1n : 0n)) - 1n;
    const min4 = signed ? -max4 - 1n : 0n;
    if (value2 > max4 || value2 < min4)
      throw new IntegerOutOfRangeError3({
        max: max4.toString(),
        min: min4.toString(),
        signed,
        size: size11 / 8,
        value: value2.toString()
      });
  }
  return {
    dynamic: false,
    encoded: fromNumber3(value2, {
      size: 32,
      signed
    })
  };
}
function encodeString(value2) {
  const hexValue = fromString6(value2);
  const partsLength = Math.ceil(size7(hexValue) / 32);
  const parts2 = [];
  for (let i9 = 0; i9 < partsLength; i9++) {
    parts2.push(padRight2(slice6(hexValue, i9 * 32, (i9 + 1) * 32)));
  }
  return {
    dynamic: true,
    encoded: concat7(padRight2(fromNumber3(size7(hexValue), { size: 32 })), ...parts2)
  };
}
function encodeTuple(value2, options) {
  const { checksumAddress: checksumAddress2, parameter } = options;
  let dynamic = false;
  const preparedParameters = [];
  for (let i9 = 0; i9 < parameter.components.length; i9++) {
    const param_ = parameter.components[i9];
    const index2 = Array.isArray(value2) ? i9 : param_.name;
    const preparedParam = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: param_,
      value: value2[index2]
    });
    preparedParameters.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encode7(preparedParameters) : concat7(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type7) {
  const matches = type7.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
function hasDynamicChild(param) {
  var _a14;
  const { type: type7 } = param;
  if (type7 === "string")
    return true;
  if (type7 === "bytes")
    return true;
  if (type7.endsWith("[]"))
    return true;
  if (type7 === "tuple")
    return (_a14 = param.components) == null ? void 0 : _a14.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({
    ...param,
    type: arrayComponents[1]
  }))
    return true;
  return false;
}

// node_modules/ox/_esm/core/internal/cursor.js
var staticCursor2 = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError2({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError3({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError2({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError2({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes2) {
    this.assertPosition(this.position + bytes2.length - 1);
    this.bytes.set(bytes2, this.position);
    this.position += bytes2.length;
  },
  pushUint8(value2) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value2;
    this.position++;
  },
  pushUint16(value2) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value2);
    this.position += 2;
  },
  pushUint24(value2) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value2 >> 8);
    this.dataView.setUint8(this.position + 2, value2 & ~4294967040);
    this.position += 3;
  },
  pushUint32(value2) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value2);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectByte();
    this.position++;
    return value2;
  },
  readBytes(length, size11) {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectBytes(length);
    this.position += size11 ?? length;
    return value2;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint8();
    this.position += 1;
    return value2;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint16();
    this.position += 2;
    return value2;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint24();
    this.position += 3;
    return value2;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value2 = this.inspectUint32();
    this.position += 4;
    return value2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
function create2(bytes2, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor2);
  cursor.bytes = bytes2;
  cursor.dataView = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var NegativeOffsetError2 = class extends BaseError6 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError3 = class extends BaseError6 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError2 = class extends BaseError6 {
  constructor({ count, limit: limit2 }) {
    super(`Recursive read limit of \`${limit2}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/ox/_esm/core/AbiParameters.js
function decode3(parameters, data, options = {}) {
  const { as: as17 = "Array", checksumAddress: checksumAddress2 = false } = options;
  const bytes2 = typeof data === "string" ? fromHex7(data) : data;
  const cursor = create2(bytes2);
  if (size6(bytes2) === 0 && parameters.length > 0)
    throw new ZeroDataError();
  if (size6(bytes2) && size6(bytes2) < 32)
    throw new DataSizeTooSmallError({
      data: typeof data === "string" ? data : fromBytes4(data),
      parameters,
      size: size6(bytes2)
    });
  let consumed = 0;
  const values = as17 === "Array" ? [] : {};
  for (let i9 = 0; i9 < parameters.length; ++i9) {
    const param = parameters[i9];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter2(cursor, param, {
      checksumAddress: checksumAddress2,
      staticPosition: 0
    });
    consumed += consumed_;
    if (as17 === "Array")
      values.push(data2);
    else
      values[param.name ?? i9] = data2;
  }
  return values;
}
function encode8(parameters, values, options) {
  const { checksumAddress: checksumAddress2 = false } = options ?? {};
  if (parameters.length !== values.length)
    throw new LengthMismatchError2({
      expectedLength: parameters.length,
      givenLength: values.length
    });
  const preparedParameters = prepareParameters2({
    checksumAddress: checksumAddress2,
    parameters,
    values
  });
  const data = encode7(preparedParameters);
  if (data.length === 0)
    return "0x";
  return data;
}
function encodePacked4(types2, values) {
  if (types2.length !== values.length)
    throw new LengthMismatchError2({
      expectedLength: types2.length,
      givenLength: values.length
    });
  const data = [];
  for (let i9 = 0; i9 < types2.length; i9++) {
    const type7 = types2[i9];
    const value2 = values[i9];
    data.push(encodePacked4.encode(type7, value2));
  }
  return concat7(...data);
}
(function(encodePacked5) {
  function encode20(type7, value2, isArray4 = false) {
    if (type7 === "address") {
      const address = value2;
      assert6(address);
      return padLeft3(address.toLowerCase(), isArray4 ? 32 : 0);
    }
    if (type7 === "string")
      return fromString6(value2);
    if (type7 === "bytes")
      return value2;
    if (type7 === "bool")
      return padLeft3(fromBoolean2(value2), isArray4 ? 32 : 1);
    const intMatch = type7.match(integerRegex5);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size11 = Number.parseInt(bits) / 8;
      return fromNumber3(value2, {
        size: isArray4 ? 32 : size11,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type7.match(bytesRegex5);
    if (bytesMatch) {
      const [_type, size11] = bytesMatch;
      if (Number.parseInt(size11) !== (value2.length - 2) / 2)
        throw new BytesSizeMismatchError4({
          expectedSize: Number.parseInt(size11),
          value: value2
        });
      return padRight2(value2, isArray4 ? 32 : 0);
    }
    const arrayMatch = type7.match(arrayRegex3);
    if (arrayMatch && Array.isArray(value2)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i9 = 0; i9 < value2.length; i9++) {
        data.push(encode20(childType, value2[i9], true));
      }
      if (data.length === 0)
        return "0x";
      return concat7(...data);
    }
    throw new InvalidTypeError2(type7);
  }
  encodePacked5.encode = encode20;
})(encodePacked4 || (encodePacked4 = {}));
function format3(parameters) {
  return formatAbiParameters2(parameters);
}
function from16(parameters) {
  if (Array.isArray(parameters) && typeof parameters[0] === "string")
    return parseAbiParameters2(parameters);
  if (typeof parameters === "string")
    return parseAbiParameters2(parameters);
  return parameters;
}
var DataSizeTooSmallError = class extends BaseError6 {
  constructor({ data, parameters, size: size11 }) {
    super(`Data size of ${size11} bytes is too small for given parameters.`, {
      metaMessages: [
        `Params: (${formatAbiParameters2(parameters)})`,
        `Data:   ${data} (${size11} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.DataSizeTooSmallError"
    });
  }
};
var ZeroDataError = class extends BaseError6 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.ZeroDataError"
    });
  }
};
var ArrayLengthMismatchError2 = class extends BaseError6 {
  constructor({ expectedLength, givenLength, type: type7 }) {
    super(`Array length mismatch for type \`${type7}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
};
var BytesSizeMismatchError4 = class extends BaseError6 {
  constructor({ expectedSize, value: value2 }) {
    super(`Size of bytes "${value2}" (bytes${size7(value2)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError2 = class extends BaseError6 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidArrayError3 = class extends BaseError6 {
  constructor(value2) {
    super(`Value \`${value2}\` is not a valid array.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidArrayError"
    });
  }
};
var InvalidTypeError2 = class extends BaseError6 {
  constructor(type7) {
    super(`Type \`${type7}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/ox/_esm/core/AbiConstructor.js
function decode4(abiConstructor, options) {
  const { bytecode } = options;
  if (abiConstructor.inputs.length === 0)
    return void 0;
  const data = options.data.replace(bytecode, "0x");
  return decode3(abiConstructor.inputs, data);
}
function encode9(abiConstructor, options) {
  var _a14;
  const { bytecode, args } = options;
  return concat7(bytecode, ((_a14 = abiConstructor.inputs) == null ? void 0 : _a14.length) && (args == null ? void 0 : args.length) ? encode8(abiConstructor.inputs, args) : "0x");
}
function format4(abiConstructor) {
  return formatAbiItem3(abiConstructor);
}
function from17(abiConstructor) {
  return from15(abiConstructor);
}
function fromAbi3(abi3) {
  const item = abi3.find((item2) => item2.type === "constructor");
  if (!item)
    throw new NotFoundError2({ name: "constructor" });
  return item;
}

// node_modules/ox/_esm/core/AbiError.js
var AbiError_exports = {};
__export(AbiError_exports, {
  decode: () => decode5,
  encode: () => encode10,
  format: () => format5,
  from: () => from18,
  fromAbi: () => fromAbi4,
  getSelector: () => getSelector3,
  panicReasons: () => panicReasons2,
  solidityError: () => solidityError,
  solidityErrorSelector: () => solidityErrorSelector,
  solidityPanic: () => solidityPanic,
  solidityPanicSelector: () => solidityPanicSelector
});
function decode5(abiError, data, options = {}) {
  if (size7(data) < 4)
    throw new InvalidSelectorSizeError2({ data });
  if (abiError.inputs.length === 0)
    return void 0;
  const values = decode3(abiError.inputs, slice6(data, 4), options);
  if (values && Object.keys(values).length === 1) {
    if (Array.isArray(values))
      return values[0];
    return Object.values(values)[0];
  }
  return values;
}
function encode10(abiError, ...args) {
  const selector = getSelector3(abiError);
  const data = args.length > 0 ? encode8(abiError.inputs, args[0]) : void 0;
  return data ? concat7(selector, data) : selector;
}
function format5(abiError) {
  return formatAbiItem3(abiError);
}
function from18(abiError, options = {}) {
  return from15(abiError, options);
}
function fromAbi4(abi3, name, options) {
  if (name === "Error")
    return solidityError;
  if (name === "Panic")
    return solidityPanic;
  if (validate5(name, { strict: false })) {
    const selector = slice6(name, 0, 4);
    if (selector === solidityErrorSelector)
      return solidityError;
    if (selector === solidityPanicSelector)
      return solidityPanic;
  }
  const item = fromAbi2(abi3, name, options);
  if (item.type !== "error")
    throw new NotFoundError2({ name, type: "error" });
  return item;
}
function getSelector3(abiItem) {
  return getSelector2(abiItem);
}
var panicReasons2 = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
var solidityError = from18({
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
});
var solidityErrorSelector = "0x08c379a0";
var solidityPanic = from18({
  inputs: [
    {
      name: "reason",
      type: "uint8"
    }
  ],
  name: "Panic",
  type: "error"
});
var solidityPanicSelector = "0x4e487b71";

// node_modules/ox/_esm/core/AbiEvent.js
var AbiEvent_exports = {};
__export(AbiEvent_exports, {
  ArgsMismatchError: () => ArgsMismatchError,
  DataMismatchError: () => DataMismatchError,
  FilterTypeNotSupportedError: () => FilterTypeNotSupportedError2,
  InputNotFoundError: () => InputNotFoundError,
  SelectorTopicMismatchError: () => SelectorTopicMismatchError,
  TopicsMismatchError: () => TopicsMismatchError,
  assertArgs: () => assertArgs,
  decode: () => decode6,
  encode: () => encode11,
  format: () => format6,
  from: () => from19,
  fromAbi: () => fromAbi5,
  getSelector: () => getSelector4
});
function assertArgs(abiEvent, args, matchArgs) {
  if (!args || !matchArgs)
    throw new ArgsMismatchError({
      abiEvent,
      expected: args,
      given: matchArgs
    });
  function isEqual4(input, value2, arg) {
    if (input.type === "address")
      return isEqual3(value2, arg);
    if (input.type === "string")
      return keccak2565(fromString7(value2)) === arg;
    if (input.type === "bytes")
      return keccak2565(value2) === arg;
    return value2 === arg;
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    for (const [index2, value2] of matchArgs.entries()) {
      if (value2 === null || value2 === void 0)
        continue;
      const input = abiEvent.inputs[index2];
      if (!input)
        throw new InputNotFoundError({
          abiEvent,
          name: `${index2}`
        });
      const value_ = Array.isArray(value2) ? value2 : [value2];
      let equal = false;
      for (const value3 of value_) {
        if (isEqual4(input, value3, args[index2]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    for (const [key, value2] of Object.entries(matchArgs)) {
      if (value2 === null || value2 === void 0)
        continue;
      const input = abiEvent.inputs.find((input2) => input2.name === key);
      if (!input)
        throw new InputNotFoundError({ abiEvent, name: key });
      const value_ = Array.isArray(value2) ? value2 : [value2];
      let equal = false;
      for (const value3 of value_) {
        if (isEqual4(input, value3, args[key]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
}
function decode6(abiEvent, log) {
  const { data, topics } = log;
  const [selector_, ...argTopics] = topics;
  const selector = getSelector4(abiEvent);
  if (selector_ !== selector)
    throw new SelectorTopicMismatchError({
      abiEvent,
      actual: selector_,
      expected: selector
    });
  const { inputs } = abiEvent;
  const isUnnamed = inputs == null ? void 0 : inputs.every((x7) => !("name" in x7 && x7.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x7) => "indexed" in x7 && x7.indexed);
  for (let i9 = 0; i9 < indexedInputs.length; i9++) {
    const param = indexedInputs[i9];
    const topic = argTopics[i9];
    if (!topic)
      throw new TopicsMismatchError({
        abiEvent,
        param
      });
    args[isUnnamed ? i9 : param.name || i9] = (() => {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return topic;
      const decoded = decode3([param], topic) || [];
      return decoded[0];
    })();
  }
  const nonIndexedInputs = inputs.filter((x7) => !("indexed" in x7 && x7.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decode3(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i9 = 0; i9 < nonIndexedInputs.length; i9++) {
              const index2 = inputs.indexOf(nonIndexedInputs[i9]);
              args[nonIndexedInputs[i9].name || index2] = decodedData[i9];
            }
          }
        }
      } catch (err) {
        if (err instanceof DataSizeTooSmallError || err instanceof PositionOutOfBoundsError3)
          throw new DataMismatchError({
            abiEvent,
            data,
            parameters: nonIndexedInputs,
            size: size7(data)
          });
        throw err;
      }
    } else {
      throw new DataMismatchError({
        abiEvent,
        data: "0x",
        parameters: nonIndexedInputs,
        size: 0
      });
    }
  }
  return Object.values(args).length > 0 ? args : void 0;
}
function encode11(abiEvent, ...[args]) {
  let topics = [];
  if (args && abiEvent.inputs) {
    const indexedInputs = abiEvent.inputs.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x7, i9) => args[x7.name ?? i9])) ?? [] : [];
    if (args_.length > 0) {
      const encode20 = (param, value2) => {
        if (param.type === "string")
          return keccak2565(fromString6(value2));
        if (param.type === "bytes")
          return keccak2565(value2);
        if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
          throw new FilterTypeNotSupportedError2(param.type);
        return encode8([param], [value2]);
      };
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i9) => {
        if (Array.isArray(args_[i9]))
          return args_[i9].map((_6, j9) => encode20(param, args_[i9][j9]));
        return typeof args_[i9] !== "undefined" && args_[i9] !== null ? encode20(param, args_[i9]) : null;
      })) ?? [];
    }
  }
  const selector = (() => {
    if (abiEvent.hash)
      return abiEvent.hash;
    return getSelector4(abiEvent);
  })();
  return { topics: [selector, ...topics] };
}
function format6(abiEvent) {
  return formatAbiItem3(abiEvent);
}
function from19(abiEvent, options = {}) {
  return from15(abiEvent, options);
}
function fromAbi5(abi3, name, options) {
  const item = fromAbi2(abi3, name, options);
  if (item.type !== "event")
    throw new NotFoundError2({ name, type: "event" });
  return item;
}
function getSelector4(abiItem) {
  return getSignatureHash(abiItem);
}
var ArgsMismatchError = class extends BaseError6 {
  constructor({ abiEvent, expected, given }) {
    super("Given arguments do not match the expected arguments.", {
      metaMessages: [
        `Event: ${format6(abiEvent)}`,
        `Expected Arguments: ${!expected ? "None" : ""}`,
        expected ? prettyPrint3(expected) : void 0,
        `Given Arguments: ${!given ? "None" : ""}`,
        given ? prettyPrint3(given) : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.ArgsMismatchError"
    });
  }
};
var InputNotFoundError = class extends BaseError6 {
  constructor({ abiEvent, name }) {
    super(`Parameter "${name}" not found on \`${format6(abiEvent)}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.InputNotFoundError"
    });
  }
};
var DataMismatchError = class extends BaseError6 {
  constructor({ abiEvent, data, parameters, size: size11 }) {
    super([
      `Data size of ${size11} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Non-indexed Parameters: (${format3(parameters)})`,
        `Data:   ${data} (${size11} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.DataMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parameters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
    this.data = data;
    this.parameters = parameters;
    this.size = size11;
  }
};
var TopicsMismatchError = class extends BaseError6 {
  constructor({ abiEvent, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} for "${format6(abiEvent)}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.TopicsMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
  }
};
var SelectorTopicMismatchError = class extends BaseError6 {
  constructor({ abiEvent, actual, expected }) {
    super(`topics[0]="${actual}" does not match the expected topics[0]="${expected}".`, {
      metaMessages: [`Event: ${format6(abiEvent)}`, `Selector: ${expected}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.SelectorTopicMismatchError"
    });
  }
};
var FilterTypeNotSupportedError2 = class extends BaseError6 {
  constructor(type7) {
    super(`Filter type "${type7}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.FilterTypeNotSupportedError"
    });
  }
};

// node_modules/ox/_esm/core/AbiFunction.js
var AbiFunction_exports2 = {};
__export(AbiFunction_exports2, {
  decodeData: () => decodeData,
  decodeResult: () => decodeResult,
  encodeData: () => encodeData3,
  encodeResult: () => encodeResult,
  format: () => format7,
  from: () => from20,
  fromAbi: () => fromAbi6,
  getSelector: () => getSelector5
});
function decodeData(abiFunction, data) {
  const { overloads } = abiFunction;
  if (size7(data) < 4)
    throw new InvalidSelectorSizeError2({ data });
  if (abiFunction.inputs.length === 0)
    return void 0;
  const item = overloads ? fromAbi6([abiFunction, ...overloads], data) : abiFunction;
  if (size7(data) <= 4)
    return void 0;
  return decode3(item.inputs, slice6(data, 4));
}
function decodeResult(abiFunction, data, options = {}) {
  const values = decode3(abiFunction.outputs, data, options);
  if (values && Object.keys(values).length === 0)
    return void 0;
  if (values && Object.keys(values).length === 1) {
    if (Array.isArray(values))
      return values[0];
    return Object.values(values)[0];
  }
  return values;
}
function encodeData3(abiFunction, ...args) {
  const { overloads } = abiFunction;
  const item = overloads ? fromAbi6([abiFunction, ...overloads], abiFunction.name, {
    args: args[0]
  }) : abiFunction;
  const selector = getSelector5(item);
  const data = args.length > 0 ? encode8(item.inputs, args[0]) : void 0;
  return data ? concat7(selector, data) : selector;
}
function encodeResult(abiFunction, output2, options = {}) {
  const { as: as17 = "Array" } = options;
  const values = (() => {
    if (abiFunction.outputs.length === 1)
      return [output2];
    if (Array.isArray(output2))
      return output2;
    if (as17 === "Object")
      return Object.values(output2);
    return [output2];
  })();
  return encode8(abiFunction.outputs, values);
}
function format7(abiFunction) {
  return formatAbiItem3(abiFunction);
}
function from20(abiFunction, options = {}) {
  return from15(abiFunction, options);
}
function fromAbi6(abi3, name, options) {
  const item = fromAbi2(abi3, name, options);
  if (item.type !== "function")
    throw new NotFoundError2({ name, type: "function" });
  return item;
}
function getSelector5(abiItem) {
  return getSelector2(abiItem);
}

// node_modules/ox/_esm/core/AccessList.js
var AccessList_exports = {};
__export(AccessList_exports, {
  InvalidStorageKeySizeError: () => InvalidStorageKeySizeError2,
  fromTupleList: () => fromTupleList,
  toTupleList: () => toTupleList
});
function fromTupleList(accessList) {
  const list = [];
  for (let i9 = 0; i9 < accessList.length; i9++) {
    const [address, storageKeys] = accessList[i9];
    if (address)
      assert6(address, { strict: false });
    list.push({
      address,
      storageKeys: storageKeys.map((key) => validate7(key) ? key : trimLeft2(key))
    });
  }
  return list;
}
function toTupleList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const tuple3 = [];
  for (const { address, storageKeys } of accessList) {
    for (let j9 = 0; j9 < storageKeys.length; j9++)
      if (size7(storageKeys[j9]) !== 32)
        throw new InvalidStorageKeySizeError2({
          storageKey: storageKeys[j9]
        });
    if (address)
      assert6(address, { strict: false });
    tuple3.push([address, storageKeys]);
  }
  return tuple3;
}
var InvalidStorageKeySizeError2 = class extends BaseError6 {
  constructor({ storageKey }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${size7(storageKey)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccessList.InvalidStorageKeySizeError"
    });
  }
};

// node_modules/ox/_esm/core/AccountProof.js
var AccountProof_exports = {};

// node_modules/ox/_esm/core/AesGcm.js
var AesGcm_exports = {};
__export(AesGcm_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2,
  getKey: () => getKey,
  ivLength: () => ivLength,
  randomSalt: () => randomSalt
});
var ivLength = 16;
async function decrypt2(value2, key, options = {}) {
  const { as: as17 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const encrypted = from12(value2);
  const iv = encrypted.slice(0, ivLength);
  const data = encrypted.slice(ivLength);
  const decrypted = await globalThis.crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, key, from12(data));
  const result = new Uint8Array(decrypted);
  if (as17 === "Bytes")
    return result;
  return from11(result);
}
async function encrypt2(value2, key, options = {}) {
  const { as: as17 = typeof value2 === "string" ? "Hex" : "Bytes" } = options;
  const iv = random(ivLength);
  const encrypted = await globalThis.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, key, from12(value2));
  const result = concat8(iv, new Uint8Array(encrypted));
  if (as17 === "Bytes")
    return result;
  return from11(result);
}
async function getKey(options) {
  const { iterations = 9e5, password, salt = randomSalt(32) } = options;
  const baseKey = await globalThis.crypto.subtle.importKey("raw", fromString7(password), { name: "PBKDF2" }, false, ["deriveBits", "deriveKey"]);
  const key = await globalThis.crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt,
    iterations,
    hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
  return key;
}
function randomSalt(size11 = 32) {
  return random(size11);
}

// node_modules/ox/_esm/core/Authorization.js
var Authorization_exports = {};
__export(Authorization_exports, {
  from: () => from23,
  fromRpc: () => fromRpc7,
  fromRpcList: () => fromRpcList,
  fromTuple: () => fromTuple2,
  fromTupleList: () => fromTupleList2,
  getSignPayload: () => getSignPayload3,
  hash: () => hash2,
  toRpc: () => toRpc8,
  toRpcList: () => toRpcList,
  toTuple: () => toTuple2,
  toTupleList: () => toTupleList2
});

// node_modules/ox/_esm/core/Rlp.js
var Rlp_exports = {};
__export(Rlp_exports, {
  decodeRlpCursor: () => decodeRlpCursor,
  from: () => from21,
  fromBytes: () => fromBytes6,
  fromHex: () => fromHex9,
  readLength: () => readLength,
  readList: () => readList,
  to: () => to3,
  toBytes: () => toBytes7,
  toHex: () => toHex8
});
function toBytes7(value2) {
  return to3(value2, "Bytes");
}
function toHex8(value2) {
  return to3(value2, "Hex");
}
function to3(value2, to6) {
  const to_ = to6 ?? (typeof value2 === "string" ? "Hex" : "Bytes");
  const bytes2 = (() => {
    if (typeof value2 === "string") {
      if (value2.length > 3 && value2.length % 2 !== 0)
        throw new InvalidLengthError(value2);
      return fromHex7(value2);
    }
    return value2;
  })();
  const cursor = create2(bytes2, {
    recursiveReadLimit: Number.POSITIVE_INFINITY
  });
  const result = decodeRlpCursor(cursor, to_);
  return result;
}
function decodeRlpCursor(cursor, to6 = "Hex") {
  if (cursor.bytes.length === 0)
    return to6 === "Hex" ? fromBytes4(cursor.bytes) : cursor.bytes;
  const prefix = cursor.readByte();
  if (prefix < 128)
    cursor.decrementPosition(1);
  if (prefix < 192) {
    const length2 = readLength(cursor, prefix, 128);
    const bytes2 = cursor.readBytes(length2);
    return to6 === "Hex" ? fromBytes4(bytes2) : bytes2;
  }
  const length = readLength(cursor, prefix, 192);
  return readList(cursor, length, to6);
}
function readLength(cursor, prefix, offset) {
  if (offset === 128 && prefix < 128)
    return 1;
  if (prefix <= offset + 55)
    return prefix - offset;
  if (prefix === offset + 55 + 1)
    return cursor.readUint8();
  if (prefix === offset + 55 + 2)
    return cursor.readUint16();
  if (prefix === offset + 55 + 3)
    return cursor.readUint24();
  if (prefix === offset + 55 + 4)
    return cursor.readUint32();
  throw new BaseError6("Invalid RLP prefix");
}
function readList(cursor, length, to6) {
  const position = cursor.position;
  const value2 = [];
  while (cursor.position - position < length)
    value2.push(decodeRlpCursor(cursor, to6));
  return value2;
}
function from21(value2, options) {
  const { as: as17 } = options;
  const encodable = getEncodable(value2);
  const cursor = create2(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (as17 === "Hex")
    return fromBytes4(cursor.bytes);
  return cursor.bytes;
}
function fromBytes6(bytes2, options = {}) {
  const { as: as17 = "Bytes" } = options;
  return from21(bytes2, { as: as17 });
}
function fromHex9(hex2, options = {}) {
  const { as: as17 = "Hex" } = options;
  return from21(hex2, { as: as17 });
}
function getEncodable(bytes2) {
  if (Array.isArray(bytes2))
    return getEncodableList(bytes2.map((x7) => getEncodable(x7)));
  return getEncodableBytes(bytes2);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x7) => acc + x7.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode20 } of list) {
        encode20(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes2 = typeof bytesOrHex === "string" ? fromHex7(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes2.length);
  const length = (() => {
    if (bytes2.length === 1 && bytes2[0] < 128)
      return 1;
    if (bytes2.length <= 55)
      return 1 + bytes2.length;
    return 1 + sizeOfBytesLength + bytes2.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes2.length === 1 && bytes2[0] < 128) {
        cursor.pushBytes(bytes2);
      } else if (bytes2.length <= 55) {
        cursor.pushByte(128 + bytes2.length);
        cursor.pushBytes(bytes2);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes2.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes2.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes2.length);
        else
          cursor.pushUint32(bytes2.length);
        cursor.pushBytes(bytes2);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError6("Length is too large.");
}

// node_modules/ox/_esm/core/Signature.js
var Signature_exports2 = {};
__export(Signature_exports2, {
  InvalidRError: () => InvalidRError,
  InvalidSError: () => InvalidSError,
  InvalidSerializedSizeError: () => InvalidSerializedSizeError2,
  InvalidVError: () => InvalidVError,
  InvalidYParityError: () => InvalidYParityError,
  MissingPropertiesError: () => MissingPropertiesError,
  assert: () => assert7,
  extract: () => extract2,
  from: () => from22,
  fromBytes: () => fromBytes7,
  fromDerBytes: () => fromDerBytes,
  fromDerHex: () => fromDerHex,
  fromHex: () => fromHex10,
  fromLegacy: () => fromLegacy,
  fromRpc: () => fromRpc6,
  fromTuple: () => fromTuple,
  toBytes: () => toBytes8,
  toDerBytes: () => toDerBytes,
  toDerHex: () => toDerHex,
  toHex: () => toHex9,
  toLegacy: () => toLegacy,
  toRpc: () => toRpc7,
  toTuple: () => toTuple,
  vToYParity: () => vToYParity,
  validate: () => validate10,
  yParityToV: () => yParityToV
});
function assert7(signature, options = {}) {
  const { recovered } = options;
  if (typeof signature.r === "undefined")
    throw new MissingPropertiesError({ signature });
  if (typeof signature.s === "undefined")
    throw new MissingPropertiesError({ signature });
  if (recovered && typeof signature.yParity === "undefined")
    throw new MissingPropertiesError({ signature });
  if (signature.r < 0n || signature.r > maxUint2563)
    throw new InvalidRError({ value: signature.r });
  if (signature.s < 0n || signature.s > maxUint2563)
    throw new InvalidSError({ value: signature.s });
  if (typeof signature.yParity === "number" && signature.yParity !== 0 && signature.yParity !== 1)
    throw new InvalidYParityError({ value: signature.yParity });
}
function fromBytes7(signature) {
  return fromHex10(fromBytes4(signature));
}
function fromHex10(signature) {
  if (signature.length !== 130 && signature.length !== 132)
    throw new InvalidSerializedSizeError2({ signature });
  const r8 = BigInt(slice6(signature, 0, 32));
  const s5 = BigInt(slice6(signature, 32, 64));
  const yParity = (() => {
    const yParity2 = Number(`0x${signature.slice(130)}`);
    if (Number.isNaN(yParity2))
      return void 0;
    try {
      return vToYParity(yParity2);
    } catch {
      throw new InvalidYParityError({ value: yParity2 });
    }
  })();
  if (typeof yParity === "undefined")
    return {
      r: r8,
      s: s5
    };
  return {
    r: r8,
    s: s5,
    yParity
  };
}
function extract2(value2) {
  if (typeof value2.r === "undefined")
    return void 0;
  if (typeof value2.s === "undefined")
    return void 0;
  return from22(value2);
}
function from22(signature) {
  const signature_ = (() => {
    if (typeof signature === "string")
      return fromHex10(signature);
    if (signature instanceof Uint8Array)
      return fromBytes7(signature);
    if (typeof signature.r === "string")
      return fromRpc6(signature);
    if (signature.v)
      return fromLegacy(signature);
    return {
      r: signature.r,
      s: signature.s,
      ...typeof signature.yParity !== "undefined" ? { yParity: signature.yParity } : {}
    };
  })();
  assert7(signature_);
  return signature_;
}
function fromDerBytes(signature) {
  return fromDerHex(fromBytes4(signature));
}
function fromDerHex(signature) {
  const { r: r8, s: s5 } = secp256k1.Signature.fromDER(from11(signature).slice(2));
  return { r: r8, s: s5 };
}
function fromLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    yParity: vToYParity(signature.v)
  };
}
function fromRpc6(signature) {
  const yParity = (() => {
    const v9 = signature.v ? Number(signature.v) : void 0;
    let yParity2 = signature.yParity ? Number(signature.yParity) : void 0;
    if (typeof v9 === "number" && typeof yParity2 !== "number")
      yParity2 = vToYParity(v9);
    if (typeof yParity2 !== "number")
      throw new InvalidYParityError({ value: signature.yParity });
    return yParity2;
  })();
  return {
    r: BigInt(signature.r),
    s: BigInt(signature.s),
    yParity
  };
}
function fromTuple(tuple3) {
  const [yParity, r8, s5] = tuple3;
  return from22({
    r: r8 === "0x" ? 0n : BigInt(r8),
    s: s5 === "0x" ? 0n : BigInt(s5),
    yParity: yParity === "0x" ? 0 : Number(yParity)
  });
}
function toBytes8(signature) {
  return fromHex7(toHex9(signature));
}
function toHex9(signature) {
  assert7(signature);
  const r8 = signature.r;
  const s5 = signature.s;
  const signature_ = concat7(
    fromNumber3(r8, { size: 32 }),
    fromNumber3(s5, { size: 32 }),
    // If the signature is recovered, add the recovery byte to the signature.
    typeof signature.yParity === "number" ? fromNumber3(yParityToV(signature.yParity), { size: 1 }) : "0x"
  );
  return signature_;
}
function toDerBytes(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return sig.toDERRawBytes();
}
function toDerHex(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return `0x${sig.toDERHex()}`;
}
function toLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    v: yParityToV(signature.yParity)
  };
}
function toRpc7(signature) {
  const { r: r8, s: s5, yParity } = signature;
  return {
    r: fromNumber3(r8, { size: 32 }),
    s: fromNumber3(s5, { size: 32 }),
    yParity: yParity === 0 ? "0x0" : "0x1"
  };
}
function toTuple(signature) {
  const { r: r8, s: s5, yParity } = signature;
  return [
    yParity ? "0x01" : "0x",
    r8 === 0n ? "0x" : trimLeft2(fromNumber3(r8)),
    s5 === 0n ? "0x" : trimLeft2(fromNumber3(s5))
  ];
}
function validate10(signature, options = {}) {
  try {
    assert7(signature, options);
    return true;
  } catch {
    return false;
  }
}
function vToYParity(v9) {
  if (v9 === 0 || v9 === 27)
    return 0;
  if (v9 === 1 || v9 === 28)
    return 1;
  if (v9 >= 35)
    return v9 % 2 === 0 ? 1 : 0;
  throw new InvalidVError({ value: v9 });
}
function yParityToV(yParity) {
  if (yParity === 0)
    return 27;
  if (yParity === 1)
    return 28;
  throw new InvalidYParityError({ value: yParity });
}
var InvalidSerializedSizeError2 = class extends BaseError6 {
  constructor({ signature }) {
    super(`Value \`${signature}\` is an invalid signature size.`, {
      metaMessages: [
        "Expected: 64 bytes or 65 bytes.",
        `Received ${size7(from11(signature))} bytes.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSerializedSizeError"
    });
  }
};
var MissingPropertiesError = class extends BaseError6 {
  constructor({ signature }) {
    super(`Signature \`${stringify6(signature)}\` is missing either an \`r\`, \`s\`, or \`yParity\` property.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.MissingPropertiesError"
    });
  }
};
var InvalidRError = class extends BaseError6 {
  constructor({ value: value2 }) {
    super(`Value \`${value2}\` is an invalid r value. r must be a positive integer less than 2^256.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidRError"
    });
  }
};
var InvalidSError = class extends BaseError6 {
  constructor({ value: value2 }) {
    super(`Value \`${value2}\` is an invalid s value. s must be a positive integer less than 2^256.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSError"
    });
  }
};
var InvalidYParityError = class extends BaseError6 {
  constructor({ value: value2 }) {
    super(`Value \`${value2}\` is an invalid y-parity value. Y-parity must be 0 or 1.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidYParityError"
    });
  }
};
var InvalidVError = class extends BaseError6 {
  constructor({ value: value2 }) {
    super(`Value \`${value2}\` is an invalid v value. v must be 27, 28 or >=35.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidVError"
    });
  }
};

// node_modules/ox/_esm/core/Authorization.js
function from23(authorization, options = {}) {
  if (typeof authorization.chainId === "string")
    return fromRpc7(authorization);
  return { ...authorization, ...options.signature };
}
function fromRpc7(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract2(authorization);
  return {
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  };
}
function fromRpcList(authorizationList) {
  return authorizationList.map(fromRpc7);
}
function fromTuple2(tuple3) {
  const [chainId, address, nonce, yParity, r8, s5] = tuple3;
  const signature = yParity && r8 && s5 ? fromTuple([yParity, r8, s5]) : void 0;
  return from23({
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  });
}
function fromTupleList2(tupleList) {
  const list = [];
  for (const tuple3 of tupleList)
    list.push(fromTuple2(tuple3));
  return list;
}
function getSignPayload3(authorization) {
  return hash2(authorization);
}
function hash2(authorization) {
  return keccak2565(concat7("0x05", fromHex9(toTuple2(authorization))));
}
function toRpc8(authorization) {
  const { address, chainId, nonce, ...signature } = authorization;
  return {
    address,
    chainId: fromNumber3(chainId),
    nonce: fromNumber3(nonce),
    ...toRpc7(signature)
  };
}
function toRpcList(authorizationList) {
  return authorizationList.map(toRpc8);
}
function toTuple2(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract2(authorization);
  return [
    chainId ? fromNumber3(chainId) : "0x",
    address,
    nonce ? fromNumber3(nonce) : "0x",
    ...signature ? toTuple(signature) : []
  ];
}
function toTupleList2(list) {
  if (!list || list.length === 0)
    return [];
  const tupleList = [];
  for (const authorization of list)
    tupleList.push(toTuple2(authorization));
  return tupleList;
}

// node_modules/ox/_esm/core/Base58.js
var Base58_exports = {};
__export(Base58_exports, {
  fromBytes: () => fromBytes8,
  fromHex: () => fromHex11,
  fromString: () => fromString8,
  toBytes: () => toBytes9,
  toHex: () => toHex10,
  toString: () => toString6
});

// node_modules/ox/_esm/core/internal/base58.js
var integerToAlphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var alphabetToInteger = (
  /* __PURE__ */
  Object.freeze({
    1: 0n,
    2: 1n,
    3: 2n,
    4: 3n,
    5: 4n,
    6: 5n,
    7: 6n,
    8: 7n,
    9: 8n,
    A: 9n,
    B: 10n,
    C: 11n,
    D: 12n,
    E: 13n,
    F: 14n,
    G: 15n,
    H: 16n,
    J: 17n,
    K: 18n,
    L: 19n,
    M: 20n,
    N: 21n,
    P: 22n,
    Q: 23n,
    R: 24n,
    S: 25n,
    T: 26n,
    U: 27n,
    V: 28n,
    W: 29n,
    X: 30n,
    Y: 31n,
    Z: 32n,
    a: 33n,
    b: 34n,
    c: 35n,
    d: 36n,
    e: 37n,
    f: 38n,
    g: 39n,
    h: 40n,
    i: 41n,
    j: 42n,
    k: 43n,
    m: 44n,
    n: 45n,
    o: 46n,
    p: 47n,
    q: 48n,
    r: 49n,
    s: 50n,
    t: 51n,
    u: 52n,
    v: 53n,
    w: 54n,
    x: 55n,
    y: 56n,
    z: 57n
  })
);
function from24(value2) {
  let bytes2 = from12(value2);
  let integer = (() => {
    let hex2 = value2;
    if (value2 instanceof Uint8Array)
      hex2 = fromBytes4(bytes2);
    return BigInt(hex2);
  })();
  let result = "";
  while (integer > 0n) {
    const remainder = Number(integer % 58n);
    integer = integer / 58n;
    result = integerToAlphabet[remainder] + result;
  }
  while (bytes2.length > 1 && bytes2[0] === 0) {
    result = "1" + result;
    bytes2 = bytes2.slice(1);
  }
  return result;
}

// node_modules/ox/_esm/core/Base58.js
function fromBytes8(value2) {
  return from24(value2);
}
function fromHex11(value2) {
  return from24(value2);
}
function fromString8(value2) {
  return from24(fromString7(value2));
}
function toBytes9(value2) {
  return fromHex7(toHex10(value2));
}
function toHex10(value2) {
  let integer = BigInt(0);
  let pad5 = 0;
  let checkPad = true;
  for (let i9 = 0; i9 < value2.length; i9++) {
    const char = value2[i9];
    if (checkPad && char === "1")
      pad5++;
    else
      checkPad = false;
    if (typeof alphabetToInteger[char] !== "bigint")
      throw new Error("invalid base58 character: " + char);
    integer = integer * 58n;
    integer = integer + alphabetToInteger[char];
  }
  if (!pad5)
    return `0x${integer.toString(16)}`;
  return `0x${"0".repeat(pad5 * 2)}${integer.toString(16)}`;
}
function toString6(value2) {
  return toString4(toHex10(value2));
}

// node_modules/ox/_esm/core/Base64.js
var Base64_exports2 = {};
__export(Base64_exports2, {
  fromBytes: () => fromBytes9,
  fromHex: () => fromHex12,
  fromString: () => fromString9,
  toBytes: () => toBytes10,
  toHex: () => toHex11,
  toString: () => toString7
});
var encoder4 = new TextEncoder();
var decoder3 = new TextDecoder();
var integerToCharacter2 = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a6, i9) => [i9, a6.charCodeAt(0)]));
var characterToInteger2 = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a6, i9) => [a6.charCodeAt(0), i9])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};
function fromBytes9(value2, options = {}) {
  const { pad: pad5 = true, url: url2 = false } = options;
  const encoded = new Uint8Array(Math.ceil(value2.length / 3) * 4);
  for (let i9 = 0, j9 = 0; j9 < value2.length; i9 += 4, j9 += 3) {
    const y11 = (value2[j9] << 16) + (value2[j9 + 1] << 8) + (value2[j9 + 2] | 0);
    encoded[i9] = integerToCharacter2[y11 >> 18];
    encoded[i9 + 1] = integerToCharacter2[y11 >> 12 & 63];
    encoded[i9 + 2] = integerToCharacter2[y11 >> 6 & 63];
    encoded[i9 + 3] = integerToCharacter2[y11 & 63];
  }
  const k11 = value2.length % 3;
  const end = Math.floor(value2.length / 3) * 4 + (k11 && k11 + 1);
  let base642 = decoder3.decode(new Uint8Array(encoded.buffer, 0, end));
  if (pad5 && k11 === 1)
    base642 += "==";
  if (pad5 && k11 === 2)
    base642 += "=";
  if (url2)
    base642 = base642.replaceAll("+", "-").replaceAll("/", "_");
  return base642;
}
function fromHex12(value2, options = {}) {
  return fromBytes9(fromHex7(value2), options);
}
function fromString9(value2, options = {}) {
  return fromBytes9(fromString7(value2), options);
}
function toBytes10(value2) {
  const base642 = value2.replace(/=+$/, "");
  const size11 = base642.length;
  const decoded = new Uint8Array(size11 + 3);
  encoder4.encodeInto(base642 + "===", decoded);
  for (let i9 = 0, j9 = 0; i9 < base642.length; i9 += 4, j9 += 3) {
    const x7 = (characterToInteger2[decoded[i9]] << 18) + (characterToInteger2[decoded[i9 + 1]] << 12) + (characterToInteger2[decoded[i9 + 2]] << 6) + characterToInteger2[decoded[i9 + 3]];
    decoded[j9] = x7 >> 16;
    decoded[j9 + 1] = x7 >> 8 & 255;
    decoded[j9 + 2] = x7 & 255;
  }
  const decodedSize = (size11 >> 2) * 3 + (size11 % 4 && size11 % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}
function toHex11(value2) {
  return fromBytes4(toBytes10(value2));
}
function toString7(value2) {
  return toString5(toBytes10(value2));
}

// node_modules/ox/_esm/core/BinaryStateTree.js
var BinaryStateTree_exports = {};
__export(BinaryStateTree_exports, {
  create: () => create3,
  insert: () => insert,
  merkelize: () => merkelize
});

// node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
function G1s(a6, b6, c9, d7, x7) {
  a6 = a6 + b6 + x7 | 0;
  d7 = rotr(d7 ^ a6, 16);
  c9 = c9 + d7 | 0;
  b6 = rotr(b6 ^ c9, 12);
  return { a: a6, b: b6, c: c9, d: d7 };
}
function G2s(a6, b6, c9, d7, x7) {
  a6 = a6 + b6 + x7 | 0;
  d7 = rotr(d7 ^ a6, 8);
  c9 = c9 + d7 | 0;
  b6 = rotr(b6 ^ c9, 7);
  return { a: a6, b: b6, c: c9, d: d7 };
}

// node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a6, b6, c9, d7, msg, x7) {
  const Xl2 = msg[x7], Xh2 = msg[x7 + 1];
  let Al2 = BBUF[2 * a6], Ah2 = BBUF[2 * a6 + 1];
  let Bl2 = BBUF[2 * b6], Bh2 = BBUF[2 * b6 + 1];
  let Cl2 = BBUF[2 * c9], Ch2 = BBUF[2 * c9 + 1];
  let Dl2 = BBUF[2 * d7], Dh2 = BBUF[2 * d7 + 1];
  let ll2 = add3L(Al2, Bl2, Xl2);
  Ah2 = add3H(ll2, Ah2, Bh2, Xh2);
  Al2 = ll2 | 0;
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: Dh2 ^ Ah2, Dl: Dl2 ^ Al2 });
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: rotr32H(Dh2, Dl2), Dl: rotr32L(Dh2, Dl2) });
  ({ h: Ch2, l: Cl2 } = add(Ch2, Cl2, Dh2, Dl2));
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: Bh2 ^ Ch2, Bl: Bl2 ^ Cl2 });
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: rotrSH(Bh2, Bl2, 24), Bl: rotrSL(Bh2, Bl2, 24) });
  BBUF[2 * a6] = Al2, BBUF[2 * a6 + 1] = Ah2;
  BBUF[2 * b6] = Bl2, BBUF[2 * b6 + 1] = Bh2;
  BBUF[2 * c9] = Cl2, BBUF[2 * c9 + 1] = Ch2;
  BBUF[2 * d7] = Dl2, BBUF[2 * d7 + 1] = Dh2;
}
function G2b(a6, b6, c9, d7, msg, x7) {
  const Xl2 = msg[x7], Xh2 = msg[x7 + 1];
  let Al2 = BBUF[2 * a6], Ah2 = BBUF[2 * a6 + 1];
  let Bl2 = BBUF[2 * b6], Bh2 = BBUF[2 * b6 + 1];
  let Cl2 = BBUF[2 * c9], Ch2 = BBUF[2 * c9 + 1];
  let Dl2 = BBUF[2 * d7], Dh2 = BBUF[2 * d7 + 1];
  let ll2 = add3L(Al2, Bl2, Xl2);
  Ah2 = add3H(ll2, Ah2, Bh2, Xh2);
  Al2 = ll2 | 0;
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: Dh2 ^ Ah2, Dl: Dl2 ^ Al2 });
  ({ Dh: Dh2, Dl: Dl2 } = { Dh: rotrSH(Dh2, Dl2, 16), Dl: rotrSL(Dh2, Dl2, 16) });
  ({ h: Ch2, l: Cl2 } = add(Ch2, Cl2, Dh2, Dl2));
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: Bh2 ^ Ch2, Bl: Bl2 ^ Cl2 });
  ({ Bh: Bh2, Bl: Bl2 } = { Bh: rotrBH(Bh2, Bl2, 63), Bl: rotrBL(Bh2, Bl2, 63) });
  BBUF[2 * a6] = Al2, BBUF[2 * a6 + 1] = Ah2;
  BBUF[2 * b6] = Bl2, BBUF[2 * b6 + 1] = Bh2;
  BBUF[2 * c9] = Cl2, BBUF[2 * c9 + 1] = Ch2;
  BBUF[2 * d7] = Dl2, BBUF[2 * d7 + 1] = Dh2;
}
function checkBlake2Opts(outputLen, opts2 = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts2;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes2(data);
    abytes(data);
    const { blockLen, buffer: buffer2, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v9, i9) => out32[i9] = swap8IfBE(v9));
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to6) {
    const { buffer: buffer2, length, finished, destroyed, outputLen, pos } = this;
    to6 || (to6 = new this.constructor({ dkLen: outputLen }));
    to6.set(...this.get());
    to6.buffer.set(buffer2);
    to6.destroyed = destroyed;
    to6.finished = finished;
    to6.length = length;
    to6.pos = pos;
    to6.outputLen = outputLen;
    return to6;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts2 = {}) {
    const olen = opts2.dkLen === void 0 ? 64 : opts2.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts2, 64, 16, 16);
    let { key, personalization, salt } = opts2;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes2(key);
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes2(salt);
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes2(personalization);
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v9, i9) => BBUF[i9] = v9);
    BBUF.set(B2B_IV, 16);
    let { h: h9, l: l9 } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l9;
    BBUF[25] = B2B_IV[9] ^ h9;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j9 = 0;
    const s5 = BSIGMA;
    for (let i9 = 0; i9 < 12; i9++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s5[j9++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s5[j9++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s5[j9++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s5[j9++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s5[j9++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s5[j9++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s5[j9++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s5[j9++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s5[j9++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s5[j9++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s5[j9++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s5[j9++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s5[j9++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s5[j9++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s5[j9++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s5[j9++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = createOptHasher((opts2) => new BLAKE2b(opts2));
function compress2(s5, offset, msg, rounds, v0, v1, v22, v34, v44, v54, v62, v72, v82, v9, v10, v11, v12, v13, v14, v15) {
  let j9 = 0;
  for (let i9 = 0; i9 < rounds; i9++) {
    ({ a: v0, b: v44, c: v82, d: v12 } = G1s(v0, v44, v82, v12, msg[offset + s5[j9++]]));
    ({ a: v0, b: v44, c: v82, d: v12 } = G2s(v0, v44, v82, v12, msg[offset + s5[j9++]]));
    ({ a: v1, b: v54, c: v9, d: v13 } = G1s(v1, v54, v9, v13, msg[offset + s5[j9++]]));
    ({ a: v1, b: v54, c: v9, d: v13 } = G2s(v1, v54, v9, v13, msg[offset + s5[j9++]]));
    ({ a: v22, b: v62, c: v10, d: v14 } = G1s(v22, v62, v10, v14, msg[offset + s5[j9++]]));
    ({ a: v22, b: v62, c: v10, d: v14 } = G2s(v22, v62, v10, v14, msg[offset + s5[j9++]]));
    ({ a: v34, b: v72, c: v11, d: v15 } = G1s(v34, v72, v11, v15, msg[offset + s5[j9++]]));
    ({ a: v34, b: v72, c: v11, d: v15 } = G2s(v34, v72, v11, v15, msg[offset + s5[j9++]]));
    ({ a: v0, b: v54, c: v10, d: v15 } = G1s(v0, v54, v10, v15, msg[offset + s5[j9++]]));
    ({ a: v0, b: v54, c: v10, d: v15 } = G2s(v0, v54, v10, v15, msg[offset + s5[j9++]]));
    ({ a: v1, b: v62, c: v11, d: v12 } = G1s(v1, v62, v11, v12, msg[offset + s5[j9++]]));
    ({ a: v1, b: v62, c: v11, d: v12 } = G2s(v1, v62, v11, v12, msg[offset + s5[j9++]]));
    ({ a: v22, b: v72, c: v82, d: v13 } = G1s(v22, v72, v82, v13, msg[offset + s5[j9++]]));
    ({ a: v22, b: v72, c: v82, d: v13 } = G2s(v22, v72, v82, v13, msg[offset + s5[j9++]]));
    ({ a: v34, b: v44, c: v9, d: v14 } = G1s(v34, v44, v9, v14, msg[offset + s5[j9++]]));
    ({ a: v34, b: v44, c: v9, d: v14 } = G2s(v34, v44, v9, v14, msg[offset + s5[j9++]]));
  }
  return { v0, v1, v2: v22, v3: v34, v4: v44, v5: v54, v6: v62, v7: v72, v8: v82, v9, v10, v11, v12, v13, v14, v15 };
}
var B2S_IV = SHA256_IV;
var BLAKE2s = class extends BLAKE2 {
  constructor(opts2 = {}) {
    const olen = opts2.dkLen === void 0 ? 32 : opts2.dkLen;
    super(64, olen);
    this.v0 = B2S_IV[0] | 0;
    this.v1 = B2S_IV[1] | 0;
    this.v2 = B2S_IV[2] | 0;
    this.v3 = B2S_IV[3] | 0;
    this.v4 = B2S_IV[4] | 0;
    this.v5 = B2S_IV[5] | 0;
    this.v6 = B2S_IV[6] | 0;
    this.v7 = B2S_IV[7] | 0;
    checkBlake2Opts(olen, opts2, 32, 8, 8);
    let { key, personalization, salt } = opts2;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes2(key);
      keyLength = key.length;
    }
    this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes2(salt);
      const slt = u32(salt);
      this.v4 ^= swap8IfBE(slt[0]);
      this.v5 ^= swap8IfBE(slt[1]);
    }
    if (personalization !== void 0) {
      personalization = toBytes2(personalization);
      const pers = u32(personalization);
      this.v6 ^= swap8IfBE(pers[0]);
      this.v7 ^= swap8IfBE(pers[1]);
    }
    if (key !== void 0) {
      abytes(key);
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  get() {
    const { v0, v1, v2: v22, v3: v34, v4: v44, v5: v54, v6: v62, v7: v72 } = this;
    return [v0, v1, v22, v34, v44, v54, v62, v72];
  }
  // prettier-ignore
  set(v0, v1, v22, v34, v44, v54, v62, v72) {
    this.v0 = v0 | 0;
    this.v1 = v1 | 0;
    this.v2 = v22 | 0;
    this.v3 = v34 | 0;
    this.v4 = v44 | 0;
    this.v5 = v54 | 0;
    this.v6 = v62 | 0;
    this.v7 = v72 | 0;
  }
  compress(msg, offset, isLast) {
    const { h: h9, l: l9 } = fromBig(BigInt(this.length));
    const { v0, v1, v2: v22, v3: v34, v4: v44, v5: v54, v6: v62, v7: v72, v8: v82, v9, v10, v11, v12, v13, v14, v15 } = compress2(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l9 ^ B2S_IV[4], h9 ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
    this.v0 ^= v0 ^ v82;
    this.v1 ^= v1 ^ v9;
    this.v2 ^= v22 ^ v10;
    this.v3 ^= v34 ^ v11;
    this.v4 ^= v44 ^ v12;
    this.v5 ^= v54 ^ v13;
    this.v6 ^= v62 ^ v14;
    this.v7 ^= v72 ^ v15;
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2s = createOptHasher((opts2) => new BLAKE2s(opts2));

// node_modules/@noble/hashes/esm/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = SHA256_IV.slice();
var B3_SIGMA = (() => {
  const Id2 = Array.from({ length: 16 }, (_6, i9) => i9);
  const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i9) => arr[i9]);
  const res = [];
  for (let i9 = 0, v9 = Id2; i9 < 7; i9++, v9 = permute(v9))
    res.push(...v9);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE2 {
  constructor(opts2 = {}, flags = 0) {
    super(64, opts2.dkLen === void 0 ? 32 : opts2.dkLen);
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.flags = 0 | 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    const { key, context } = opts2;
    const hasContext = context !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      const k11 = toBytes2(key).slice();
      abytes(k11, 32);
      this.IV = u32(k11);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      const ctx = toBytes2(context);
      const contextKey = new _BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u32(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u8(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter, flags, buf, bufPos = 0) {
    const { state: s5, pos } = this;
    const { h: h9, l: l9 } = fromBig(BigInt(counter), true);
    const { v0, v1, v2: v22, v3: v34, v4: v44, v5: v54, v6: v62, v7: v72, v8: v82, v9, v10, v11, v12, v13, v14, v15 } = compress2(B3_SIGMA, bufPos, buf, 7, s5[0], s5[1], s5[2], s5[3], s5[4], s5[5], s5[6], s5[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h9, l9, pos, flags);
    s5[0] = v0 ^ v82;
    s5[1] = v1 ^ v9;
    s5[2] = v22 ^ v10;
    s5[3] = v34 ^ v11;
    s5[4] = v44 ^ v12;
    s5[5] = v54 ^ v13;
    s5[6] = v62 ^ v14;
    s5[7] = v72 ^ v15;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last5, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last5 = this.stack.pop()))
          break;
        this.buffer32.set(last5, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to6) {
    to6 = super._cloneInto(to6);
    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to6.state.set(state.slice());
    to6.stack = stack.map((i9) => Uint32Array.from(i9));
    to6.IV.set(IV);
    to6.flags = flags;
    to6.chunkPos = chunkPos;
    to6.chunksDone = chunksDone;
    to6.posOut = posOut;
    to6.chunkOut = chunkOut;
    to6.enableXOF = this.enableXOF;
    to6.bufferOut32.set(this.bufferOut32);
    return to6;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s5, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h: h9, l: l9 } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2: v22, v3: v34, v4: v44, v5: v54, v6: v62, v7: v72, v8: v82, v9, v10, v11, v12, v13, v14, v15 } = compress2(B3_SIGMA, 0, buffer32, 7, s5[0], s5[1], s5[2], s5[3], s5[4], s5[5], s5[6], s5[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l9, h9, pos, flags);
    out32[0] = v0 ^ v82;
    out32[1] = v1 ^ v9;
    out32[2] = v22 ^ v10;
    out32[3] = v34 ^ v11;
    out32[4] = v44 ^ v12;
    out32[5] = v54 ^ v13;
    out32[6] = v62 ^ v14;
    out32[7] = v72 ^ v15;
    out32[8] = s5[0] ^ v82;
    out32[9] = s5[1] ^ v9;
    out32[10] = s5[2] ^ v10;
    out32[11] = s5[3] ^ v11;
    out32[12] = s5[4] ^ v12;
    out32[13] = s5[5] ^ v13;
    out32[14] = s5[6] ^ v14;
    out32[15] = s5[7] ^ v15;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = createXOFer((opts2) => new BLAKE3(opts2));

// node_modules/ox/_esm/core/BinaryStateTree.js
function create3() {
  return {
    root: emptyNode()
  };
}
function insert(tree, key, value2) {
  const stem = slice7(key, 0, 31);
  const subIndex = slice7(key, 31)[0];
  if (tree.root.type === "empty") {
    tree.root = stemNode(stem);
    tree.root.values[subIndex] = value2;
    return;
  }
  function inner(node_, stem2, subIndex2, value3, depth) {
    let node = node_;
    if (node.type === "empty") {
      node = stemNode(stem2);
      node.values[subIndex2] = value3;
      return node;
    }
    const stemBits = bytesToBits(stem2);
    if (node.type === "stem") {
      if (isEqual2(node.stem, stem2)) {
        node.values[subIndex2] = value3;
        return node;
      }
      const existingStemBits = bytesToBits(node.stem);
      return splitLeaf(node, stemBits, existingStemBits, subIndex2, value3, depth);
    }
    if (node.type === "internal") {
      const bit = stemBits[depth];
      if (bit === 0) {
        node.left = inner(node.left, stem2, subIndex2, value3, depth + 1);
      } else {
        node.right = inner(node.right, stem2, subIndex2, value3, depth + 1);
      }
      return node;
    }
    return emptyNode();
  }
  tree.root = inner(tree.root, stem, subIndex, value2, 0);
}
function merkelize(tree) {
  function inner(node) {
    if (node.type === "empty")
      return new Uint8Array(32).fill(0);
    if (node.type === "internal") {
      const hash_left = inner(node.left);
      const hash_right = inner(node.right);
      return hash3(concat8(hash_left, hash_right));
    }
    let level = node.values.map(hash3);
    while (level.length > 1) {
      const level_ = [];
      for (let i9 = 0; i9 < level.length; i9 += 2)
        level_.push(hash3(concat8(level[i9], level[i9 + 1])));
      level = level_;
    }
    return hash3(concat8(node.stem, new Uint8Array(1).fill(0), level[0]));
  }
  return inner(tree.root);
}
function splitLeaf(leaf, stemBits, existingStemBits, subIndex, value2, depth) {
  if (stemBits[depth] === existingStemBits[depth]) {
    const internal2 = internalNode();
    const bit2 = stemBits[depth];
    if (bit2 === 0) {
      internal2.left = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value2, depth + 1);
    } else {
      internal2.right = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value2, depth + 1);
    }
    return internal2;
  }
  const internal = internalNode();
  const bit = stemBits[depth];
  const stem = bitsToBytes(stemBits);
  if (bit === 0) {
    internal.left = stemNode(stem);
    internal.left.values[subIndex] = value2;
    internal.right = leaf;
  } else {
    internal.right = stemNode(stem);
    internal.right.values[subIndex] = value2;
    internal.left = leaf;
  }
  return internal;
}
function emptyNode() {
  return {
    type: "empty"
  };
}
function internalNode() {
  return {
    left: emptyNode(),
    right: emptyNode(),
    type: "internal"
  };
}
function stemNode(stem) {
  return {
    stem,
    values: Array.from({ length: 256 }, () => void 0),
    type: "stem"
  };
}
function bytesToBits(bytes2) {
  const bits = [];
  for (const byte of bytes2)
    for (let i9 = 0; i9 < 8; i9++)
      bits.push(byte >> 7 - i9 & 1);
  return bits;
}
function bitsToBytes(bits) {
  const byte_data = new Uint8Array(bits.length / 8);
  for (let i9 = 0; i9 < bits.length; i9 += 8) {
    let byte = 0;
    for (let j9 = 0; j9 < 8; j9++)
      byte |= bits[i9 + j9] << 7 - j9;
    byte_data[i9 / 8] = byte;
  }
  return byte_data;
}
function hash3(bytes2) {
  if (!bytes2)
    return new Uint8Array(32).fill(0);
  if (!bytes2.some((byte) => byte !== 0))
    return new Uint8Array(32).fill(0);
  return blake3(bytes2);
}

// node_modules/ox/_esm/core/Blobs.js
var Blobs_exports = {};
__export(Blobs_exports, {
  BlobSizeTooLargeError: () => BlobSizeTooLargeError2,
  EmptyBlobError: () => EmptyBlobError2,
  EmptyBlobVersionedHashesError: () => EmptyBlobVersionedHashesError,
  InvalidVersionedHashSizeError: () => InvalidVersionedHashSizeError2,
  InvalidVersionedHashVersionError: () => InvalidVersionedHashVersionError2,
  bytesPerBlob: () => bytesPerBlob2,
  bytesPerFieldElement: () => bytesPerFieldElement2,
  commitmentToVersionedHash: () => commitmentToVersionedHash2,
  commitmentsToVersionedHashes: () => commitmentsToVersionedHashes2,
  fieldElementsPerBlob: () => fieldElementsPerBlob2,
  from: () => from26,
  maxBytesPerTransaction: () => maxBytesPerTransaction2,
  sidecarsToVersionedHashes: () => sidecarsToVersionedHashes2,
  to: () => to4,
  toBytes: () => toBytes11,
  toCommitments: () => toCommitments,
  toHex: () => toHex12,
  toProofs: () => toProofs,
  toSidecars: () => toSidecars,
  toVersionedHashes: () => toVersionedHashes
});

// node_modules/ox/_esm/core/Kzg.js
var Kzg_exports = {};
__export(Kzg_exports, {
  from: () => from25,
  versionedHashVersion: () => versionedHashVersion
});
var versionedHashVersion = 1;
function from25(value2) {
  const { blobToKzgCommitment, computeBlobKzgProof } = value2;
  return {
    blobToKzgCommitment,
    computeBlobKzgProof
  };
}

// node_modules/ox/_esm/core/Blobs.js
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob2 * blobsPerTransaction2;
function commitmentsToVersionedHashes2(commitments, options = {}) {
  const { version: version11 } = options;
  const as17 = options.as ?? (typeof commitments[0] === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash2(commitment, {
      as: as17,
      version: version11
    }));
  }
  return hashes;
}
function commitmentToVersionedHash2(commitment, options = {}) {
  const { version: version11 = 1 } = options;
  const as17 = options.as ?? (typeof commitment === "string" ? "Hex" : "Bytes");
  const versionedHash = sha2565(commitment, { as: "Bytes" });
  versionedHash.set([version11], 0);
  return as17 === "Bytes" ? versionedHash : fromBytes4(versionedHash);
}
function from26(data, options = {}) {
  const as17 = options.as ?? (typeof data === "string" ? "Hex" : "Bytes");
  const data_ = typeof data === "string" ? fromHex7(data) : data;
  const size_ = size6(data_);
  if (!size_)
    throw new EmptyBlobError2();
  if (size_ > maxBytesPerTransaction2)
    throw new BlobSizeTooLargeError2({
      maxSize: maxBytesPerTransaction2,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = create2(new Uint8Array(bytesPerBlob2));
    let size11 = 0;
    while (size11 < fieldElementsPerBlob2) {
      const bytes2 = data_.slice(position, position + (bytesPerFieldElement2 - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes2);
      if (bytes2.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size11++;
      position += 31;
    }
    blobs.push(blob);
  }
  return as17 === "Bytes" ? blobs.map((x7) => x7.bytes) : blobs.map((x7) => fromBytes4(x7.bytes));
}
function sidecarsToVersionedHashes2(sidecars, options = {}) {
  const { version: version11 } = options;
  const as17 = options.as ?? (typeof sidecars[0].blob === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const { commitment } of sidecars) {
    hashes.push(commitmentToVersionedHash2(commitment, {
      as: as17,
      version: version11
    }));
  }
  return hashes;
}
function to4(blobs, to6) {
  const to_ = to6 ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x7) => fromHex7(x7)) : blobs;
  const length = blobs_.reduce((length2, blob) => length2 + blob.length, 0);
  const data = create2(new Uint8Array(length));
  let active = true;
  for (const blob of blobs_) {
    const cursor = create2(blob);
    while (active && cursor.position < blob.length) {
      cursor.incrementPosition(1);
      let consume = 31;
      if (blob.length - cursor.position < 31)
        consume = blob.length - cursor.position;
      for (const _6 in Array.from({ length: consume })) {
        const byte = cursor.readByte();
        const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
        if (isTerminator) {
          active = false;
          break;
        }
        data.pushByte(byte);
      }
    }
  }
  const trimmedData = data.bytes.slice(0, data.position);
  return to_ === "Hex" ? fromBytes4(trimmedData) : trimmedData;
}
function toHex12(blobs) {
  return to4(blobs, "Hex");
}
function toBytes11(blobs) {
  return to4(blobs, "Bytes");
}
function toCommitments(blobs, options) {
  const { kzg } = options;
  const as17 = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x7) => fromHex7(x7)) : blobs;
  const commitments = [];
  for (const blob of blobs_)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return as17 === "Bytes" ? commitments : commitments.map((x7) => fromBytes4(x7));
}
function toProofs(blobs, options) {
  const { kzg } = options;
  const as17 = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x7) => fromHex7(x7)) : blobs;
  const commitments = typeof options.commitments[0] === "string" ? options.commitments.map((x7) => fromHex7(x7)) : options.commitments;
  const proofs = [];
  for (let i9 = 0; i9 < blobs_.length; i9++) {
    const blob = blobs_[i9];
    const commitment = commitments[i9];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return as17 === "Bytes" ? proofs : proofs.map((x7) => fromBytes4(x7));
}
function toSidecars(blobs, options) {
  const { kzg } = options;
  const commitments = options.commitments ?? toCommitments(blobs, { kzg });
  const proofs = options.proofs ?? toProofs(blobs, { commitments, kzg });
  const sidecars = [];
  for (let i9 = 0; i9 < blobs.length; i9++)
    sidecars.push({
      blob: blobs[i9],
      commitment: commitments[i9],
      proof: proofs[i9]
    });
  return sidecars;
}
function toVersionedHashes(blobs, options) {
  const commitments = toCommitments(blobs, options);
  return commitmentsToVersionedHashes2(commitments, options);
}
var BlobSizeTooLargeError2 = class extends BaseError6 {
  constructor({ maxSize, size: size11 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size11} bytes`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError2 = class extends BaseError6 {
  constructor() {
    super("Blob data must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobError"
    });
  }
};
var EmptyBlobVersionedHashesError = class extends BaseError6 {
  constructor() {
    super("Blob versioned hashes must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobVersionedHashesError"
    });
  }
};
var InvalidVersionedHashSizeError2 = class extends BaseError6 {
  constructor({ hash: hash9, size: size11 }) {
    super(`Versioned hash "${hash9}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size11}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError2 = class extends BaseError6 {
  constructor({ hash: hash9, version: version11 }) {
    super(`Versioned hash "${hash9}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersion}`,
        `Received: ${version11}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashVersionError"
    });
  }
};

// node_modules/ox/_esm/core/Block.js
var Block_exports = {};
__export(Block_exports, {
  fromRpc: () => fromRpc10,
  toRpc: () => toRpc11
});

// node_modules/ox/_esm/core/Transaction.js
var Transaction_exports = {};
__export(Transaction_exports, {
  fromRpc: () => fromRpc8,
  fromRpcType: () => fromRpcType2,
  toRpc: () => toRpc9,
  toRpcType: () => toRpcType2
});
var toRpcType2 = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
var fromRpcType2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function fromRpc8(transaction, _options = {}) {
  if (!transaction)
    return null;
  const signature = extract2(transaction);
  const transaction_ = {
    ...transaction,
    ...signature
  };
  transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;
  transaction_.data = transaction.input;
  transaction_.gas = BigInt(transaction.gas ?? 0n);
  transaction_.nonce = BigInt(transaction.nonce ?? 0n);
  transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;
  transaction_.value = BigInt(transaction.value ?? 0n);
  if (transaction.authorizationList)
    transaction_.authorizationList = fromRpcList(transaction.authorizationList);
  if (transaction.chainId)
    transaction_.chainId = Number(transaction.chainId);
  if (transaction.gasPrice)
    transaction_.gasPrice = BigInt(transaction.gasPrice);
  if (transaction.maxFeePerBlobGas)
    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);
  if (transaction.maxFeePerGas)
    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);
  if (transaction.maxPriorityFeePerGas)
    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);
  if (transaction.type)
    transaction_.type = fromRpcType2[transaction.type] ?? transaction.type;
  if (signature)
    transaction_.v = yParityToV(signature.yParity);
  return transaction_;
}
function toRpc9(transaction, _options) {
  const rpc2 = {};
  rpc2.blockHash = transaction.blockHash;
  rpc2.blockNumber = typeof transaction.blockNumber === "bigint" ? fromNumber3(transaction.blockNumber) : null;
  rpc2.from = transaction.from;
  rpc2.gas = fromNumber3(transaction.gas ?? 0n);
  rpc2.hash = transaction.hash;
  rpc2.input = transaction.input;
  rpc2.nonce = fromNumber3(transaction.nonce ?? 0n);
  rpc2.to = transaction.to;
  rpc2.transactionIndex = transaction.transactionIndex ? fromNumber3(transaction.transactionIndex) : null;
  rpc2.type = toRpcType2[transaction.type] ?? transaction.type;
  rpc2.value = fromNumber3(transaction.value ?? 0n);
  if (transaction.accessList)
    rpc2.accessList = transaction.accessList;
  if (transaction.authorizationList)
    rpc2.authorizationList = toRpcList(transaction.authorizationList);
  if (transaction.blobVersionedHashes)
    rpc2.blobVersionedHashes = transaction.blobVersionedHashes;
  if (transaction.chainId)
    rpc2.chainId = fromNumber3(transaction.chainId);
  if (typeof transaction.gasPrice === "bigint")
    rpc2.gasPrice = fromNumber3(transaction.gasPrice);
  if (typeof transaction.maxFeePerBlobGas === "bigint")
    rpc2.maxFeePerBlobGas = fromNumber3(transaction.maxFeePerBlobGas);
  if (typeof transaction.maxFeePerGas === "bigint")
    rpc2.maxFeePerGas = fromNumber3(transaction.maxFeePerGas);
  if (typeof transaction.maxPriorityFeePerGas === "bigint")
    rpc2.maxPriorityFeePerGas = fromNumber3(transaction.maxPriorityFeePerGas);
  if (typeof transaction.r === "bigint")
    rpc2.r = fromNumber3(transaction.r, { size: 32 });
  if (typeof transaction.s === "bigint")
    rpc2.s = fromNumber3(transaction.s, { size: 32 });
  if (typeof transaction.v === "number")
    rpc2.v = fromNumber3(transaction.v, { size: 1 });
  if (typeof transaction.yParity === "number")
    rpc2.yParity = transaction.yParity === 0 ? "0x0" : "0x1";
  return rpc2;
}

// node_modules/ox/_esm/core/Withdrawal.js
var Withdrawal_exports = {};
__export(Withdrawal_exports, {
  fromRpc: () => fromRpc9,
  toRpc: () => toRpc10
});
function fromRpc9(withdrawal) {
  return {
    ...withdrawal,
    amount: BigInt(withdrawal.amount),
    index: Number(withdrawal.index),
    validatorIndex: Number(withdrawal.validatorIndex)
  };
}
function toRpc10(withdrawal) {
  return {
    address: withdrawal.address,
    amount: fromNumber3(withdrawal.amount),
    index: fromNumber3(withdrawal.index),
    validatorIndex: fromNumber3(withdrawal.validatorIndex)
  };
}

// node_modules/ox/_esm/core/Block.js
function toRpc11(block, _options = {}) {
  var _a14;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return toRpc9(transaction);
  });
  return {
    baseFeePerGas: typeof block.baseFeePerGas === "bigint" ? fromNumber3(block.baseFeePerGas) : void 0,
    blobGasUsed: typeof block.blobGasUsed === "bigint" ? fromNumber3(block.blobGasUsed) : void 0,
    excessBlobGas: typeof block.excessBlobGas === "bigint" ? fromNumber3(block.excessBlobGas) : void 0,
    extraData: block.extraData,
    difficulty: typeof block.difficulty === "bigint" ? fromNumber3(block.difficulty) : void 0,
    gasLimit: fromNumber3(block.gasLimit),
    gasUsed: fromNumber3(block.gasUsed),
    hash: block.hash,
    logsBloom: block.logsBloom,
    miner: block.miner,
    mixHash: block.mixHash,
    nonce: block.nonce,
    number: typeof block.number === "bigint" ? fromNumber3(block.number) : null,
    parentBeaconBlockRoot: block.parentBeaconBlockRoot,
    parentHash: block.parentHash,
    receiptsRoot: block.receiptsRoot,
    sealFields: block.sealFields,
    sha3Uncles: block.sha3Uncles,
    size: fromNumber3(block.size),
    stateRoot: block.stateRoot,
    timestamp: fromNumber3(block.timestamp),
    totalDifficulty: typeof block.totalDifficulty === "bigint" ? fromNumber3(block.totalDifficulty) : void 0,
    transactions,
    transactionsRoot: block.transactionsRoot,
    uncles: block.uncles,
    withdrawals: (_a14 = block.withdrawals) == null ? void 0 : _a14.map(toRpc10),
    withdrawalsRoot: block.withdrawalsRoot
  };
}
function fromRpc10(block, _options = {}) {
  var _a14;
  if (!block)
    return null;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return fromRpc8(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : void 0,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: BigInt(block.gasLimit ?? 0n),
    gasUsed: BigInt(block.gasUsed ?? 0n),
    number: block.number ? BigInt(block.number) : null,
    size: BigInt(block.size ?? 0n),
    stateRoot: block.stateRoot,
    timestamp: BigInt(block.timestamp ?? 0n),
    totalDifficulty: BigInt(block.totalDifficulty ?? 0n),
    transactions,
    withdrawals: (_a14 = block.withdrawals) == null ? void 0 : _a14.map(fromRpc9)
  };
}

// node_modules/ox/_esm/core/BlockOverrides.js
var BlockOverrides_exports2 = {};
__export(BlockOverrides_exports2, {
  fromRpc: () => fromRpc11,
  toRpc: () => toRpc12
});
function fromRpc11(rpcBlockOverrides) {
  return {
    ...rpcBlockOverrides.baseFeePerGas && {
      baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas)
    },
    ...rpcBlockOverrides.blobBaseFee && {
      blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee)
    },
    ...rpcBlockOverrides.feeRecipient && {
      feeRecipient: rpcBlockOverrides.feeRecipient
    },
    ...rpcBlockOverrides.gasLimit && {
      gasLimit: BigInt(rpcBlockOverrides.gasLimit)
    },
    ...rpcBlockOverrides.number && {
      number: BigInt(rpcBlockOverrides.number)
    },
    ...rpcBlockOverrides.prevRandao && {
      prevRandao: BigInt(rpcBlockOverrides.prevRandao)
    },
    ...rpcBlockOverrides.time && {
      time: BigInt(rpcBlockOverrides.time)
    },
    ...rpcBlockOverrides.withdrawals && {
      withdrawals: rpcBlockOverrides.withdrawals.map(fromRpc9)
    }
  };
}
function toRpc12(blockOverrides) {
  return {
    ...typeof blockOverrides.baseFeePerGas === "bigint" && {
      baseFeePerGas: fromNumber3(blockOverrides.baseFeePerGas)
    },
    ...typeof blockOverrides.blobBaseFee === "bigint" && {
      blobBaseFee: fromNumber3(blockOverrides.blobBaseFee)
    },
    ...typeof blockOverrides.feeRecipient === "string" && {
      feeRecipient: blockOverrides.feeRecipient
    },
    ...typeof blockOverrides.gasLimit === "bigint" && {
      gasLimit: fromNumber3(blockOverrides.gasLimit)
    },
    ...typeof blockOverrides.number === "bigint" && {
      number: fromNumber3(blockOverrides.number)
    },
    ...typeof blockOverrides.prevRandao === "bigint" && {
      prevRandao: fromNumber3(blockOverrides.prevRandao)
    },
    ...typeof blockOverrides.time === "bigint" && {
      time: fromNumber3(blockOverrides.time)
    },
    ...blockOverrides.withdrawals && {
      withdrawals: blockOverrides.withdrawals.map(toRpc10)
    }
  };
}

// node_modules/ox/_esm/core/Bloom.js
var Bloom_exports = {};
__export(Bloom_exports, {
  contains: () => contains,
  validate: () => validate11
});
function contains(bloom, input) {
  const filter10 = fromHex7(bloom);
  const hash9 = keccak2565(input, { as: "Bytes" });
  for (const i9 of [0, 2, 4]) {
    const bit = hash9[i9 + 1] + (hash9[i9] << 8) & 2047;
    if ((filter10[256 - 1 - Math.floor(bit / 8)] & 1 << bit % 8) === 0)
      return false;
  }
  return true;
}
function validate11(value2) {
  return validate5(value2) && size7(value2) === 256;
}

// node_modules/ox/_esm/core/Bls.js
var Bls_exports = {};
__export(Bls_exports, {
  aggregate: () => aggregate,
  getPublicKey: () => getPublicKey,
  noble: () => noble,
  randomPrivateKey: () => randomPrivateKey,
  sign: () => sign3,
  verify: () => verify2
});

// node_modules/@noble/curves/esm/abstract/bls.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
function NAfDecomposition(a6) {
  const res = [];
  for (; a6 > _1n2; a6 >>= _1n2) {
    if ((a6 & _1n2) === _0n2)
      res.unshift(0);
    else if ((a6 & _3n) === _3n) {
      res.unshift(-1);
      a6 += _1n2;
    } else
      res.unshift(1);
  }
  return res;
}
function aNonEmpty(arr) {
  if (!Array.isArray(arr) || arr.length === 0)
    throw new Error("expected non-empty array");
}
function createBlsPairing(fields, G1, G22, params) {
  const { Fp2: Fp22, Fp12: Fp122 } = fields;
  const { twistType, ateLoopSize, xNegative, postPrecompute } = params;
  let lineFunction;
  if (twistType === "multiplicative") {
    lineFunction = (c0, c1, c22, f16, Px, Py) => Fp122.mul014(f16, c0, Fp22.mul(c1, Px), Fp22.mul(c22, Py));
  } else if (twistType === "divisive") {
    lineFunction = (c0, c1, c22, f16, Px, Py) => Fp122.mul034(f16, Fp22.mul(c22, Py), Fp22.mul(c1, Px), c0);
  } else
    throw new Error("bls: unknown twist type");
  const Fp2div2 = Fp22.div(Fp22.ONE, Fp22.mul(Fp22.ONE, _2n2));
  function pointDouble(ell, Rx, Ry, Rz) {
    const t0 = Fp22.sqr(Ry);
    const t1 = Fp22.sqr(Rz);
    const t22 = Fp22.mulByB(Fp22.mul(t1, _3n));
    const t32 = Fp22.mul(t22, _3n);
    const t42 = Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(Ry, Rz)), t1), t0);
    const c0 = Fp22.sub(t22, t0);
    const c1 = Fp22.mul(Fp22.sqr(Rx), _3n);
    const c22 = Fp22.neg(t42);
    ell.push([c0, c1, c22]);
    Rx = Fp22.mul(Fp22.mul(Fp22.mul(Fp22.sub(t0, t32), Rx), Ry), Fp2div2);
    Ry = Fp22.sub(Fp22.sqr(Fp22.mul(Fp22.add(t0, t32), Fp2div2)), Fp22.mul(Fp22.sqr(t22), _3n));
    Rz = Fp22.mul(t0, t42);
    return { Rx, Ry, Rz };
  }
  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
    const t0 = Fp22.sub(Ry, Fp22.mul(Qy, Rz));
    const t1 = Fp22.sub(Rx, Fp22.mul(Qx, Rz));
    const c0 = Fp22.sub(Fp22.mul(t0, Qx), Fp22.mul(t1, Qy));
    const c1 = Fp22.neg(t0);
    const c22 = t1;
    ell.push([c0, c1, c22]);
    const t22 = Fp22.sqr(t1);
    const t32 = Fp22.mul(t22, t1);
    const t42 = Fp22.mul(t22, Rx);
    const t52 = Fp22.add(Fp22.sub(t32, Fp22.mul(t42, _2n2)), Fp22.mul(Fp22.sqr(t0), Rz));
    Rx = Fp22.mul(t1, t52);
    Ry = Fp22.sub(Fp22.mul(Fp22.sub(t42, t52), t0), Fp22.mul(t32, Ry));
    Rz = Fp22.mul(Rz, t32);
    return { Rx, Ry, Rz };
  }
  const ATE_NAF = NAfDecomposition(ateLoopSize);
  const calcPairingPrecomputes = memoized((point) => {
    const p9 = point;
    const { x: x7, y: y11 } = p9.toAffine();
    const Qx = x7, Qy = y11, negQy = Fp22.neg(y11);
    let Rx = Qx, Ry = Qy, Rz = Fp22.ONE;
    const ell = [];
    for (const bit of ATE_NAF) {
      const cur = [];
      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));
      if (bit)
        ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));
      ell.push(cur);
    }
    if (postPrecompute) {
      const last5 = ell[ell.length - 1];
      postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last5));
    }
    return ell;
  });
  function millerLoopBatch(pairs, withFinalExponent = false) {
    let f122 = Fp122.ONE;
    if (pairs.length) {
      const ellLen = pairs[0][0].length;
      for (let i9 = 0; i9 < ellLen; i9++) {
        f122 = Fp122.sqr(f122);
        for (const [ell, Px, Py] of pairs) {
          for (const [c0, c1, c22] of ell[i9])
            f122 = lineFunction(c0, c1, c22, f122, Px, Py);
        }
      }
    }
    if (xNegative)
      f122 = Fp122.conjugate(f122);
    return withFinalExponent ? Fp122.finalExponentiate(f122) : f122;
  }
  function pairingBatch(pairs, withFinalExponent = true) {
    const res = [];
    normalizeZ(G1, pairs.map(({ g1 }) => g1));
    normalizeZ(G22, pairs.map(({ g2: g22 }) => g22));
    for (const { g1, g2: g22 } of pairs) {
      if (g1.is0() || g22.is0())
        throw new Error("pairing is not available for ZERO point");
      g1.assertValidity();
      g22.assertValidity();
      const Qa2 = g1.toAffine();
      res.push([calcPairingPrecomputes(g22), Qa2.x, Qa2.y]);
    }
    return millerLoopBatch(res, withFinalExponent);
  }
  function pairing(Q7, P7, withFinalExponent = true) {
    return pairingBatch([{ g1: Q7, g2: P7 }], withFinalExponent);
  }
  return {
    Fp12: Fp122,
    // NOTE: we re-export Fp12 here because pairing results are Fp12!
    millerLoopBatch,
    pairing,
    pairingBatch,
    calcPairingPrecomputes
  };
}
function createBlsSig(blsPairing, PubCurve, SigCurve, SignatureCoder, isSigG1) {
  const { Fp12: Fp122, pairingBatch } = blsPairing;
  function normPub(point) {
    return point instanceof PubCurve.Point ? point : PubCurve.Point.fromHex(point);
  }
  function normSig(point) {
    return point instanceof SigCurve.Point ? point : SigCurve.Point.fromHex(point);
  }
  function amsg(m6) {
    if (!(m6 instanceof SigCurve.Point))
      throw new Error(`expected valid message hashed to ${!isSigG1 ? "G2" : "G1"} curve`);
    return m6;
  }
  const pair = !isSigG1 ? (a6, b6) => ({ g1: a6, g2: b6 }) : (a6, b6) => ({ g1: b6, g2: a6 });
  return {
    // P = pk x G
    getPublicKey(secretKey) {
      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);
      return PubCurve.Point.BASE.multiply(sec);
    },
    // S = pk x H(m)
    sign(message, secretKey, unusedArg) {
      if (unusedArg != null)
        throw new Error("sign() expects 2 arguments");
      const sec = _normFnElement(PubCurve.Point.Fn, secretKey);
      amsg(message).assertValidity();
      return message.multiply(sec);
    },
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(P, H(m)) == e(G, S)
    // e(S, G) == e(H(m), P)
    verify(signature, message, publicKey, unusedArg) {
      if (unusedArg != null)
        throw new Error("verify() expects 3 arguments");
      signature = normSig(signature);
      publicKey = normPub(publicKey);
      const P7 = publicKey.negate();
      const G7 = PubCurve.Point.BASE;
      const Hm = amsg(message);
      const S8 = signature;
      const exp = pairingBatch([pair(P7, Hm), pair(G7, S8)]);
      return Fp122.eql(exp, Fp122.ONE);
    },
    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))
    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?
    verifyBatch(signature, messages, publicKeys) {
      aNonEmpty(messages);
      if (publicKeys.length !== messages.length)
        throw new Error("amount of public keys and messages should be equal");
      const sig = normSig(signature);
      const nMessages = messages;
      const nPublicKeys = publicKeys.map(normPub);
      const messagePubKeyMap = /* @__PURE__ */ new Map();
      for (let i9 = 0; i9 < nPublicKeys.length; i9++) {
        const pub = nPublicKeys[i9];
        const msg = nMessages[i9];
        let keys5 = messagePubKeyMap.get(msg);
        if (keys5 === void 0) {
          keys5 = [];
          messagePubKeyMap.set(msg, keys5);
        }
        keys5.push(pub);
      }
      const paired = [];
      const G7 = PubCurve.Point.BASE;
      try {
        for (const [msg, keys5] of messagePubKeyMap) {
          const groupPublicKey = keys5.reduce((acc, msg2) => acc.add(msg2));
          paired.push(pair(groupPublicKey, msg));
        }
        paired.push(pair(G7.negate(), sig));
        return Fp122.eql(pairingBatch(paired), Fp122.ONE);
      } catch {
        return false;
      }
    },
    // Adds a bunch of public key points together.
    // pk1 + pk2 + pk3 = pkA
    aggregatePublicKeys(publicKeys) {
      aNonEmpty(publicKeys);
      publicKeys = publicKeys.map((pub) => normPub(pub));
      const agg = publicKeys.reduce((sum, p9) => sum.add(p9), PubCurve.Point.ZERO);
      agg.assertValidity();
      return agg;
    },
    // Adds a bunch of signature points together.
    // pk1 + pk2 + pk3 = pkA
    aggregateSignatures(signatures) {
      aNonEmpty(signatures);
      signatures = signatures.map((sig) => normSig(sig));
      const agg = signatures.reduce((sum, s5) => sum.add(s5), SigCurve.Point.ZERO);
      agg.assertValidity();
      return agg;
    },
    hash(messageBytes, DST) {
      abytes(messageBytes);
      const opts2 = DST ? { DST } : void 0;
      return SigCurve.hashToCurve(messageBytes, opts2);
    },
    Signature: SignatureCoder
  };
}
function bls(CURVE) {
  const { Fp: Fp4, Fr: Fr3, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122 } = CURVE.fields;
  const G1_ = weierstrassPoints(CURVE.G1);
  const G1 = Object.assign(G1_, createHasher2(G1_.Point, CURVE.G1.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G1.htfDefaults
  }));
  const G2_ = weierstrassPoints(CURVE.G2);
  const G22 = Object.assign(G2_, createHasher2(G2_.Point, CURVE.G2.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G2.htfDefaults
  }));
  const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G22.Point, {
    ...CURVE.params,
    postPrecompute: CURVE.postPrecompute
  });
  const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;
  const longSignatures = createBlsSig(pairingRes, G1, G22, CURVE.G2.Signature, false);
  const shortSignatures = createBlsSig(pairingRes, G22, G1, CURVE.G1.ShortSignature, true);
  const rand = CURVE.randomBytes || randomBytes;
  const randomSecretKey = () => {
    const length = getMinHashLength(Fr3.ORDER);
    return mapHashToField(rand(length), Fr3.ORDER);
  };
  const utils2 = {
    randomSecretKey,
    randomPrivateKey: randomSecretKey,
    calcPairingPrecomputes
  };
  const { ShortSignature } = CURVE.G1;
  const { Signature } = CURVE.G2;
  function normP1Hash(point, htfOpts) {
    return point instanceof G1.Point ? point : shortSignatures.hash(ensureBytes("point", point), htfOpts == null ? void 0 : htfOpts.DST);
  }
  function normP2Hash(point, htfOpts) {
    return point instanceof G22.Point ? point : longSignatures.hash(ensureBytes("point", point), htfOpts == null ? void 0 : htfOpts.DST);
  }
  function getPublicKey4(privateKey) {
    return longSignatures.getPublicKey(privateKey).toBytes(true);
  }
  function getPublicKeyForShortSignatures(privateKey) {
    return shortSignatures.getPublicKey(privateKey).toBytes(true);
  }
  function sign9(message, privateKey, htfOpts) {
    const Hm = normP2Hash(message, htfOpts);
    const S8 = longSignatures.sign(Hm, privateKey);
    return message instanceof G22.Point ? S8 : Signature.toBytes(S8);
  }
  function signShortSignature(message, privateKey, htfOpts) {
    const Hm = normP1Hash(message, htfOpts);
    const S8 = shortSignatures.sign(Hm, privateKey);
    return message instanceof G1.Point ? S8 : ShortSignature.toBytes(S8);
  }
  function verify7(signature, message, publicKey, htfOpts) {
    const Hm = normP2Hash(message, htfOpts);
    return longSignatures.verify(signature, Hm, publicKey);
  }
  function verifyShortSignature(signature, message, publicKey, htfOpts) {
    const Hm = normP1Hash(message, htfOpts);
    return shortSignatures.verify(signature, Hm, publicKey);
  }
  function aggregatePublicKeys(publicKeys) {
    const agg = longSignatures.aggregatePublicKeys(publicKeys);
    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);
  }
  function aggregateSignatures(signatures) {
    const agg = longSignatures.aggregateSignatures(signatures);
    return signatures[0] instanceof G22.Point ? agg : Signature.toBytes(agg);
  }
  function aggregateShortSignatures(signatures) {
    const agg = shortSignatures.aggregateSignatures(signatures);
    return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);
  }
  function verifyBatch(signature, messages, publicKeys, htfOpts) {
    const Hm = messages.map((m6) => normP2Hash(m6, htfOpts));
    return longSignatures.verifyBatch(signature, Hm, publicKeys);
  }
  G1.Point.BASE.precompute(4);
  return {
    longSignatures,
    shortSignatures,
    millerLoopBatch,
    pairing,
    pairingBatch,
    verifyBatch,
    fields: {
      Fr: Fr3,
      Fp: Fp4,
      Fp2: Fp22,
      Fp6: Fp62,
      Fp12: Fp122
    },
    params: {
      ateLoopSize: CURVE.params.ateLoopSize,
      twistType: CURVE.params.twistType,
      // deprecated
      r: CURVE.params.r,
      G1b: CURVE.G1.b,
      G2b: CURVE.G2.b
    },
    utils: utils2,
    // deprecated
    getPublicKey: getPublicKey4,
    getPublicKeyForShortSignatures,
    sign: sign9,
    signShortSignature,
    verify: verify7,
    verifyShortSignature,
    aggregatePublicKeys,
    aggregateSignatures,
    aggregateShortSignatures,
    G1,
    G2: G22,
    Signature,
    ShortSignature
  };
}

// node_modules/@noble/curves/esm/abstract/tower.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
function calcFrobeniusCoefficients(Fp4, nonResidue, modulus, degree, num3 = 1, divisor) {
  const _divisor = BigInt(divisor === void 0 ? degree : divisor);
  const towerModulus = modulus ** BigInt(degree);
  const res = [];
  for (let i9 = 0; i9 < num3; i9++) {
    const a6 = BigInt(i9 + 1);
    const powers2 = [];
    for (let j9 = 0, qPower = _1n3; j9 < degree; j9++) {
      const power = (a6 * qPower - a6) / _divisor % towerModulus;
      powers2.push(Fp4.pow(nonResidue, power));
      qPower *= modulus;
    }
    res.push(powers2);
  }
  return res;
}
function psiFrobenius(Fp4, Fp22, base4) {
  const PSI_X = Fp22.pow(base4, (Fp4.ORDER - _1n3) / _3n2);
  const PSI_Y = Fp22.pow(base4, (Fp4.ORDER - _1n3) / _2n3);
  function psi(x7, y11) {
    const x22 = Fp22.mul(Fp22.frobeniusMap(x7, 1), PSI_X);
    const y22 = Fp22.mul(Fp22.frobeniusMap(y11, 1), PSI_Y);
    return [x22, y22];
  }
  const PSI2_X = Fp22.pow(base4, (Fp4.ORDER ** _2n3 - _1n3) / _3n2);
  const PSI2_Y = Fp22.pow(base4, (Fp4.ORDER ** _2n3 - _1n3) / _2n3);
  if (!Fp22.eql(PSI2_Y, Fp22.neg(Fp22.ONE)))
    throw new Error("psiFrobenius: PSI2_Y!==-1");
  function psi2(x7, y11) {
    return [Fp22.mul(x7, PSI2_X), Fp22.neg(y11)];
  }
  const mapAffine = (fn4) => (c9, P7) => {
    const affine = P7.toAffine();
    const p9 = fn4(affine.x, affine.y);
    return c9.fromAffine({ x: p9[0], y: p9[1] });
  };
  const G2psi3 = mapAffine(psi);
  const G2psi22 = mapAffine(psi2);
  return { psi, psi2, G2psi: G2psi3, G2psi2: G2psi22, PSI_X, PSI_Y, PSI2_X, PSI2_Y };
}
var Fp2fromBigTuple = (Fp4, tuple3) => {
  if (tuple3.length !== 2)
    throw new Error("invalid tuple");
  const fps = tuple3.map((n5) => Fp4.create(n5));
  return { c0: fps[0], c1: fps[1] };
};
var _Field2 = class {
  constructor(Fp4, opts2 = {}) {
    this.MASK = _1n3;
    const ORDER = Fp4.ORDER;
    const FP2_ORDER = ORDER * ORDER;
    this.Fp = Fp4;
    this.ORDER = FP2_ORDER;
    this.BITS = bitLen(FP2_ORDER);
    this.BYTES = Math.ceil(bitLen(FP2_ORDER) / 8);
    this.isLE = Fp4.isLE;
    this.ZERO = { c0: Fp4.ZERO, c1: Fp4.ZERO };
    this.ONE = { c0: Fp4.ONE, c1: Fp4.ZERO };
    this.Fp_NONRESIDUE = Fp4.create(opts2.NONRESIDUE || BigInt(-1));
    this.Fp_div2 = Fp4.div(Fp4.ONE, _2n3);
    this.NONRESIDUE = Fp2fromBigTuple(Fp4, opts2.FP2_NONRESIDUE);
    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp4, this.Fp_NONRESIDUE, Fp4.ORDER, 2)[0];
    this.mulByB = opts2.Fp2mulByB;
    Object.seal(this);
  }
  fromBigTuple(tuple3) {
    return Fp2fromBigTuple(this.Fp, tuple3);
  }
  create(num3) {
    return num3;
  }
  isValid({ c0, c1 }) {
    function isValidC(num3, ORDER) {
      return typeof num3 === "bigint" && _0n3 <= num3 && num3 < ORDER;
    }
    return isValidC(c0, this.ORDER) && isValidC(c1, this.ORDER);
  }
  is0({ c0, c1 }) {
    return this.Fp.is0(c0) && this.Fp.is0(c1);
  }
  isValidNot0(num3) {
    return !this.is0(num3) && this.isValid(num3);
  }
  eql({ c0, c1 }, { c0: r0, c1: r1 }) {
    return this.Fp.eql(c0, r0) && this.Fp.eql(c1, r1);
  }
  neg({ c0, c1 }) {
    return { c0: this.Fp.neg(c0), c1: this.Fp.neg(c1) };
  }
  pow(num3, power) {
    return FpPow(this, num3, power);
  }
  invertBatch(nums) {
    return FpInvertBatch(this, nums);
  }
  // Normalized
  add(f1, f22) {
    const { c0, c1 } = f1;
    const { c0: r0, c1: r1 } = f22;
    return {
      c0: this.Fp.add(c0, r0),
      c1: this.Fp.add(c1, r1)
    };
  }
  sub({ c0, c1 }, { c0: r0, c1: r1 }) {
    return {
      c0: this.Fp.sub(c0, r0),
      c1: this.Fp.sub(c1, r1)
    };
  }
  mul({ c0, c1 }, rhs) {
    const { Fp: Fp4 } = this;
    if (typeof rhs === "bigint")
      return { c0: Fp4.mul(c0, rhs), c1: Fp4.mul(c1, rhs) };
    const { c0: r0, c1: r1 } = rhs;
    let t1 = Fp4.mul(c0, r0);
    let t22 = Fp4.mul(c1, r1);
    const o0 = Fp4.sub(t1, t22);
    const o1 = Fp4.sub(Fp4.mul(Fp4.add(c0, c1), Fp4.add(r0, r1)), Fp4.add(t1, t22));
    return { c0: o0, c1: o1 };
  }
  sqr({ c0, c1 }) {
    const { Fp: Fp4 } = this;
    const a6 = Fp4.add(c0, c1);
    const b6 = Fp4.sub(c0, c1);
    const c9 = Fp4.add(c0, c0);
    return { c0: Fp4.mul(a6, b6), c1: Fp4.mul(c9, c1) };
  }
  // NonNormalized stuff
  addN(a6, b6) {
    return this.add(a6, b6);
  }
  subN(a6, b6) {
    return this.sub(a6, b6);
  }
  mulN(a6, b6) {
    return this.mul(a6, b6);
  }
  sqrN(a6) {
    return this.sqr(a6);
  }
  // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
  div(lhs, rhs) {
    const { Fp: Fp4 } = this;
    return this.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : this.inv(rhs));
  }
  inv({ c0: a6, c1: b6 }) {
    const { Fp: Fp4 } = this;
    const factor = Fp4.inv(Fp4.create(a6 * a6 + b6 * b6));
    return { c0: Fp4.mul(factor, Fp4.create(a6)), c1: Fp4.mul(factor, Fp4.create(-b6)) };
  }
  sqrt(num3) {
    const { Fp: Fp4 } = this;
    const Fp22 = this;
    const { c0, c1 } = num3;
    if (Fp4.is0(c1)) {
      if (FpLegendre(Fp4, c0) === 1)
        return Fp22.create({ c0: Fp4.sqrt(c0), c1: Fp4.ZERO });
      else
        return Fp22.create({ c0: Fp4.ZERO, c1: Fp4.sqrt(Fp4.div(c0, this.Fp_NONRESIDUE)) });
    }
    const a6 = Fp4.sqrt(Fp4.sub(Fp4.sqr(c0), Fp4.mul(Fp4.sqr(c1), this.Fp_NONRESIDUE)));
    let d7 = Fp4.mul(Fp4.add(a6, c0), this.Fp_div2);
    const legendre = FpLegendre(Fp4, d7);
    if (legendre === -1)
      d7 = Fp4.sub(d7, a6);
    const a0 = Fp4.sqrt(d7);
    const candidateSqrt = Fp22.create({ c0: a0, c1: Fp4.div(Fp4.mul(c1, this.Fp_div2), a0) });
    if (!Fp22.eql(Fp22.sqr(candidateSqrt), num3))
      throw new Error("Cannot find square root");
    const x1 = candidateSqrt;
    const x22 = Fp22.neg(x1);
    const { re: re1, im: im1 } = Fp22.reim(x1);
    const { re: re22, im: im2 } = Fp22.reim(x22);
    if (im1 > im2 || im1 === im2 && re1 > re22)
      return x1;
    return x22;
  }
  // Same as sgn0_m_eq_2 in RFC 9380
  isOdd(x7) {
    const { re: x0, im: x1 } = this.reim(x7);
    const sign_0 = x0 % _2n3;
    const zero_0 = x0 === _0n3;
    const sign_1 = x1 % _2n3;
    return BigInt(sign_0 || zero_0 && sign_1) == _1n3;
  }
  // Bytes util
  fromBytes(b6) {
    const { Fp: Fp4 } = this;
    if (b6.length !== this.BYTES)
      throw new Error("fromBytes invalid length=" + b6.length);
    return { c0: Fp4.fromBytes(b6.subarray(0, Fp4.BYTES)), c1: Fp4.fromBytes(b6.subarray(Fp4.BYTES)) };
  }
  toBytes({ c0, c1 }) {
    return concatBytes(this.Fp.toBytes(c0), this.Fp.toBytes(c1));
  }
  cmov({ c0, c1 }, { c0: r0, c1: r1 }, c9) {
    return {
      c0: this.Fp.cmov(c0, r0, c9),
      c1: this.Fp.cmov(c1, r1, c9)
    };
  }
  reim({ c0, c1 }) {
    return { re: c0, im: c1 };
  }
  Fp4Square(a6, b6) {
    const Fp22 = this;
    const a22 = Fp22.sqr(a6);
    const b22 = Fp22.sqr(b6);
    return {
      first: Fp22.add(Fp22.mulByNonresidue(b22), a22),
      // b * Nonresidue + a
      second: Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(a6, b6)), a22), b22)
      // (a + b) - a - b
    };
  }
  // multiply by u + 1
  mulByNonresidue({ c0, c1 }) {
    return this.mul({ c0, c1 }, this.NONRESIDUE);
  }
  frobeniusMap({ c0, c1 }, power) {
    return {
      c0,
      c1: this.Fp.mul(c1, this.FROBENIUS_COEFFICIENTS[power % 2])
    };
  }
};
var _Field6 = class {
  constructor(Fp22) {
    this.MASK = _1n3;
    this.Fp2 = Fp22;
    this.ORDER = Fp22.ORDER;
    this.BITS = 3 * Fp22.BITS;
    this.BYTES = 3 * Fp22.BYTES;
    this.isLE = Fp22.isLE;
    this.ZERO = { c0: Fp22.ZERO, c1: Fp22.ZERO, c2: Fp22.ZERO };
    this.ONE = { c0: Fp22.ONE, c1: Fp22.ZERO, c2: Fp22.ZERO };
    const { Fp: Fp4 } = Fp22;
    const frob = calcFrobeniusCoefficients(Fp22, Fp22.NONRESIDUE, Fp4.ORDER, 6, 2, 3);
    this.FROBENIUS_COEFFICIENTS_1 = frob[0];
    this.FROBENIUS_COEFFICIENTS_2 = frob[1];
    Object.seal(this);
  }
  add({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r22 }) {
    const { Fp2: Fp22 } = this;
    return {
      c0: Fp22.add(c0, r0),
      c1: Fp22.add(c1, r1),
      c2: Fp22.add(c22, r22)
    };
  }
  sub({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r22 }) {
    const { Fp2: Fp22 } = this;
    return {
      c0: Fp22.sub(c0, r0),
      c1: Fp22.sub(c1, r1),
      c2: Fp22.sub(c22, r22)
    };
  }
  mul({ c0, c1, c2: c22 }, rhs) {
    const { Fp2: Fp22 } = this;
    if (typeof rhs === "bigint") {
      return {
        c0: Fp22.mul(c0, rhs),
        c1: Fp22.mul(c1, rhs),
        c2: Fp22.mul(c22, rhs)
      };
    }
    const { c0: r0, c1: r1, c2: r22 } = rhs;
    const t0 = Fp22.mul(c0, r0);
    const t1 = Fp22.mul(c1, r1);
    const t22 = Fp22.mul(c22, r22);
    return {
      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
      c0: Fp22.add(t0, Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c22), Fp22.add(r1, r22)), Fp22.add(t1, t22)))),
      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
      c1: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c1), Fp22.add(r0, r1)), Fp22.add(t0, t1)), Fp22.mulByNonresidue(t22)),
      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
      c2: Fp22.sub(Fp22.add(t1, Fp22.mul(Fp22.add(c0, c22), Fp22.add(r0, r22))), Fp22.add(t0, t22))
    };
  }
  sqr({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    let t0 = Fp22.sqr(c0);
    let t1 = Fp22.mul(Fp22.mul(c0, c1), _2n3);
    let t32 = Fp22.mul(Fp22.mul(c1, c22), _2n3);
    let t42 = Fp22.sqr(c22);
    return {
      c0: Fp22.add(Fp22.mulByNonresidue(t32), t0),
      // T3 * (u + 1) + T0
      c1: Fp22.add(Fp22.mulByNonresidue(t42), t1),
      // T4 * (u + 1) + T1
      // T1 + (c0 - c1 + c2) + T3 - T0 - T4
      c2: Fp22.sub(Fp22.sub(Fp22.add(Fp22.add(t1, Fp22.sqr(Fp22.add(Fp22.sub(c0, c1), c22))), t32), t0), t42)
    };
  }
  addN(a6, b6) {
    return this.add(a6, b6);
  }
  subN(a6, b6) {
    return this.sub(a6, b6);
  }
  mulN(a6, b6) {
    return this.mul(a6, b6);
  }
  sqrN(a6) {
    return this.sqr(a6);
  }
  create(num3) {
    return num3;
  }
  isValid({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    return Fp22.isValid(c0) && Fp22.isValid(c1) && Fp22.isValid(c22);
  }
  is0({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    return Fp22.is0(c0) && Fp22.is0(c1) && Fp22.is0(c22);
  }
  isValidNot0(num3) {
    return !this.is0(num3) && this.isValid(num3);
  }
  neg({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    return { c0: Fp22.neg(c0), c1: Fp22.neg(c1), c2: Fp22.neg(c22) };
  }
  eql({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r22 }) {
    const { Fp2: Fp22 } = this;
    return Fp22.eql(c0, r0) && Fp22.eql(c1, r1) && Fp22.eql(c22, r22);
  }
  sqrt(_6) {
    return notImplemented();
  }
  // Do we need division by bigint at all? Should be done via order:
  div(lhs, rhs) {
    const { Fp2: Fp22 } = this;
    const { Fp: Fp4 } = Fp22;
    return this.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : this.inv(rhs));
  }
  pow(num3, power) {
    return FpPow(this, num3, power);
  }
  invertBatch(nums) {
    return FpInvertBatch(this, nums);
  }
  inv({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    let t0 = Fp22.sub(Fp22.sqr(c0), Fp22.mulByNonresidue(Fp22.mul(c22, c1)));
    let t1 = Fp22.sub(Fp22.mulByNonresidue(Fp22.sqr(c22)), Fp22.mul(c0, c1));
    let t22 = Fp22.sub(Fp22.sqr(c1), Fp22.mul(c0, c22));
    let t42 = Fp22.inv(Fp22.add(Fp22.mulByNonresidue(Fp22.add(Fp22.mul(c22, t1), Fp22.mul(c1, t22))), Fp22.mul(c0, t0)));
    return { c0: Fp22.mul(t42, t0), c1: Fp22.mul(t42, t1), c2: Fp22.mul(t42, t22) };
  }
  // Bytes utils
  fromBytes(b6) {
    const { Fp2: Fp22 } = this;
    if (b6.length !== this.BYTES)
      throw new Error("fromBytes invalid length=" + b6.length);
    const B22 = Fp22.BYTES;
    return {
      c0: Fp22.fromBytes(b6.subarray(0, B22)),
      c1: Fp22.fromBytes(b6.subarray(B22, B22 * 2)),
      c2: Fp22.fromBytes(b6.subarray(2 * B22))
    };
  }
  toBytes({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    return concatBytes(Fp22.toBytes(c0), Fp22.toBytes(c1), Fp22.toBytes(c22));
  }
  cmov({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r22 }, c9) {
    const { Fp2: Fp22 } = this;
    return {
      c0: Fp22.cmov(c0, r0, c9),
      c1: Fp22.cmov(c1, r1, c9),
      c2: Fp22.cmov(c22, r22, c9)
    };
  }
  fromBigSix(t6) {
    const { Fp2: Fp22 } = this;
    if (!Array.isArray(t6) || t6.length !== 6)
      throw new Error("invalid Fp6 usage");
    return {
      c0: Fp22.fromBigTuple(t6.slice(0, 2)),
      c1: Fp22.fromBigTuple(t6.slice(2, 4)),
      c2: Fp22.fromBigTuple(t6.slice(4, 6))
    };
  }
  frobeniusMap({ c0, c1, c2: c22 }, power) {
    const { Fp2: Fp22 } = this;
    return {
      c0: Fp22.frobeniusMap(c0, power),
      c1: Fp22.mul(Fp22.frobeniusMap(c1, power), this.FROBENIUS_COEFFICIENTS_1[power % 6]),
      c2: Fp22.mul(Fp22.frobeniusMap(c22, power), this.FROBENIUS_COEFFICIENTS_2[power % 6])
    };
  }
  mulByFp2({ c0, c1, c2: c22 }, rhs) {
    const { Fp2: Fp22 } = this;
    return {
      c0: Fp22.mul(c0, rhs),
      c1: Fp22.mul(c1, rhs),
      c2: Fp22.mul(c22, rhs)
    };
  }
  mulByNonresidue({ c0, c1, c2: c22 }) {
    const { Fp2: Fp22 } = this;
    return { c0: Fp22.mulByNonresidue(c22), c1: c0, c2: c1 };
  }
  // Sparse multiplication
  mul1({ c0, c1, c2: c22 }, b1) {
    const { Fp2: Fp22 } = this;
    return {
      c0: Fp22.mulByNonresidue(Fp22.mul(c22, b1)),
      c1: Fp22.mul(c0, b1),
      c2: Fp22.mul(c1, b1)
    };
  }
  // Sparse multiplication
  mul01({ c0, c1, c2: c22 }, b0, b1) {
    const { Fp2: Fp22 } = this;
    let t0 = Fp22.mul(c0, b0);
    let t1 = Fp22.mul(c1, b1);
    return {
      // ((c1 + c2) * b1 - T1) * (u + 1) + T0
      c0: Fp22.add(Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c22), b1), t1)), t0),
      // (b0 + b1) * (c0 + c1) - T0 - T1
      c1: Fp22.sub(Fp22.sub(Fp22.mul(Fp22.add(b0, b1), Fp22.add(c0, c1)), t0), t1),
      // (c0 + c2) * b0 - T0 + T1
      c2: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c22), b0), t0), t1)
    };
  }
};
var _Field12 = class {
  constructor(Fp62, opts2) {
    this.MASK = _1n3;
    const { Fp2: Fp22 } = Fp62;
    const { Fp: Fp4 } = Fp22;
    this.Fp6 = Fp62;
    this.ORDER = Fp22.ORDER;
    this.BITS = 2 * Fp62.BITS;
    this.BYTES = 2 * Fp62.BYTES;
    this.isLE = Fp62.isLE;
    this.ZERO = { c0: Fp62.ZERO, c1: Fp62.ZERO };
    this.ONE = { c0: Fp62.ONE, c1: Fp62.ZERO };
    this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp22, Fp22.NONRESIDUE, Fp4.ORDER, 12, 1, 6)[0];
    this.X_LEN = opts2.X_LEN;
    this.finalExponentiate = opts2.Fp12finalExponentiate;
  }
  create(num3) {
    return num3;
  }
  isValid({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return Fp62.isValid(c0) && Fp62.isValid(c1);
  }
  is0({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return Fp62.is0(c0) && Fp62.is0(c1);
  }
  isValidNot0(num3) {
    return !this.is0(num3) && this.isValid(num3);
  }
  neg({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return { c0: Fp62.neg(c0), c1: Fp62.neg(c1) };
  }
  eql({ c0, c1 }, { c0: r0, c1: r1 }) {
    const { Fp6: Fp62 } = this;
    return Fp62.eql(c0, r0) && Fp62.eql(c1, r1);
  }
  sqrt(_6) {
    notImplemented();
  }
  inv({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    let t6 = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));
    return { c0: Fp62.mul(c0, t6), c1: Fp62.neg(Fp62.mul(c1, t6)) };
  }
  div(lhs, rhs) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp22 } = Fp62;
    const { Fp: Fp4 } = Fp22;
    return this.mul(lhs, typeof rhs === "bigint" ? Fp4.inv(Fp4.create(rhs)) : this.inv(rhs));
  }
  pow(num3, power) {
    return FpPow(this, num3, power);
  }
  invertBatch(nums) {
    return FpInvertBatch(this, nums);
  }
  // Normalized
  add({ c0, c1 }, { c0: r0, c1: r1 }) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.add(c0, r0),
      c1: Fp62.add(c1, r1)
    };
  }
  sub({ c0, c1 }, { c0: r0, c1: r1 }) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.sub(c0, r0),
      c1: Fp62.sub(c1, r1)
    };
  }
  mul({ c0, c1 }, rhs) {
    const { Fp6: Fp62 } = this;
    if (typeof rhs === "bigint")
      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };
    let { c0: r0, c1: r1 } = rhs;
    let t1 = Fp62.mul(c0, r0);
    let t22 = Fp62.mul(c1, r1);
    return {
      c0: Fp62.add(t1, Fp62.mulByNonresidue(t22)),
      // T1 + T2 * v
      // (c0 + c1) * (r0 + r1) - (T1 + T2)
      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t22))
    };
  }
  sqr({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    let ab = Fp62.mul(c0, c1);
    return {
      // (c1 * v + c0) * (c0 + c1) - AB - AB * v
      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),
      c1: Fp62.add(ab, ab)
    };
  }
  // NonNormalized stuff
  addN(a6, b6) {
    return this.add(a6, b6);
  }
  subN(a6, b6) {
    return this.sub(a6, b6);
  }
  mulN(a6, b6) {
    return this.mul(a6, b6);
  }
  sqrN(a6) {
    return this.sqr(a6);
  }
  // Bytes utils
  fromBytes(b6) {
    const { Fp6: Fp62 } = this;
    if (b6.length !== this.BYTES)
      throw new Error("fromBytes invalid length=" + b6.length);
    return {
      c0: Fp62.fromBytes(b6.subarray(0, Fp62.BYTES)),
      c1: Fp62.fromBytes(b6.subarray(Fp62.BYTES))
    };
  }
  toBytes({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    return concatBytes(Fp62.toBytes(c0), Fp62.toBytes(c1));
  }
  cmov({ c0, c1 }, { c0: r0, c1: r1 }, c9) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.cmov(c0, r0, c9),
      c1: Fp62.cmov(c1, r1, c9)
    };
  }
  // Utils
  // toString() {
  //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
  // },
  // fromTuple(c: [Fp6, Fp6]) {
  //   return new Fp12(...c);
  // }
  fromBigTwelve(t6) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.fromBigSix(t6.slice(0, 6)),
      c1: Fp62.fromBigSix(t6.slice(6, 12))
    };
  }
  // Raises to q**i -th power
  frobeniusMap(lhs, power) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp22 } = Fp62;
    const { c0, c1, c2: c22 } = Fp62.frobeniusMap(lhs.c1, power);
    const coeff = this.FROBENIUS_COEFFICIENTS[power % 12];
    return {
      c0: Fp62.frobeniusMap(lhs.c0, power),
      c1: Fp62.create({
        c0: Fp22.mul(c0, coeff),
        c1: Fp22.mul(c1, coeff),
        c2: Fp22.mul(c22, coeff)
      })
    };
  }
  mulByFp2({ c0, c1 }, rhs) {
    const { Fp6: Fp62 } = this;
    return {
      c0: Fp62.mulByFp2(c0, rhs),
      c1: Fp62.mulByFp2(c1, rhs)
    };
  }
  conjugate({ c0, c1 }) {
    return { c0, c1: this.Fp6.neg(c1) };
  }
  // Sparse multiplication
  mul014({ c0, c1 }, o0, o1, o42) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp22 } = Fp62;
    let t0 = Fp62.mul01(c0, o0, o1);
    let t1 = Fp62.mul1(c1, o42);
    return {
      c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),
      // T1 * v + T0
      // (c1 + c0) * [o0, o1+o4] - T0 - T1
      c1: Fp62.sub(Fp62.sub(Fp62.mul01(Fp62.add(c1, c0), o0, Fp22.add(o1, o42)), t0), t1)
    };
  }
  mul034({ c0, c1 }, o0, o32, o42) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp22 } = Fp62;
    const a6 = Fp62.create({
      c0: Fp22.mul(c0.c0, o0),
      c1: Fp22.mul(c0.c1, o0),
      c2: Fp22.mul(c0.c2, o0)
    });
    const b6 = Fp62.mul01(c1, o32, o42);
    const e11 = Fp62.mul01(Fp62.add(c0, c1), Fp22.add(o0, o32), o42);
    return {
      c0: Fp62.add(Fp62.mulByNonresidue(b6), a6),
      c1: Fp62.sub(e11, Fp62.add(a6, b6))
    };
  }
  // A cyclotomic group is a subgroup of Fp^n defined by
  //   G(p) = {  Fp : ^(p) = 1}
  // The result of any pairing is in a cyclotomic subgroup
  // https://eprint.iacr.org/2009/565.pdf
  // https://eprint.iacr.org/2010/354.pdf
  _cyclotomicSquare({ c0, c1 }) {
    const { Fp6: Fp62 } = this;
    const { Fp2: Fp22 } = Fp62;
    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;
    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;
    const { first: t32, second: t42 } = Fp22.Fp4Square(c0c0, c1c1);
    const { first: t52, second: t6 } = Fp22.Fp4Square(c1c0, c0c2);
    const { first: t7, second: t8 } = Fp22.Fp4Square(c0c1, c1c2);
    const t9 = Fp22.mulByNonresidue(t8);
    return {
      c0: Fp62.create({
        c0: Fp22.add(Fp22.mul(Fp22.sub(t32, c0c0), _2n3), t32),
        // 2 * (T3 - c0c0)  + T3
        c1: Fp22.add(Fp22.mul(Fp22.sub(t52, c0c1), _2n3), t52),
        // 2 * (T5 - c0c1)  + T5
        c2: Fp22.add(Fp22.mul(Fp22.sub(t7, c0c2), _2n3), t7)
      }),
      // 2 * (T7 - c0c2)  + T7
      c1: Fp62.create({
        c0: Fp22.add(Fp22.mul(Fp22.add(t9, c1c0), _2n3), t9),
        // 2 * (T9 + c1c0) + T9
        c1: Fp22.add(Fp22.mul(Fp22.add(t42, c1c1), _2n3), t42),
        // 2 * (T4 + c1c1) + T4
        c2: Fp22.add(Fp22.mul(Fp22.add(t6, c1c2), _2n3), t6)
      })
    };
  }
  // https://eprint.iacr.org/2009/565.pdf
  _cyclotomicExp(num3, n5) {
    let z9 = this.ONE;
    for (let i9 = this.X_LEN - 1; i9 >= 0; i9--) {
      z9 = this._cyclotomicSquare(z9);
      if (bitGet(n5, i9))
        z9 = this.mul(z9, num3);
    }
    return z9;
  }
};
function tower12(opts2) {
  const Fp4 = Field2(opts2.ORDER);
  const Fp22 = new _Field2(Fp4, opts2);
  const Fp62 = new _Field6(Fp22);
  const Fp122 = new _Field12(Fp62, opts2);
  return { Fp: Fp4, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122 };
}

// node_modules/@noble/curves/esm/bls12-381.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n4 = BigInt(2);
var _3n3 = BigInt(3);
var _4n = BigInt(4);
var BLS_X = BigInt("0xd201000000010000");
var BLS_X_LEN = bitLen(BLS_X);
var bls12_381_CURVE_G1 = {
  p: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
  n: BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"),
  h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
  a: _0n4,
  b: _4n,
  Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
  Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1")
};
var bls12_381_Fr = Field2(bls12_381_CURVE_G1.n, {
  modFromBytes: true,
  isLE: true
});
var { Fp, Fp2, Fp6, Fp12 } = tower12({
  ORDER: bls12_381_CURVE_G1.p,
  X_LEN: BLS_X_LEN,
  // Finite extension field over irreducible polynominal.
  // Fp(u) / (u - ) where  = -1
  FP2_NONRESIDUE: [_1n4, _1n4],
  Fp2mulByB: ({ c0, c1 }) => {
    const t0 = Fp.mul(c0, _4n);
    const t1 = Fp.mul(c1, _4n);
    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };
  },
  Fp12finalExponentiate: (num3) => {
    const x7 = BLS_X;
    const t0 = Fp12.div(Fp12.frobeniusMap(num3, 6), num3);
    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
    const t22 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x7));
    const t32 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t22);
    const t42 = Fp12.conjugate(Fp12._cyclotomicExp(t32, x7));
    const t52 = Fp12.conjugate(Fp12._cyclotomicExp(t42, x7));
    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t52, x7)), Fp12._cyclotomicSquare(t22));
    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x7));
    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t22, t52), 2);
    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t42, t1), 3);
    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t32)), t1);
    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
  }
});
var { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE));
var htfDefaults = Object.freeze({
  DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  p: Fp.ORDER,
  m: 2,
  k: 128,
  expand: "xmd",
  hash: sha256
});
var bls12_381_CURVE_G2 = {
  p: Fp2.ORDER,
  n: bls12_381_CURVE_G1.n,
  h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
  a: Fp2.ZERO,
  b: Fp2.fromBigTuple([_4n, _4n]),
  Gx: Fp2.fromBigTuple([
    BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),
    BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
  ]),
  Gy: Fp2.fromBigTuple([
    BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),
    BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")
  ])
};
var COMPZERO = setMask(Fp.toBytes(_0n4), { infinity: true, compressed: true });
function parseMask(bytes2) {
  bytes2 = bytes2.slice();
  const mask = bytes2[0] & 224;
  const compressed = !!(mask >> 7 & 1);
  const infinity = !!(mask >> 6 & 1);
  const sort = !!(mask >> 5 & 1);
  bytes2[0] &= 31;
  return { compressed, infinity, sort, value: bytes2 };
}
function setMask(bytes2, mask) {
  if (bytes2[0] & 224)
    throw new Error("setMask: non-empty mask");
  if (mask.compressed)
    bytes2[0] |= 128;
  if (mask.infinity)
    bytes2[0] |= 64;
  if (mask.sort)
    bytes2[0] |= 32;
  return bytes2;
}
function pointG1ToBytes(_c3, point, isComp) {
  const { BYTES: L7, ORDER: P7 } = Fp;
  const is0 = point.is0();
  const { x: x7, y: y11 } = point.toAffine();
  if (isComp) {
    if (is0)
      return COMPZERO.slice();
    const sort = Boolean(y11 * _2n4 / P7);
    return setMask(numberToBytesBE(x7, L7), { compressed: true, sort });
  } else {
    if (is0) {
      return concatBytes(Uint8Array.of(64), new Uint8Array(2 * L7 - 1));
    } else {
      return concatBytes(numberToBytesBE(x7, L7), numberToBytesBE(y11, L7));
    }
  }
}
function signatureG1ToBytes(point) {
  point.assertValidity();
  const { BYTES: L7, ORDER: P7 } = Fp;
  const { x: x7, y: y11 } = point.toAffine();
  if (point.is0())
    return COMPZERO.slice();
  const sort = Boolean(y11 * _2n4 / P7);
  return setMask(numberToBytesBE(x7, L7), { compressed: true, sort });
}
function pointG1FromBytes(bytes2) {
  const { compressed, infinity, sort, value: value2 } = parseMask(bytes2);
  const { BYTES: L7, ORDER: P7 } = Fp;
  if (value2.length === 48 && compressed) {
    const compressedValue = bytesToNumberBE(value2);
    const x7 = Fp.create(compressedValue & bitMask(Fp.BITS));
    if (infinity) {
      if (x7 !== _0n4)
        throw new Error("invalid G1 point: non-empty, at infinity, with compression");
      return { x: _0n4, y: _0n4 };
    }
    const right13 = Fp.add(Fp.pow(x7, _3n3), Fp.create(bls12_381_CURVE_G1.b));
    let y11 = Fp.sqrt(right13);
    if (!y11)
      throw new Error("invalid G1 point: compressed point");
    if (y11 * _2n4 / P7 !== BigInt(sort))
      y11 = Fp.neg(y11);
    return { x: Fp.create(x7), y: Fp.create(y11) };
  } else if (value2.length === 96 && !compressed) {
    const x7 = bytesToNumberBE(value2.subarray(0, L7));
    const y11 = bytesToNumberBE(value2.subarray(L7));
    if (infinity) {
      if (x7 !== _0n4 || y11 !== _0n4)
        throw new Error("G1: non-empty point at infinity");
      return bls12_381.G1.Point.ZERO.toAffine();
    }
    return { x: Fp.create(x7), y: Fp.create(y11) };
  } else {
    throw new Error("invalid G1 point: expected 48/96 bytes");
  }
}
function signatureG1FromBytes(hex2) {
  const { infinity, sort, value: value2 } = parseMask(ensureBytes("signatureHex", hex2, 48));
  const P7 = Fp.ORDER;
  const Point3 = bls12_381.G1.Point;
  const compressedValue = bytesToNumberBE(value2);
  if (infinity)
    return Point3.ZERO;
  const x7 = Fp.create(compressedValue & bitMask(Fp.BITS));
  const right13 = Fp.add(Fp.pow(x7, _3n3), Fp.create(bls12_381_CURVE_G1.b));
  let y11 = Fp.sqrt(right13);
  if (!y11)
    throw new Error("invalid G1 point: compressed");
  const aflag = BigInt(sort);
  if (y11 * _2n4 / P7 !== aflag)
    y11 = Fp.neg(y11);
  const point = Point3.fromAffine({ x: x7, y: y11 });
  point.assertValidity();
  return point;
}
function pointG2ToBytes(_c3, point, isComp) {
  const { BYTES: L7, ORDER: P7 } = Fp;
  const is0 = point.is0();
  const { x: x7, y: y11 } = point.toAffine();
  if (isComp) {
    if (is0)
      return concatBytes(COMPZERO, numberToBytesBE(_0n4, L7));
    const flag = Boolean(y11.c1 === _0n4 ? y11.c0 * _2n4 / P7 : y11.c1 * _2n4 / P7);
    return concatBytes(setMask(numberToBytesBE(x7.c1, L7), { compressed: true, sort: flag }), numberToBytesBE(x7.c0, L7));
  } else {
    if (is0)
      return concatBytes(Uint8Array.of(64), new Uint8Array(4 * L7 - 1));
    const { re: x0, im: x1 } = Fp2.reim(x7);
    const { re: y0, im: y1 } = Fp2.reim(y11);
    return concatBytes(numberToBytesBE(x1, L7), numberToBytesBE(x0, L7), numberToBytesBE(y1, L7), numberToBytesBE(y0, L7));
  }
}
function signatureG2ToBytes(point) {
  point.assertValidity();
  const { BYTES: L7 } = Fp;
  if (point.is0())
    return concatBytes(COMPZERO, numberToBytesBE(_0n4, L7));
  const { x: x7, y: y11 } = point.toAffine();
  const { re: x0, im: x1 } = Fp2.reim(x7);
  const { re: y0, im: y1 } = Fp2.reim(y11);
  const tmp = y1 > _0n4 ? y1 * _2n4 : y0 * _2n4;
  const sort = Boolean(tmp / Fp.ORDER & _1n4);
  const z22 = x0;
  return concatBytes(setMask(numberToBytesBE(x1, L7), { sort, compressed: true }), numberToBytesBE(z22, L7));
}
function pointG2FromBytes(bytes2) {
  const { BYTES: L7, ORDER: P7 } = Fp;
  const { compressed, infinity, sort, value: value2 } = parseMask(bytes2);
  if (!compressed && !infinity && sort || // 00100000
  !compressed && infinity && sort || // 01100000
  sort && infinity && compressed) {
    throw new Error("invalid encoding flag: " + (bytes2[0] & 224));
  }
  const slc = (b6, from40, to6) => bytesToNumberBE(b6.slice(from40, to6));
  if (value2.length === 96 && compressed) {
    if (infinity) {
      if (value2.reduce((p9, c9) => p9 !== 0 ? c9 + 1 : c9, 0) > 0) {
        throw new Error("invalid G2 point: compressed");
      }
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    }
    const x_1 = slc(value2, 0, L7);
    const x_0 = slc(value2, L7, 2 * L7);
    const x7 = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });
    const right13 = Fp2.add(Fp2.pow(x7, _3n3), bls12_381_CURVE_G2.b);
    let y11 = Fp2.sqrt(right13);
    const Y_bit = y11.c1 === _0n4 ? y11.c0 * _2n4 / P7 : y11.c1 * _2n4 / P7 ? _1n4 : _0n4;
    y11 = sort && Y_bit > 0 ? y11 : Fp2.neg(y11);
    return { x: x7, y: y11 };
  } else if (value2.length === 192 && !compressed) {
    if (infinity) {
      if (value2.reduce((p9, c9) => p9 !== 0 ? c9 + 1 : c9, 0) > 0) {
        throw new Error("invalid G2 point: uncompressed");
      }
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    }
    const x1 = slc(value2, 0 * L7, 1 * L7);
    const x0 = slc(value2, 1 * L7, 2 * L7);
    const y1 = slc(value2, 2 * L7, 3 * L7);
    const y0 = slc(value2, 3 * L7, 4 * L7);
    return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };
  } else {
    throw new Error("invalid G2 point: expected 96/192 bytes");
  }
}
function signatureG2FromBytes(hex2) {
  const { ORDER: P7 } = Fp;
  const { infinity, sort, value: value2 } = parseMask(ensureBytes("signatureHex", hex2));
  const Point3 = bls12_381.G2.Point;
  const half = value2.length / 2;
  if (half !== 48 && half !== 96)
    throw new Error("invalid compressed signature length, expected 96/192 bytes");
  const z1 = bytesToNumberBE(value2.slice(0, half));
  const z22 = bytesToNumberBE(value2.slice(half));
  if (infinity)
    return Point3.ZERO;
  const x1 = Fp.create(z1 & bitMask(Fp.BITS));
  const x22 = Fp.create(z22);
  const x7 = Fp2.create({ c0: x22, c1: x1 });
  const y22 = Fp2.add(Fp2.pow(x7, _3n3), bls12_381_CURVE_G2.b);
  let y11 = Fp2.sqrt(y22);
  if (!y11)
    throw new Error("Failed to find a square root");
  const { re: y0, im: y1 } = Fp2.reim(y11);
  const aflag1 = BigInt(sort);
  const isGreater = y1 > _0n4 && y1 * _2n4 / P7 !== aflag1;
  const is0 = y1 === _0n4 && y0 * _2n4 / P7 !== aflag1;
  if (isGreater || is0)
    y11 = Fp2.neg(y11);
  const point = Point3.fromAffine({ x: x7, y: y11 });
  point.assertValidity();
  return point;
}
var bls12_381 = bls({
  // Fields
  fields: {
    Fp,
    Fp2,
    Fp6,
    Fp12,
    Fr: bls12_381_Fr
  },
  // G1: y = x + 4
  G1: {
    ...bls12_381_CURVE_G1,
    Fp,
    htfDefaults: { ...htfDefaults, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    isTorsionFree: (c9, point) => {
      const beta = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
      const phi = new c9(Fp.mul(point.X, beta), point.Y, point.Z);
      const xP = point.multiplyUnsafe(BLS_X).negate();
      const u2P = xP.multiplyUnsafe(BLS_X);
      return u2P.equals(phi);
    },
    // Clear cofactor of G1
    // https://eprint.iacr.org/2019/403
    clearCofactor: (_c3, point) => {
      return point.multiplyUnsafe(BLS_X).add(point);
    },
    mapToCurve: mapToG1,
    fromBytes: pointG1FromBytes,
    toBytes: pointG1ToBytes,
    ShortSignature: {
      fromBytes(bytes2) {
        abytes(bytes2);
        return signatureG1FromBytes(bytes2);
      },
      fromHex(hex2) {
        return signatureG1FromBytes(hex2);
      },
      toBytes(point) {
        return signatureG1ToBytes(point);
      },
      toRawBytes(point) {
        return signatureG1ToBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG1ToBytes(point));
      }
    }
  },
  G2: {
    ...bls12_381_CURVE_G2,
    Fp: Fp2,
    // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor
    // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12
    hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
    htfDefaults: { ...htfDefaults },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    mapToCurve: mapToG2,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    // Older version: https://eprint.iacr.org/2019/814.pdf
    isTorsionFree: (c9, P7) => {
      return P7.multiplyUnsafe(BLS_X).negate().equals(G2psi(c9, P7));
    },
    // Maps the point into the prime-order subgroup G2.
    // clear_cofactor_bls12381_g2 from RFC 9380.
    // https://eprint.iacr.org/2017/419.pdf
    // prettier-ignore
    clearCofactor: (c9, P7) => {
      const x7 = BLS_X;
      let t1 = P7.multiplyUnsafe(x7).negate();
      let t22 = G2psi(c9, P7);
      let t32 = P7.double();
      t32 = G2psi2(c9, t32);
      t32 = t32.subtract(t22);
      t22 = t1.add(t22);
      t22 = t22.multiplyUnsafe(x7).negate();
      t32 = t32.add(t22);
      t32 = t32.subtract(t1);
      const Q7 = t32.subtract(P7);
      return Q7;
    },
    fromBytes: pointG2FromBytes,
    toBytes: pointG2ToBytes,
    Signature: {
      fromBytes(bytes2) {
        abytes(bytes2);
        return signatureG2FromBytes(bytes2);
      },
      fromHex(hex2) {
        return signatureG2FromBytes(hex2);
      },
      toBytes(point) {
        return signatureG2ToBytes(point);
      },
      toRawBytes(point) {
        return signatureG2ToBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG2ToBytes(point));
      }
    }
  },
  params: {
    ateLoopSize: BLS_X,
    // The BLS parameter x for BLS12-381
    r: bls12_381_CURVE_G1.n,
    // order; z  z + 1; CURVE.n from other curves
    xNegative: true,
    twistType: "multiplicative"
  },
  htfDefaults,
  hash: sha256
});
var isogenyMapG2 = isogenyMap(Fp2, [
  // xNum
  [
    [
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"
    ],
    [
      "0x0",
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"
    ],
    [
      "0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1",
      "0x0"
    ]
  ],
  // xDen
  [
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"
    ],
    [
      "0xc",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ],
  // yNum
  [
    [
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706",
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"
    ],
    [
      "0x0",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"
    ],
    [
      "0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10",
      "0x0"
    ]
  ],
  // yDen
  [
    [
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"
    ],
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"
    ],
    [
      "0x12",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ]
].map((i9) => i9.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));
var isogenyMapG1 = isogenyMap(Fp, [
  // xNum
  [
    "0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7",
    "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb",
    "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0",
    "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861",
    "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9",
    "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983",
    "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84",
    "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e",
    "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317",
    "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e",
    "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b",
    "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"
  ],
  // xDen
  [
    "0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c",
    "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff",
    "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19",
    "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8",
    "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e",
    "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5",
    "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a",
    "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e",
    "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641",
    "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33",
    "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696",
    "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6",
    "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb",
    "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb",
    "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0",
    "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2",
    "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29",
    "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587",
    "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30",
    "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132",
    "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e",
    "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8",
    "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133",
    "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b",
    "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"
  ],
  // yDen
  [
    "0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1",
    "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d",
    "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2",
    "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416",
    "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d",
    "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac",
    "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c",
    "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9",
    "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a",
    "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55",
    "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8",
    "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092",
    "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc",
    "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7",
    "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i9) => i9.map((j9) => BigInt(j9))));
var G1_SWU = mapToCurveSimpleSWU2(Fp, {
  A: Fp.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
  B: Fp.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
  Z: Fp.create(BigInt(11))
});
var G2_SWU = mapToCurveSimpleSWU2(Fp2, {
  A: Fp2.create({ c0: Fp.create(_0n4), c1: Fp.create(BigInt(240)) }),
  // A' = 240 * I
  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }),
  // B' = 1012 * (1 + I)
  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) })
  // Z: -(2 + I)
});
function mapToG1(scalars) {
  const { x: x7, y: y11 } = G1_SWU(Fp.create(scalars[0]));
  return isogenyMapG1(x7, y11);
}
function mapToG2(scalars) {
  const { x: x7, y: y11 } = G2_SWU(Fp2.fromBigTuple(scalars));
  return isogenyMapG2(x7, y11);
}

// node_modules/ox/_esm/core/Bls.js
var noble = bls12_381;
function aggregate(points) {
  var _a14;
  const group = typeof ((_a14 = points[0]) == null ? void 0 : _a14.x) === "bigint" ? bls12_381.G1 : bls12_381.G2;
  const point = points.reduce((acc, point2) => acc.add(new group.ProjectivePoint(point2.x, point2.y, point2.z)), group.ProjectivePoint.ZERO);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function getPublicKey(options) {
  const { privateKey, size: size11 = "short-key:long-sig" } = options;
  const group = size11 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const { px, py, pz } = group.ProjectivePoint.fromPrivateKey(from11(privateKey).slice(2));
  return { x: px, y: py, z: pz };
}
function randomPrivateKey(options = {}) {
  const { as: as17 = "Hex" } = options;
  const bytes2 = bls12_381.utils.randomPrivateKey();
  if (as17 === "Hex")
    return fromBytes4(bytes2);
  return bytes2;
}
function sign3(options) {
  const { payload, privateKey, suite, size: size11 = "short-key:long-sig" } = options;
  const payloadGroup = size11 === "short-key:long-sig" ? bls12_381.G2 : bls12_381.G1;
  const payloadPoint = payloadGroup.hashToCurve(from12(payload), suite ? { DST: fromString7(suite) } : void 0);
  const privateKeyGroup = size11 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));
  return {
    x: signature.px,
    y: signature.py,
    z: signature.pz
  };
}
function verify2(options) {
  const { payload, suite } = options;
  const publicKey = options.publicKey;
  const signature = options.signature;
  const isShortSig = typeof signature.x === "bigint";
  const group = isShortSig ? bls12_381.G1 : bls12_381.G2;
  const payloadPoint = group.hashToCurve(from12(payload), suite ? { DST: fromString7(suite) } : void 0);
  const shortSigPairing = () => bls12_381.pairingBatch([
    {
      g1: payloadPoint,
      g2: new bls12_381.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)
    },
    {
      g1: new bls12_381.G1.ProjectivePoint(signature.x, signature.y, signature.z),
      g2: bls12_381.G2.ProjectivePoint.BASE.negate()
    }
  ]);
  const longSigPairing = () => bls12_381.pairingBatch([
    {
      g1: new bls12_381.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),
      g2: payloadPoint
    },
    {
      g1: bls12_381.G1.ProjectivePoint.BASE,
      g2: new bls12_381.G2.ProjectivePoint(signature.x, signature.y, signature.z)
    }
  ]);
  return bls12_381.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls12_381.fields.Fp12.ONE);
}

// node_modules/ox/_esm/core/BlsPoint.js
var BlsPoint_exports = {};
__export(BlsPoint_exports, {
  fromBytes: () => fromBytes10,
  fromHex: () => fromHex13,
  toBytes: () => toBytes12,
  toHex: () => toHex13
});
function toBytes12(point) {
  const group = typeof point.z === "bigint" ? bls12_381.G1 : bls12_381.G2;
  return new group.ProjectivePoint(point.x, point.y, point.z).toRawBytes();
}
function toHex13(point) {
  return fromBytes4(toBytes12(point));
}
function fromBytes10(bytes2) {
  const group = bytes2.length === 48 ? bls12_381.G1 : bls12_381.G2;
  const point = group.ProjectivePoint.fromHex(bytes2);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function fromHex13(hex2, group) {
  return fromBytes10(toBytes5(hex2), group);
}

// node_modules/ox/_esm/core/ContractAddress.js
var ContractAddress_exports = {};
__export(ContractAddress_exports, {
  from: () => from27,
  fromCreate: () => fromCreate,
  fromCreate2: () => fromCreate2
});
function from27(options) {
  if (options.salt)
    return fromCreate2(options);
  return fromCreate(options);
}
function fromCreate(options) {
  const from40 = fromHex7(from14(options.from));
  let nonce = fromNumber4(options.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return from14(`0x${keccak2565(fromBytes6([from40, nonce], { as: "Hex" })).slice(26)}`);
}
function fromCreate2(options) {
  const from40 = fromHex7(from14(options.from));
  const salt = padLeft4(validate6(options.salt) ? options.salt : fromHex7(options.salt), 32);
  const bytecodeHash = (() => {
    if ("bytecodeHash" in options) {
      if (validate6(options.bytecodeHash))
        return options.bytecodeHash;
      return fromHex7(options.bytecodeHash);
    }
    return keccak2565(options.bytecode, { as: "Bytes" });
  })();
  return from14(slice6(keccak2565(concat8(fromHex7("0xff"), from40, salt, bytecodeHash), { as: "Hex" }), 12));
}

// node_modules/ox/_esm/core/Ens.js
var Ens_exports = {};
__export(Ens_exports, {
  labelhash: () => labelhash2,
  namehash: () => namehash3,
  normalize: () => normalize3
});

// node_modules/ox/_esm/core/internal/ens.js
function unwrapLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash9 = `0x${label.slice(1, 65)}`;
  if (!validate5(hash9, { strict: true }))
    return null;
  return hash9;
}

// node_modules/ox/_esm/core/Ens.js
function labelhash2(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return fromBytes4(result);
  return unwrapLabelhash(label) || keccak2565(fromString6(label));
}
function namehash3(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return fromBytes4(result);
  const labels = name.split(".");
  for (let i9 = labels.length - 1; i9 >= 0; i9 -= 1) {
    const hashFromEncodedLabel = unwrapLabelhash(labels[i9]);
    const hashed = hashFromEncodedLabel ? fromHex7(hashFromEncodedLabel) : keccak2565(fromString7(labels[i9]), { as: "Bytes" });
    result = keccak2565(concat8(result, hashed), { as: "Bytes" });
  }
  return fromBytes4(result);
}
function normalize3(name) {
  return ens_normalize(name);
}

// node_modules/ox/_esm/core/Filter.js
var Filter_exports = {};
__export(Filter_exports, {
  fromRpc: () => fromRpc12,
  toRpc: () => toRpc13
});
function fromRpc12(filter10) {
  const { fromBlock, toBlock } = filter10;
  return {
    ...filter10,
    ...fromBlock && {
      fromBlock: validate5(fromBlock, { strict: false }) ? BigInt(fromBlock) : fromBlock
    },
    ...toBlock && {
      toBlock: validate5(toBlock, { strict: false }) ? BigInt(toBlock) : toBlock
    }
  };
}
function toRpc13(filter10) {
  const { address, topics, fromBlock, toBlock } = filter10;
  return {
    ...address && { address },
    ...topics && { topics },
    ...typeof fromBlock !== "undefined" ? {
      fromBlock: typeof fromBlock === "bigint" ? fromNumber3(fromBlock) : fromBlock
    } : {},
    ...typeof toBlock !== "undefined" ? {
      toBlock: typeof toBlock === "bigint" ? fromNumber3(toBlock) : toBlock
    } : {}
  };
}

// node_modules/ox/_esm/core/HdKey.js
var HdKey_exports = {};
__export(HdKey_exports, {
  fromExtendedKey: () => fromExtendedKey,
  fromJson: () => fromJson,
  fromSeed: () => fromSeed,
  path: () => path
});

// node_modules/ox/_esm/core/Secp256k1.js
var Secp256k1_exports = {};
__export(Secp256k1_exports, {
  getPublicKey: () => getPublicKey2,
  noble: () => noble2,
  randomPrivateKey: () => randomPrivateKey2,
  recoverAddress: () => recoverAddress2,
  recoverPublicKey: () => recoverPublicKey2,
  sign: () => sign4,
  verify: () => verify3
});

// node_modules/ox/_esm/core/internal/entropy.js
var extraEntropy2 = false;

// node_modules/ox/_esm/core/Secp256k1.js
var noble2 = secp256k1;
function getPublicKey2(options) {
  const { privateKey } = options;
  const point = secp256k1.ProjectivePoint.fromPrivateKey(from11(privateKey).slice(2));
  return from13(point);
}
function randomPrivateKey2(options = {}) {
  const { as: as17 = "Hex" } = options;
  const bytes2 = secp256k1.utils.randomPrivateKey();
  if (as17 === "Hex")
    return fromBytes4(bytes2);
  return bytes2;
}
function recoverAddress2(options) {
  return fromPublicKey(recoverPublicKey2(options));
}
function recoverPublicKey2(options) {
  const { payload, signature } = options;
  const { r: r8, s: s5, yParity } = signature;
  const signature_ = new secp256k1.Signature(BigInt(r8), BigInt(s5)).addRecoveryBit(yParity);
  const point = signature_.recoverPublicKey(from11(payload).substring(2));
  return from13(point);
}
function sign4(options) {
  const { extraEntropy: extraEntropy3 = extraEntropy2, hash: hash9, payload, privateKey } = options;
  const { r: r8, s: s5, recovery } = secp256k1.sign(from12(payload), from12(privateKey), {
    extraEntropy: typeof extraEntropy3 === "boolean" ? extraEntropy3 : from11(extraEntropy3).slice(2),
    lowS: true,
    ...hash9 ? { prehash: true } : {}
  });
  return {
    r: r8,
    s: s5,
    yParity: recovery
  };
}
function verify3(options) {
  const { address, hash: hash9, payload, publicKey, signature } = options;
  if (address)
    return isEqual3(address, recoverAddress2({ payload, signature }));
  return secp256k1.verify(signature, from12(payload), toBytes6(publicKey), ...hash9 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/internal/hdKey.js
function fromScure(key) {
  return {
    derive: (path2) => fromScure(key.derive(path2)),
    depth: key.depth,
    identifier: fromBytes4(key.identifier),
    index: key.index,
    privateKey: fromBytes4(key.privateKey),
    privateExtendedKey: key.privateExtendedKey,
    publicKey: getPublicKey2({ privateKey: key.privateKey }),
    publicExtendedKey: key.publicExtendedKey,
    versions: key.versions
  };
}

// node_modules/ox/_esm/core/HdKey.js
function fromExtendedKey(extendedKey) {
  const key = HDKey.fromExtendedKey(extendedKey);
  return fromScure(key);
}
function fromJson(json) {
  return fromScure(HDKey.fromJSON(json));
}
function fromSeed(seed, options = {}) {
  const { versions } = options;
  const key = HDKey.fromMasterSeed(from12(seed), versions);
  return fromScure(key);
}
function path(options = {}) {
  const { account: account2 = 0, change = 0, index: index2 = 0 } = options;
  return `m/44'/60'/${account2}'/${change}/${index2}`;
}

// node_modules/ox/_esm/core/Fee.js
var Fee_exports = {};

// node_modules/ox/_esm/core/Log.js
var Log_exports2 = {};
__export(Log_exports2, {
  fromRpc: () => fromRpc13,
  toRpc: () => toRpc14
});
function fromRpc13(log, _options = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null
  };
}
function toRpc14(log, _options = {}) {
  return {
    address: log.address,
    blockHash: log.blockHash,
    blockNumber: typeof log.blockNumber === "bigint" ? fromNumber3(log.blockNumber) : null,
    data: log.data,
    logIndex: typeof log.logIndex === "number" ? fromNumber3(log.logIndex) : null,
    topics: log.topics,
    transactionHash: log.transactionHash,
    transactionIndex: typeof log.transactionIndex === "number" ? fromNumber3(log.transactionIndex) : null,
    removed: log.removed
  };
}

// node_modules/ox/_esm/core/Mnemonic.js
var Mnemonic_exports = {};
__export(Mnemonic_exports, {
  czech: () => wordlist,
  english: () => wordlist2,
  french: () => wordlist3,
  italian: () => wordlist4,
  japanese: () => wordlist5,
  korean: () => wordlist6,
  path: () => path,
  portuguese: () => wordlist7,
  random: () => random3,
  simplifiedChinese: () => wordlist8,
  spanish: () => wordlist9,
  toHdKey: () => toHdKey,
  toPrivateKey: () => toPrivateKey,
  toSeed: () => toSeed,
  traditionalChinese: () => wordlist10,
  validate: () => validate12
});
function random3(wordlist11, options = {}) {
  const { strength = 128 } = options;
  return generateMnemonic(wordlist11, strength);
}
function toHdKey(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = toSeed(mnemonic, { passphrase });
  return fromSeed(seed);
}
function toPrivateKey(mnemonic, options = {}) {
  const { path: path2 = path(), passphrase } = options;
  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path2);
  if (options.as === "Bytes")
    return from12(hdKey.privateKey);
  return hdKey.privateKey;
}
function toSeed(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = mnemonicToSeedSync(mnemonic, passphrase);
  if (options.as === "Hex")
    return toHex6(seed);
  return seed;
}
function validate12(mnemonic, wordlist11) {
  return validateMnemonic(mnemonic, wordlist11);
}

// node_modules/ox/_esm/core/PersonalMessage.js
var PersonalMessage_exports = {};
__export(PersonalMessage_exports, {
  encode: () => encode12,
  getSignPayload: () => getSignPayload4
});
function encode12(data) {
  const message = from11(data);
  return concat7(
    // Personal Sign Format: `0x19  "Ethereum Signed Message:\n"  message.length  message`
    "0x19",
    fromString6("Ethereum Signed Message:\n" + size7(message)),
    message
  );
}
function getSignPayload4(data) {
  return keccak2565(encode12(data));
}

// node_modules/ox/_esm/core/Provider.js
var Provider_exports = {};
__export(Provider_exports, {
  ChainDisconnectedError: () => ChainDisconnectedError2,
  DisconnectedError: () => DisconnectedError,
  IsUndefinedError: () => IsUndefinedError,
  ProviderRpcError: () => ProviderRpcError3,
  UnauthorizedError: () => UnauthorizedError,
  UnsupportedMethodError: () => UnsupportedMethodError,
  UserRejectedRequestError: () => UserRejectedRequestError4,
  createEmitter: () => createEmitter,
  from: () => from29,
  parseError: () => parseError2
});

// node_modules/ox/_esm/core/RpcResponse.js
var RpcResponse_exports = {};
__export(RpcResponse_exports, {
  BaseError: () => BaseError7,
  InternalError: () => InternalError,
  InvalidInputError: () => InvalidInputError4,
  InvalidParamsError: () => InvalidParamsError,
  InvalidRequestError: () => InvalidRequestError,
  LimitExceededError: () => LimitExceededError,
  MethodNotFoundError: () => MethodNotFoundError,
  MethodNotSupportedError: () => MethodNotSupportedError,
  ParseError: () => ParseError,
  ResourceNotFoundError: () => ResourceNotFoundError,
  ResourceUnavailableError: () => ResourceUnavailableError,
  TransactionRejectedError: () => TransactionRejectedError,
  VersionNotSupportedError: () => VersionNotSupportedError,
  from: () => from28,
  parse: () => parse2,
  parseError: () => parseError
});
function from28(response, options = {}) {
  const { request: request2 } = options;
  return {
    ...response,
    id: response.id ?? (request2 == null ? void 0 : request2.id),
    jsonrpc: response.jsonrpc ?? request2.jsonrpc
  };
}
function parse2(response, options = {}) {
  const { raw = false } = options;
  const response_ = response;
  if (raw)
    return response;
  if (response_.error)
    throw parseError(response_.error);
  return response_.result;
}
function parseError(errorObject) {
  const errorObject_ = errorObject;
  const { code } = errorObject_;
  if (code === InternalError.code)
    return new InternalError(errorObject_);
  if (code === InvalidInputError4.code)
    return new InvalidInputError4(errorObject_);
  if (code === InvalidParamsError.code)
    return new InvalidParamsError(errorObject_);
  if (code === InvalidRequestError.code)
    return new InvalidRequestError(errorObject_);
  if (code === LimitExceededError.code)
    return new LimitExceededError(errorObject_);
  if (code === MethodNotFoundError.code)
    return new MethodNotFoundError(errorObject_);
  if (code === MethodNotSupportedError.code)
    return new MethodNotSupportedError(errorObject_);
  if (code === ParseError.code)
    return new ParseError(errorObject_);
  if (code === ResourceNotFoundError.code)
    return new ResourceNotFoundError(errorObject_);
  if (code === ResourceUnavailableError.code)
    return new ResourceUnavailableError(errorObject_);
  if (code === TransactionRejectedError.code)
    return new TransactionRejectedError(errorObject_);
  if (code === VersionNotSupportedError.code)
    return new VersionNotSupportedError(errorObject_);
  return new InternalError({
    data: errorObject_,
    message: errorObject_.message
  });
}
var BaseError7 = class extends Error {
  constructor(errorObject) {
    const { code, message, data } = errorObject;
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.BaseError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.data = data;
  }
};
var InvalidInputError4 = class _InvalidInputError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _InvalidInputError.code,
      data: parameters.data,
      message: parameters.message ?? "Missing or invalid parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidInputError"
    });
  }
};
Object.defineProperty(InvalidInputError4, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var ResourceNotFoundError = class _ResourceNotFoundError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _ResourceNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not found."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceNotFoundError"
    });
  }
};
Object.defineProperty(ResourceNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceUnavailableError = class _ResourceUnavailableError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _ResourceUnavailableError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not available."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceUnavailableError"
    });
  }
};
Object.defineProperty(ResourceUnavailableError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var TransactionRejectedError = class _TransactionRejectedError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _TransactionRejectedError.code,
      data: parameters.data,
      message: parameters.message ?? "Transaction creation failed."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.TransactionRejectedError"
    });
  }
};
Object.defineProperty(TransactionRejectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var MethodNotSupportedError = class _MethodNotSupportedError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "Method is not implemented."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotSupportedError"
    });
  }
};
Object.defineProperty(MethodNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var LimitExceededError = class _LimitExceededError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _LimitExceededError.code,
      data: parameters.data,
      message: parameters.message ?? "Rate limit exceeded."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.LimitExceededError"
    });
  }
};
Object.defineProperty(LimitExceededError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var VersionNotSupportedError = class _VersionNotSupportedError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _VersionNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "JSON-RPC version not supported."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.VersionNotSupportedError"
    });
  }
};
Object.defineProperty(VersionNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var InvalidRequestError = class _InvalidRequestError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _InvalidRequestError.code,
      data: parameters.data,
      message: parameters.message ?? "Input is not a valid JSON-RPC request."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidRequestError"
    });
  }
};
Object.defineProperty(InvalidRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var MethodNotFoundError = class _MethodNotFoundError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Method does not exist."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotFoundError"
    });
  }
};
Object.defineProperty(MethodNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var InvalidParamsError = class _InvalidParamsError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _InvalidParamsError.code,
      data: parameters.data,
      message: parameters.message ?? "Invalid method parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidParamsError"
    });
  }
};
Object.defineProperty(InvalidParamsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InternalError = class _InternalError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _InternalError.code,
      data: parameters.data,
      message: parameters.message ?? "Internal JSON-RPC error."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InternalError"
    });
  }
};
Object.defineProperty(InternalError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var ParseError = class _ParseError extends BaseError7 {
  constructor(parameters = {}) {
    super({
      code: _ParseError.code,
      data: parameters.data,
      message: parameters.message ?? "Failed to parse JSON-RPC response."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ParseError"
    });
  }
};
Object.defineProperty(ParseError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});

// node_modules/ox/_esm/core/Provider.js
var ProviderRpcError3 = class extends Error {
  constructor(code, message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.details = message;
  }
};
var UserRejectedRequestError4 = class extends ProviderRpcError3 {
  constructor({ message = "The user rejected the request." } = {}) {
    super(4001, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError4, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UnauthorizedError = class extends ProviderRpcError3 {
  constructor({ message = "The requested method and/or account has not been authorized by the user." } = {}) {
    super(4100, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnauthorizedError"
    });
  }
};
Object.defineProperty(UnauthorizedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnsupportedMethodError = class extends ProviderRpcError3 {
  constructor({ message = "The provider does not support the requested method." } = {}) {
    super(4200, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedMethodError"
    });
  }
};
Object.defineProperty(UnsupportedMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var DisconnectedError = class extends ProviderRpcError3 {
  constructor({ message = "The provider is disconnected from all chains." } = {}) {
    super(4900, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DisconnectedError"
    });
  }
};
Object.defineProperty(DisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ChainDisconnectedError2 = class extends ProviderRpcError3 {
  constructor({ message = "The provider is not connected to the requested chain." } = {}) {
    super(4901, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
function createEmitter() {
  const emitter = new import_index.default();
  return {
    get eventNames() {
      return emitter.eventNames.bind(emitter);
    },
    get listenerCount() {
      return emitter.listenerCount.bind(emitter);
    },
    get listeners() {
      return emitter.listeners.bind(emitter);
    },
    addListener: emitter.addListener.bind(emitter),
    emit: emitter.emit.bind(emitter),
    off: emitter.off.bind(emitter),
    on: emitter.on.bind(emitter),
    once: emitter.once.bind(emitter),
    removeAllListeners: emitter.removeAllListeners.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter)
  };
}
function from29(provider, options = {}) {
  var _a14, _b;
  const { includeEvents = true } = options;
  if (!provider)
    throw new IsUndefinedError();
  return {
    ...includeEvents ? {
      on: (_a14 = provider.on) == null ? void 0 : _a14.bind(provider),
      removeListener: (_b = provider.removeListener) == null ? void 0 : _b.bind(provider)
    } : {},
    async request(args) {
      try {
        const result = await provider.request(args);
        if (result && typeof result === "object" && "jsonrpc" in result)
          return parse2(result);
        return result;
      } catch (error) {
        throw parseError2(error);
      }
    }
  };
}
function parseError2(errorObject) {
  const errorObject_ = errorObject;
  const error = parseError(errorObject_);
  if (error instanceof InternalError) {
    if (!error.data)
      return error;
    const { code } = error.data;
    if (code === DisconnectedError.code)
      return new DisconnectedError(errorObject_);
    if (code === ChainDisconnectedError2.code)
      return new ChainDisconnectedError2(errorObject_);
    if (code === UserRejectedRequestError4.code)
      return new UserRejectedRequestError4(errorObject_);
    if (code === UnauthorizedError.code)
      return new UnauthorizedError(errorObject_);
    if (code === UnsupportedMethodError.code)
      return new UnsupportedMethodError(errorObject_);
  }
  return error;
}
var IsUndefinedError = class extends BaseError6 {
  constructor() {
    super("`provider` is undefined.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.IsUndefinedError"
    });
  }
};

// node_modules/ox/_esm/core/RpcSchema.js
var RpcSchema_exports2 = {};
__export(RpcSchema_exports2, {
  from: () => from30
});
function from30() {
  return null;
}

// node_modules/ox/_esm/core/RpcRequest.js
var RpcRequest_exports = {};
__export(RpcRequest_exports, {
  createStore: () => createStore3,
  from: () => from31
});
function createStore3(options = {}) {
  let id2 = options.id ?? 0;
  return {
    prepare(options2) {
      return from31({
        id: id2++,
        ...options2
      });
    },
    get id() {
      return id2;
    }
  };
}
function from31(options) {
  return {
    ...options,
    jsonrpc: "2.0"
  };
}

// node_modules/ox/_esm/core/RpcTransport.js
var RpcTransport_exports = {};
__export(RpcTransport_exports, {
  HttpError: () => HttpError,
  MalformedResponseError: () => MalformedResponseError,
  fromHttp: () => fromHttp
});

// node_modules/ox/_esm/core/internal/promise.js
function withTimeout2(fn4, options) {
  const { errorInstance = new TimeoutError2(), timeout, signal } = options;
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0)
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        resolve(await fn4({ signal: controller.signal }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
var TimeoutError2 = class extends BaseError6 {
  constructor() {
    super("Operation timed out.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Promise.TimeoutError"
    });
  }
};

// node_modules/ox/_esm/core/internal/rpcTransport.js
function create4(transport, options_root) {
  const requestStore = createStore3();
  return {
    request: async ({ method, params }, options = {}) => {
      const body = requestStore.prepare({ method, params });
      const data = await transport.request(body, options);
      return parse2(data, {
        raw: options.raw ?? (options_root == null ? void 0 : options_root.raw)
      });
    }
  };
}

// node_modules/ox/_esm/core/RpcTransport.js
function fromHttp(url2, options = {}) {
  return create4({
    async request(body_, options_) {
      const { fetchFn = options.fetchFn ?? fetch, fetchOptions: fetchOptions_ = options.fetchOptions, timeout = options.timeout ?? 1e4 } = options_;
      const body = JSON.stringify(body_);
      const fetchOptions = typeof fetchOptions_ === "function" ? await fetchOptions_(body_) : fetchOptions_;
      const response = await withTimeout2(({ signal }) => {
        const init4 = {
          ...fetchOptions,
          body,
          headers: {
            "Content-Type": "application/json",
            ...fetchOptions == null ? void 0 : fetchOptions.headers
          },
          method: (fetchOptions == null ? void 0 : fetchOptions.method) ?? "POST",
          signal: (fetchOptions == null ? void 0 : fetchOptions.signal) ?? (timeout > 0 ? signal : null)
        };
        const request2 = new Request(url2, init4);
        return fetchFn(request2);
      }, {
        timeout,
        signal: true
      });
      const data = await (async () => {
        var _a14;
        if ((_a14 = response.headers.get("Content-Type")) == null ? void 0 : _a14.startsWith("application/json"))
          return response.json();
        return response.text().then((data2) => {
          try {
            return JSON.parse(data2 || "{}");
          } catch (err) {
            if (response.ok)
              throw new MalformedResponseError({
                response: data2
              });
            return { error: data2 };
          }
        });
      })();
      if (!response.ok)
        throw new HttpError({
          body,
          details: JSON.stringify(data.error) ?? response.statusText,
          response,
          url: url2
        });
      return data;
    }
  }, { raw: options.raw });
}
var HttpError = class extends BaseError6 {
  constructor({ body, details, response, url: url2 }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        `Status: ${response.status}`,
        `URL: ${getUrl(url2)}`,
        body ? `Body: ${JSON.stringify(body)}` : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.HttpError"
    });
  }
};
var MalformedResponseError = class extends BaseError6 {
  constructor({ response }) {
    super("HTTP Response could not be parsed as JSON.", {
      metaMessages: [`Response: ${response}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.MalformedResponseError"
    });
  }
};

// node_modules/ox/_esm/core/P256.js
var P256_exports2 = {};
__export(P256_exports2, {
  getPublicKey: () => getPublicKey3,
  noble: () => noble3,
  randomPrivateKey: () => randomPrivateKey3,
  recoverPublicKey: () => recoverPublicKey3,
  sign: () => sign5,
  verify: () => verify4
});
var noble3 = secp256r1;
function getPublicKey3(options) {
  const { privateKey } = options;
  const point = secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === "string" ? privateKey.slice(2) : fromBytes4(privateKey).slice(2));
  return from13(point);
}
function randomPrivateKey3(options = {}) {
  const { as: as17 = "Hex" } = options;
  const bytes2 = secp256r1.utils.randomPrivateKey();
  if (as17 === "Hex")
    return fromBytes4(bytes2);
  return bytes2;
}
function recoverPublicKey3(options) {
  const { payload, signature } = options;
  const { r: r8, s: s5, yParity } = signature;
  const signature_ = new secp256r1.Signature(BigInt(r8), BigInt(s5)).addRecoveryBit(yParity);
  const payload_ = payload instanceof Uint8Array ? fromBytes4(payload) : payload;
  const point = signature_.recoverPublicKey(payload_.substring(2));
  return from13(point);
}
function sign5(options) {
  const { extraEntropy: extraEntropy3 = extraEntropy2, hash: hash9, payload, privateKey } = options;
  const { r: r8, s: s5, recovery } = secp256r1.sign(payload instanceof Uint8Array ? payload : fromHex7(payload), privateKey instanceof Uint8Array ? privateKey : fromHex7(privateKey), {
    extraEntropy: typeof extraEntropy3 === "boolean" ? extraEntropy3 : from11(extraEntropy3).slice(2),
    lowS: true,
    ...hash9 ? { prehash: true } : {}
  });
  return {
    r: r8,
    s: s5,
    yParity: recovery
  };
}
function verify4(options) {
  const { hash: hash9, payload, publicKey, signature } = options;
  return secp256r1.verify(signature, payload instanceof Uint8Array ? payload : fromHex7(payload), toHex7(publicKey).substring(2), ...hash9 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/Siwe.js
var Siwe_exports = {};
__export(Siwe_exports, {
  InvalidMessageFieldError: () => InvalidMessageFieldError,
  createMessage: () => createMessage,
  domainRegex: () => domainRegex,
  generateNonce: () => generateNonce,
  ipRegex: () => ipRegex,
  isUri: () => isUri,
  localhostRegex: () => localhostRegex,
  nonceRegex: () => nonceRegex,
  parseMessage: () => parseMessage,
  prefixRegex: () => prefixRegex,
  schemeRegex: () => schemeRegex,
  suffixRegex: () => suffixRegex,
  validateMessage: () => validateMessage
});

// node_modules/ox/_esm/core/internal/uid.js
var size8 = 256;
var index = size8;
var buffer;
function uid2(length = 11) {
  if (!buffer || index + length > size8 * 2) {
    buffer = "";
    index = 0;
    for (let i9 = 0; i9 < size8; i9++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length);
}

// node_modules/ox/_esm/core/Siwe.js
var domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;
var ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;
var localhostRegex = /^localhost(:[0-9]{1,5})?$/;
var nonceRegex = /^[a-zA-Z0-9]{8,}$/;
var schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function createMessage(value2) {
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version11 } = value2;
  {
    if (chainId !== Math.floor(chainId))
      throw new InvalidMessageFieldError({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${chainId}`
        ]
      });
    if (!(domainRegex.test(domain) || ipRegex.test(domain) || localhostRegex.test(domain)))
      throw new InvalidMessageFieldError({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${domain}`
        ]
      });
    if (!nonceRegex.test(nonce))
      throw new InvalidMessageFieldError({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${nonce}`
        ]
      });
    if (!isUri(uri))
      throw new InvalidMessageFieldError({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${uri}`
        ]
      });
    if (version11 !== "1")
      throw new InvalidMessageFieldError({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${version11}`
        ]
      });
    if (scheme && !schemeRegex.test(scheme))
      throw new InvalidMessageFieldError({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${scheme}`
        ]
      });
    const statement2 = value2.statement;
    if (statement2 == null ? void 0 : statement2.includes("\n"))
      throw new InvalidMessageFieldError({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${statement2}`
        ]
      });
  }
  const address = from14(value2.address, { checksum: true });
  const origin3 = (() => {
    if (scheme)
      return `${scheme}://${domain}`;
    return domain;
  })();
  const statement = (() => {
    if (!value2.statement)
      return "";
    return `${value2.statement}
`;
  })();
  const prefix = `${origin3} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version11}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!isUri(resource))
        throw new InvalidMessageFieldError({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${resource}`
          ]
        });
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
function generateNonce() {
  return uid2(96);
}
function isUri(value2) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value2))
    return false;
  if (/%[^0-9a-f]/i.test(value2))
    return false;
  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value2))
    return false;
  const splitted = splitUri(value2);
  const scheme = splitted[1];
  const authority = splitted[2];
  const path2 = splitted[3];
  const query = splitted[4];
  const fragment = splitted[5];
  if (!((scheme == null ? void 0 : scheme.length) && path2 && path2.length >= 0))
    return false;
  if (authority == null ? void 0 : authority.length) {
    if (!(path2.length === 0 || /^\//.test(path2)))
      return false;
  } else {
    if (/^\/\//.test(path2))
      return false;
  }
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
    return false;
  let out = "";
  out += `${scheme}:`;
  if (authority == null ? void 0 : authority.length)
    out += `//${authority}`;
  out += path2;
  if (query == null ? void 0 : query.length)
    out += `?${query}`;
  if (fragment == null ? void 0 : fragment.length)
    out += `#${fragment}`;
  return out;
}
function splitUri(value2) {
  return value2.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function parseMessage(message) {
  var _a14, _b, _c3;
  const { scheme, statement, ...prefix } = ((_a14 = message.match(prefixRegex)) == null ? void 0 : _a14.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b = message.match(suffixRegex)) == null ? void 0 : _b.groups) ?? {};
  const resources = (_c3 = message.split("Resources:")[1]) == null ? void 0 : _c3.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
function validateMessage(value2) {
  const { address, domain, message, nonce, scheme, time = /* @__PURE__ */ new Date() } = value2;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time >= message.expirationTime)
    return false;
  if (message.notBefore && time < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isEqual3(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}
var InvalidMessageFieldError = class extends BaseError6 {
  constructor(parameters) {
    const { field, metaMessages } = parameters;
    super(`Invalid Sign-In with Ethereum message field "${field}".`, {
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Siwe.InvalidMessageFieldError"
    });
  }
};

// node_modules/ox/_esm/core/StateOverrides.js
var StateOverrides_exports = {};
__export(StateOverrides_exports, {
  fromRpc: () => fromRpc14,
  toRpc: () => toRpc15
});
function fromRpc14(rpcStateOverrides) {
  const stateOverrides = {};
  for (const [address, accountOverridesRpc] of Object.entries(rpcStateOverrides)) {
    const accountOverrides = {};
    if (accountOverridesRpc.balance)
      accountOverrides.balance = BigInt(accountOverridesRpc.balance);
    if (accountOverridesRpc.code)
      accountOverrides.code = accountOverridesRpc.code;
    if (accountOverridesRpc.movePrecompileToAddress)
      accountOverrides.movePrecompileToAddress = accountOverridesRpc.movePrecompileToAddress;
    if (accountOverridesRpc.nonce)
      accountOverrides.nonce = BigInt(accountOverridesRpc.nonce);
    if (accountOverridesRpc.state)
      accountOverrides.state = accountOverridesRpc.state;
    if (accountOverridesRpc.stateDiff)
      accountOverrides.stateDiff = accountOverridesRpc.stateDiff;
    stateOverrides[address] = accountOverrides;
  }
  return stateOverrides;
}
function toRpc15(stateOverrides) {
  const rpcStateOverrides = {};
  for (const [address, accountOverrides] of Object.entries(stateOverrides)) {
    const accountOverridesRpc = {};
    if (typeof accountOverrides.balance === "bigint")
      accountOverridesRpc.balance = fromNumber3(accountOverrides.balance);
    if (accountOverrides.code)
      accountOverridesRpc.code = accountOverrides.code;
    if (accountOverrides.movePrecompileToAddress)
      accountOverridesRpc.movePrecompileToAddress = accountOverrides.movePrecompileToAddress;
    if (typeof accountOverrides.nonce === "bigint")
      accountOverridesRpc.nonce = fromNumber3(accountOverrides.nonce);
    if (accountOverrides.state)
      accountOverridesRpc.state = accountOverrides.state;
    if (accountOverrides.stateDiff)
      accountOverridesRpc.stateDiff = accountOverrides.stateDiff;
    rpcStateOverrides[address] = accountOverridesRpc;
  }
  return rpcStateOverrides;
}

// node_modules/ox/_esm/core/TransactionEnvelope.js
var TransactionEnvelope_exports = {};
__export(TransactionEnvelope_exports, {
  FeeCapTooHighError: () => FeeCapTooHighError2,
  GasPriceTooHighError: () => GasPriceTooHighError,
  InvalidChainIdError: () => InvalidChainIdError2,
  InvalidSerializedError: () => InvalidSerializedError,
  TipAboveFeeCapError: () => TipAboveFeeCapError2
});

// node_modules/ox/_esm/core/Value.js
var Value_exports = {};
__export(Value_exports, {
  InvalidDecimalNumberError: () => InvalidDecimalNumberError2,
  exponents: () => exponents,
  format: () => format8,
  formatEther: () => formatEther4,
  formatGwei: () => formatGwei3,
  from: () => from32,
  fromEther: () => fromEther,
  fromGwei: () => fromGwei
});
var exponents = {
  wei: 0,
  gwei: 9,
  szabo: 12,
  finney: 15,
  ether: 18
};
function format8(value2, decimals = 0) {
  let display = value2.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatEther4(wei, unit = "wei") {
  return format8(wei, exponents.ether - exponents[unit]);
}
function formatGwei3(wei, unit = "wei") {
  return format8(wei, exponents.gwei - exponents[unit]);
}
function from32(value2, decimals = 0) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value2))
    throw new InvalidDecimalNumberError2({ value: value2 });
  let [integer = "", fraction = "0"] = value2.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left13, unit, right13] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right13}`));
    if (rounded > 9)
      fraction = `${BigInt(left13) + BigInt(1)}0`.padStart(left13.length + 1, "0");
    else
      fraction = `${left13}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
function fromEther(ether, unit = "wei") {
  return from32(ether, exponents.ether - exponents[unit]);
}
function fromGwei(gwei, unit = "wei") {
  return from32(gwei, exponents.gwei - exponents[unit]);
}
var InvalidDecimalNumberError2 = class extends BaseError6 {
  constructor({ value: value2 }) {
    super(`Value \`${value2}\` is not a valid decimal number.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Value.InvalidDecimalNumberError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionEnvelope.js
var FeeCapTooHighError2 = class extends BaseError6 {
  constructor({ feeCap } = {}) {
    super(`The fee cap (\`maxFeePerGas\`/\`maxPriorityFeePerGas\`${feeCap ? ` = ${formatGwei3(feeCap)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.FeeCapTooHighError"
    });
  }
};
var GasPriceTooHighError = class extends BaseError6 {
  constructor({ gasPrice } = {}) {
    super(`The gas price (\`gasPrice\`${gasPrice ? ` = ${formatGwei3(gasPrice)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.GasPriceTooHighError"
    });
  }
};
var InvalidChainIdError2 = class extends BaseError6 {
  constructor({ chainId }) {
    super(typeof chainId !== "undefined" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidChainIdError"
    });
  }
};
var InvalidSerializedError = class extends BaseError6 {
  constructor({ attributes, serialized, type: type7 }) {
    const missing = Object.entries(attributes).map(([key, value2]) => typeof value2 === "undefined" ? key : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${type7}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serialized}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidSerializedError"
    });
  }
};
var TipAboveFeeCapError2 = class extends BaseError6 {
  constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei3(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei3(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.TipAboveFeeCapError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js
var TransactionEnvelopeLegacy_exports = {};
__export(TransactionEnvelopeLegacy_exports, {
  assert: () => assert8,
  deserialize: () => deserialize,
  from: () => from33,
  getSignPayload: () => getSignPayload5,
  hash: () => hash4,
  serialize: () => serialize2,
  toRpc: () => toRpc16,
  type: () => type,
  validate: () => validate13
});
var type = "legacy";
function assert8(envelope) {
  const { chainId, gasPrice, to: to6 } = envelope;
  if (to6)
    assert6(to6, { strict: false });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize(serialized) {
  const tuple3 = toHex8(serialized);
  const [nonce, gasPrice, gas, to6, value2, data, chainIdOrV_, r8, s5] = tuple3;
  if (!(tuple3.length === 6 || tuple3.length === 9))
    throw new InvalidSerializedError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to: to6,
        value: value2,
        data,
        ...tuple3.length > 6 ? {
          v: chainIdOrV_,
          r: r8,
          s: s5
        } : {}
      },
      serialized,
      type
    });
  const transaction = {
    type
  };
  if (validate5(to6) && to6 !== "0x")
    transaction.to = to6;
  if (validate5(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate5(data) && data !== "0x")
    transaction.data = data;
  if (validate5(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate5(value2) && value2 !== "0x")
    transaction.value = BigInt(value2);
  if (validate5(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (tuple3.length === 6)
    return transaction;
  const chainIdOrV = validate5(chainIdOrV_) && chainIdOrV_ !== "0x" ? Number(chainIdOrV_) : 0;
  if (s5 === "0x" && r8 === "0x") {
    if (chainIdOrV > 0)
      transaction.chainId = Number(chainIdOrV);
    return transaction;
  }
  const v9 = chainIdOrV;
  const chainId = Math.floor((v9 - 35) / 2);
  if (chainId > 0)
    transaction.chainId = chainId;
  else if (v9 !== 27 && v9 !== 28)
    throw new InvalidVError({ value: v9 });
  transaction.yParity = vToYParity(v9);
  transaction.v = v9;
  transaction.s = s5 === "0x" ? 0n : BigInt(s5);
  transaction.r = r8 === "0x" ? 0n : BigInt(r8);
  assert8(transaction);
  return transaction;
}
function from33(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize(envelope) : envelope;
  assert8(envelope_);
  const signature_ = (() => {
    if (!signature)
      return {};
    const s5 = from22(signature);
    s5.v = yParityToV(s5.yParity);
    return s5;
  })();
  return {
    ...envelope_,
    ...signature_,
    type: "legacy"
  };
}
function getSignPayload5(envelope) {
  return hash4(envelope, { presign: true });
}
function hash4(envelope, options = {}) {
  const { presign } = options;
  return keccak2565(serialize2({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize2(envelope, options = {}) {
  const { chainId = 0, gas, data, input, nonce, to: to6, value: value2, gasPrice } = envelope;
  assert8(envelope);
  let serialized = [
    nonce ? fromNumber3(nonce) : "0x",
    gasPrice ? fromNumber3(gasPrice) : "0x",
    gas ? fromNumber3(gas) : "0x",
    to6 ?? "0x",
    value2 ? fromNumber3(value2) : "0x",
    data ?? input ?? "0x"
  ];
  const signature = (() => {
    if (options.signature)
      return {
        r: options.signature.r,
        s: options.signature.s,
        v: yParityToV(options.signature.yParity)
      };
    if (typeof envelope.r === "undefined" || typeof envelope.s === "undefined")
      return void 0;
    return {
      r: envelope.r,
      s: envelope.s,
      v: envelope.v
    };
  })();
  if (signature) {
    const v9 = (() => {
      if (signature.v >= 35) {
        const inferredChainId = Math.floor((signature.v - 35) / 2);
        if (inferredChainId > 0)
          return signature.v;
        return 27 + (signature.v === 35 ? 0 : 1);
      }
      if (chainId > 0)
        return chainId * 2 + 35 + signature.v - 27;
      const v10 = 27 + (signature.v === 27 ? 0 : 1);
      if (signature.v !== v10)
        throw new InvalidVError({ value: signature.v });
      return v10;
    })();
    serialized = [
      ...serialized,
      fromNumber3(v9),
      signature.r === 0n ? "0x" : trimLeft2(fromNumber3(signature.r)),
      signature.s === 0n ? "0x" : trimLeft2(fromNumber3(signature.s))
    ];
  } else if (chainId > 0)
    serialized = [...serialized, fromNumber3(chainId), "0x", "0x"];
  return fromHex9(serialized);
}
function toRpc16(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: typeof envelope.chainId === "number" ? fromNumber3(envelope.chainId) : void 0,
    data: envelope.data ?? envelope.input,
    type: "0x0",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber3(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber3(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber3(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber3(envelope.gasPrice) } : {},
    ...signature ? {
      ...toRpc7(signature),
      v: signature.yParity === 0 ? "0x1b" : "0x1c"
    } : {}
  };
}
function validate13(envelope) {
  try {
    assert8(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js
var TransactionEnvelopeEip1559_exports = {};
__export(TransactionEnvelopeEip1559_exports, {
  assert: () => assert9,
  deserialize: () => deserialize2,
  from: () => from34,
  getSignPayload: () => getSignPayload6,
  hash: () => hash5,
  serialize: () => serialize3,
  serializedType: () => serializedType,
  toRpc: () => toRpc17,
  type: () => type2,
  validate: () => validate14
});
var serializedType = "0x02";
var type2 = "eip1559";
function assert9(envelope) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to6 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to6)
    assert6(to6, { strict: false });
  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)
    throw new FeeCapTooHighError2({ feeCap: maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError2({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
}
function deserialize2(serialized) {
  const transactionArray = toHex8(slice6(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to6, value2, data, accessList, yParity, r8, s5] = transactionArray;
  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to6,
        value: value2,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r8,
          s: s5
        } : {}
      },
      serialized,
      type: type2
    });
  let transaction = {
    chainId: Number(chainId),
    type: type2
  };
  if (validate5(to6) && to6 !== "0x")
    transaction.to = to6;
  if (validate5(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate5(data) && data !== "0x")
    transaction.data = data;
  if (validate5(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate5(value2) && value2 !== "0x")
    transaction.value = BigInt(value2);
  if (validate5(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate5(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r8 && s5 && yParity ? fromTuple([yParity, r8, s5]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert9(transaction);
  return transaction;
}
function from34(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize2(envelope) : envelope;
  assert9(envelope_);
  return {
    ...envelope_,
    ...signature ? from22(signature) : {},
    type: "eip1559"
  };
}
function getSignPayload6(envelope) {
  return hash5(envelope, { presign: true });
}
function hash5(envelope, options = {}) {
  const { presign } = options;
  return keccak2565(serialize3({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize3(envelope, options = {}) {
  const { chainId, gas, nonce, to: to6, value: value2, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert9(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber3(chainId),
    nonce ? fromNumber3(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber3(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber3(maxFeePerGas) : "0x",
    gas ? fromNumber3(gas) : "0x",
    to6 ?? "0x",
    value2 ? fromNumber3(value2) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat7(serializedType, fromHex9(serialized));
}
function toRpc17(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber3(envelope.chainId),
    data: envelope.data ?? envelope.input,
    type: "0x2",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber3(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber3(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber3(envelope.value) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber3(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? {
      maxPriorityFeePerGas: fromNumber3(envelope.maxPriorityFeePerGas)
    } : {},
    ...signature ? toRpc7(signature) : {}
  };
}
function validate14(envelope) {
  try {
    assert9(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js
var TransactionEnvelopeEip2930_exports = {};
__export(TransactionEnvelopeEip2930_exports, {
  assert: () => assert10,
  deserialize: () => deserialize3,
  from: () => from35,
  getSignPayload: () => getSignPayload7,
  hash: () => hash6,
  serialize: () => serialize4,
  serializedType: () => serializedType2,
  toRpc: () => toRpc18,
  type: () => type3,
  validate: () => validate15
});
var serializedType2 = "0x01";
var type3 = "eip2930";
function assert10(envelope) {
  const { chainId, gasPrice, to: to6 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to6)
    assert6(to6, { strict: false });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize3(serialized) {
  const transactionArray = toHex8(slice6(serialized, 1));
  const [chainId, nonce, gasPrice, gas, to6, value2, data, accessList, yParity, r8, s5] = transactionArray;
  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to: to6,
        value: value2,
        data,
        accessList,
        ...transactionArray.length > 8 ? {
          yParity,
          r: r8,
          s: s5
        } : {}
      },
      serialized,
      type: type3
    });
  let transaction = {
    chainId: Number(chainId),
    type: type3
  };
  if (validate5(to6) && to6 !== "0x")
    transaction.to = to6;
  if (validate5(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate5(data) && data !== "0x")
    transaction.data = data;
  if (validate5(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate5(value2) && value2 !== "0x")
    transaction.value = BigInt(value2);
  if (validate5(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r8 && s5 && yParity ? fromTuple([yParity, r8, s5]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert10(transaction);
  return transaction;
}
function from35(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize3(envelope) : envelope;
  assert10(envelope_);
  return {
    ...envelope_,
    ...signature ? from22(signature) : {},
    type: "eip2930"
  };
}
function getSignPayload7(envelope) {
  return hash6(envelope, { presign: true });
}
function hash6(envelope, options = {}) {
  const { presign } = options;
  return keccak2565(serialize4({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize4(envelope, options = {}) {
  const { chainId, gas, data, input, nonce, to: to6, value: value2, accessList, gasPrice } = envelope;
  assert10(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber3(chainId),
    nonce ? fromNumber3(nonce) : "0x",
    gasPrice ? fromNumber3(gasPrice) : "0x",
    gas ? fromNumber3(gas) : "0x",
    to6 ?? "0x",
    value2 ? fromNumber3(value2) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat7("0x01", fromHex9(serialized));
}
function toRpc18(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber3(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber3(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber3(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber3(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber3(envelope.gasPrice) } : {},
    type: "0x1",
    ...signature ? toRpc7(signature) : {}
  };
}
function validate15(envelope) {
  try {
    assert10(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js
var TransactionEnvelopeEip4844_exports = {};
__export(TransactionEnvelopeEip4844_exports, {
  assert: () => assert11,
  deserialize: () => deserialize4,
  from: () => from36,
  getSignPayload: () => getSignPayload8,
  hash: () => hash7,
  serialize: () => serialize5,
  serializedType: () => serializedType3,
  toRpc: () => toRpc19,
  type: () => type4,
  validate: () => validate16
});
var serializedType3 = "0x03";
var type4 = "eip4844";
function assert11(envelope) {
  const { blobVersionedHashes } = envelope;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobVersionedHashesError();
    for (const hash9 of blobVersionedHashes) {
      const size11 = size7(hash9);
      const version11 = toNumber2(slice6(hash9, 0, 1));
      if (size11 !== 32)
        throw new InvalidVersionedHashSizeError2({ hash: hash9, size: size11 });
      if (version11 !== versionedHashVersion)
        throw new InvalidVersionedHashVersionError2({
          hash: hash9,
          version: version11
        });
    }
  }
  assert9(envelope);
}
function deserialize4(serialized) {
  const transactionOrWrapperArray = toHex8(slice6(serialized, 1));
  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to6, value2, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r8, s5] = transactionArray;
  const [blobs, commitments, proofs] = wrapperArray;
  if (!(transactionArray.length === 11 || transactionArray.length === 14))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to6,
        value: value2,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r8,
          s: s5
        } : {}
      },
      serialized,
      type: type4
    });
  let transaction = {
    blobVersionedHashes,
    chainId: Number(chainId),
    type: type4
  };
  if (validate5(to6) && to6 !== "0x")
    transaction.to = to6;
  if (validate5(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate5(data) && data !== "0x")
    transaction.data = data;
  if (validate5(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate5(value2) && value2 !== "0x")
    transaction.value = BigInt(value2);
  if (validate5(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);
  if (validate5(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate5(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if ((accessList == null ? void 0 : accessList.length) !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (blobs && commitments && proofs)
    transaction.sidecars = toSidecars(blobs, {
      commitments,
      proofs
    });
  const signature = r8 && s5 && yParity ? fromTuple([yParity, r8, s5]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert11(transaction);
  return transaction;
}
function from36(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize4(envelope) : envelope;
  assert11(envelope_);
  return {
    ...envelope_,
    ...signature ? from22(signature) : {},
    type: "eip4844"
  };
}
function getSignPayload8(envelope) {
  return hash7(envelope, { presign: true });
}
function hash7(envelope, options = {}) {
  const { presign } = options;
  return keccak2565(serialize5({
    ...envelope,
    ...presign ? {
      sidecars: void 0,
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize5(envelope, options = {}) {
  const { blobVersionedHashes, chainId, gas, nonce, to: to6, value: value2, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = envelope;
  assert11(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber3(chainId),
    nonce ? fromNumber3(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber3(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber3(maxFeePerGas) : "0x",
    gas ? fromNumber3(gas) : "0x",
    to6 ?? "0x",
    value2 ? fromNumber3(value2) : "0x",
    data ?? "0x",
    accessTupleList,
    maxFeePerBlobGas ? fromNumber3(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...signature ? toTuple(signature) : []
  ];
  const sidecars = options.sidecars || envelope.sidecars;
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i9 = 0; i9 < sidecars.length; i9++) {
      const { blob, commitment, proof } = sidecars[i9];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concat7("0x03", sidecars ? (
    // If sidecars are provided, envelope turns into a "network wrapper":
    fromHex9([serialized, blobs, commitments, proofs])
  ) : (
    // Otherwise, standard envelope is used:
    fromHex9(serialized)
  ));
}
function toRpc19(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber3(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber3(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber3(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber3(envelope.value) } : {},
    ...typeof envelope.maxFeePerBlobGas === "bigint" ? { maxFeePerBlobGas: fromNumber3(envelope.maxFeePerBlobGas) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber3(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? { maxPriorityFeePerGas: fromNumber3(envelope.maxPriorityFeePerGas) } : {},
    type: "0x3",
    ...signature ? toRpc7(signature) : {}
  };
}
function validate16(envelope) {
  try {
    assert11(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js
var TransactionEnvelopeEip7702_exports = {};
__export(TransactionEnvelopeEip7702_exports, {
  assert: () => assert12,
  deserialize: () => deserialize5,
  from: () => from37,
  getSignPayload: () => getSignPayload9,
  hash: () => hash8,
  serialize: () => serialize6,
  serializedType: () => serializedType4,
  type: () => type5,
  validate: () => validate17
});
var serializedType4 = "0x04";
var type5 = "eip7702";
function assert12(envelope) {
  const { authorizationList } = envelope;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { address, chainId } = authorization;
      if (address)
        assert6(address, { strict: false });
      if (Number(chainId) < 0)
        throw new InvalidChainIdError2({ chainId });
    }
  }
  assert9(envelope);
}
function deserialize5(serialized) {
  const transactionArray = toHex8(slice6(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to6, value2, data, accessList, authorizationList, yParity, r8, s5] = transactionArray;
  if (!(transactionArray.length === 10 || transactionArray.length === 13))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to6,
        value: value2,
        data,
        accessList,
        authorizationList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r8,
          s: s5
        } : {}
      },
      serialized,
      type: type5
    });
  let transaction = {
    chainId: Number(chainId),
    type: type5
  };
  if (validate5(to6) && to6 !== "0x")
    transaction.to = to6;
  if (validate5(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate5(data) && data !== "0x")
    transaction.data = data;
  if (validate5(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate5(value2) && value2 !== "0x")
    transaction.value = BigInt(value2);
  if (validate5(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate5(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (authorizationList !== "0x")
    transaction.authorizationList = fromTupleList2(authorizationList);
  const signature = r8 && s5 && yParity ? fromTuple([yParity, r8, s5]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert12(transaction);
  return transaction;
}
function from37(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize5(envelope) : envelope;
  assert12(envelope_);
  return {
    ...envelope_,
    ...signature ? from22(signature) : {},
    type: "eip7702"
  };
}
function getSignPayload9(envelope) {
  return hash8(envelope, { presign: true });
}
function hash8(envelope, options = {}) {
  const { presign } = options;
  return keccak2565(serialize6({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0
    } : {}
  }));
}
function serialize6(envelope, options = {}) {
  const { authorizationList, chainId, gas, nonce, to: to6, value: value2, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert12(envelope);
  const accessTupleList = toTupleList(accessList);
  const authorizationTupleList = toTupleList2(authorizationList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber3(chainId),
    nonce ? fromNumber3(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber3(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber3(maxFeePerGas) : "0x",
    gas ? fromNumber3(gas) : "0x",
    to6 ?? "0x",
    value2 ? fromNumber3(value2) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    authorizationTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat7(serializedType4, fromHex9(serialized));
}
function validate17(envelope) {
  try {
    assert12(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionReceipt.js
var TransactionReceipt_exports2 = {};
__export(TransactionReceipt_exports2, {
  fromRpc: () => fromRpc15,
  fromRpcStatus: () => fromRpcStatus2,
  fromRpcType: () => fromRpcType3,
  toRpc: () => toRpc20,
  toRpcStatus: () => toRpcStatus2,
  toRpcType: () => toRpcType3
});
var fromRpcStatus2 = {
  "0x0": "reverted",
  "0x1": "success"
};
var toRpcStatus2 = {
  reverted: "0x0",
  success: "0x1"
};
var fromRpcType3 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType3 = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function fromRpc15(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log) => fromRpc13(log, { pending: false })),
    status: fromRpcStatus2[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType3[receipt.type] || receipt.type
  };
}
function toRpc20(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber3(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber3(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber3(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber3(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber3(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber3(receipt.gasUsed),
    logs: receipt.logs.map(toRpc14),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus2[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber3(receipt.transactionIndex),
    type: toRpcType3[receipt.type] ?? receipt.type
  };
}

// node_modules/ox/_esm/core/TransactionRequest.js
var TransactionRequest_exports = {};
__export(TransactionRequest_exports, {
  toRpc: () => toRpc21
});
function toRpc21(request2) {
  const request_rpc = {};
  if (typeof request2.accessList !== "undefined")
    request_rpc.accessList = request2.accessList;
  if (typeof request2.authorizationList !== "undefined")
    request_rpc.authorizationList = toRpcList(request2.authorizationList);
  if (typeof request2.blobVersionedHashes !== "undefined")
    request_rpc.blobVersionedHashes = request2.blobVersionedHashes;
  if (typeof request2.blobs !== "undefined")
    request_rpc.blobs = request2.blobs;
  if (typeof request2.chainId !== "undefined")
    request_rpc.chainId = fromNumber3(request2.chainId);
  if (typeof request2.data !== "undefined") {
    request_rpc.data = request2.data;
    request_rpc.input = request2.data;
  } else if (typeof request2.input !== "undefined") {
    request_rpc.data = request2.input;
    request_rpc.input = request2.input;
  }
  if (typeof request2.from !== "undefined")
    request_rpc.from = request2.from;
  if (typeof request2.gas !== "undefined")
    request_rpc.gas = fromNumber3(request2.gas);
  if (typeof request2.gasPrice !== "undefined")
    request_rpc.gasPrice = fromNumber3(request2.gasPrice);
  if (typeof request2.maxFeePerBlobGas !== "undefined")
    request_rpc.maxFeePerBlobGas = fromNumber3(request2.maxFeePerBlobGas);
  if (typeof request2.maxFeePerGas !== "undefined")
    request_rpc.maxFeePerGas = fromNumber3(request2.maxFeePerGas);
  if (typeof request2.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber3(request2.maxPriorityFeePerGas);
  if (typeof request2.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber3(request2.maxPriorityFeePerGas);
  if (typeof request2.nonce !== "undefined")
    request_rpc.nonce = fromNumber3(request2.nonce);
  if (typeof request2.to !== "undefined")
    request_rpc.to = request2.to;
  if (typeof request2.type !== "undefined")
    request_rpc.type = request2.type;
  if (typeof request2.value !== "undefined")
    request_rpc.value = fromNumber3(request2.value);
  return request_rpc;
}

// node_modules/ox/_esm/core/TypedData.js
var TypedData_exports2 = {};
__export(TypedData_exports2, {
  BytesSizeMismatchError: () => BytesSizeMismatchError5,
  InvalidDomainError: () => InvalidDomainError3,
  InvalidPrimaryTypeError: () => InvalidPrimaryTypeError3,
  InvalidStructTypeError: () => InvalidStructTypeError3,
  assert: () => assert13,
  domainSeparator: () => domainSeparator2,
  encode: () => encode13,
  encodeData: () => encodeData4,
  encodeField: () => encodeField2,
  encodeType: () => encodeType3,
  extractEip712DomainTypes: () => extractEip712DomainTypes2,
  findTypeDependencies: () => findTypeDependencies2,
  getSignPayload: () => getSignPayload10,
  hashDomain: () => hashDomain3,
  hashStruct: () => hashStruct4,
  hashType: () => hashType2,
  serialize: () => serialize7,
  validate: () => validate18
});
function assert13(value2) {
  const { domain, message, primaryType, types: types2 } = value2;
  const validateData = (struct2, data) => {
    for (const param of struct2) {
      const { name, type: type7 } = param;
      const value3 = data[name];
      const integerMatch = type7.match(integerRegex5);
      if (integerMatch && (typeof value3 === "number" || typeof value3 === "bigint")) {
        const [, base4, size_] = integerMatch;
        fromNumber3(value3, {
          signed: base4 === "int",
          size: Number.parseInt(size_ ?? "") / 8
        });
      }
      if (type7 === "address" && typeof value3 === "string" && !validate9(value3))
        throw new InvalidAddressError5({
          address: value3,
          cause: new InvalidInputError3()
        });
      const bytesMatch = type7.match(bytesRegex5);
      if (bytesMatch) {
        const [, size11] = bytesMatch;
        if (size11 && size7(value3) !== Number.parseInt(size11))
          throw new BytesSizeMismatchError5({
            expectedSize: Number.parseInt(size11),
            givenSize: size7(value3)
          });
      }
      const struct3 = types2[type7];
      if (struct3) {
        validateReference2(type7);
        validateData(struct3, value3);
      }
    }
  };
  if (types2.EIP712Domain && domain) {
    if (typeof domain !== "object")
      throw new InvalidDomainError3({ domain });
    validateData(types2.EIP712Domain, domain);
  }
  if (primaryType !== "EIP712Domain") {
    if (types2[primaryType])
      validateData(types2[primaryType], message);
    else
      throw new InvalidPrimaryTypeError3({ primaryType, types: types2 });
  }
}
function domainSeparator2(domain) {
  return hashDomain3({
    domain
  });
}
function encode13(value2) {
  const { domain = {}, message, primaryType } = value2;
  const types2 = {
    EIP712Domain: extractEip712DomainTypes2(domain),
    ...value2.types
  };
  assert13({
    domain,
    message,
    primaryType,
    types: types2
  });
  const parts2 = ["0x19", "0x01"];
  if (domain)
    parts2.push(hashDomain3({
      domain,
      types: types2
    }));
  if (primaryType !== "EIP712Domain")
    parts2.push(hashStruct4({
      data: message,
      primaryType,
      types: types2
    }));
  return concat7(...parts2);
}
function encodeType3(value2) {
  const { primaryType, types: types2 } = value2;
  let result = "";
  const unsortedDeps = findTypeDependencies2({ primaryType, types: types2 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type7 of deps) {
    result += `${type7}(${(types2[type7] ?? []).map(({ name, type: t6 }) => `${t6} ${name}`).join(",")})`;
  }
  return result;
}
function extractEip712DomainTypes2(domain) {
  return [
    typeof (domain == null ? void 0 : domain.name) === "string" && { name: "name", type: "string" },
    (domain == null ? void 0 : domain.version) && { name: "version", type: "string" },
    typeof (domain == null ? void 0 : domain.chainId) === "number" && {
      name: "chainId",
      type: "uint256"
    },
    (domain == null ? void 0 : domain.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain == null ? void 0 : domain.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function getSignPayload10(value2) {
  return keccak2565(encode13(value2));
}
function hashDomain3(value2) {
  const { domain, types: types2 } = value2;
  return hashStruct4({
    data: domain,
    primaryType: "EIP712Domain",
    types: {
      ...types2,
      EIP712Domain: (types2 == null ? void 0 : types2.EIP712Domain) || extractEip712DomainTypes2(domain)
    }
  });
}
function hashStruct4(value2) {
  const { data, primaryType, types: types2 } = value2;
  const encoded = encodeData4({
    data,
    primaryType,
    types: types2
  });
  return keccak2565(encoded);
}
function serialize7(value2) {
  const { domain: domain_, message: message_, primaryType, types: types2 } = value2;
  const normalizeData = (struct2, value3) => {
    const data = { ...value3 };
    for (const param of struct2) {
      const { name, type: type7 } = param;
      if (type7 === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!domain_)
      return {};
    const type7 = types2.EIP712Domain ?? extractEip712DomainTypes2(domain_);
    return normalizeData(type7, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    if (!types2[primaryType])
      return {};
    return normalizeData(types2[primaryType], message_);
  })();
  return stringify6({ domain, message, primaryType, types: types2 }, (_6, value3) => {
    if (typeof value3 === "bigint")
      return value3.toString();
    return value3;
  });
}
function validate18(value2) {
  try {
    assert13(value2);
    return true;
  } catch {
    return false;
  }
}
var BytesSizeMismatchError5 = class extends BaseError6 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.BytesSizeMismatchError"
    });
  }
};
var InvalidDomainError3 = class extends BaseError6 {
  constructor({ domain }) {
    super(`Invalid domain "${stringify6(domain)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidDomainError"
    });
  }
};
var InvalidPrimaryTypeError3 = class extends BaseError6 {
  constructor({ primaryType, types: types2 }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types2))}\`.`, {
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidPrimaryTypeError"
    });
  }
};
var InvalidStructTypeError3 = class extends BaseError6 {
  constructor({ type: type7 }) {
    super(`Struct type "${type7}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidStructTypeError"
    });
  }
};
function encodeData4(value2) {
  const { data, primaryType, types: types2 } = value2;
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType2({ primaryType, types: types2 })];
  for (const field of types2[primaryType] ?? []) {
    const [type7, value3] = encodeField2({
      types: types2,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type7);
    encodedValues.push(value3);
  }
  return encode8(encodedTypes, encodedValues);
}
function hashType2(value2) {
  const { primaryType, types: types2 } = value2;
  const encodedHashType = fromString6(encodeType3({ primaryType, types: types2 }));
  return keccak2565(encodedHashType);
}
function encodeField2(properties) {
  let { types: types2, name, type: type7, value: value2 } = properties;
  if (types2[type7] !== void 0)
    return [
      { type: "bytes32" },
      keccak2565(encodeData4({ data: value2, primaryType: type7, types: types2 }))
    ];
  if (type7 === "bytes") {
    const prepend3 = value2.length % 2 ? "0" : "";
    value2 = `0x${prepend3 + value2.slice(2)}`;
    return [{ type: "bytes32" }, keccak2565(value2, { as: "Hex" })];
  }
  if (type7 === "string")
    return [
      { type: "bytes32" },
      keccak2565(fromString7(value2), { as: "Hex" })
    ];
  if (type7.lastIndexOf("]") === type7.length - 1) {
    const parsedType = type7.slice(0, type7.lastIndexOf("["));
    const typeValuePairs = value2.map((item) => encodeField2({
      name,
      type: parsedType,
      types: types2,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak2565(encode8(typeValuePairs.map(([t6]) => t6), typeValuePairs.map(([, v9]) => v9)))
    ];
  }
  return [{ type: type7 }, value2];
}
function findTypeDependencies2(value2, results = /* @__PURE__ */ new Set()) {
  const { primaryType: primaryType_, types: types2 } = value2;
  const match14 = primaryType_.match(/^\w*/u);
  const primaryType = match14 == null ? void 0 : match14[0];
  if (results.has(primaryType) || types2[primaryType] === void 0)
    return results;
  results.add(primaryType);
  for (const field of types2[primaryType])
    findTypeDependencies2({ primaryType: field.type, types: types2 }, results);
  return results;
}
function validateReference2(type7) {
  if (type7 === "address" || type7 === "bool" || type7 === "string" || type7.startsWith("bytes") || type7.startsWith("uint") || type7.startsWith("int"))
    throw new InvalidStructTypeError3({ type: type7 });
}

// node_modules/ox/_esm/core/ValidatorData.js
var ValidatorData_exports = {};
__export(ValidatorData_exports, {
  encode: () => encode14,
  getSignPayload: () => getSignPayload11
});
function encode14(value2) {
  const { data, validator } = value2;
  return concat7(
    // Validator Data Format: `0x19  0x00  <intended validator address>  <data to sign>`
    "0x19",
    "0x00",
    validator,
    from11(data)
  );
}
function getSignPayload11(value2) {
  return keccak2565(encode14(value2));
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var WebAuthnP256_exports2 = {};
__export(WebAuthnP256_exports2, {
  CredentialCreationFailedError: () => CredentialCreationFailedError2,
  CredentialRequestFailedError: () => CredentialRequestFailedError,
  createChallenge: () => createChallenge2,
  createCredential: () => createCredential2,
  getAuthenticatorData: () => getAuthenticatorData,
  getClientDataJSON: () => getClientDataJSON,
  getCredentialCreationOptions: () => getCredentialCreationOptions,
  getCredentialRequestOptions: () => getCredentialRequestOptions,
  getSignPayload: () => getSignPayload12,
  sign: () => sign6,
  verify: () => verify5
});

// node_modules/ox/_esm/core/internal/webauthn.js
function parseAsn1Signature2(bytes2) {
  const r_start = bytes2[4] === 0 ? 5 : 4;
  const r_end = r_start + 32;
  const s_start = bytes2[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
  const r8 = BigInt(fromBytes4(bytes2.slice(r_start, r_end)));
  const s5 = BigInt(fromBytes4(bytes2.slice(s_start)));
  return {
    r: r8,
    s: s5 > p256.CURVE.n / 2n ? p256.CURVE.n - s5 : s5
  };
}
async function parseCredentialPublicKey2(response) {
  try {
    const publicKeyBuffer = response.getPublicKey();
    if (!publicKeyBuffer)
      throw new CredentialCreationFailedError2();
    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
    const cryptoKey = await crypto.subtle.importKey("spki", new Uint8Array(publicKeyBytes), {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: "SHA-256"
    }, true, ["verify"]);
    const publicKey = new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKey));
    return from13(publicKey);
  } catch (error) {
    if (error.message !== "Permission denied to access object")
      throw error;
    const data = new Uint8Array(response.attestationObject);
    const coordinateLength = 32;
    const cborPrefix = 88;
    const findStart = (key) => {
      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);
      for (let i9 = 0; i9 < data.length - coordinate.length; i9++)
        if (coordinate.every((byte, j9) => data[i9 + j9] === byte))
          return i9 + coordinate.length;
      throw new CredentialCreationFailedError2();
    };
    const xStart = findStart(33);
    const yStart = findStart(34);
    return from13(new Uint8Array([
      4,
      ...data.slice(xStart, xStart + coordinateLength),
      ...data.slice(yStart, yStart + coordinateLength)
    ]));
  }
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge2 = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);
async function createCredential2(options) {
  const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;
  const creationOptions = getCredentialCreationOptions(rest);
  try {
    const credential = await createFn(creationOptions);
    if (!credential)
      throw new CredentialCreationFailedError2();
    const response = credential.response;
    const publicKey = await parseCredentialPublicKey2(response);
    return {
      id: credential.id,
      publicKey,
      raw: credential
    };
  } catch (error) {
    throw new CredentialCreationFailedError2({
      cause: error
    });
  }
}
function getAuthenticatorData(options = {}) {
  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;
  const rpIdHash = sha2565(fromString6(rpId));
  const flag_bytes = fromNumber3(flag, { size: 1 });
  const signCount_bytes = fromNumber3(signCount, { size: 4 });
  return concat7(rpIdHash, flag_bytes, signCount_bytes);
}
function getClientDataJSON(options) {
  const { challenge: challenge3, crossOrigin = false, extraClientData, origin: origin3 = window.location.origin } = options;
  return JSON.stringify({
    type: "webauthn.get",
    challenge: fromHex12(challenge3, { url: true, pad: false }),
    origin: origin3,
    crossOrigin,
    ...extraClientData
  });
}
function getCredentialCreationOptions(options) {
  const { attestation = "none", authenticatorSelection = {
    residentKey: "preferred",
    requireResidentKey: false,
    userVerification: "required"
  }, challenge: challenge3 = createChallenge2, excludeCredentialIds, name: name_, rp: rp2 = {
    id: window.location.hostname,
    name: window.document.title
  }, user, extensions } = options;
  const name = (user == null ? void 0 : user.name) ?? name_;
  return {
    publicKey: {
      attestation,
      authenticatorSelection,
      challenge: challenge3,
      ...excludeCredentialIds ? {
        excludeCredentials: excludeCredentialIds == null ? void 0 : excludeCredentialIds.map((id2) => ({
          id: toBytes10(id2),
          type: "public-key"
        }))
      } : {},
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
          // p256
        }
      ],
      rp: rp2,
      user: {
        id: (user == null ? void 0 : user.id) ?? keccak2565(fromString7(name), { as: "Bytes" }),
        name,
        displayName: (user == null ? void 0 : user.displayName) ?? name
      },
      extensions
    }
  };
}
function getCredentialRequestOptions(options) {
  const { credentialId, challenge: challenge3, rpId = window.location.hostname, userVerification = "required" } = options;
  return {
    publicKey: {
      ...credentialId ? {
        allowCredentials: [
          {
            id: toBytes10(credentialId),
            type: "public-key"
          }
        ]
      } : {},
      challenge: fromHex7(challenge3),
      rpId,
      userVerification
    }
  };
}
function getSignPayload12(options) {
  const { challenge: challenge3, crossOrigin, extraClientData, flag, origin: origin3, rpId, signCount, userVerification = "required" } = options;
  const authenticatorData = getAuthenticatorData({
    flag,
    rpId,
    signCount
  });
  const clientDataJSON = getClientDataJSON({
    challenge: challenge3,
    crossOrigin,
    extraClientData,
    origin: origin3
  });
  const clientDataJSONHash = sha2565(fromString6(clientDataJSON));
  const challengeIndex = clientDataJSON.indexOf('"challenge"');
  const typeIndex = clientDataJSON.indexOf('"type"');
  const metadata = {
    authenticatorData,
    clientDataJSON,
    challengeIndex,
    typeIndex,
    userVerificationRequired: userVerification === "required"
  };
  const payload = concat7(authenticatorData, clientDataJSONHash);
  return { metadata, payload };
}
async function sign6(options) {
  const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;
  const requestOptions = getCredentialRequestOptions(rest);
  try {
    const credential = await getFn(requestOptions);
    if (!credential)
      throw new CredentialRequestFailedError();
    const response = credential.response;
    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
    const challengeIndex = clientDataJSON.indexOf('"challenge"');
    const typeIndex = clientDataJSON.indexOf('"type"');
    const signature = parseAsn1Signature2(new Uint8Array(response.signature));
    return {
      metadata: {
        authenticatorData: fromBytes4(new Uint8Array(response.authenticatorData)),
        clientDataJSON,
        challengeIndex,
        typeIndex,
        userVerificationRequired: requestOptions.publicKey.userVerification === "required"
      },
      signature,
      raw: credential
    };
  } catch (error) {
    throw new CredentialRequestFailedError({
      cause: error
    });
  }
}
function verify5(options) {
  const { challenge: challenge3, hash: hash9 = true, metadata, publicKey, signature } = options;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex7(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  const type7 = '"type":"webauthn.get"';
  if (type7 !== clientDataJSON.slice(Number(typeIndex), type7.length + 1))
    return false;
  const match14 = clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/);
  if (!match14)
    return false;
  const [_6, challenge_extracted] = match14;
  if (fromBytes4(toBytes10(challenge_extracted)) !== challenge3)
    return false;
  const clientDataJSONHash = sha2565(fromString7(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat8(authenticatorDataBytes, clientDataJSONHash);
  return verify4({
    hash: hash9,
    payload,
    publicKey,
    signature
  });
}
var CredentialCreationFailedError2 = class extends BaseError6 {
  constructor({ cause } = {}) {
    super("Failed to create credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialCreationFailedError"
    });
  }
};
var CredentialRequestFailedError = class extends BaseError6 {
  constructor({ cause } = {}) {
    super("Failed to request credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialRequestFailedError"
    });
  }
};

// node_modules/ox/_esm/core/WebCryptoP256.js
var WebCryptoP256_exports = {};
__export(WebCryptoP256_exports, {
  createKeyPair: () => createKeyPair,
  sign: () => sign7,
  verify: () => verify6
});
async function createKeyPair(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from13(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function sign7(options) {
  const { payload, privateKey } = options;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from12(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r8 = toBigInt3(slice7(signature_bytes, 0, 32));
  let s5 = toBigInt3(slice7(signature_bytes, 32, 64));
  if (s5 > p256.CURVE.n / 2n)
    s5 = p256.CURVE.n - s5;
  return { r: r8, s: s5 };
}
async function verify6(options) {
  const { payload, signature } = options;
  const publicKey = await globalThis.crypto.subtle.importKey("raw", toBytes6(options.publicKey), { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
  return await globalThis.crypto.subtle.verify({
    name: "ECDSA",
    hash: "SHA-256"
  }, publicKey, concat8(fromNumber4(signature.r), fromNumber4(signature.s)), from12(payload));
}

// node_modules/@base-org/account/dist/kms/crypto-key/storage.js
function createStorage2(scope, name) {
  const store2 = typeof indexedDB !== "undefined" ? createStore(scope, name) : void 0;
  return {
    getItem: async (key) => {
      const value2 = await get(key, store2);
      if (!value2) {
        return null;
      }
      return value2;
    },
    removeItem: async (key) => {
      return del(key, store2);
    },
    setItem: async (key, value2) => {
      return set(key, value2, store2);
    }
  };
}

// node_modules/@base-org/account/dist/kms/crypto-key/index.js
var STORAGE_SCOPE = "base-acc-sdk";
var STORAGE_NAME = "keys";
var ACTIVE_ID_KEY = "activeId";
var storage = createStorage2(STORAGE_SCOPE, STORAGE_NAME);
async function generateKeyPair2() {
  const keypair = await WebCryptoP256_exports.createKeyPair({ extractable: false });
  const publicKey = Hex_exports3.slice(PublicKey_exports3.toHex(keypair.publicKey), 1);
  await storage.setItem(publicKey, keypair);
  await storage.setItem(ACTIVE_ID_KEY, publicKey);
  return keypair;
}
async function getKeypair() {
  const id2 = await storage.getItem(ACTIVE_ID_KEY);
  if (!id2) {
    return null;
  }
  const keypair = await storage.getItem(id2);
  if (!keypair) {
    return null;
  }
  return keypair;
}
async function getOrCreateKeypair() {
  const keypair = await getKeypair();
  if (!keypair) {
    const kp2 = await generateKeyPair2();
    const pubKey = Hex_exports3.slice(PublicKey_exports3.toHex(kp2.publicKey), 1);
    await storage.setItem(pubKey, kp2);
    await storage.setItem(ACTIVE_ID_KEY, pubKey);
    return kp2;
  }
  return keypair;
}
async function getAccount() {
  const keypair = await getOrCreateKeypair();
  const publicKey = Hex_exports3.slice(PublicKey_exports3.toHex(keypair.publicKey), 1);
  const sign9 = async (payload) => {
    const { payload: message, metadata } = WebAuthnP256_exports2.getSignPayload({
      challenge: payload,
      origin: "https://keys.coinbase.com",
      userVerification: "preferred"
    });
    const signature = await WebCryptoP256_exports.sign({
      payload: message,
      privateKey: keypair.privateKey
    });
    return {
      signature: Signature_exports2.toHex(signature),
      raw: {},
      // type changed in viem
      webauthn: metadata
    };
  };
  return {
    id: publicKey,
    publicKey,
    async sign({ hash: hash9 }) {
      return sign9(hash9);
    },
    async signMessage({ message }) {
      return sign9(hashMessage(message));
    },
    async signTypedData(parameters) {
      return sign9(hashTypedData(parameters));
    },
    type: "webAuthn"
  };
}
async function getCryptoKeyAccount() {
  const account2 = await getAccount();
  return {
    account: account2
  };
}

// node_modules/@base-org/account/dist/sign/base-account/SCWKeyManager.js
var OWN_PRIVATE_KEY = {
  storageKey: "ownPrivateKey",
  keyType: "private"
};
var OWN_PUBLIC_KEY = {
  storageKey: "ownPublicKey",
  keyType: "public"
};
var PEER_PUBLIC_KEY = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
var SCWKeyManager = class {
  constructor() {
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    await this.loadKeysIfNeeded();
    return this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    await this.loadKeysIfNeeded();
    return this.sharedSecret;
  }
  async setPeerPublicKey(key) {
    this.sharedSecret = null;
    this.peerPublicKey = key;
    await this.storeKey(PEER_PUBLIC_KEY, key);
    await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
    store.keys.clear();
  }
  async generateKeyPair() {
    const newKeyPair = await generateKeyPair();
    this.ownPrivateKey = newKeyPair.privateKey;
    this.ownPublicKey = newKeyPair.publicKey;
    await this.storeKey(OWN_PRIVATE_KEY, newKeyPair.privateKey);
    await this.storeKey(OWN_PUBLIC_KEY, newKeyPair.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null) {
      this.ownPrivateKey = await this.loadKey(OWN_PRIVATE_KEY);
    }
    if (this.ownPublicKey === null) {
      this.ownPublicKey = await this.loadKey(OWN_PUBLIC_KEY);
    }
    if (this.ownPrivateKey === null || this.ownPublicKey === null) {
      await this.generateKeyPair();
    }
    if (this.peerPublicKey === null) {
      this.peerPublicKey = await this.loadKey(PEER_PUBLIC_KEY);
    }
    if (this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await deriveSharedSecret(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(item) {
    const key = store.keys.get(item.storageKey);
    if (!key)
      return null;
    return importKeyFromHexString(item.keyType, key);
  }
  async storeKey(item, key) {
    const hexString = await exportKeyToHexString(item.keyType, key);
    store.keys.set(item.storageKey, hexString);
  }
};

// node_modules/@base-org/account/dist/util/get.js
function get2(obj, path2) {
  if (typeof obj !== "object" || obj === null)
    return void 0;
  return path2.split(/[.[\]]+/).filter(Boolean).reduce((value2, key) => {
    if (typeof value2 === "object" && value2 !== null) {
      return value2[key];
    }
    return void 0;
  }, obj);
}

// node_modules/@base-org/account/dist/sign/base-account/utils.js
function getSenderFromRequest(request2) {
  var _a14;
  if (!Array.isArray(request2.params)) {
    return null;
  }
  switch (request2.method) {
    case "personal_sign":
      return request2.params[1];
    case "eth_signTypedData_v4":
      return request2.params[0];
    case "eth_signTransaction":
    case "eth_sendTransaction":
    case "wallet_sendCalls":
      return (_a14 = request2.params[0]) === null || _a14 === void 0 ? void 0 : _a14.from;
    default:
      return null;
  }
}
function addSenderToRequest(request2, sender) {
  if (!Array.isArray(request2.params)) {
    throw standardErrors.rpc.invalidParams();
  }
  const params = [...request2.params];
  switch (request2.method) {
    case "eth_signTransaction":
    case "eth_sendTransaction":
    case "wallet_sendCalls":
      params[0].from = sender;
      break;
    case "eth_signTypedData_v4":
      params[0] = sender;
      break;
    case "personal_sign":
      params[1] = sender;
      break;
    default:
      break;
  }
  return Object.assign(Object.assign({}, request2), { params });
}
function assertParamsChainId(params) {
  var _a14;
  if (!params || !Array.isArray(params) || !((_a14 = params[0]) === null || _a14 === void 0 ? void 0 : _a14.chainId)) {
    throw standardErrors.rpc.invalidParams();
  }
  if (typeof params[0].chainId !== "string" && typeof params[0].chainId !== "number") {
    throw standardErrors.rpc.invalidParams();
  }
}
function assertGetCapabilitiesParams(params) {
  if (!params || !Array.isArray(params) || params.length !== 1 && params.length !== 2) {
    throw standardErrors.rpc.invalidParams();
  }
  if (typeof params[0] !== "string" || !isAddress(params[0])) {
    throw standardErrors.rpc.invalidParams();
  }
  if (params.length === 2) {
    if (!Array.isArray(params[1])) {
      throw standardErrors.rpc.invalidParams();
    }
    for (const param of params[1]) {
      if (typeof param !== "string" || !param.startsWith("0x")) {
        throw standardErrors.rpc.invalidParams();
      }
    }
  }
}
function injectRequestCapabilities(request2, capabilities) {
  const modifiedRequest = Object.assign({}, request2);
  if (capabilities && request2.method.startsWith("wallet_")) {
    let requestCapabilities = get2(modifiedRequest, "params.0.capabilities");
    if (typeof requestCapabilities === "undefined") {
      requestCapabilities = {};
    }
    if (typeof requestCapabilities !== "object") {
      throw standardErrors.rpc.invalidParams();
    }
    requestCapabilities = Object.assign(Object.assign({}, capabilities), requestCapabilities);
    if (modifiedRequest.params && Array.isArray(modifiedRequest.params)) {
      modifiedRequest.params[0] = Object.assign(Object.assign({}, modifiedRequest.params[0]), { capabilities: requestCapabilities });
    }
  }
  return modifiedRequest;
}
async function initSubAccountConfig() {
  var _a14;
  const config2 = (_a14 = store.subAccountsConfig.get()) !== null && _a14 !== void 0 ? _a14 : {};
  const capabilities = {};
  if (config2.enableAutoSubAccounts) {
    const { account: owner } = config2.toOwnerAccount ? await config2.toOwnerAccount() : await getCryptoKeyAccount();
    if (!owner) {
      throw standardErrors.provider.unauthorized("No owner account found");
    }
    capabilities.addSubAccount = {
      account: {
        type: "create",
        keys: [
          {
            type: owner.address ? "address" : "webauthn-p256",
            publicKey: owner.address || owner.publicKey
          }
        ]
      }
    };
  }
  store.subAccountsConfig.set({
    capabilities
  });
}
function assertFetchPermissionsRequest(request2) {
  if (request2.method === "coinbase_fetchPermissions" && request2.params === void 0) {
    return;
  }
  if (request2.method === "coinbase_fetchPermissions" && Array.isArray(request2.params) && request2.params.length === 1 && typeof request2.params[0] === "object") {
    if (typeof request2.params[0].account !== "string" || !request2.params[0].chainId.startsWith("0x")) {
      throw standardErrors.rpc.invalidParams("FetchPermissions - Invalid params: params[0].account must be a hex string");
    }
    if (typeof request2.params[0].chainId !== "string" || !request2.params[0].chainId.startsWith("0x")) {
      throw standardErrors.rpc.invalidParams("FetchPermissions - Invalid params: params[0].chainId must be a hex string");
    }
    if (typeof request2.params[0].spender !== "string" || !request2.params[0].spender.startsWith("0x")) {
      throw standardErrors.rpc.invalidParams("FetchPermissions - Invalid params: params[0].spender must be a hex string");
    }
    return;
  }
  throw standardErrors.rpc.invalidParams();
}
function fillMissingParamsForFetchPermissions(request2) {
  var _a14, _b, _c3;
  if (request2.params !== void 0) {
    return request2;
  }
  const accountFromStore = (_a14 = store.getState().account.accounts) === null || _a14 === void 0 ? void 0 : _a14[0];
  const chainId = (_b = store.getState().account.chain) === null || _b === void 0 ? void 0 : _b.id;
  const subAccountFromStore = (_c3 = store.getState().subAccount) === null || _c3 === void 0 ? void 0 : _c3.address;
  if (!accountFromStore || !subAccountFromStore || !chainId) {
    throw standardErrors.rpc.invalidParams("FetchPermissions - one or more of account, sub account, or chain id is missing, connect to sub account via wallet_connect first");
  }
  return {
    method: "coinbase_fetchPermissions",
    params: [
      {
        account: accountFromStore,
        chainId: numberToHex(chainId),
        spender: subAccountFromStore
      }
    ]
  };
}
function createSpendPermissionMessage({ spendPermission, chainId }) {
  return {
    domain: {
      name: "Spend Permission Manager",
      version: "1",
      chainId,
      verifyingContract: spendPermissionManagerAddress
    },
    types: {
      SpendPermission: [
        { name: "account", type: "address" },
        { name: "spender", type: "address" },
        { name: "token", type: "address" },
        { name: "allowance", type: "uint160" },
        { name: "period", type: "uint48" },
        { name: "start", type: "uint48" },
        { name: "end", type: "uint48" },
        { name: "salt", type: "uint256" },
        { name: "extraData", type: "bytes" }
      ]
    },
    primaryType: "SpendPermission",
    message: {
      account: spendPermission.account,
      spender: spendPermission.spender,
      token: spendPermission.token,
      allowance: spendPermission.allowance,
      period: spendPermission.period,
      start: spendPermission.start,
      end: spendPermission.end,
      salt: spendPermission.salt,
      extraData: spendPermission.extraData
    }
  };
}
function createSpendPermissionBatchMessage({ spendPermissionBatch, chainId }) {
  return {
    domain: {
      name: "Spend Permission Manager",
      version: "1",
      chainId,
      verifyingContract: spendPermissionManagerAddress
    },
    types: {
      SpendPermissionBatch: [
        { name: "account", type: "address" },
        { name: "period", type: "uint48" },
        { name: "start", type: "uint48" },
        { name: "end", type: "uint48" },
        { name: "permissions", type: "PermissionDetails[]" }
      ],
      PermissionDetails: [
        { name: "spender", type: "address" },
        { name: "token", type: "address" },
        { name: "allowance", type: "uint160" },
        { name: "salt", type: "uint256" },
        { name: "extraData", type: "bytes" }
      ]
    },
    primaryType: "SpendPermissionBatch",
    message: {
      account: spendPermissionBatch.account,
      period: spendPermissionBatch.period,
      start: spendPermissionBatch.start,
      end: spendPermissionBatch.end,
      permissions: spendPermissionBatch.permissions.map((p9) => ({
        spender: p9.spender,
        token: p9.token,
        allowance: p9.allowance,
        salt: p9.salt,
        extraData: p9.extraData
      }))
    }
  };
}
async function waitForCallsTransactionHash({ client, id: id2 }) {
  var _a14;
  const result = await waitForCallsStatus(client, {
    id: id2
  });
  if (result.status === "success") {
    return (_a14 = result.receipts) === null || _a14 === void 0 ? void 0 : _a14[0].transactionHash;
  }
  throw standardErrors.rpc.internal("failed to send transaction");
}
function createWalletSendCallsRequest({ calls, from: from40, chainId, capabilities }) {
  const paymasterUrls = config.get().paymasterUrls;
  let request2 = {
    method: "wallet_sendCalls",
    params: [
      {
        version: "1.0",
        calls,
        chainId: numberToHex(chainId),
        from: from40,
        atomicRequired: true,
        capabilities
      }
    ]
  };
  if (paymasterUrls === null || paymasterUrls === void 0 ? void 0 : paymasterUrls[chainId]) {
    request2 = injectRequestCapabilities(request2, {
      paymasterService: { url: paymasterUrls === null || paymasterUrls === void 0 ? void 0 : paymasterUrls[chainId] }
    });
  }
  return request2;
}
async function presentSubAccountFundingDialog() {
  const dialog2 = initDialog();
  const userChoice = await new Promise((resolve) => {
    logDialogShown({ dialogContext: "sub_account_insufficient_balance" });
    dialog2.presentItem({
      title: "Insufficient spend permission",
      message: "Your spend permission's remaining balance cannot cover this transaction. Please choose how to proceed:",
      onClose: () => {
        logDialogDismissed({ dialogContext: "sub_account_insufficient_balance" });
        dialog2.clear();
      },
      actionItems: [
        {
          text: "Edit spend permission",
          variant: "primary",
          onClick: () => {
            logDialogActionClicked({
              dialogContext: "sub_account_insufficient_balance",
              dialogAction: "create_permission"
            });
            dialog2.clear();
            resolve("update_permission");
          }
        },
        {
          text: "Use primary account",
          variant: "secondary",
          onClick: () => {
            logDialogActionClicked({
              dialogContext: "sub_account_insufficient_balance",
              dialogAction: "continue_in_popup"
            });
            dialog2.clear();
            resolve("continue_popup");
          }
        }
      ]
    });
  });
  return userChoice;
}
function parseFundingOptions({ errorData, sourceAddress }) {
  var _a14;
  const spendPermissionRequests = [];
  for (const [token, { amount, sources }] of Object.entries((_a14 = errorData === null || errorData === void 0 ? void 0 : errorData.required) !== null && _a14 !== void 0 ? _a14 : {})) {
    const sourcesWithSufficientBalance = sources.filter((source) => {
      return hexToBigInt(source.balance) >= hexToBigInt(amount) && source.address.toLowerCase() === (sourceAddress === null || sourceAddress === void 0 ? void 0 : sourceAddress.toLowerCase());
    });
    if (sourcesWithSufficientBalance.length === 0) {
      throw new Error("Source address has insufficient balance for a token");
    }
    spendPermissionRequests.push({
      token,
      requiredAmount: hexToBigInt(amount)
    });
  }
  return spendPermissionRequests;
}
function isSendCallsParams(params) {
  return typeof params === "object" && params !== null && "calls" in params;
}
function isEthSendTransactionParams(params) {
  return Array.isArray(params) && params.length === 1 && typeof params[0] === "object" && params[0] !== null && "to" in params[0];
}
function compute16ByteHash(input) {
  return slice(keccak256(toHex(input)), 0, 16);
}
function makeDataSuffix({ attribution, dappOrigin }) {
  if (!attribution) {
    return;
  }
  if ("auto" in attribution && attribution.auto && dappOrigin) {
    return compute16ByteHash(dappOrigin);
  }
  if ("dataSuffix" in attribution) {
    return attribution.dataSuffix;
  }
  return;
}
function requestHasCapability(request2, capabilityName) {
  var _a14;
  if (!Array.isArray(request2 === null || request2 === void 0 ? void 0 : request2.params))
    return false;
  const capabilities = (_a14 = request2.params[0]) === null || _a14 === void 0 ? void 0 : _a14.capabilities;
  if (!capabilities || typeof capabilities !== "object")
    return false;
  return capabilityName in capabilities;
}
function prependWithoutDuplicates(array, item) {
  const filtered = array.filter((i9) => i9 !== item);
  return [item, ...filtered];
}
function appendWithoutDuplicates(array, item) {
  const filtered = array.filter((i9) => i9 !== item);
  return [...filtered, item];
}
async function getCachedWalletConnectResponse() {
  const spendPermissions2 = store.spendPermissions.get();
  const subAccount = store.subAccounts.get();
  const accounts = store.account.get().accounts;
  if (!accounts) {
    return null;
  }
  const walletConnectAccounts = accounts === null || accounts === void 0 ? void 0 : accounts.map((account2) => ({
    address: account2,
    capabilities: {
      subAccounts: subAccount ? [subAccount] : void 0,
      spendPermissions: spendPermissions2.length > 0 ? { permissions: spendPermissions2 } : void 0
    }
  }));
  return {
    accounts: walletConnectAccounts
  };
}

// node_modules/@base-org/account/dist/util/encoding.js
function base64ToBase64Url(base642) {
  return base642.replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
}
function arrayBufferToBase64Url(buffer2) {
  const base64String = btoa(String.fromCharCode(...new Uint8Array(buffer2)));
  return base64ToBase64Url(base64String);
}
function convertCredentialToJSON({ webauthn, signature, id: id2 }) {
  const signatureRaw = Signature_exports2.fromHex(signature);
  return {
    id: id2,
    rawId: arrayBufferToBase64Url(stringToBytes(id2)),
    response: {
      authenticatorData: arrayBufferToBase64Url(hexToBytes(webauthn.authenticatorData)),
      clientDataJSON: arrayBufferToBase64Url(stringToBytes(webauthn.clientDataJSON)),
      signature: arrayBufferToBase64Url(asn1EncodeSignature(signatureRaw.r, signatureRaw.s))
    },
    type: JSON.parse(webauthn.clientDataJSON).type
  };
}
function asn1EncodeSignature(r8, s5) {
  const rBytes = hexToBytes(trim(numberToHex(r8)));
  const sBytes = hexToBytes(trim(numberToHex(s5)));
  const rLength = rBytes.length;
  const sLength = sBytes.length;
  const totalLength2 = rLength + sLength + 4;
  const signature = new Uint8Array(totalLength2 + 2);
  signature[0] = 48;
  signature[1] = totalLength2;
  signature[2] = 2;
  signature[3] = rLength;
  signature.set(rBytes, 4);
  signature[rLength + 4] = 2;
  signature[rLength + 5] = sLength;
  signature.set(sBytes, rLength + 6);
  return signature;
}

// node_modules/@base-org/account/dist/sign/base-account/utils/createSmartAccount.js
var __rest3 = function(s5, e11) {
  var t6 = {};
  for (var p9 in s5) if (Object.prototype.hasOwnProperty.call(s5, p9) && e11.indexOf(p9) < 0)
    t6[p9] = s5[p9];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i9 = 0, p9 = Object.getOwnPropertySymbols(s5); i9 < p9.length; i9++) {
      if (e11.indexOf(p9[i9]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p9[i9]))
        t6[p9[i9]] = s5[p9[i9]];
    }
  return t6;
};
async function createSmartAccount(parameters) {
  const { owner, ownerIndex, address, client, factoryData } = parameters;
  const entryPoint = {
    abi: entryPoint06Abi,
    address: entryPoint06Address2,
    version: "0.6"
  };
  const factory2 = {
    abi: factoryAbi,
    address: factoryAddress
  };
  return toSmartAccount({
    client,
    entryPoint,
    extend: { abi, factory: factory2 },
    async decodeCalls(data) {
      const result = decodeFunctionData({
        abi,
        data
      });
      if (result.functionName === "execute")
        return [{ to: result.args[0], value: result.args[1], data: result.args[2] }];
      if (result.functionName === "executeBatch")
        return result.args[0].map((arg) => ({
          to: arg.target,
          value: arg.value,
          data: arg.data
        }));
      throw new BaseError(`unable to decode calls for "${result.functionName}"`);
    },
    async encodeCalls(calls) {
      var _a14, _b;
      if (calls.length === 1) {
        return encodeFunctionData({
          abi,
          functionName: "execute",
          args: [calls[0].to, (_a14 = calls[0].value) !== null && _a14 !== void 0 ? _a14 : BigInt(0), (_b = calls[0].data) !== null && _b !== void 0 ? _b : "0x"]
        });
      }
      return encodeFunctionData({
        abi,
        functionName: "executeBatch",
        args: [
          calls.map((call3) => {
            var _a15, _b2;
            return {
              data: (_a15 = call3.data) !== null && _a15 !== void 0 ? _a15 : "0x",
              target: call3.to,
              value: (_b2 = call3.value) !== null && _b2 !== void 0 ? _b2 : BigInt(0)
            };
          })
        ]
      });
    },
    async getAddress() {
      return address;
    },
    async getFactoryArgs() {
      if (factoryData)
        return { factory: factory2.address, factoryData };
      return { factory: factory2.address, factoryData };
    },
    async getStubSignature() {
      if (owner.type === "webAuthn")
        return "0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000170000000000000000000000000000000000000000000000000000000000000001949fc7c88032b9fcb5f6efc7a7b8c63668eae9871b765e23123bb473ff57aa831a7c0d9276168ebcc29f2875a0239cffdf2a9cd1c2007c5c77c071db9264df1d000000000000000000000000000000000000000000000000000000000000002549960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008a7b2274797065223a22776562617574686e2e676574222c226368616c6c656e6765223a2273496a396e6164474850596759334b7156384f7a4a666c726275504b474f716d59576f4d57516869467773222c226f726967696e223a2268747470733a2f2f7369676e2e636f696e626173652e636f6d222c2263726f73734f726967696e223a66616c73657d00000000000000000000000000000000000000000000";
      return wrapSignature({
        ownerIndex,
        signature: "0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c"
      });
    },
    async sign(parameters2) {
      const address2 = await this.getAddress();
      const hash9 = toReplaySafeHash({
        address: address2,
        chainId: client.chain.id,
        hash: parameters2.hash
      });
      const signature = await sign8({ hash: hash9, owner });
      return wrapSignature({
        ownerIndex,
        signature
      });
    },
    async signMessage(parameters2) {
      const { message } = parameters2;
      const address2 = await this.getAddress();
      const hash9 = toReplaySafeHash({
        address: address2,
        chainId: client.chain.id,
        hash: hashMessage(message)
      });
      const signature = await sign8({ hash: hash9, owner });
      return wrapSignature({
        ownerIndex,
        signature
      });
    },
    async signTypedData(parameters2) {
      const { domain, types: types2, primaryType, message } = parameters2;
      const address2 = await this.getAddress();
      const hash9 = toReplaySafeHash({
        address: address2,
        chainId: client.chain.id,
        hash: hashTypedData({
          domain,
          message,
          primaryType,
          types: types2
        })
      });
      const signature = await sign8({ hash: hash9, owner });
      return wrapSignature({
        ownerIndex,
        signature
      });
    },
    async signUserOperation(parameters2) {
      const { chainId = client.chain.id } = parameters2, userOperation = __rest3(parameters2, ["chainId"]);
      const address2 = await this.getAddress();
      const hash9 = getUserOperationHash({
        chainId,
        entryPointAddress: entryPoint.address,
        entryPointVersion: entryPoint.version,
        userOperation: Object.assign(Object.assign({}, userOperation), { sender: address2 })
      });
      const signature = await sign8({ hash: hash9, owner });
      return wrapSignature({
        ownerIndex,
        signature
      });
    },
    userOperation: {
      async estimateGas(userOperation) {
        var _a14;
        if (owner.type !== "webAuthn")
          return;
        return {
          verificationGasLimit: BigInt(Math.max(Number((_a14 = userOperation.verificationGasLimit) !== null && _a14 !== void 0 ? _a14 : BigInt(0)), 8e5))
        };
      }
    }
  });
}
async function sign8({ hash: hash9, owner }) {
  if (owner.type === "webAuthn") {
    const { signature, webauthn } = await owner.sign({
      hash: hash9
    });
    return toWebAuthnSignature({ signature, webauthn });
  }
  if (owner.sign)
    return owner.sign({ hash: hash9 });
  throw new BaseError("`owner` does not support raw sign.");
}
function toReplaySafeHash({ address, chainId, hash: hash9 }) {
  return hashTypedData({
    domain: {
      chainId,
      name: "Coinbase Smart Wallet",
      verifyingContract: address,
      version: "1"
    },
    types: {
      CoinbaseSmartWalletMessage: [
        {
          name: "hash",
          type: "bytes32"
        }
      ]
    },
    primaryType: "CoinbaseSmartWalletMessage",
    message: {
      hash: hash9
    }
  });
}
function toWebAuthnSignature({ webauthn, signature }) {
  const { r: r8, s: s5 } = fromHex10(signature);
  return encodeAbiParameters([
    {
      components: [
        {
          name: "authenticatorData",
          type: "bytes"
        },
        { name: "clientDataJSON", type: "bytes" },
        { name: "challengeIndex", type: "uint256" },
        { name: "typeIndex", type: "uint256" },
        {
          name: "r",
          type: "uint256"
        },
        {
          name: "s",
          type: "uint256"
        }
      ],
      type: "tuple"
    }
  ], [
    {
      authenticatorData: webauthn.authenticatorData,
      clientDataJSON: stringToHex(webauthn.clientDataJSON),
      challengeIndex: BigInt(webauthn.challengeIndex),
      typeIndex: BigInt(webauthn.typeIndex),
      r: r8,
      s: s5
    }
  ]);
}
function wrapSignature(parameters) {
  const { ownerIndex = 0 } = parameters;
  const signatureData = (() => {
    if (size(parameters.signature) !== 65)
      return parameters.signature;
    const signature = parseSignature(parameters.signature);
    return encodePacked(["bytes32", "bytes32", "uint8"], [signature.r, signature.s, signature.yParity === 0 ? 27 : 28]);
  })();
  return encodeAbiParameters([
    {
      components: [
        {
          name: "ownerIndex",
          type: "uint8"
        },
        {
          name: "signatureData",
          type: "bytes"
        }
      ],
      type: "tuple"
    }
  ], [
    {
      ownerIndex,
      signatureData
    }
  ]);
}

// node_modules/@base-org/account/dist/sign/base-account/utils/createSubAccountSigner.js
async function createSubAccountSigner({ address, client, factory: factory2, factoryData, owner, ownerIndex, parentAddress, attribution }) {
  var _a14;
  const subAccount = {
    address,
    factory: factory2,
    factoryData
  };
  const chainId = (_a14 = client.chain) === null || _a14 === void 0 ? void 0 : _a14.id;
  if (!chainId) {
    throw standardErrors.rpc.internal("chainId not found");
  }
  const account2 = await createSmartAccount({
    owner,
    ownerIndex: ownerIndex !== null && ownerIndex !== void 0 ? ownerIndex : 1,
    address,
    client,
    factoryData
  });
  const request2 = async (args) => {
    var _a15, _b, _c3, _d2, _e6, _f3;
    try {
      switch (args.method) {
        case "wallet_addSubAccount":
          return subAccount;
        case "eth_accounts":
          return [subAccount.address];
        case "eth_coinbase":
          return subAccount.address;
        case "net_version":
          return chainId.toString();
        case "eth_chainId":
          return numberToHex(chainId);
        case "eth_sendTransaction": {
          assertArrayPresence(args.params);
          const rawParams = args.params[0];
          assertPresence(rawParams.to, standardErrors.rpc.invalidParams("to is required"));
          const params = {
            to: rawParams.to,
            data: ensureHexString((_a15 = rawParams.data) !== null && _a15 !== void 0 ? _a15 : "0x", true),
            value: ensureHexString((_b = rawParams.value) !== null && _b !== void 0 ? _b : "0x", true),
            from: (_c3 = rawParams.from) !== null && _c3 !== void 0 ? _c3 : subAccount.address
          };
          const sendCallsRequest = createWalletSendCallsRequest({
            calls: [params],
            chainId,
            from: params.from
          });
          const response = await request2(sendCallsRequest);
          return waitForCallsTransactionHash({
            client,
            id: response
          });
        }
        case "wallet_sendCalls": {
          assertArrayPresence(args.params);
          const chainId2 = get2(args.params[0], "chainId");
          if (!chainId2) {
            throw standardErrors.rpc.invalidParams("chainId is required");
          }
          if (!isHex(chainId2)) {
            throw standardErrors.rpc.invalidParams("chainId must be a hex encoded integer");
          }
          if (!args.params[0]) {
            throw standardErrors.rpc.invalidParams("params are required");
          }
          if (!("calls" in args.params[0])) {
            throw standardErrors.rpc.invalidParams("calls are required");
          }
          let prepareCallsRequest = {
            method: "wallet_prepareCalls",
            params: [
              {
                version: "1.0",
                calls: args.params[0].calls,
                chainId: chainId2,
                from: subAccount.address,
                capabilities: "capabilities" in args.params[0] ? args.params[0].capabilities : {}
              }
            ]
          };
          if (parentAddress) {
            prepareCallsRequest = injectRequestCapabilities(prepareCallsRequest, {
              funding: [
                {
                  type: "spendPermission",
                  data: {
                    autoApply: true,
                    sources: [parentAddress],
                    preference: "PREFER_DIRECT_BALANCE"
                  }
                }
              ]
            });
          }
          let prepareCallsResponse = await request2(prepareCallsRequest);
          const signResponse = await ((_e6 = (_d2 = owner).sign) === null || _e6 === void 0 ? void 0 : _e6.call(_d2, {
            // Hash returned from wallet_prepareCalls is double hex encoded
            hash: hexToString(prepareCallsResponse.signatureRequest.hash)
          }));
          let signatureData;
          if (!signResponse) {
            throw standardErrors.rpc.internal("signature not found");
          }
          if (isHex(signResponse)) {
            signatureData = {
              type: "secp256k1",
              data: {
                address: owner.address,
                signature: signResponse
              }
            };
          } else {
            signatureData = {
              type: "webauthn",
              data: {
                signature: JSON.stringify(convertCredentialToJSON(Object.assign({ id: (_f3 = owner.id) !== null && _f3 !== void 0 ? _f3 : "1" }, signResponse))),
                publicKey: owner.publicKey
              }
            };
          }
          const sendPreparedCallsResponse = await request2({
            method: "wallet_sendPreparedCalls",
            params: [
              {
                version: "1.0",
                type: prepareCallsResponse.type,
                data: prepareCallsResponse.userOp,
                chainId: prepareCallsResponse.chainId,
                signature: signatureData
              }
            ]
          });
          return sendPreparedCallsResponse[0];
        }
        case "wallet_sendPreparedCalls": {
          assertArrayPresence(args.params);
          const chainId2 = get2(args.params[0], "chainId");
          if (!chainId2) {
            throw standardErrors.rpc.invalidParams("chainId is required");
          }
          if (!isHex(chainId2)) {
            throw standardErrors.rpc.invalidParams("chainId must be a hex encoded integer");
          }
          const sendPreparedCallsResponse = await client.request({
            method: "wallet_sendPreparedCalls",
            params: args.params
          });
          return sendPreparedCallsResponse;
        }
        case "wallet_prepareCalls": {
          assertArrayPresence(args.params);
          const chainId2 = get2(args.params[0], "chainId");
          if (!chainId2) {
            throw standardErrors.rpc.invalidParams("chainId is required");
          }
          if (!isHex(chainId2)) {
            throw standardErrors.rpc.invalidParams("chainId must be a hex encoded integer");
          }
          if (!args.params[0]) {
            throw standardErrors.rpc.invalidParams("params are required");
          }
          if (!get2(args.params[0], "calls")) {
            throw standardErrors.rpc.invalidParams("calls are required");
          }
          const prepareCallsParams = args.params[0];
          if (attribution && prepareCallsParams.capabilities && !("attribution" in prepareCallsParams.capabilities)) {
            prepareCallsParams.capabilities.attribution = attribution;
          }
          const prepareCallsResponse = await client.request({
            method: "wallet_prepareCalls",
            params: [Object.assign(Object.assign({}, args.params[0]), { chainId: chainId2 })]
          });
          return prepareCallsResponse;
        }
        case "personal_sign": {
          assertArrayPresence(args.params);
          if (!isHex(args.params[0])) {
            throw standardErrors.rpc.invalidParams("message must be a hex encoded string");
          }
          const message = hexToString(args.params[0]);
          return account2.signMessage({ message });
        }
        case "eth_signTypedData_v4": {
          assertArrayPresence(args.params);
          const typedData = typeof args.params[1] === "string" ? JSON.parse(args.params[1]) : args.params[1];
          return account2.signTypedData(typedData);
        }
        case "eth_signTypedData_v1":
        case "eth_signTypedData_v3":
        case "wallet_addEthereumChain":
        case "wallet_switchEthereumChain":
        default:
          throw standardErrors.rpc.methodNotSupported();
      }
    } catch (error) {
      if (isViemError(error)) {
        const newError = viemHttpErrorToProviderError(error);
        if (newError) {
          throw newError;
        }
      }
      throw error;
    }
  };
  return { request: request2 };
}

// node_modules/@base-org/account/dist/sign/base-account/utils/findOwnerIndex.js
async function findOwnerIndex({ address, client, publicKey, factory: factory2, factoryData }) {
  const code = await getCode(client, {
    address
  });
  if (!code && factory2 && factoryData) {
    const initData = decodeFunctionData({
      abi: factoryAbi,
      data: factoryData
    });
    if (initData.functionName !== "createAccount") {
      throw standardErrors.rpc.internal("unknown factory function");
    }
    const [owners] = initData.args;
    return owners.findIndex((owner) => {
      return owner.toLowerCase() === formatPublicKey(publicKey).toLowerCase();
    });
  }
  const ownerCount = await readContract(client, {
    address,
    abi,
    functionName: "ownerCount"
  });
  for (let i9 = Number(ownerCount) - 1; i9 >= 0; i9--) {
    const owner = await readContract(client, {
      address,
      abi,
      functionName: "ownerAtIndex",
      args: [BigInt(i9)]
    });
    const formatted = formatPublicKey(publicKey);
    if (owner.toLowerCase() === formatted.toLowerCase()) {
      return i9;
    }
  }
  return -1;
}
function formatPublicKey(publicKey) {
  if (isAddress(publicKey)) {
    return pad(publicKey);
  }
  return publicKey;
}

// node_modules/viem/_esm/experimental/erc7821/constants.js
var executionMode = {
  default: "0x0100000000000000000000000000000000000000000000000000000000000000",
  opData: "0x0100000000007821000100000000000000000000000000000000000000000000",
  batchOfBatches: "0x0100000000007821000200000000000000000000000000000000000000000000"
};

// node_modules/viem/node_modules/ox/_esm/core/AbiError.js
function from39(abiError, options = {}) {
  return from(abiError, options);
}
var solidityError2 = from39({
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
});
var solidityPanic2 = from39({
  inputs: [
    {
      name: "reason",
      type: "uint8"
    }
  ],
  name: "Panic",
  type: "error"
});

// node_modules/viem/_esm/experimental/erc7821/actions/supportsExecutionMode.js
var toSerializedMode = {
  default: executionMode.default,
  opData: executionMode.opData,
  batchOfBatches: executionMode.batchOfBatches
};

// node_modules/@base-org/account/dist/sign/base-account/utils/presentAddOwnerDialog.js
async function presentAddOwnerDialog() {
  var _a14, _b;
  const appName = (_b = (_a14 = store.config.get().metadata) === null || _a14 === void 0 ? void 0 : _a14.appName) !== null && _b !== void 0 ? _b : "App";
  const dialog2 = initDialog();
  return new Promise((resolve) => {
    logDialogShown({ dialogContext: "sub_account_add_owner" });
    dialog2.presentItem({
      title: `Re-authorize ${appName}`,
      message: `${appName} has lost access to your account. Please sign at the next step to re-authorize ${appName}`,
      onClose: () => {
        logDialogDismissed({ dialogContext: "sub_account_add_owner" });
        resolve("cancel");
      },
      actionItems: [
        {
          text: "Continue",
          variant: "primary",
          onClick: () => {
            logDialogActionClicked({
              dialogContext: "sub_account_add_owner",
              dialogAction: "confirm"
            });
            dialog2.clear();
            resolve("authenticate");
          }
        },
        {
          text: "Not now",
          variant: "secondary",
          onClick: () => {
            logDialogActionClicked({
              dialogContext: "sub_account_add_owner",
              dialogAction: "cancel"
            });
            dialog2.clear();
            resolve("cancel");
          }
        }
      ]
    });
  });
}

// node_modules/@base-org/account/dist/sign/base-account/utils/handleAddSubAccountOwner.js
async function handleAddSubAccountOwner({ ownerAccount, globalAccountRequest }) {
  var _a14, _b;
  const account2 = store.account.get();
  const subAccount = store.subAccounts.get();
  const globalAccount = (_a14 = account2.accounts) === null || _a14 === void 0 ? void 0 : _a14.find((account3) => account3.toLowerCase() !== (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address.toLowerCase()));
  assertPresence(globalAccount, standardErrors.provider.unauthorized("no global account"));
  assertPresence((_b = account2.chain) === null || _b === void 0 ? void 0 : _b.id, standardErrors.provider.unauthorized("no chain id"));
  assertPresence(subAccount === null || subAccount === void 0 ? void 0 : subAccount.address, standardErrors.provider.unauthorized("no sub account"));
  const calls = [];
  if (ownerAccount.type === "local" && ownerAccount.address) {
    calls.push({
      to: subAccount.address,
      data: encodeFunctionData({
        abi,
        functionName: "addOwnerAddress",
        args: [ownerAccount.address]
      }),
      value: toHex(0)
    });
  }
  if (ownerAccount.publicKey) {
    const [x7, y11] = decodeAbiParameters([{ type: "bytes32" }, { type: "bytes32" }], ownerAccount.publicKey);
    calls.push({
      to: subAccount.address,
      data: encodeFunctionData({
        abi,
        functionName: "addOwnerPublicKey",
        args: [x7, y11]
      }),
      value: toHex(0)
    });
  }
  const request2 = {
    method: "wallet_sendCalls",
    params: [
      {
        version: "1",
        calls,
        chainId: numberToHex(84532),
        from: globalAccount
      }
    ]
  };
  const selection = await presentAddOwnerDialog();
  if (selection === "cancel") {
    throw standardErrors.provider.unauthorized("user cancelled");
  }
  const callsId = await globalAccountRequest(request2);
  const client = getClient(account2.chain.id);
  assertPresence(client, standardErrors.rpc.internal(`client not found for chainId ${account2.chain.id}`));
  const callsResult = await waitForCallsStatus(client, {
    id: callsId
  });
  if (callsResult.status !== "success") {
    throw standardErrors.rpc.internal("add owner call failed");
  }
  const ownerIndex = await findOwnerIndex({
    address: subAccount.address,
    publicKey: ownerAccount.type === "local" && ownerAccount.address ? ownerAccount.address : ownerAccount.publicKey,
    client
  });
  if (ownerIndex === -1) {
    throw standardErrors.rpc.internal("failed to find owner index");
  }
  return ownerIndex;
}

// node_modules/@base-org/account/dist/sign/base-account/utils/handleInsufficientBalance.js
async function handleInsufficientBalanceError({ errorData, globalAccountAddress, subAccountAddress, client, request: request2, subAccountRequest, globalAccountRequest }) {
  var _a14;
  const chainId = (_a14 = client.chain) === null || _a14 === void 0 ? void 0 : _a14.id;
  assertPresence(chainId, standardErrors.rpc.internal(`invalid chainId`));
  const spendPermissionRequests = parseFundingOptions({
    errorData,
    sourceAddress: globalAccountAddress
  });
  const userChoice = await presentSubAccountFundingDialog();
  if (userChoice === "cancel") {
    throw new Error("User cancelled funding");
  }
  let signatureRequest;
  const defaultPeriod = 60 * 60 * 24;
  const defaultMultiplier = 3;
  if (userChoice === "update_permission") {
    if (spendPermissionRequests.length === 1) {
      const spendPermission = spendPermissionRequests[0];
      const message = createSpendPermissionMessage({
        spendPermission: {
          token: spendPermission.token,
          allowance: numberToHex(spendPermission.requiredAmount * BigInt(defaultMultiplier)),
          period: defaultPeriod,
          account: globalAccountAddress,
          spender: subAccountAddress,
          start: 0,
          end: 281474976710655,
          salt: numberToHex(BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER))),
          extraData: "0x"
        },
        chainId
      });
      signatureRequest = {
        method: "eth_signTypedData_v4",
        params: [globalAccountAddress, message]
      };
    } else {
      const message = createSpendPermissionBatchMessage({
        spendPermissionBatch: {
          account: globalAccountAddress,
          period: defaultPeriod,
          start: 0,
          end: 281474976710655,
          permissions: spendPermissionRequests.map((spendPermission) => ({
            token: spendPermission.token,
            allowance: numberToHex(spendPermission.requiredAmount * BigInt(defaultMultiplier)),
            period: defaultPeriod,
            account: globalAccountAddress,
            spender: subAccountAddress,
            salt: "0x0",
            extraData: "0x"
          }))
        },
        chainId
      });
      signatureRequest = {
        method: "eth_signTypedData_v4",
        params: [globalAccountAddress, message]
      };
    }
    try {
      await globalAccountRequest(signatureRequest);
    } catch (error) {
      console.error(error);
      throw new Error("User denied spend permission request");
    }
    return subAccountRequest(request2);
  }
  const transferCalls = spendPermissionRequests.map((spendPermission) => {
    const isNative = spendPermission.token.toLowerCase() === "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE".toLowerCase();
    if (isNative) {
      return {
        to: subAccountAddress,
        value: numberToHex(spendPermission.requiredAmount),
        data: "0x"
      };
    }
    return {
      to: spendPermission.token,
      value: "0x0",
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: "transfer",
        args: [subAccountAddress, spendPermission.requiredAmount]
      })
    };
  });
  let originalSendCallsParams;
  if (request2.method === "wallet_sendCalls" && isSendCallsParams(request2.params)) {
    originalSendCallsParams = request2.params[0];
  } else if (request2.method === "eth_sendTransaction" && isEthSendTransactionParams(request2.params)) {
    const sendCallsRequest = createWalletSendCallsRequest({
      calls: [request2.params[0]],
      chainId,
      from: request2.params[0].from
    });
    originalSendCallsParams = sendCallsRequest.params[0];
  } else {
    throw new Error("Could not get original call");
  }
  const subAccountCallData = encodeFunctionData({
    abi,
    functionName: "executeBatch",
    args: [
      originalSendCallsParams.calls.map((call3) => {
        var _a15, _b;
        return {
          target: call3.to,
          value: hexToBigInt((_a15 = call3.value) !== null && _a15 !== void 0 ? _a15 : "0x0"),
          data: (_b = call3.data) !== null && _b !== void 0 ? _b : "0x"
        };
      })
    ]
  });
  const calls = [
    ...transferCalls,
    { data: subAccountCallData, to: subAccountAddress, value: "0x0" }
  ];
  const result = await globalAccountRequest({
    method: "wallet_sendCalls",
    params: [Object.assign(Object.assign({}, originalSendCallsParams), { calls, from: globalAccountAddress })]
  });
  if (request2.method === "eth_sendTransaction") {
    return waitForCallsTransactionHash({
      client,
      id: result
    });
  }
  return result;
}

// node_modules/@base-org/account/dist/sign/base-account/Signer.js
var Signer = class {
  constructor(params) {
    var _a14, _b, _c3, _d2;
    this.communicator = params.communicator;
    this.callback = params.callback;
    this.keyManager = new SCWKeyManager();
    const { account: account2, chains: chains2 } = store.getState();
    this.accounts = (_a14 = account2.accounts) !== null && _a14 !== void 0 ? _a14 : [];
    this.chain = (_b = account2.chain) !== null && _b !== void 0 ? _b : {
      id: (_d2 = (_c3 = params.metadata.appChainIds) === null || _c3 === void 0 ? void 0 : _c3[0]) !== null && _d2 !== void 0 ? _d2 : 1
    };
    if (chains2) {
      createClients(chains2);
    }
  }
  get isConnected() {
    return this.accounts.length > 0;
  }
  async handshake(args) {
    var _a14, _b, _c3;
    const correlationId = correlationIds.get(args);
    logHandshakeStarted({ method: args.method, correlationId });
    try {
      await ((_b = (_a14 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a14));
      const handshakeMessage = await this.createRequestMessage({
        handshake: {
          method: args.method,
          params: (_c3 = args.params) !== null && _c3 !== void 0 ? _c3 : []
        }
      }, correlationId);
      const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);
      if ("failure" in response.content) {
        throw response.content.failure;
      }
      const peerPublicKey = await importKeyFromHexString("public", response.sender);
      await this.keyManager.setPeerPublicKey(peerPublicKey);
      const decrypted = await this.decryptResponseMessage(response);
      this.handleResponse(args, decrypted);
      logHandshakeCompleted({ method: args.method, correlationId });
    } catch (error) {
      logHandshakeError({
        method: args.method,
        correlationId,
        errorMessage: parseErrorMessageFromAny(error)
      });
      throw error;
    }
  }
  async request(request2) {
    const correlationId = correlationIds.get(request2);
    logRequestStarted2({ method: request2.method, correlationId });
    try {
      const result = await this._request(request2);
      logRequestCompleted({ method: request2.method, correlationId });
      return result;
    } catch (error) {
      logRequestError2({
        method: request2.method,
        correlationId,
        errorMessage: parseErrorMessageFromAny(error)
      });
      throw error;
    }
  }
  async _request(request2) {
    var _a14, _b, _c3, _d2, _e6, _f3, _g, _h2, _j, _k;
    if (this.accounts.length === 0) {
      switch (request2.method) {
        case "wallet_switchEthereumChain": {
          assertParamsChainId(request2.params);
          this.chain.id = Number(request2.params[0].chainId);
          return;
        }
        case "wallet_connect": {
          await ((_b = (_a14 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a14));
          await initSubAccountConfig();
          let capabilitiesToInject = {};
          if (requestHasCapability(request2, "addSubAccount")) {
            capabilitiesToInject = (_d2 = (_c3 = store.subAccountsConfig.get()) === null || _c3 === void 0 ? void 0 : _c3.capabilities) !== null && _d2 !== void 0 ? _d2 : {};
          }
          const modifiedRequest = injectRequestCapabilities(request2, capabilitiesToInject);
          return this.sendRequestToPopup(modifiedRequest);
        }
        case "wallet_sendCalls":
        case "wallet_sign": {
          return this.sendRequestToPopup(request2);
        }
        default:
          throw standardErrors.provider.unauthorized();
      }
    }
    if (this.shouldRequestUseSubAccountSigner(request2)) {
      const correlationId = correlationIds.get(request2);
      logSubAccountRequestStarted({ method: request2.method, correlationId });
      try {
        const result = await this.sendRequestToSubAccountSigner(request2);
        logSubAccountRequestCompleted({ method: request2.method, correlationId });
        return result;
      } catch (error) {
        logSubAccountRequestError({
          method: request2.method,
          correlationId,
          errorMessage: parseErrorMessageFromAny(error)
        });
        throw error;
      }
    }
    switch (request2.method) {
      case "eth_requestAccounts":
      case "eth_accounts": {
        const subAccount = store.subAccounts.get();
        const subAccountsConfig2 = store.subAccountsConfig.get();
        if (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address) {
          this.accounts = (subAccountsConfig2 === null || subAccountsConfig2 === void 0 ? void 0 : subAccountsConfig2.enableAutoSubAccounts) ? prependWithoutDuplicates(this.accounts, subAccount.address) : appendWithoutDuplicates(this.accounts, subAccount.address);
        }
        (_e6 = this.callback) === null || _e6 === void 0 ? void 0 : _e6.call(this, "connect", { chainId: numberToHex(this.chain.id) });
        return this.accounts;
      }
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return numberToHex(this.chain.id);
      case "wallet_getCapabilities":
        return this.handleGetCapabilitiesRequest(request2);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(request2);
      case "eth_ecRecover":
      case "personal_sign":
      case "wallet_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(request2);
      case "wallet_connect": {
        const cachedResponse = await getCachedWalletConnectResponse();
        if (cachedResponse) {
          return cachedResponse;
        }
        await ((_g = (_f3 = this.communicator).waitForPopupLoaded) === null || _g === void 0 ? void 0 : _g.call(_f3));
        await initSubAccountConfig();
        const subAccountsConfig2 = store.subAccountsConfig.get();
        const modifiedRequest = injectRequestCapabilities(request2, (_h2 = subAccountsConfig2 === null || subAccountsConfig2 === void 0 ? void 0 : subAccountsConfig2.capabilities) !== null && _h2 !== void 0 ? _h2 : {});
        const result = await this.sendRequestToPopup(modifiedRequest);
        (_j = this.callback) === null || _j === void 0 ? void 0 : _j.call(this, "connect", { chainId: numberToHex(this.chain.id) });
        return result;
      }
      case "wallet_getSubAccounts": {
        const subAccount = store.subAccounts.get();
        if (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address) {
          return {
            subAccounts: [subAccount]
          };
        }
        if (!this.chain.rpcUrl) {
          throw standardErrors.rpc.internal("No RPC URL set for chain");
        }
        const response = await fetchRPCRequest(request2, this.chain.rpcUrl);
        assertArrayPresence(response.subAccounts, "subAccounts");
        if (response.subAccounts.length > 0) {
          assertSubAccount(response.subAccounts[0]);
          const subAccount2 = response.subAccounts[0];
          store.subAccounts.set({
            address: subAccount2.address,
            factory: subAccount2.factory,
            factoryData: subAccount2.factoryData
          });
        }
        return response;
      }
      case "wallet_addSubAccount":
        return this.addSubAccount(request2);
      case "coinbase_fetchPermissions": {
        assertFetchPermissionsRequest(request2);
        const completeRequest = fillMissingParamsForFetchPermissions(request2);
        const permissions = await fetchRPCRequest(completeRequest, CB_WALLET_RPC_URL);
        const requestedChainId = hexToNumber((_k = completeRequest.params) === null || _k === void 0 ? void 0 : _k[0].chainId);
        store.spendPermissions.set(permissions.permissions.map((permission) => Object.assign(Object.assign({}, permission), { chainId: requestedChainId })));
        return permissions;
      }
      default:
        if (!this.chain.rpcUrl) {
          throw standardErrors.rpc.internal("No RPC URL set for chain");
        }
        return fetchRPCRequest(request2, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(request2) {
    var _a14, _b;
    await ((_b = (_a14 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a14));
    const response = await this.sendEncryptedRequest(request2);
    const decrypted = await this.decryptResponseMessage(response);
    return this.handleResponse(request2, decrypted);
  }
  async handleResponse(request2, decrypted) {
    var _a14, _b, _c3, _d2, _e6;
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    switch (request2.method) {
      case "eth_requestAccounts": {
        const accounts = result.value;
        this.accounts = accounts;
        store.account.set({
          accounts,
          chain: this.chain
        });
        (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "accountsChanged", accounts);
        break;
      }
      case "wallet_connect": {
        const response = result.value;
        const accounts = response.accounts.map((account3) => account3.address);
        this.accounts = accounts;
        store.account.set({
          accounts
        });
        const account2 = response.accounts.at(0);
        const capabilities = account2 === null || account2 === void 0 ? void 0 : account2.capabilities;
        if (capabilities === null || capabilities === void 0 ? void 0 : capabilities.subAccounts) {
          const capabilityResponse = capabilities === null || capabilities === void 0 ? void 0 : capabilities.subAccounts;
          assertArrayPresence(capabilityResponse, "subAccounts");
          assertSubAccount(capabilityResponse[0]);
          store.subAccounts.set({
            address: capabilityResponse[0].address,
            factory: capabilityResponse[0].factory,
            factoryData: capabilityResponse[0].factoryData
          });
        }
        let accounts_ = [this.accounts[0]];
        const subAccount = store.subAccounts.get();
        const subAccountsConfig2 = store.subAccountsConfig.get();
        if (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address) {
          this.accounts = (subAccountsConfig2 === null || subAccountsConfig2 === void 0 ? void 0 : subAccountsConfig2.enableAutoSubAccounts) ? prependWithoutDuplicates(this.accounts, subAccount.address) : appendWithoutDuplicates(this.accounts, subAccount.address);
        }
        const spendPermissions2 = (_c3 = (_b = response === null || response === void 0 ? void 0 : response.accounts) === null || _b === void 0 ? void 0 : _b[0].capabilities) === null || _c3 === void 0 ? void 0 : _c3.spendPermissions;
        if (spendPermissions2 && "permissions" in spendPermissions2) {
          store.spendPermissions.set(spendPermissions2 === null || spendPermissions2 === void 0 ? void 0 : spendPermissions2.permissions);
        }
        (_d2 = this.callback) === null || _d2 === void 0 ? void 0 : _d2.call(this, "accountsChanged", accounts_);
        break;
      }
      case "wallet_addSubAccount": {
        assertSubAccount(result.value);
        const subAccount = result.value;
        store.subAccounts.set(subAccount);
        const subAccountsConfig2 = store.subAccountsConfig.get();
        this.accounts = (subAccountsConfig2 === null || subAccountsConfig2 === void 0 ? void 0 : subAccountsConfig2.enableAutoSubAccounts) ? prependWithoutDuplicates(this.accounts, subAccount.address) : appendWithoutDuplicates(this.accounts, subAccount.address);
        (_e6 = this.callback) === null || _e6 === void 0 ? void 0 : _e6.call(this, "accountsChanged", this.accounts);
        break;
      }
      default:
        break;
    }
    return result.value;
  }
  async cleanup() {
    var _a14, _b;
    const metadata = store.config.get().metadata;
    await this.keyManager.clear();
    store.account.clear();
    store.subAccounts.clear();
    store.spendPermissions.clear();
    store.chains.clear();
    this.accounts = [];
    this.chain = {
      id: (_b = (_a14 = metadata === null || metadata === void 0 ? void 0 : metadata.appChainIds) === null || _a14 === void 0 ? void 0 : _a14[0]) !== null && _b !== void 0 ? _b : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(request2) {
    assertParamsChainId(request2.params);
    const chainId = ensureIntNumber(request2.params[0].chainId);
    const localResult = this.updateChain(chainId);
    if (localResult)
      return null;
    const popupResult = await this.sendRequestToPopup(request2);
    if (popupResult === null) {
      this.updateChain(chainId);
    }
    return popupResult;
  }
  async handleGetCapabilitiesRequest(request2) {
    assertGetCapabilitiesParams(request2.params);
    const requestedAccount = request2.params[0];
    const filterChainIds = request2.params[1];
    if (!this.accounts.some((account2) => isAddressEqual(account2, requestedAccount))) {
      throw standardErrors.provider.unauthorized("no active account found when getting capabilities");
    }
    const capabilities = store.getState().account.capabilities;
    if (!capabilities) {
      return {};
    }
    if (!filterChainIds || filterChainIds.length === 0) {
      return capabilities;
    }
    const filterChainNumbers = new Set(filterChainIds.map((chainId) => hexToNumber(chainId)));
    const filteredCapabilities = Object.fromEntries(Object.entries(capabilities).filter(([capabilityKey]) => {
      try {
        const capabilityChainNumber = hexToNumber(capabilityKey);
        return filterChainNumbers.has(capabilityChainNumber);
      } catch (_a14) {
        return false;
      }
    }));
    return filteredCapabilities;
  }
  async sendEncryptedRequest(request2) {
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors.provider.unauthorized("No shared secret found when encrypting request");
    }
    const encrypted = await encryptContent({
      action: request2,
      chainId: this.chain.id
    }, sharedSecret);
    const correlationId = correlationIds.get(request2);
    const message = await this.createRequestMessage({ encrypted }, correlationId);
    return this.communicator.postRequestAndWaitForResponse(message);
  }
  async createRequestMessage(content, correlationId) {
    const publicKey = await exportKeyToHexString("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      correlationId,
      sender: publicKey,
      content,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(message) {
    var _a14, _b, _c3;
    const content = message.content;
    if ("failure" in content) {
      throw content.failure;
    }
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors.provider.unauthorized("Invalid session: no shared secret found when decrypting response");
    }
    const response = await decryptContent(content.encrypted, sharedSecret);
    const availableChains = (_a14 = response.data) === null || _a14 === void 0 ? void 0 : _a14.chains;
    if (availableChains) {
      const nativeCurrencies = (_b = response.data) === null || _b === void 0 ? void 0 : _b.nativeCurrencies;
      const chains2 = Object.entries(availableChains).map(([id2, rpcUrl]) => {
        const nativeCurrency = nativeCurrencies === null || nativeCurrencies === void 0 ? void 0 : nativeCurrencies[Number(id2)];
        return Object.assign({ id: Number(id2), rpcUrl }, nativeCurrency ? { nativeCurrency } : {});
      });
      store.chains.set(chains2);
      this.updateChain(this.chain.id, chains2);
      createClients(chains2);
    }
    const walletCapabilities = (_c3 = response.data) === null || _c3 === void 0 ? void 0 : _c3.capabilities;
    if (walletCapabilities) {
      store.account.set({
        capabilities: walletCapabilities
      });
    }
    return response;
  }
  updateChain(chainId, newAvailableChains) {
    var _a14;
    const state = store.getState();
    const chains2 = newAvailableChains !== null && newAvailableChains !== void 0 ? newAvailableChains : state.chains;
    const chain6 = chains2 === null || chains2 === void 0 ? void 0 : chains2.find((chain7) => chain7.id === chainId);
    if (!chain6)
      return false;
    if (chain6 !== this.chain) {
      this.chain = chain6;
      store.account.set({
        chain: chain6
      });
      (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "chainChanged", hexStringFromNumber(chain6.id));
    }
    return true;
  }
  async addSubAccount(request2) {
    var _a14, _b, _c3, _d2;
    const state = store.getState();
    const subAccount = state.subAccount;
    const subAccountsConfig2 = store.subAccountsConfig.get();
    if (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address) {
      this.accounts = (subAccountsConfig2 === null || subAccountsConfig2 === void 0 ? void 0 : subAccountsConfig2.enableAutoSubAccounts) ? prependWithoutDuplicates(this.accounts, subAccount.address) : appendWithoutDuplicates(this.accounts, subAccount.address);
      (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "accountsChanged", this.accounts);
      return subAccount;
    }
    await ((_c3 = (_b = this.communicator).waitForPopupLoaded) === null || _c3 === void 0 ? void 0 : _c3.call(_b));
    if (Array.isArray(request2.params) && request2.params.length > 0 && request2.params[0].account && request2.params[0].account.type === "create") {
      let keys5;
      if (request2.params[0].account.keys && request2.params[0].account.keys.length > 0) {
        keys5 = request2.params[0].account.keys;
      } else {
        const config2 = (_d2 = store.subAccountsConfig.get()) !== null && _d2 !== void 0 ? _d2 : {};
        const { account: ownerAccount } = config2.toOwnerAccount ? await config2.toOwnerAccount() : await getCryptoKeyAccount();
        if (!ownerAccount) {
          throw standardErrors.provider.unauthorized("could not get subaccount owner account when adding sub account");
        }
        keys5 = [
          {
            type: ownerAccount.address ? "address" : "webauthn-p256",
            publicKey: ownerAccount.address || ownerAccount.publicKey
          }
        ];
      }
      request2.params[0].account.keys = keys5;
    }
    const response = await this.sendRequestToPopup(request2);
    assertSubAccount(response);
    return response;
  }
  shouldRequestUseSubAccountSigner(request2) {
    const sender = getSenderFromRequest(request2);
    const subAccount = store.subAccounts.get();
    if (sender) {
      return sender.toLowerCase() === (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address.toLowerCase());
    }
    return false;
  }
  async sendRequestToSubAccountSigner(request2) {
    var _a14;
    const subAccount = store.subAccounts.get();
    const subAccountsConfig2 = store.subAccountsConfig.get();
    const config2 = store.config.get();
    assertPresence(subAccount === null || subAccount === void 0 ? void 0 : subAccount.address, standardErrors.provider.unauthorized("no active sub account when sending request to sub account signer"));
    const ownerAccount = (subAccountsConfig2 === null || subAccountsConfig2 === void 0 ? void 0 : subAccountsConfig2.toOwnerAccount) ? await subAccountsConfig2.toOwnerAccount() : await getCryptoKeyAccount();
    assertPresence(ownerAccount === null || ownerAccount === void 0 ? void 0 : ownerAccount.account, standardErrors.provider.unauthorized("no active sub account owner when sending request to sub account signer"));
    const sender = getSenderFromRequest(request2);
    if (sender === void 0) {
      request2 = addSenderToRequest(request2, subAccount.address);
    }
    const client = getClient(this.chain.id);
    assertPresence(client, standardErrors.rpc.internal(`client not found for chainId ${this.chain.id} when sending request to sub account signer`));
    const globalAccountAddress = this.accounts.find((account2) => account2.toLowerCase() !== subAccount.address.toLowerCase());
    assertPresence(globalAccountAddress, standardErrors.provider.unauthorized("no global account found when sending request to sub account signer"));
    const dataSuffix = makeDataSuffix({
      attribution: (_a14 = config2.preference) === null || _a14 === void 0 ? void 0 : _a14.attribution,
      dappOrigin: window.location.origin
    });
    const publicKey = ownerAccount.account.type === "local" ? ownerAccount.account.address : ownerAccount.account.publicKey;
    let ownerIndex = await findOwnerIndex({
      address: subAccount.address,
      factory: subAccount.factory,
      factoryData: subAccount.factoryData,
      publicKey,
      client
    });
    if (ownerIndex === -1) {
      const correlationId = correlationIds.get(request2);
      logAddOwnerStarted({ method: request2.method, correlationId });
      try {
        ownerIndex = await handleAddSubAccountOwner({
          ownerAccount: ownerAccount.account,
          globalAccountRequest: this.sendRequestToPopup.bind(this)
        });
        logAddOwnerCompleted({ method: request2.method, correlationId });
      } catch (error) {
        logAddOwnerError({
          method: request2.method,
          correlationId,
          errorMessage: parseErrorMessageFromAny(error)
        });
        return standardErrors.provider.unauthorized("failed to add sub account owner when sending request to sub account signer");
      }
    }
    const { request: subAccountRequest } = await createSubAccountSigner({
      address: subAccount.address,
      owner: ownerAccount.account,
      client,
      factory: subAccount.factory,
      factoryData: subAccount.factoryData,
      parentAddress: globalAccountAddress,
      attribution: dataSuffix ? { suffix: dataSuffix } : void 0,
      ownerIndex
    });
    try {
      const result = await subAccountRequest(request2);
      return result;
    } catch (error) {
      let errorObject;
      if (isViemError(error)) {
        errorObject = JSON.parse(error.details);
      } else if (isActionableHttpRequestError(error)) {
        errorObject = error;
      } else {
        throw error;
      }
      if (!(isActionableHttpRequestError(errorObject) && errorObject.data)) {
        throw error;
      }
      if (!errorObject.data) {
        throw error;
      }
      const correlationId = correlationIds.get(request2);
      logInsufficientBalanceErrorHandlingStarted({ method: request2.method, correlationId });
      try {
        const result = await handleInsufficientBalanceError({
          errorData: errorObject.data,
          globalAccountAddress,
          subAccountAddress: subAccount.address,
          client,
          request: request2,
          subAccountRequest,
          globalAccountRequest: this.request.bind(this)
        });
        logInsufficientBalanceErrorHandlingCompleted({ method: request2.method, correlationId });
        return result;
      } catch (handlingError) {
        console.error(handlingError);
        logInsufficientBalanceErrorHandlingError({
          method: request2.method,
          correlationId,
          errorMessage: parseErrorMessageFromAny(handlingError)
        });
        throw error;
      }
    }
  }
};

// node_modules/@base-org/account/dist/interface/builder/core/BaseAccountProvider.js
var __rest4 = function(s5, e11) {
  var t6 = {};
  for (var p9 in s5) if (Object.prototype.hasOwnProperty.call(s5, p9) && e11.indexOf(p9) < 0)
    t6[p9] = s5[p9];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i9 = 0, p9 = Object.getOwnPropertySymbols(s5); i9 < p9.length; i9++) {
      if (e11.indexOf(p9[i9]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p9[i9]))
        t6[p9[i9]] = s5[p9[i9]];
    }
  return t6;
};
var BaseAccountProvider = class extends ProviderEventEmitter {
  constructor(_a14) {
    var { metadata } = _a14, _b = _a14.preference, { walletUrl } = _b, preference = __rest4(_b, ["walletUrl"]);
    super();
    this.isBaseAccount = true;
    this.communicator = new Communicator({
      url: walletUrl,
      metadata,
      preference
    });
    this.signer = new Signer({
      metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
  async request(args) {
    const correlationId = crypto.randomUUID();
    correlationIds.set(args, correlationId);
    logRequestStarted({ method: args.method, correlationId });
    try {
      const result = await this._request(args);
      logRequestResponded({
        method: args.method,
        correlationId
      });
      return result;
    } catch (error) {
      logRequestError({
        method: args.method,
        correlationId,
        errorMessage: error instanceof Error ? error.message : ""
      });
      throw error;
    } finally {
      correlationIds.delete(args);
    }
  }
  async _request(args) {
    var _a14, _b;
    try {
      checkErrorForInvalidRequestArgs(args);
      if (!this.signer.isConnected) {
        switch (args.method) {
          case "eth_requestAccounts": {
            await this.signer.handshake({ method: "handshake" });
            await initSubAccountConfig();
            await this.signer.request({
              method: "wallet_connect",
              params: [
                {
                  version: "1",
                  capabilities: Object.assign({}, (_b = (_a14 = store.subAccountsConfig.get()) === null || _a14 === void 0 ? void 0 : _a14.capabilities) !== null && _b !== void 0 ? _b : {})
                }
              ]
            });
            break;
          }
          case "wallet_connect": {
            await this.signer.handshake({ method: "handshake" });
            const result2 = await this.signer.request(args);
            return result2;
          }
          case "wallet_sendCalls":
          case "wallet_sign": {
            try {
              await this.signer.handshake({ method: "handshake" });
              const result2 = await this.signer.request(args);
              return result2;
            } finally {
              await this.signer.cleanup();
            }
          }
          case "wallet_getCallsStatus": {
            const result2 = await fetchRPCRequest(args, CB_WALLET_RPC_URL);
            return result2;
          }
          case "eth_accounts": {
            return [];
          }
          case "net_version": {
            const result2 = 1;
            return result2;
          }
          case "eth_chainId": {
            const result2 = hexStringFromNumber(1);
            return result2;
          }
          default: {
            throw standardErrors.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
          }
        }
      }
      const result = await this.signer.request(args);
      return result;
    } catch (error) {
      const { code } = error;
      if (code === standardErrorCodes.provider.unauthorized) {
        await this.disconnect();
      }
      return Promise.reject(serializeError(error));
    }
  }
  async disconnect() {
    await this.signer.cleanup();
    correlationIds.clear();
    this.emit("disconnect", standardErrors.provider.disconnected("User initiated disconnection"));
  }
};

// node_modules/@base-org/account/dist/interface/builder/core/getInjectedProvider.js
var TBA_PROVIDER_IDENTIFIER = "isCoinbaseBrowser";
function getInjectedProvider() {
  var _a14, _b;
  const injectedProvider = (_a14 = window.ethereum) !== null && _a14 !== void 0 ? _a14 : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;
  if (injectedProvider === null || injectedProvider === void 0 ? void 0 : injectedProvider[TBA_PROVIDER_IDENTIFIER]) {
    return injectedProvider;
  }
  return null;
}

// node_modules/@base-org/account/dist/interface/builder/core/createBaseAccountSDK.js
function createBaseAccountSDK(params) {
  var _a14, _b, _c3, _d2;
  const options = {
    metadata: {
      appName: params.appName || "App",
      appLogoUrl: params.appLogoUrl || "",
      appChainIds: params.appChainIds || []
    },
    preference: (_a14 = params.preference) !== null && _a14 !== void 0 ? _a14 : {},
    paymasterUrls: params.paymasterUrls
  };
  if ((_b = params.subAccounts) === null || _b === void 0 ? void 0 : _b.toOwnerAccount) {
    validateSubAccount(params.subAccounts.toOwnerAccount);
  }
  store.subAccountsConfig.set({
    toOwnerAccount: (_c3 = params.subAccounts) === null || _c3 === void 0 ? void 0 : _c3.toOwnerAccount,
    // @ts-expect-error - enableSubAccounts is not officially supported yet
    enableAutoSubAccounts: (_d2 = params.subAccounts) === null || _d2 === void 0 ? void 0 : _d2.enableAutoSubAccounts
  });
  store.config.set(options);
  void store.persist.rehydrate();
  void checkCrossOriginOpenerPolicy();
  validatePreferences(options.preference);
  if (options.preference.telemetry !== false) {
    void loadTelemetryScript();
  }
  let provider = null;
  const sdk = {
    getProvider: () => {
      var _a15;
      if (!provider) {
        provider = (_a15 = getInjectedProvider()) !== null && _a15 !== void 0 ? _a15 : new BaseAccountProvider(options);
      }
      return provider;
    },
    subAccount: {
      async create(accountParam) {
        var _a15;
        return await ((_a15 = sdk.getProvider()) === null || _a15 === void 0 ? void 0 : _a15.request({
          method: "wallet_addSubAccount",
          params: [
            {
              version: "1",
              account: accountParam
            }
          ]
        }));
      },
      async get() {
        var _a15, _b2;
        const subAccount = store.subAccounts.get();
        if (subAccount === null || subAccount === void 0 ? void 0 : subAccount.address) {
          return subAccount;
        }
        const response = await ((_a15 = sdk.getProvider()) === null || _a15 === void 0 ? void 0 : _a15.request({
          method: "wallet_connect",
          params: [
            {
              version: "1",
              capabilities: {}
            }
          ]
        }));
        const subAccounts2 = (_b2 = response.accounts[0].capabilities) === null || _b2 === void 0 ? void 0 : _b2.subAccounts;
        if (!Array.isArray(subAccounts2)) {
          return null;
        }
        return subAccounts2[0];
      },
      addOwner: async ({ address, publicKey, chainId }) => {
        var _a15, _b2;
        const subAccount = store.subAccounts.get();
        const account2 = store.account.get();
        assertPresence(account2, new Error("account does not exist"));
        assertPresence(subAccount === null || subAccount === void 0 ? void 0 : subAccount.address, new Error("subaccount does not exist"));
        const calls = [];
        if (publicKey) {
          const [x7, y11] = decodeAbiParameters([{ type: "bytes32" }, { type: "bytes32" }], publicKey);
          calls.push({
            to: subAccount.address,
            data: encodeFunctionData({
              abi,
              functionName: "addOwnerPublicKey",
              args: [x7, y11]
            }),
            value: toHex(0)
          });
        }
        if (address) {
          calls.push({
            to: subAccount.address,
            data: encodeFunctionData({
              abi,
              functionName: "addOwnerAddress",
              args: [address]
            }),
            value: toHex(0)
          });
        }
        return await ((_a15 = sdk.getProvider()) === null || _a15 === void 0 ? void 0 : _a15.request({
          method: "wallet_sendCalls",
          params: [
            {
              calls,
              chainId: toHex(chainId),
              from: (_b2 = account2.accounts) === null || _b2 === void 0 ? void 0 : _b2[0],
              version: "1"
            }
          ]
        }));
      },
      setToOwnerAccount(toSubAccountOwner) {
        validateSubAccount(toSubAccountOwner);
        store.subAccountsConfig.set({
          toOwnerAccount: toSubAccountOwner
        });
      }
    }
  };
  return sdk;
}

// node_modules/@dynamic-labs-connectors/base-account-evm/src/helpers.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i9 = 1; i9 < arguments.length; i9++) {
      var source = arguments[i9];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var baseAccountProvider;
var baseSepolia2 = 84532;
var baseMainnet = 8453;
var getBaseAccountProvider = (opts2) => {
  const { evmNetworks } = opts2;
  const appChainIds = evmNetworks == null ? void 0 : evmNetworks.map((network) => Number(network.chainId));
  const hasBaseSepolia = evmNetworks == null ? void 0 : evmNetworks.some((network) => Number(network.chainId) === baseSepolia2);
  if (hasBaseSepolia) {
    appChainIds == null ? void 0 : appChainIds.sort((a6, b6) => a6 === baseSepolia2 ? -1 : b6 === baseSepolia2 ? 1 : 0);
  }
  const hasBaseMainnet = evmNetworks == null ? void 0 : evmNetworks.some((network) => Number(network.chainId) === baseMainnet);
  if (hasBaseMainnet) {
    appChainIds == null ? void 0 : appChainIds.sort((a6, b6) => a6 === baseMainnet ? -1 : b6 === baseMainnet ? 1 : 0);
  }
  if (!baseAccountProvider) {
    const baseAccountSdk = createBaseAccountSDK(_extends({}, opts2, {
      appChainIds
    }));
    baseAccountProvider = baseAccountSdk.getProvider();
  }
  return baseAccountProvider;
};

// node_modules/@dynamic-labs-connectors/base-account-evm/src/BaseAccountEvmWalletConnector.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i9 = 1; i9 < arguments.length; i9++) {
      var source = arguments[i9];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var BaseAccountEvmWalletConnector = class extends EthereumWalletConnector {
  get baseAccountProvider() {
    return getBaseAccountProvider(this.props);
  }
  async getConnectedAccounts() {
    try {
      const accounts = await this.baseAccountProvider.request({
        method: "eth_accounts"
      });
      if (accounts[0]) {
        this.setActiveAccount(this.parseAddress(accounts[0]));
      }
      return accounts.map(this.parseAddress);
    } catch (error) {
      logger.error("Error getting connected accounts", error);
      return [];
    }
  }
  async getAddress() {
    try {
      const [address] = await this.baseAccountProvider.request({
        method: "eth_requestAccounts"
      });
      if (!address) {
        throw new Error("No address found");
      }
      const parsedAddress = this.parseAddress(address);
      this.setActiveAccount(parsedAddress);
      return parsedAddress;
    } catch (error) {
      logger.error("Error requesting address", error);
      return;
    }
  }
  async signMessage(messageToSign) {
    try {
      const [address] = await this.baseAccountProvider.request({
        method: "eth_requestAccounts"
      });
      if (!address) {
        throw new Error("No address found");
      }
      const parsedAddress = this.parseAddress(address);
      const signature = await this.baseAccountProvider.request({
        method: "personal_sign",
        params: [
          toHex(toBytes(messageToSign)),
          parsedAddress
        ]
      });
      return signature;
    } catch (err) {
      logger.error("Error signing message", err);
      return void 0;
    }
  }
  setupEventListeners() {
    const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
    this.baseAccountProvider.on("accountsChanged", handleAccountChange);
    this.baseAccountProvider.on("chainChanged", handleChainChange);
    this.baseAccountProvider.on("disconnect", handleDisconnect);
    this.teardownEventListeners = () => {
      this.baseAccountProvider.removeListener("accountsChanged", handleAccountChange);
      this.baseAccountProvider.removeListener("chainChanged", handleChainChange);
      this.baseAccountProvider.removeListener("disconnect", handleDisconnect);
    };
  }
  getWalletClient(chainId) {
    return createWalletClient({
      account: this.getActiveAccount(),
      chain: chainId ? chainsMap[chainId] : this.getActiveChain(),
      transport: custom(this.baseAccountProvider, this.providersConfig.httpTransportConfig)
    });
  }
  constructor(props) {
    super(_extends2({}, props, {
      metadata: {
        id: "baseAccount",
        name: "Base Account",
        icon: "https://base.org/favicon.ico"
      }
    }));
    this.name = "Base Account";
    this.canConnectViaCustodialService = true;
    this.props = props;
  }
};

// node_modules/@dynamic-labs-connectors/base-account-evm/src/index.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i9 = 1; i9 < arguments.length; i9++) {
      var source = arguments[i9];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var createBaseAccountConnector = (baseAccountOpts = {}) => {
  return () => [
    class extends BaseAccountEvmWalletConnector {
      constructor(props) {
        super(_extends3({}, props, baseAccountOpts));
      }
    }
  ];
};

// node_modules/@dynamic-labs/embedded-wallet-evm/package.js
var version5 = "4.43.0";

// node_modules/@dynamic-labs/embedded-wallet/package.js
var version6 = "4.43.0";

// node_modules/@dynamic-labs/embedded-wallet/_virtual/_tslib.js
function __awaiter3(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f16) {
  if (kind === "a" && !f16) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f16 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f16 : kind === "a" ? f16.call(receiver) : f16 ? f16.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value2, kind, f16) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f16) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f16 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f16.call(receiver, value2) : f16 ? f16.value = value2 : state.set(receiver, value2), value2;
}

// node_modules/@turnkey/api-key-stamper/dist/index.mjs
var stampHeaderName = "X-Stamp";
var isCryptoEnabledBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var detectRuntime = () => {
  if (isCryptoEnabledBrowser) {
    return "browser";
  }
  if (isNode) {
    return "node";
  }
  return "purejs";
};
var signWithApiKey = async (input, runtimeOverride) => {
  const runtime = runtimeOverride ?? detectRuntime();
  switch (runtime) {
    case "browser":
      return (await import("./webcrypto-2RZV6LT6.js")).signWithApiKey(input);
    case "node":
      return (await import("./nodecrypto-CI7MH263.js")).signWithApiKey(input);
    case "purejs":
      return (await import("./purejs-PZQFAR7N.js")).signWithApiKey(input);
    default:
      throw new Error(`Unsupported runtime: ${runtime}`);
  }
};
var ApiKeyStamper = class {
  constructor(config2) {
    this.apiPublicKey = config2.apiPublicKey;
    this.apiPrivateKey = config2.apiPrivateKey;
    this.runtimeOverride = config2.runtimeOverride;
  }
  async stamp(payload) {
    const signature = await signWithApiKey({
      publicKey: this.apiPublicKey,
      privateKey: this.apiPrivateKey,
      content: payload
    }, this.runtimeOverride);
    const stamp = {
      publicKey: this.apiPublicKey,
      scheme: "SIGNATURE_SCHEME_TK_API_P256",
      signature
    };
    return {
      stampHeaderName,
      stampHeaderValue: stringToBase64urlString(JSON.stringify(stamp))
    };
  }
};

// node_modules/@turnkey/http/dist/universal.mjs
var import_cross_fetch = __toESM(require_browser_ponyfill2(), 1);
var fetch2 = import_cross_fetch.fetch;

// node_modules/@turnkey/http/dist/webauthn-json/convert.mjs
var copyValue = "copy";
var convertValue = "convert";
function derived(schema, derive) {
  return {
    required: true,
    schema,
    derive
  };
}
function required(schema) {
  return {
    required: true,
    schema
  };
}
function optional(schema) {
  return {
    required: false,
    schema
  };
}

// node_modules/@turnkey/http/dist/webauthn-json/schema.mjs
var simplifiedClientExtensionResultsSchema = {
  appid: optional(copyValue),
  appidExclude: optional(copyValue),
  credProps: optional(copyValue)
};
var publicKeyCredentialWithAttestation = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    attestationObject: required(convertValue),
    transports: derived(copyValue, (response) => {
      var _a14;
      return ((_a14 = response.getTransports) == null ? void 0 : _a14.call(response)) || [];
    })
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
};
var publicKeyCredentialWithAssertion = {
  type: required(copyValue),
  id: required(copyValue),
  rawId: required(convertValue),
  authenticatorAttachment: optional(copyValue),
  response: required({
    clientDataJSON: required(convertValue),
    authenticatorData: required(convertValue),
    signature: required(convertValue),
    userHandle: required(convertValue)
  }),
  clientExtensionResults: derived(simplifiedClientExtensionResultsSchema, (pkc) => pkc.getClientExtensionResults())
};

// node_modules/@turnkey/http/dist/webauthn.mjs
var defaultTimeout = 5 * 60 * 1e3;

// node_modules/@turnkey/http/dist/base.mjs
function isHttpClient(client) {
  return (client == null ? void 0 : client.name) === "TurnkeyClient";
}
var TurnkeyRequestError = class extends Error {
  constructor(input) {
    let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;
    if (input.details != null) {
      turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;
    }
    super(turnkeyErrorMessage);
    this.name = "TurnkeyRequestError";
    this.details = input.details ?? null;
    this.code = input.code;
  }
};

// node_modules/@turnkey/http/dist/version.mjs
var VERSION = "@turnkey/http@3.10.0";

// node_modules/@turnkey/http/dist/__generated__/services/coordinator/public/v1/public_api.client.mjs
var TurnkeyClient = class {
  constructor(config2, stamper) {
    this.name = "TurnkeyClient";
    this.getActivity = async (input) => {
      return this.request("/public/v1/query/get_activity", input);
    };
    this.stampGetActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getApiKey = async (input) => {
      return this.request("/public/v1/query/get_api_key", input);
    };
    this.stampGetApiKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getApiKeys = async (input) => {
      return this.request("/public/v1/query/get_api_keys", input);
    };
    this.stampGetApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAttestationDocument = async (input) => {
      return this.request("/public/v1/query/get_attestation", input);
    };
    this.stampGetAttestationDocument = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_attestation";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAuthenticator = async (input) => {
      return this.request("/public/v1/query/get_authenticator", input);
    };
    this.stampGetAuthenticator = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticator";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getAuthenticators = async (input) => {
      return this.request("/public/v1/query/get_authenticators", input);
    };
    this.stampGetAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOauthProviders = async (input) => {
      return this.request("/public/v1/query/get_oauth_providers", input);
    };
    this.stampGetOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOrganization = async (input) => {
      return this.request("/public/v1/query/get_organization", input);
    };
    this.stampGetOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getOrganizationConfigs = async (input) => {
      return this.request("/public/v1/query/get_organization_configs", input);
    };
    this.stampGetOrganizationConfigs = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_organization_configs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicy = async (input) => {
      return this.request("/public/v1/query/get_policy", input);
    };
    this.stampGetPolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicyEvaluations = async (input) => {
      return this.request("/public/v1/query/get_policy_evaluations", input);
    };
    this.stampGetPolicyEvaluations = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_policy_evaluations";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPrivateKey = async (input) => {
      return this.request("/public/v1/query/get_private_key", input);
    };
    this.stampGetPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSmartContractInterface = async (input) => {
      return this.request("/public/v1/query/get_smart_contract_interface", input);
    };
    this.stampGetSmartContractInterface = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_smart_contract_interface";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getUser = async (input) => {
      return this.request("/public/v1/query/get_user", input);
    };
    this.stampGetUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWallet = async (input) => {
      return this.request("/public/v1/query/get_wallet", input);
    };
    this.stampGetWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWalletAccount = async (input) => {
      return this.request("/public/v1/query/get_wallet_account", input);
    };
    this.stampGetWalletAccount = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/get_wallet_account";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getActivities = async (input) => {
      return this.request("/public/v1/query/list_activities", input);
    };
    this.stampGetActivities = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_activities";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPolicies = async (input) => {
      return this.request("/public/v1/query/list_policies", input);
    };
    this.stampGetPolicies = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_policies";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.listPrivateKeyTags = async (input) => {
      return this.request("/public/v1/query/list_private_key_tags", input);
    };
    this.stampListPrivateKeyTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_key_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getPrivateKeys = async (input) => {
      return this.request("/public/v1/query/list_private_keys", input);
    };
    this.stampGetPrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSmartContractInterfaces = async (input) => {
      return this.request("/public/v1/query/list_smart_contract_interfaces", input);
    };
    this.stampGetSmartContractInterfaces = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_smart_contract_interfaces";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getSubOrgIds = async (input) => {
      return this.request("/public/v1/query/list_suborgs", input);
    };
    this.stampGetSubOrgIds = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_suborgs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.listUserTags = async (input) => {
      return this.request("/public/v1/query/list_user_tags", input);
    };
    this.stampListUserTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_user_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getUsers = async (input) => {
      return this.request("/public/v1/query/list_users", input);
    };
    this.stampGetUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getVerifiedSubOrgIds = async (input) => {
      return this.request("/public/v1/query/list_verified_suborgs", input);
    };
    this.stampGetVerifiedSubOrgIds = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_verified_suborgs";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWalletAccounts = async (input) => {
      return this.request("/public/v1/query/list_wallet_accounts", input);
    };
    this.stampGetWalletAccounts = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallet_accounts";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWallets = async (input) => {
      return this.request("/public/v1/query/list_wallets", input);
    };
    this.stampGetWallets = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/list_wallets";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.getWhoami = async (input) => {
      return this.request("/public/v1/query/whoami", input);
    };
    this.stampGetWhoami = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/query/whoami";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.approveActivity = async (input) => {
      return this.request("/public/v1/submit/approve_activity", input);
    };
    this.stampApproveActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/approve_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createApiKeys = async (input) => {
      return this.request("/public/v1/submit/create_api_keys", input);
    };
    this.stampCreateApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createApiOnlyUsers = async (input) => {
      return this.request("/public/v1/submit/create_api_only_users", input);
    };
    this.stampCreateApiOnlyUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_api_only_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createAuthenticators = async (input) => {
      return this.request("/public/v1/submit/create_authenticators", input);
    };
    this.stampCreateAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createInvitations = async (input) => {
      return this.request("/public/v1/submit/create_invitations", input);
    };
    this.stampCreateInvitations = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_invitations";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createOauthProviders = async (input) => {
      return this.request("/public/v1/submit/create_oauth_providers", input);
    };
    this.stampCreateOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPolicies = async (input) => {
      return this.request("/public/v1/submit/create_policies", input);
    };
    this.stampCreatePolicies = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policies";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPolicy = async (input) => {
      return this.request("/public/v1/submit/create_policy", input);
    };
    this.stampCreatePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPrivateKeyTag = async (input) => {
      return this.request("/public/v1/submit/create_private_key_tag", input);
    };
    this.stampCreatePrivateKeyTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_key_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createPrivateKeys = async (input) => {
      return this.request("/public/v1/submit/create_private_keys", input);
    };
    this.stampCreatePrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createReadOnlySession = async (input) => {
      return this.request("/public/v1/submit/create_read_only_session", input);
    };
    this.stampCreateReadOnlySession = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_only_session";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createReadWriteSession = async (input) => {
      return this.request("/public/v1/submit/create_read_write_session", input);
    };
    this.stampCreateReadWriteSession = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_read_write_session";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createSmartContractInterface = async (input) => {
      return this.request("/public/v1/submit/create_smart_contract_interface", input);
    };
    this.stampCreateSmartContractInterface = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_smart_contract_interface";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createSubOrganization = async (input) => {
      return this.request("/public/v1/submit/create_sub_organization", input);
    };
    this.stampCreateSubOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_sub_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createUserTag = async (input) => {
      return this.request("/public/v1/submit/create_user_tag", input);
    };
    this.stampCreateUserTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_user_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createUsers = async (input) => {
      return this.request("/public/v1/submit/create_users", input);
    };
    this.stampCreateUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createWallet = async (input) => {
      return this.request("/public/v1/submit/create_wallet", input);
    };
    this.stampCreateWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.createWalletAccounts = async (input) => {
      return this.request("/public/v1/submit/create_wallet_accounts", input);
    };
    this.stampCreateWalletAccounts = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/create_wallet_accounts";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteApiKeys = async (input) => {
      return this.request("/public/v1/submit/delete_api_keys", input);
    };
    this.stampDeleteApiKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_api_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteAuthenticators = async (input) => {
      return this.request("/public/v1/submit/delete_authenticators", input);
    };
    this.stampDeleteAuthenticators = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_authenticators";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteInvitation = async (input) => {
      return this.request("/public/v1/submit/delete_invitation", input);
    };
    this.stampDeleteInvitation = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_invitation";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteOauthProviders = async (input) => {
      return this.request("/public/v1/submit/delete_oauth_providers", input);
    };
    this.stampDeleteOauthProviders = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_oauth_providers";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePolicy = async (input) => {
      return this.request("/public/v1/submit/delete_policy", input);
    };
    this.stampDeletePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePrivateKeyTags = async (input) => {
      return this.request("/public/v1/submit/delete_private_key_tags", input);
    };
    this.stampDeletePrivateKeyTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_key_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deletePrivateKeys = async (input) => {
      return this.request("/public/v1/submit/delete_private_keys", input);
    };
    this.stampDeletePrivateKeys = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_private_keys";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteSmartContractInterface = async (input) => {
      return this.request("/public/v1/submit/delete_smart_contract_interface", input);
    };
    this.stampDeleteSmartContractInterface = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_smart_contract_interface";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteSubOrganization = async (input) => {
      return this.request("/public/v1/submit/delete_sub_organization", input);
    };
    this.stampDeleteSubOrganization = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_sub_organization";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteUserTags = async (input) => {
      return this.request("/public/v1/submit/delete_user_tags", input);
    };
    this.stampDeleteUserTags = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_user_tags";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteUsers = async (input) => {
      return this.request("/public/v1/submit/delete_users", input);
    };
    this.stampDeleteUsers = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_users";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.deleteWallets = async (input) => {
      return this.request("/public/v1/submit/delete_wallets", input);
    };
    this.stampDeleteWallets = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/delete_wallets";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.emailAuth = async (input) => {
      return this.request("/public/v1/submit/email_auth", input);
    };
    this.stampEmailAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/email_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportPrivateKey = async (input) => {
      return this.request("/public/v1/submit/export_private_key", input);
    };
    this.stampExportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportWallet = async (input) => {
      return this.request("/public/v1/submit/export_wallet", input);
    };
    this.stampExportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.exportWalletAccount = async (input) => {
      return this.request("/public/v1/submit/export_wallet_account", input);
    };
    this.stampExportWalletAccount = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/export_wallet_account";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.importPrivateKey = async (input) => {
      return this.request("/public/v1/submit/import_private_key", input);
    };
    this.stampImportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/import_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.importWallet = async (input) => {
      return this.request("/public/v1/submit/import_wallet", input);
    };
    this.stampImportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/import_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initFiatOnRamp = async (input) => {
      return this.request("/public/v1/submit/init_fiat_on_ramp", input);
    };
    this.stampInitFiatOnRamp = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_fiat_on_ramp";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initImportPrivateKey = async (input) => {
      return this.request("/public/v1/submit/init_import_private_key", input);
    };
    this.stampInitImportPrivateKey = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_private_key";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initImportWallet = async (input) => {
      return this.request("/public/v1/submit/init_import_wallet", input);
    };
    this.stampInitImportWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_import_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initOtp = async (input) => {
      return this.request("/public/v1/submit/init_otp", input);
    };
    this.stampInitOtp = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initOtpAuth = async (input) => {
      return this.request("/public/v1/submit/init_otp_auth", input);
    };
    this.stampInitOtpAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_otp_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.initUserEmailRecovery = async (input) => {
      return this.request("/public/v1/submit/init_user_email_recovery", input);
    };
    this.stampInitUserEmailRecovery = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/init_user_email_recovery";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.oauth = async (input) => {
      return this.request("/public/v1/submit/oauth", input);
    };
    this.stampOauth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.oauthLogin = async (input) => {
      return this.request("/public/v1/submit/oauth_login", input);
    };
    this.stampOauthLogin = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/oauth_login";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.otpAuth = async (input) => {
      return this.request("/public/v1/submit/otp_auth", input);
    };
    this.stampOtpAuth = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_auth";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.otpLogin = async (input) => {
      return this.request("/public/v1/submit/otp_login", input);
    };
    this.stampOtpLogin = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/otp_login";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.recoverUser = async (input) => {
      return this.request("/public/v1/submit/recover_user", input);
    };
    this.stampRecoverUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/recover_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.rejectActivity = async (input) => {
      return this.request("/public/v1/submit/reject_activity", input);
    };
    this.stampRejectActivity = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/reject_activity";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.removeOrganizationFeature = async (input) => {
      return this.request("/public/v1/submit/remove_organization_feature", input);
    };
    this.stampRemoveOrganizationFeature = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/remove_organization_feature";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.setOrganizationFeature = async (input) => {
      return this.request("/public/v1/submit/set_organization_feature", input);
    };
    this.stampSetOrganizationFeature = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/set_organization_feature";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signRawPayload = async (input) => {
      return this.request("/public/v1/submit/sign_raw_payload", input);
    };
    this.stampSignRawPayload = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payload";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signRawPayloads = async (input) => {
      return this.request("/public/v1/submit/sign_raw_payloads", input);
    };
    this.stampSignRawPayloads = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_raw_payloads";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.signTransaction = async (input) => {
      return this.request("/public/v1/submit/sign_transaction", input);
    };
    this.stampSignTransaction = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/sign_transaction";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.stampLogin = async (input) => {
      return this.request("/public/v1/submit/stamp_login", input);
    };
    this.stampStampLogin = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/stamp_login";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updatePolicy = async (input) => {
      return this.request("/public/v1/submit/update_policy", input);
    };
    this.stampUpdatePolicy = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_policy";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updatePrivateKeyTag = async (input) => {
      return this.request("/public/v1/submit/update_private_key_tag", input);
    };
    this.stampUpdatePrivateKeyTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_private_key_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateRootQuorum = async (input) => {
      return this.request("/public/v1/submit/update_root_quorum", input);
    };
    this.stampUpdateRootQuorum = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_root_quorum";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUser = async (input) => {
      return this.request("/public/v1/submit/update_user", input);
    };
    this.stampUpdateUser = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserEmail = async (input) => {
      return this.request("/public/v1/submit/update_user_email", input);
    };
    this.stampUpdateUserEmail = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_email";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserName = async (input) => {
      return this.request("/public/v1/submit/update_user_name", input);
    };
    this.stampUpdateUserName = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_name";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserPhoneNumber = async (input) => {
      return this.request("/public/v1/submit/update_user_phone_number", input);
    };
    this.stampUpdateUserPhoneNumber = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_phone_number";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateUserTag = async (input) => {
      return this.request("/public/v1/submit/update_user_tag", input);
    };
    this.stampUpdateUserTag = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_user_tag";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.updateWallet = async (input) => {
      return this.request("/public/v1/submit/update_wallet", input);
    };
    this.stampUpdateWallet = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/update_wallet";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.verifyOtp = async (input) => {
      return this.request("/public/v1/submit/verify_otp", input);
    };
    this.stampVerifyOtp = async (input) => {
      const fullUrl = this.config.baseUrl + "/public/v1/submit/verify_otp";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    this.testRateLimits = async (input) => {
      return this.request("/tkhq/api/v1/test_rate_limits", input);
    };
    this.stampTestRateLimits = async (input) => {
      const fullUrl = this.config.baseUrl + "/tkhq/api/v1/test_rate_limits";
      const body = JSON.stringify(input);
      const stamp = await this.stamper.stamp(body);
      return {
        body,
        stamp,
        url: fullUrl
      };
    };
    if (!config2.baseUrl) {
      throw new Error(`Missing base URL. Please verify env vars.`);
    }
    this.config = config2;
    this.stamper = stamper;
  }
  async request(url2, body) {
    const fullUrl = this.config.baseUrl + url2;
    const stringifiedBody = JSON.stringify(body);
    const stamp = await this.stamper.stamp(stringifiedBody);
    const response = await fetch2(fullUrl, {
      method: "POST",
      headers: {
        [stamp.stampHeaderName]: stamp.stampHeaderValue,
        "X-Client-Version": VERSION
      },
      body: stringifiedBody,
      redirect: "follow"
    });
    if (!response.ok) {
      let res;
      try {
        res = await response.json();
      } catch (_6) {
        throw new Error(`${response.status} ${response.statusText}`);
      }
      throw new TurnkeyRequestError(res);
    }
    const data = await response.json();
    return data;
  }
};

// node_modules/@turnkey/http/dist/shared.mjs
var TurnkeyActivityError = class extends Error {
  constructor(input) {
    const { message, cause, activityId, activityStatus, activityType } = input;
    super(message);
    this.name = "TurnkeyActivityError";
    this.activityId = activityId ?? void 0;
    this.activityStatus = activityStatus ?? void 0;
    this.activityType = activityType ?? void 0;
    this.cause = cause ?? void 0;
  }
};
var TurnkeyActivityConsensusNeededError = class extends Error {
  constructor(input) {
    const { message, cause, activityId, activityStatus, activityType } = input;
    super(message);
    this.name = "TurnkeyActivityConsensusNeededError";
    this.activityId = activityId ?? void 0;
    this.activityStatus = activityStatus ?? void 0;
    this.activityType = activityType ?? void 0;
    this.cause = cause ?? void 0;
  }
};
function assertActivityCompleted(activity) {
  const { id: activityId, status: activityStatus } = activity;
  if (activityStatus === "ACTIVITY_STATUS_CONSENSUS_NEEDED") {
    throw new TurnkeyActivityConsensusNeededError({
      message: "Activity requires consensus",
      activityId,
      activityStatus
    });
  }
  if (activityStatus !== "ACTIVITY_STATUS_COMPLETED") {
    throw new TurnkeyActivityError({
      message: `Expected COMPLETED status, got ${activityStatus}`,
      activityId,
      activityStatus
    });
  }
  return true;
}
function assertNonNull(input) {
  if (input == null) {
    throw new Error(`Got unexpected ${JSON.stringify(input)}`);
  }
  return input;
}

// node_modules/@turnkey/iframe-stamper/dist/index.mjs
var stampHeaderName2 = "X-Stamp";
var IframeEventType;
(function(IframeEventType2) {
  IframeEventType2["PublicKeyReady"] = "PUBLIC_KEY_READY";
  IframeEventType2["InjectCredentialBundle"] = "INJECT_CREDENTIAL_BUNDLE";
  IframeEventType2["InjectKeyExportBundle"] = "INJECT_KEY_EXPORT_BUNDLE";
  IframeEventType2["InjectWalletExportBundle"] = "INJECT_WALLET_EXPORT_BUNDLE";
  IframeEventType2["InjectImportBundle"] = "INJECT_IMPORT_BUNDLE";
  IframeEventType2["ExtractWalletEncryptedBundle"] = "EXTRACT_WALLET_ENCRYPTED_BUNDLE";
  IframeEventType2["ExtractKeyEncryptedBundle"] = "EXTRACT_KEY_ENCRYPTED_BUNDLE";
  IframeEventType2["ApplySettings"] = "APPLY_SETTINGS";
  IframeEventType2["BundleInjected"] = "BUNDLE_INJECTED";
  IframeEventType2["EncryptedBundleExtracted"] = "ENCRYPTED_BUNDLE_EXTRACTED";
  IframeEventType2["SettingsApplied"] = "SETTINGS_APPLIED";
  IframeEventType2["StampRequest"] = "STAMP_REQUEST";
  IframeEventType2["Stamp"] = "STAMP";
  IframeEventType2["TurnkeyInitMessageChannel"] = "TURNKEY_INIT_MESSAGE_CHANNEL";
  IframeEventType2["GetEmbeddedPublicKey"] = "GET_EMBEDDED_PUBLIC_KEY";
  IframeEventType2["ClearEmbeddedKey"] = "RESET_EMBEDDED_KEY";
  IframeEventType2["InitEmbeddedKey"] = "INIT_EMBEDDED_KEY";
  IframeEventType2["Error"] = "ERROR";
})(IframeEventType || (IframeEventType = {}));
var KeyFormat;
(function(KeyFormat2) {
  KeyFormat2["Hexadecimal"] = "HEXADECIMAL";
  KeyFormat2["Solana"] = "SOLANA";
})(KeyFormat || (KeyFormat = {}));
function generateUUID() {
  return crypto.randomUUID();
}
var IframeStamper = class {
  /**
   * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.
   * Call `.init()` to insert the iframe element in the DOM.
   */
  constructor(config2) {
    if (typeof window === "undefined") {
      throw new Error("Cannot initialize iframe in non-browser environment");
    }
    if (typeof MessageChannel === "undefined") {
      throw new Error("Cannot initialize iframe without MessageChannel support");
    }
    if (!config2.iframeContainer) {
      throw new Error("Iframe container cannot be found");
    }
    this.container = config2.iframeContainer;
    if (this.container.querySelector(`#${config2.iframeElementId}`)) {
      throw new Error(`Iframe element with ID ${config2.iframeElementId} already exists`);
    }
    let iframe = window.document.createElement("iframe");
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
    iframe.id = config2.iframeElementId;
    iframe.src = config2.iframeUrl;
    this.iframe = iframe;
    const iframeUrl = new URL(config2.iframeUrl);
    this.iframeOrigin = iframeUrl.origin;
    this.iframePublicKey = null;
    this.messageChannel = new MessageChannel();
    this.pendingRequests = /* @__PURE__ */ new Map();
  }
  onMessageHandler(event) {
    const { type: type7, value: value2, requestId } = event.data || {};
    if (!requestId) {
      if (type7 === IframeEventType.PublicKeyReady) {
        this.iframePublicKey = value2;
        return;
      }
      return;
    }
    const pendingRequest = this.pendingRequests.get(requestId);
    if (!pendingRequest) {
      console.warn(`Received response for unknown request: ${requestId}`);
      return;
    }
    this.pendingRequests.delete(requestId);
    if (type7 === IframeEventType.Error) {
      pendingRequest.reject(new Error(value2));
      return;
    }
    switch (type7) {
      case IframeEventType.Stamp:
        pendingRequest.resolve({
          stampHeaderName: stampHeaderName2,
          stampHeaderValue: value2
        });
        break;
      default:
        pendingRequest.resolve(value2);
    }
  }
  /**
   * Inserts the iframe on the page and returns a promise resolving to the iframe's public key
   * @param dangerouslyOverrideIframeKeyTtl Optional TTL override for the iframe's embedded key (default 48 hours). Only use this if you are intentional about the security implications.
   */
  async init(dangerouslyOverrideIframeKeyTtl) {
    return new Promise((resolve, reject) => {
      this.container.appendChild(this.iframe);
      this.iframe.addEventListener("load", () => {
        var _a14;
        if (!((_a14 = this.iframe.contentWindow) == null ? void 0 : _a14.postMessage)) {
          reject(new Error("contentWindow or contentWindow.postMessage does not exist"));
          return;
        }
        this.iframe.contentWindow.postMessage({
          type: IframeEventType.TurnkeyInitMessageChannel,
          dangerouslyOverrideIframeKeyTtl
        }, this.iframeOrigin, [this.messageChannel.port2]);
      });
      this.messageChannel.port1.onmessage = (event) => {
        var _a14;
        if (((_a14 = event.data) == null ? void 0 : _a14.type) === IframeEventType.PublicKeyReady) {
          this.iframePublicKey = event.data.value;
          resolve(event.data.value);
        }
        this.onMessageHandler(event);
      };
    });
  }
  /**
   * Removes the iframe from the DOM
   */
  clear() {
    var _a14, _b, _c3, _d2;
    (_b = (_a14 = this.messageChannel) == null ? void 0 : _a14.port1) == null ? void 0 : _b.close();
    (_d2 = (_c3 = this.messageChannel) == null ? void 0 : _c3.port2) == null ? void 0 : _d2.close();
    this.iframe.remove();
    this.pendingRequests.clear();
  }
  /**
   * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
   */
  publicKey() {
    return this.iframePublicKey;
  }
  /**
   * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
   * This differs from the above in that it reaches out to the live iframe to see if an embedded key exists.
   */
  async getEmbeddedPublicKey() {
    const publicKey = await this.createRequest(IframeEventType.GetEmbeddedPublicKey);
    this.iframePublicKey = publicKey;
    return publicKey;
  }
  /**
   * Clears the embedded key within an iframe.
   */
  async clearEmbeddedKey() {
    await this.createRequest(IframeEventType.ClearEmbeddedKey);
    this.iframePublicKey = "";
    return null;
  }
  /**
   * Creates a new embedded key within an iframe. If an embedded key already exists, this will return it.
   * This is primarily to be used in conjunction with `clearEmbeddedKey()`: after an embedded key is cleared,
   * this can be used to create a new one.
   * @return {string | null} the newly created embedded public key.
   */
  async initEmbeddedKey() {
    const publicKey = await this.createRequest(IframeEventType.InitEmbeddedKey);
    this.iframePublicKey = publicKey;
    return publicKey;
  }
  /**
   * Generic function to abstract away request creation
   * @param type
   * @param payload
   * @returns expected shape <T>
   */
  createRequest(type7, payload = {}) {
    return new Promise((resolve, reject) => {
      const requestId = generateUUID();
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        requestId
      });
      this.messageChannel.port1.postMessage({
        type: type7,
        requestId,
        ...payload
      });
    });
  }
  /**
   * Function to inject a new credential into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during recovery and auth flows.
   */
  async injectCredentialBundle(bundle) {
    return this.createRequest(IframeEventType.InjectCredentialBundle, {
      value: bundle
    });
  }
  /**
   * Function to inject an export bundle into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
   * This is used during the private key export flow.
   */
  async injectKeyExportBundle(bundle, organizationId, keyFormat) {
    return this.createRequest(IframeEventType.InjectKeyExportBundle, {
      value: bundle,
      keyFormat,
      organizationId
    });
  }
  /**
   * Function to inject an export bundle into the iframe
   * The bundle should be encrypted to the iframe's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during the wallet export flow.
   */
  async injectWalletExportBundle(bundle, organizationId) {
    return this.createRequest(IframeEventType.InjectWalletExportBundle, {
      value: bundle,
      organizationId
    });
  }
  /**
   * Function to inject an import bundle into the iframe
   * This is used to initiate either the wallet import flow or the private key import flow.
   */
  async injectImportBundle(bundle, organizationId, userId) {
    return this.createRequest(IframeEventType.InjectImportBundle, {
      value: bundle,
      organizationId,
      userId
    });
  }
  /**
   * Function to extract an encrypted bundle from the iframe
   * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * This is used during the wallet import flow.
   */
  async extractWalletEncryptedBundle() {
    return this.createRequest(IframeEventType.ExtractWalletEncryptedBundle);
  }
  /**
   * Function to extract an encrypted bundle from the iframe
   * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
   * Encryption should be performed with HPKE (RFC 9180).
   * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
   * This is used during the private key import flow.
   */
  async extractKeyEncryptedBundle(keyFormat) {
    return this.createRequest(IframeEventType.ExtractKeyEncryptedBundle, { keyFormat });
  }
  /**
   * Function to apply settings on allowed parameters in the iframe
   * This is used to style the HTML element used for plaintext in wallet and private key import.
   */
  async applySettings(settings) {
    return this.createRequest(IframeEventType.ApplySettings, {
      value: JSON.stringify(settings)
    });
  }
  /**
   * Function to sign a payload with the underlying iframe
   */
  async stamp(payload) {
    if (this.iframePublicKey === null) {
      throw new Error("null iframe public key. Have you called/awaited .init()?");
    }
    return this.createRequest(IframeEventType.StampRequest, {
      value: payload
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/BaseTurnkeyHandler.js
var BaseTurnkeyHandler = class {
  get client() {
    return this.__turnkeyClient;
  }
  get publicKey() {
    return this.__publicKey;
  }
  clear() {
    var _a14;
    (_a14 = this.__iframeStamper) === null || _a14 === void 0 ? void 0 : _a14.clear();
    this.__iframeStamper = void 0;
    this.__publicKey = void 0;
    this.__turnkeyClient = void 0;
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/constants.js
var TURNKEY_API_BASE_URL = "https://api.turnkey.com";
var TURNKEY_API_KEY_EXPIRY_MESSAGE = "Turnkey error 16: expired api key";
var TURNKEY_API_KEY_NOT_FOUND_MESSAGE = "Turnkey error 16: could not find public key";
var WEBAUTHN_NOT_SUPPORTED_OR_CANCELLED_ERROR_MESSAGE = "The operation either timed out or was not allowed";
var WEBAUTHN_NOT_SUPPORTED_OR_DISABLED_ERROR_MESSAGE = "The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.";
var INVALID_PASSKEY_SELECTED_ERROR_MESSAGE = "Turnkey error 5: webauthn authenticator not found in organization or parent organization";
var USER_CANCELLED_REQUEST_ERROR_MESSAGE = "The user cancelled the request";
var TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS = [
  TURNKEY_API_KEY_EXPIRY_MESSAGE,
  TURNKEY_API_KEY_NOT_FOUND_MESSAGE
];
var TURNKEY_SDK_BENIGN_ERRORS = [
  WEBAUTHN_NOT_SUPPORTED_OR_CANCELLED_ERROR_MESSAGE,
  WEBAUTHN_NOT_SUPPORTED_OR_DISABLED_ERROR_MESSAGE,
  INVALID_PASSKEY_SELECTED_ERROR_MESSAGE,
  USER_CANCELLED_REQUEST_ERROR_MESSAGE
];

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/convertAttestationTransports/convertAttestationTransports.js
var transportMap = {
  AUTHENTICATOR_TRANSPORT_BLE: AuthenticatorTransportProtocol.Ble,
  AUTHENTICATOR_TRANSPORT_HYBRID: AuthenticatorTransportProtocol.Hybrid,
  AUTHENTICATOR_TRANSPORT_INTERNAL: AuthenticatorTransportProtocol.Internal,
  AUTHENTICATOR_TRANSPORT_NFC: AuthenticatorTransportProtocol.Nfc,
  AUTHENTICATOR_TRANSPORT_USB: AuthenticatorTransportProtocol.Usb
};
var convertAttestationTransports = (attestationTransports) => attestationTransports.map((transport) => transportMap[transport]);

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/logger/logger.js
var DynamicEmbeddedWalletsLogger = class extends Logger {
  constructor(name, level) {
    super(name, level);
  }
  error(message, ...args) {
    const [err] = args;
    if (!(err === null || err === void 0 ? void 0 : err.message) || !TURNKEY_SDK_BENIGN_ERRORS.some((errorMsg) => err.message.includes(errorMsg))) {
      this.log(LogLevel.ERROR, message, ...args);
    } else {
      this.warn(message, ...args);
    }
  }
};
var logger4 = new DynamicEmbeddedWalletsLogger("Dynamic embedded wallets", LogLevel.INFO);

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs
function bufferToBase64url2(buffer2) {
  const byteView = new Uint8Array(buffer2);
  let str = "";
  for (const charCode of byteView) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  const base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return base64urlString;
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs
var copyValue2 = "copy";
var convertValue2 = "convert";
function convert2(conversionFn, schema, input) {
  if (schema === copyValue2) {
    return input;
  }
  if (schema === convertValue2) {
    return conversionFn(input);
  }
  if (schema instanceof Array) {
    return input.map((v9) => convert2(conversionFn, schema[0], v9));
  }
  if (schema instanceof Object) {
    const output2 = {};
    for (const [key, schemaField] of Object.entries(schema)) {
      if (schemaField.derive) {
        const v9 = schemaField.derive(input);
        if (v9 !== void 0) {
          input[key] = v9;
        }
      }
      if (!(key in input)) {
        if (schemaField.required) {
          throw new Error(`Missing key: ${key}`);
        }
        continue;
      }
      if (input[key] == null) {
        output2[key] = null;
        continue;
      }
      output2[key] = convert2(conversionFn, schemaField.schema, input[key]);
    }
    return output2;
  }
}
function derived2(schema, derive) {
  return {
    required: true,
    schema,
    derive
  };
}
function required2(schema) {
  return {
    required: true,
    schema
  };
}
function optional2(schema) {
  return {
    required: false,
    schema
  };
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs
var simplifiedClientExtensionResultsSchema2 = {
  appid: optional2(copyValue2),
  appidExclude: optional2(copyValue2),
  credProps: optional2(copyValue2)
};
var publicKeyCredentialWithAssertion2 = {
  type: required2(copyValue2),
  id: required2(copyValue2),
  rawId: required2(convertValue2),
  authenticatorAttachment: optional2(copyValue2),
  response: required2({
    clientDataJSON: required2(convertValue2),
    authenticatorData: required2(convertValue2),
    signature: required2(convertValue2),
    userHandle: required2(convertValue2)
  }),
  clientExtensionResults: derived2(simplifiedClientExtensionResultsSchema2, (pkc) => pkc.getClientExtensionResults())
};

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs
function getResponseToJSON2(credential) {
  return convert2(bufferToBase64url2, publicKeyCredentialWithAssertion2, credential);
}

// node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs
async function get4(options) {
  const response = await navigator.credentials.get(options);
  response.toJSON = () => getResponseToJSON2(response);
  return response;
}

// node_modules/@turnkey/webauthn-stamper/dist/index.mjs
var stampHeaderName3 = "X-Stamp-Webauthn";
var defaultTimeout2 = 5 * 60 * 1e3;
var defaultUserVerification = "preferred";
var WebauthnStamper = class {
  constructor(config2) {
    this.rpId = config2.rpId;
    this.timeout = config2.timeout || defaultTimeout2;
    this.userVerification = config2.userVerification || defaultUserVerification;
    this.allowCredentials = config2.allowCredentials || [];
  }
  async stamp(payload) {
    const challenge3 = getChallengeFromPayload(payload);
    const signingOptions = {
      publicKey: {
        rpId: this.rpId,
        challenge: challenge3,
        allowCredentials: this.allowCredentials,
        timeout: this.timeout,
        userVerification: this.userVerification
      }
    };
    const clientGetResult = await get4(signingOptions);
    const assertion = clientGetResult.toJSON();
    const stamp = {
      authenticatorData: assertion.response.authenticatorData,
      clientDataJson: assertion.response.clientDataJSON,
      credentialId: assertion.id,
      signature: assertion.response.signature
    };
    return {
      stampHeaderName: stampHeaderName3,
      stampHeaderValue: JSON.stringify(stamp)
    };
  }
};
function getChallengeFromPayload(payload) {
  const hexString = createHash().update(payload).digest("hex");
  return new TextEncoder().encode(hexString);
}

// node_modules/@dynamic-labs/webauthn/package.js
var version7 = "4.43.0";

// node_modules/@dynamic-labs/webauthn/src/lib/errors/WebauthnNotSupportedError.js
var WebauthnNotSupportedError = class extends Error {
  constructor() {
    super("Webauthn is not supported on this device");
  }
};

// node_modules/@dynamic-labs/webauthn/_virtual/_tslib.js
function __awaiter4(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/webauthn/src/lib/logger.js
var logger5 = new Logger("Webauthn");

// node_modules/@dynamic-labs/webauthn/src/lib/createWebauthnCredential.js
var createWebauthnCredential = (options) => __awaiter4(void 0, void 0, void 0, function* () {
  if (!browserSupportsWebAuthn()) {
    throw new WebauthnNotSupportedError();
  }
  let attestationResp;
  try {
    attestationResp = yield startRegistration({
      optionsJSON: options
    });
  } catch (error) {
    logger5.debug("Failed to create webauthn credential", error);
    throw error;
  }
  return attestationResp;
});

// node_modules/@dynamic-labs/webauthn/src/lib/adapters/convertTransportEnumToTurnkeyEnum.js
var convertTransportEnumToTurnkeyEnum = (transportEnum) => {
  switch (transportEnum) {
    case "internal": {
      return "AUTHENTICATOR_TRANSPORT_INTERNAL";
    }
    case "usb": {
      return "AUTHENTICATOR_TRANSPORT_USB";
    }
    case "nfc": {
      return "AUTHENTICATOR_TRANSPORT_NFC";
    }
    case "ble": {
      return "AUTHENTICATOR_TRANSPORT_BLE";
    }
    case "hybrid": {
      return "AUTHENTICATOR_TRANSPORT_HYBRID";
    }
    default: {
      throw new Error("unsupported transport format " + transportEnum);
    }
  }
};

// node_modules/@dynamic-labs/webauthn/src/lib/adapters/getWebAuthnAttestationTurnkeyAdapter.js
var getWebAuthnAttestationTurnkeyAdapter = (options) => __awaiter4(void 0, void 0, void 0, function* () {
  if (!options.publicKey) {
    throw new Error("Invalid options. Public key attribute must be defined");
  }
  const attestation = yield createWebauthnCredential(convertPublicKeyToWebauthn(options.publicKey));
  return convertAttestationResultToTurnkey(attestation);
});
var convertAttestationResultToTurnkey = (attestation) => {
  var _a14;
  return {
    attestationObject: attestation.response.attestationObject,
    clientDataJson: attestation.response.clientDataJSON,
    credentialId: attestation.rawId,
    transports: ((_a14 = attestation.response.transports) === null || _a14 === void 0 ? void 0 : _a14.map(convertTransportEnumToTurnkeyEnum)) || []
  };
};
var convertPublicKeyToWebauthn = (publicKey) => {
  var _a14;
  return Object.assign(Object.assign({}, publicKey), { challenge: bufferSourceToString(publicKey.challenge), excludeCredentials: (_a14 = publicKey.excludeCredentials) === null || _a14 === void 0 ? void 0 : _a14.map((cred) => Object.assign(Object.assign({}, cred), { id: bufferSourceToString(cred.id) })), user: Object.assign(Object.assign({}, publicKey.user), { id: bufferSourceToString(publicKey.user.id) }) });
};
var bufferSourceToString = (buf) => {
  if (buf instanceof ArrayBuffer) {
    return bufferToBase64URLString(buf);
  } else {
    const arr = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    return bufferToBase64URLString(arr);
  }
};

// node_modules/@dynamic-labs/webauthn/src/index.js
assertPackageVersion("@dynamic-labs/webauthn", version7);

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/TurnkeyPasskeyService/utils/createTurnkeyPasskeyService/createTurnkeyPasskeyService.js
var createTurnkeyPasskeyService = () => ({
  createWebauthnStamper: (config2) => new WebauthnStamper(config2),
  getWebAuthnAttestation: getWebAuthnAttestationTurnkeyAdapter
});

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/TurnkeyPasskeyService/TurnkeyPasskeyService.js
var _a3;
var _TurnkeyPasskeyService_implementation;
var TurnkeyPasskeyService = class {
  /**
   * Gets the current passkey service implementation.
   * If no implementation is set, it will create a new turnkey passkey service.
   * @returns {ITurnkeyPasskeyService} The passkey service implementation.
   */
  static get implementation() {
    if (!__classPrivateFieldGet(_a3, _a3, "f", _TurnkeyPasskeyService_implementation)) {
      return createTurnkeyPasskeyService();
    }
    return __classPrivateFieldGet(_a3, _a3, "f", _TurnkeyPasskeyService_implementation);
  }
  /**
   * Sets the passkey service implementation.
   * @param {ITurnkeyPasskeyService} implementation The passkey service implementation to set.
   */
  static set implementation(implementation) {
    __classPrivateFieldSet(_a3, _a3, implementation, "f", _TurnkeyPasskeyService_implementation);
  }
  /**
   * Gets the WebAuthn attestation method from the current implementation.
   */
  static get getWebAuthnAttestation() {
    return _a3.implementation.getWebAuthnAttestation;
  }
  /**
   * Gets the createWebauthnStamper method from the current implementation.
   */
  static get createWebauthnStamper() {
    return _a3.implementation.createWebauthnStamper;
  }
};
_a3 = TurnkeyPasskeyService;
_TurnkeyPasskeyService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/embedded-wallet/src/lib/AuthenticatorHandler/TurnkeyAuthenticatorRecoveryHandler.js
var turnkeyPasskeyRecoveryUrl = "https://recovery.turnkey.com";
var turnkeyEmailRecoveryUrl = "https://auth.turnkey.com";
var TURNKEY_RECOVERY_CREDENTIAL_EXPIRATION_SECONDS = 900;
var TURNKEY_SESSION_EXPIRATION_SECONDS = 1800;
var EMAIL_AUTH_CREDENTIAL_TYPE = "CREDENTIAL_TYPE_API_KEY_P256";
var PASSKEY_RECOVERY_CREDENTIAL_TYPE = "CREDENTIAL_TYPE_RECOVER_USER_KEY_P256";
var TurnkeyAuthenticatorRecoveryHandler = class extends BaseTurnkeyHandler {
  constructor() {
    super(...arguments);
    this.isSessionActive = () => {
      if (!this.__createdAt || this.__recoveryType !== "email") {
        return false;
      }
      const isExpired = this.isExpired(this.__createdAt, this.__sessionExpiration || TURNKEY_SESSION_EXPIRATION_SECONDS);
      if (isExpired) {
        this.clear();
        return false;
      }
      return true;
    };
    this.isValidCode = (organizationId) => __awaiter3(this, void 0, void 0, function* () {
      var _a14, _b, _c3, _d2;
      if (!organizationId || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      const userResponse = yield (_a14 = this.__turnkeyClient) === null || _a14 === void 0 ? void 0 : _a14.getUser({
        organizationId,
        userId: this.__turnkeyRecoveryUserId
      });
      const credentialTypeMap = {
        email: EMAIL_AUTH_CREDENTIAL_TYPE,
        passkey: PASSKEY_RECOVERY_CREDENTIAL_TYPE
      };
      const recoveryCredential = (_d2 = (_c3 = (_b = userResponse === null || userResponse === void 0 ? void 0 : userResponse.user) === null || _b === void 0 ? void 0 : _b.apiKeys) === null || _c3 === void 0 ? void 0 : _c3.filter((k11) => k11.credential.type === credentialTypeMap[this.__recoveryType])) === null || _d2 === void 0 ? void 0 : _d2.pop();
      if (!recoveryCredential) {
        return false;
      }
      const isExpired = this.isExpired(parseInt(recoveryCredential.createdAt.seconds, 10), TURNKEY_RECOVERY_CREDENTIAL_EXPIRATION_SECONDS);
      if (isExpired) {
        return false;
      }
      this.__createdAt = parseInt(recoveryCredential.createdAt.seconds, 10);
      return true;
    });
    this.isExpired = (createdAtSeconds, expirationTimeSeconds) => {
      const recoveryExpirationSeconds = createdAtSeconds + expirationTimeSeconds;
      const expirationTime = new Date(recoveryExpirationSeconds * 1e3);
      if (/* @__PURE__ */ new Date() >= expirationTime) {
        return true;
      }
      return false;
    };
  }
  get recoveryType() {
    return this.__recoveryType;
  }
  get recoveryUserId() {
    return this.__turnkeyRecoveryUserId || "";
  }
  set recoveryUserId(turnkeyRecoveryUserId) {
    this.__turnkeyRecoveryUserId = turnkeyRecoveryUserId;
  }
  clear() {
    super.clear();
    this.__recoveryType = void 0;
    this.__turnkeyRecoveryUserId = void 0;
    this.__createdAt = void 0;
  }
  initRecovery(authType, iframeContainer, iframeElementId, sessionExpiration) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this.__recoveryType) {
        this.clear();
      }
      this.__sessionExpiration = sessionExpiration;
      this.__recoveryType = authType;
      const iframeUrl = authType === "passkey" ? turnkeyPasskeyRecoveryUrl : turnkeyEmailRecoveryUrl;
      this.__iframeStamper = new IframeStamper({
        iframeContainer,
        iframeElementId,
        iframeUrl
      });
      yield this.__iframeStamper.init();
      this.__publicKey = this.__iframeStamper.publicKey();
      return this.__publicKey;
    });
  }
  verifyRecoveryCode(recoveryBundle, organizationId) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        yield this.__iframeStamper.injectCredentialBundle(recoveryBundle);
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, this.__iframeStamper);
        if (!organizationId || !this.__turnkeyRecoveryUserId) {
          throw new DynamicError("Cannot proceed with your request");
        }
        if (!(yield this.isValidCode(organizationId))) {
          throw new DynamicError("The code is invalid or expired.");
        }
      } catch (err) {
        logger4.error("Error while verifying recovery code", err);
        if (err instanceof DynamicError) {
          throw err;
        }
        throw new DynamicError("The code is invalid or expired.");
      }
    });
  }
  completeRecovery(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ attestation, challenge: challenge3, turnkeySubOrganizationId }) {
      if (!this.__turnkeyClient || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return this.__turnkeyClient.recoverUser({
          organizationId: turnkeySubOrganizationId,
          parameters: {
            authenticator: {
              attestation,
              authenticatorName: "Passkey",
              challenge: challenge3
            },
            userId: this.__turnkeyRecoveryUserId
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_RECOVER_USER"
        });
      } catch (err) {
        logger4.error("[TK] Error while completing recovery process", err);
        throw err;
      }
    });
  }
  addPasskeyAuthenticator(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ attestation, challenge: challenge3, turnkeySubOrganizationId }) {
      if (!this.__turnkeyClient || !this.__turnkeyRecoveryUserId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return this.__turnkeyClient.createAuthenticators({
          organizationId: turnkeySubOrganizationId,
          parameters: {
            authenticators: [
              {
                attestation,
                authenticatorName: "Passkey",
                challenge: challenge3
              }
            ],
            userId: this.__turnkeyRecoveryUserId
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
        });
      } catch (err) {
        logger4.error("[TK] Error while creating new authenticator", err);
        throw err;
      }
    });
  }
  addEmailRecovery(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ organizationId, email, turnkeyUserId }) {
      let rpId = getTLD();
      if (!rpId) {
        rpId = PlatformService.getHostname();
      }
      const stamper = TurnkeyPasskeyService.createWebauthnStamper({
        rpId
      });
      const client = new TurnkeyClient({
        baseUrl: TURNKEY_API_BASE_URL
      }, stamper);
      try {
        const signedRequest2 = yield client.stampUpdateUser({
          organizationId,
          parameters: {
            userEmail: email,
            userId: turnkeyUserId,
            userTagIds: []
          },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_UPDATE_USER"
        });
        return { signedRequest: signedRequest2, userId: turnkeyUserId };
      } catch (err) {
        logger4.error("Error while adding email recovery", err);
        throw err;
      }
    });
  }
};
var turnkeyAuthenticatorRecoveryHandler = new TurnkeyAuthenticatorRecoveryHandler();

// node_modules/@dynamic-labs/embedded-wallet/src/lib/ExportHandler/TurnkeyExportHandler.js
var turnkeyExportUrl = "https://export.turnkey.com";
var TurnkeyExportHandler = class _TurnkeyExportHandler extends BaseTurnkeyHandler {
  initExport(iframeContainer, iframeElementId) {
    return __awaiter3(this, void 0, void 0, function* () {
      this.__iframeStamper = new IframeStamper({
        iframeContainer,
        iframeElementId,
        iframeUrl: turnkeyExportUrl
      });
      yield this.__iframeStamper.init();
      this.__publicKey = this.__iframeStamper.publicKey();
      if (turnkeyAuthenticatorRecoveryHandler.isSessionActive()) {
        this.__turnkeyClient = turnkeyAuthenticatorRecoveryHandler.client;
      } else {
        let rpId = getTLD();
        if (!rpId) {
          rpId = PlatformService.getHostname();
        }
        const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
          rpId
        });
        const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
        const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, stamper);
      }
      return this.__publicKey;
    });
  }
  verifyExportWallet(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ exportBundle, organizationId }) {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        return yield this.__iframeStamper.injectWalletExportBundle(exportBundle, organizationId);
      } catch (err) {
        logger4.error("Error while verifying export wallet", err);
        throw err;
      }
    });
  }
  verifyExportPrivateKey(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ exportBundle, organizationId, chain: chain6 }) {
      if (!this.__iframeStamper) {
        throw new DynamicError("Cannot proceed with your request");
      }
      const keyFormat = chain6 === "solana" || chain6 === "SOL" ? KeyFormat.Solana : KeyFormat.Hexadecimal;
      try {
        return yield this.__iframeStamper.injectKeyExportBundle(exportBundle, organizationId, keyFormat);
      } catch (err) {
        logger4.error("Error while verifying export private key", err);
        throw err;
      }
    });
  }
  exportPrivateKey(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ privateKeyId, organizationId }) {
      const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
      if (apiKeyStamper) {
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, apiKeyStamper);
      }
      if (!this.__iframeStamper || !this.__publicKey || !this.__turnkeyClient || !privateKeyId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        const newActivity = yield this.__turnkeyClient.exportPrivateKey({
          organizationId,
          parameters: { privateKeyId, targetPublicKey: this.__publicKey },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
        });
        return newActivity.activity;
      } catch (err) {
        logger4.error("[TK] Error while completing export private key process", err);
        throw err;
      }
    });
  }
  exportWallet(_a14) {
    return __awaiter3(this, arguments, void 0, function* ({ walletId, organizationId, address }) {
      const apiKeyStamper = _TurnkeyExportHandler === null || _TurnkeyExportHandler === void 0 ? void 0 : _TurnkeyExportHandler.apiKeyStamper;
      if (apiKeyStamper) {
        this.__turnkeyClient = new TurnkeyClient({
          baseUrl: TURNKEY_API_BASE_URL
        }, apiKeyStamper);
      }
      if (!this.__iframeStamper || !this.__publicKey || !this.__turnkeyClient || !walletId) {
        throw new DynamicError("Cannot proceed with your request");
      }
      try {
        if (address) {
          const newActivity2 = yield this.__turnkeyClient.exportWalletAccount({
            organizationId,
            parameters: { address, targetPublicKey: this.__publicKey },
            timestampMs: String(Date.now()),
            type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
          });
          return newActivity2.activity;
        }
        const newActivity = yield this.__turnkeyClient.exportWallet({
          organizationId,
          parameters: { targetPublicKey: this.__publicKey, walletId },
          timestampMs: String(Date.now()),
          type: "ACTIVITY_TYPE_EXPORT_WALLET"
        });
        return newActivity.activity;
      } catch (err) {
        logger4.error("[TK] Error while completing export wallet process", err);
        throw err;
      }
    });
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/base64UrlEncode/base64UrlEncode.js
var base64UrlEncode = (challenge3) => Buffer.from(challenge3).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/generateRandomBuffer/generateRandomBuffer.js
var generateRandomBuffer = () => {
  const arr = new Uint8Array(32);
  crypto.getRandomValues(arr);
  return arr.buffer;
};

// node_modules/@dynamic-labs/embedded-wallet/src/lib/TurnkeyWalletConnectorBase/TurnkeyWalletConnectorBase.js
var TurnkeyWalletConnectorBase = class _TurnkeyWalletConnectorBase extends WalletConnectorBase {
  constructor(nameAndKey, props) {
    super(props);
    this.requiresNonDynamicEmailOtp = false;
    this.isEmbeddedWallet = true;
    this.removeSessionKeys = () => __awaiter3(this, void 0, void 0, function* () {
      _TurnkeyWalletConnectorBase.sessionKeys = void 0;
      _TurnkeyWalletConnectorBase.apiKeyStamper = void 0;
      TurnkeyExportHandler.apiKeyStamper = void 0;
    });
    this.stampCreateWalletAccountRequest = (_a14) => __awaiter3(this, [_a14], void 0, function* ({ request: request2 }) {
      yield this.createOrRestoreSession();
      const turnkeyClient = yield this.getTurnkeyClient();
      return turnkeyClient.stampCreateWalletAccounts(request2);
    });
    this.stampDeleteSubOrganizationRequest = (_b) => __awaiter3(this, [_b], void 0, function* ({ request: request2 }) {
      yield this.createOrRestoreSession();
      const turnkeyClient = yield this.getTurnkeyClient();
      return turnkeyClient.stampDeleteSubOrganization(request2);
    });
    if (!props.appName) {
      throw new Error("appName not set");
    }
    this.name = nameAndKey.name;
    this.overrideKey = nameAndKey.key;
    this.appName = props.appName;
    this.__authenticatorMethodHandler = turnkeyAuthenticatorRecoveryHandler;
  }
  getWebAuthnAttestation() {
    return __awaiter3(this, void 0, void 0, function* () {
      const challenge3 = generateRandomBuffer();
      const authenticatorUserId = generateRandomBuffer();
      const { email, passkeyIdentifier } = this;
      if (!email && !passkeyIdentifier) {
        throw new Error("Email or passkeyIdentifier must be set to register a webauthn credential.");
      }
      const displayName = email || `${this.appName} - ${passkeyIdentifier}`;
      const webAuthnCreateParams = {
        publicKey: {
          authenticatorSelection: {
            authenticatorAttachment: void 0,
            requireResidentKey: false,
            residentKey: "preferred",
            userVerification: "discouraged"
          },
          challenge: challenge3,
          pubKeyCredParams: [
            {
              alg: -7,
              type: "public-key"
            }
          ],
          rp: {
            id: getTLD(),
            name: this.appName
          },
          user: {
            displayName,
            id: authenticatorUserId,
            name: email || `${this.appName} - ${passkeyIdentifier}`
          }
        }
      };
      let attestation;
      try {
        attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
      } catch (error) {
        logger4.warn(`Unable to register webauthn credential on the current page's TLD ${getTLD()}. Falling back to using hostname. ${PlatformService.getHostname()}`, error);
        webAuthnCreateParams.publicKey.rp.id = PlatformService.getHostname();
        attestation = yield TurnkeyPasskeyService.getWebAuthnAttestation(webAuthnCreateParams);
      }
      return {
        attestation: {
          attestationObject: attestation.attestationObject,
          clientDataJson: attestation.clientDataJson,
          credentialId: attestation.credentialId,
          transports: convertAttestationTransports(attestation.transports)
        },
        challenge: base64UrlEncode(challenge3),
        displayName
      };
    });
  }
  getAuthenticatorHandler() {
    return this.__authenticatorMethodHandler;
  }
  getExportHandler() {
    if (!_TurnkeyWalletConnectorBase.__exportHandler) {
      _TurnkeyWalletConnectorBase.__exportHandler = new TurnkeyExportHandler();
    }
    return _TurnkeyWalletConnectorBase.__exportHandler;
  }
  // Public methods
  get email() {
    return this._email;
  }
  setEmail(email) {
    this._email = email;
  }
  get phone() {
    return this._phone;
  }
  setPhone(phone) {
    this._phone = phone;
  }
  get passkeyIdentifier() {
    return this._passkeyIdentifier;
  }
  setPasskeyIdentifier(passkeyIdentifier) {
    this._passkeyIdentifier = passkeyIdentifier;
  }
  clearEmail() {
    this._email = null;
  }
  getAddress() {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a14;
      return (_a14 = this.verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.address;
    });
  }
  getConnectedAccounts() {
    return __awaiter3(this, void 0, void 0, function* () {
      const verifiedCredentials = this.verifiedCredentials || [];
      const addresses = verifiedCredentials.map((vc3) => vc3 === null || vc3 === void 0 ? void 0 : vc3.address).filter((a6) => typeof a6 === "string");
      return addresses;
    });
  }
  get turnkeyAddress() {
    var _a14;
    const { address } = (_a14 = this.verifiedCredential) !== null && _a14 !== void 0 ? _a14 : {};
    return address;
  }
  get walletProperties() {
    const { walletProperties } = this.verifiedCredential || {};
    return walletProperties;
  }
  // Private methods
  set verifiedCredentials(verifiedCredentials) {
    this._verifiedCredentials = verifiedCredentials;
  }
  get verifiedCredentials() {
    return this._verifiedCredentials;
  }
  set verifiedCredential(verifiedCredential) {
    this._verifiedCredential = verifiedCredential;
  }
  get verifiedCredential() {
    return this._verifiedCredential;
  }
  setSessionKeyFetcher(func) {
    this.createOrRestoreSessionFetcherFunction = func;
  }
  setSessionKeyRemoveFunction(func) {
    this.removeSessionKeysFunction = func;
  }
  createOrRestoreSession() {
    return __awaiter3(this, arguments, void 0, function* ({ ignoreRestore } = {}) {
      var _a14, _b, _c3;
      if (!this.isSessionKeyCompatible() || _TurnkeyWalletConnectorBase.isLoadingSession) {
        return;
      }
      if (!this.createOrRestoreSessionFetcherFunction) {
        throw new DynamicError("Cannot register session key to init provider");
      }
      const { sessionKeys } = _TurnkeyWalletConnectorBase;
      if (sessionKeys === null || sessionKeys === void 0 ? void 0 : sessionKeys.publicKey) {
        const isExpired = /* @__PURE__ */ new Date() >= new Date(sessionKeys.expirationDate);
        if (!isExpired)
          return sessionKeys.publicKey;
      }
      try {
        _TurnkeyWalletConnectorBase.isLoadingSession = true;
        this.isLoadingSessionDeferredPromise = new DeferredPromise();
        if (!((_a14 = this.verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.id)) {
          throw new DynamicError("No wallet ID found");
        }
        const sessionKeys2 = yield this.createOrRestoreSessionFetcherFunction({
          ignoreRestore,
          walletId: (_b = this.verifiedCredential) === null || _b === void 0 ? void 0 : _b.id
        });
        _TurnkeyWalletConnectorBase.sessionKeys = sessionKeys2;
        _TurnkeyWalletConnectorBase.apiKeyStamper = new ApiKeyStamper({
          apiPrivateKey: sessionKeys2.privateKey,
          apiPublicKey: sessionKeys2.publicKey
        });
        TurnkeyExportHandler.apiKeyStamper = _TurnkeyWalletConnectorBase.apiKeyStamper;
        logger4.metaData.set("sessionApiPublicKey", sessionKeys2.publicKey);
        return sessionKeys2.publicKey;
      } catch (error) {
        logger4.error(error);
        throw new DynamicError("Failed to create or restore session");
      } finally {
        _TurnkeyWalletConnectorBase.isLoadingSession = false;
        (_c3 = this.isLoadingSessionDeferredPromise) === null || _c3 === void 0 ? void 0 : _c3.resolve();
      }
    });
  }
  isSessionKeyCompatible() {
    var _a14;
    const walletProperties = (_a14 = this.verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.walletProperties;
    const isSessionKeyCompatible = walletProperties === null || walletProperties === void 0 ? void 0 : walletProperties.isSessionKeyCompatible;
    return Boolean(isSessionKeyCompatible);
  }
  isSessionActive() {
    return __awaiter3(this, void 0, void 0, function* () {
      const hasWallet = yield this.getAddress();
      return Boolean(hasWallet && _TurnkeyWalletConnectorBase.sessionKeys && _TurnkeyWalletConnectorBase.apiKeyStamper);
    });
  }
  get sessionKeys() {
    return _TurnkeyWalletConnectorBase.sessionKeys;
  }
  getTurnkeyClient() {
    return __awaiter3(this, void 0, void 0, function* () {
      var _a14, _b;
      if (_TurnkeyWalletConnectorBase.isLoadingSession) {
        yield (_a14 = this.isLoadingSessionDeferredPromise) === null || _a14 === void 0 ? void 0 : _a14.promise;
      }
      let rpId = getTLD();
      if (!rpId) {
        rpId = PlatformService.getHostname();
      }
      const passkeyStamper = TurnkeyPasskeyService.createWebauthnStamper({
        rpId
      });
      const apiKeyStamper = _TurnkeyWalletConnectorBase === null || _TurnkeyWalletConnectorBase === void 0 ? void 0 : _TurnkeyWalletConnectorBase.apiKeyStamper;
      const stamper = apiKeyStamper !== null && apiKeyStamper !== void 0 ? apiKeyStamper : passkeyStamper;
      this.__turnkeyClient = (_b = this.getAuthenticatorHandler().client) !== null && _b !== void 0 ? _b : new TurnkeyClient({
        baseUrl: TURNKEY_API_BASE_URL
      }, stamper);
      return this.__turnkeyClient;
    });
  }
  setLoggerMetadata() {
    var _a14, _b, _c3;
    logger4.metaData.set("turnkeySubOrganizationId", (_b = (_a14 = this._verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.walletProperties) === null || _b === void 0 ? void 0 : _b.turnkeySubOrganizationId);
    logger4.metaData.set("walletId", (_c3 = this._verifiedCredential) === null || _c3 === void 0 ? void 0 : _c3.id);
    let authMethod = "Unknown";
    if (this.isSessionKeyCompatible()) {
      authMethod = "SessionKeys";
    } else if (this.__authenticatorMethodHandler.recoveryType === "passkey") {
      authMethod = "Passkey";
    } else if (this.__authenticatorMethodHandler.recoveryType === "email") {
      authMethod = "EmailAuth";
    }
    logger4.metaData.set("authMethod", authMethod);
  }
};
TurnkeyWalletConnectorBase.isLoadingSession = false;

// node_modules/@dynamic-labs/embedded-wallet/src/lib/utils/findTurnkeyVerifiedCredentials/findTurnkeyVerifiedCredentials.js
var findTurnkeyVerifiedCredentialsWithSmartWalletRef = (verifiedCredentials, chain6) => verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.reduce((acc, vc3) => {
  var _a14;
  if (((_a14 = vc3.walletName) === null || _a14 === void 0 ? void 0 : _a14.startsWith("turnkey")) && chain6 === vc3.chain) {
    const smartWallet = verifiedCredentials.find((v9) => v9.signerRefId === vc3.id);
    const smartWalletRefId = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.id;
    const smartWalletRefAddress = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.address;
    acc.push(Object.assign(Object.assign({}, vc3), { smartWalletRefAddress, smartWalletRefId }));
  }
  return acc;
}, []);

// node_modules/@dynamic-labs/embedded-wallet/src/types.js
var TurnkeyWalletConnectorInfo = {
  Turnkey: {
    key: "turnkey",
    name: "Turnkey"
  },
  TurnkeyHD: {
    key: "turnkeyhd",
    name: "Turnkey HD"
  }
};

// node_modules/@dynamic-labs/embedded-wallet/src/index.js
assertPackageVersion("@dynamic-labs/embedded-wallet", version6);

// node_modules/@dynamic-labs/embedded-wallet-evm/_virtual/_tslib.js
function __awaiter5(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@turnkey/viem/node_modules/@noble/hashes/esm/_assert.js
function anumber3(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0)
    throw new Error("positive integer expected, got " + n5);
}
function isBytes4(a6) {
  return a6 instanceof Uint8Array || ArrayBuffer.isView(a6) && a6.constructor.name === "Uint8Array";
}
function abytes3(b6, ...lengths) {
  if (!isBytes4(b6))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b6.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b6.length);
}
function ahash2(h9) {
  if (typeof h9 !== "function" || typeof h9.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber3(h9.outputLen);
  anumber3(h9.blockLen);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes3(out);
  const min4 = instance.outputLen;
  if (out.length < min4) {
    throw new Error("digestInto() expects output buffer of length at least " + min4);
  }
}

// node_modules/@turnkey/viem/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@turnkey/viem/node_modules/@noble/hashes/esm/utils.js
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hexes2 = Array.from({ length: 256 }, (_6, i9) => i9.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes13(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  abytes3(data);
  return data;
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i9 = 0; i9 < arrays.length; i9++) {
    const a6 = arrays[i9];
    abytes3(a6);
    sum += a6.length;
  }
  const res = new Uint8Array(sum);
  for (let i9 = 0, pad5 = 0; i9 < arrays.length; i9++) {
    const a6 = arrays[i9];
    res.set(a6, pad5);
    pad5 += a6.length;
  }
  return res;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes13(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto2 && typeof crypto2.randomBytes === "function") {
    return crypto2.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@turnkey/viem/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value2, isLE5) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE5);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value2 >> _32n3 & _u32_max);
  const wl2 = Number(value2 & _u32_max);
  const h9 = isLE5 ? 4 : 0;
  const l9 = isLE5 ? 0 : 4;
  view.setUint32(byteOffset + h9, wh2, isLE5);
  view.setUint32(byteOffset + l9, wl2, isLE5);
}
var Chi = (a6, b6, c9) => a6 & b6 ^ ~a6 & c9;
var Maj = (a6, b6, c9) => a6 & b6 ^ a6 & c9 ^ b6 & c9;
var HashMD = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE5) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE5;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    aexists2(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes13(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE5 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i9 = pos; i9 < blockLen; i9++)
      buffer2[i9] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE5);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i9 = 0; i9 < outLen; i9++)
      oview.setUint32(4 * i9, state[i9], isLE5);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to6) {
    to6 || (to6 = new this.constructor());
    to6.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to6.length = length;
    to6.pos = pos;
    to6.finished = finished;
    to6.destroyed = destroyed;
    if (length % blockLen)
      to6.buffer.set(buffer2);
    return to6;
  }
};

// node_modules/@turnkey/viem/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV2[0] | 0;
    this.B = SHA256_IV2[1] | 0;
    this.C = SHA256_IV2[2] | 0;
    this.D = SHA256_IV2[3] | 0;
    this.E = SHA256_IV2[4] | 0;
    this.F = SHA256_IV2[5] | 0;
    this.G = SHA256_IV2[6] | 0;
    this.H = SHA256_IV2[7] | 0;
  }
  get() {
    const { A: A9, B: B9, C: C10, D: D9, E: E8, F: F8, G: G7, H: H4 } = this;
    return [A9, B9, C10, D9, E8, F8, G7, H4];
  }
  // prettier-ignore
  set(A9, B9, C10, D9, E8, F8, G7, H4) {
    this.A = A9 | 0;
    this.B = B9 | 0;
    this.C = C10 | 0;
    this.D = D9 | 0;
    this.E = E8 | 0;
    this.F = F8 | 0;
    this.G = G7 | 0;
    this.H = H4 | 0;
  }
  process(view, offset) {
    for (let i9 = 0; i9 < 16; i9++, offset += 4)
      SHA256_W[i9] = view.getUint32(offset, false);
    for (let i9 = 16; i9 < 64; i9++) {
      const W15 = SHA256_W[i9 - 15];
      const W22 = SHA256_W[i9 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W22, 17) ^ rotr2(W22, 19) ^ W22 >>> 10;
      SHA256_W[i9] = s1 + SHA256_W[i9 - 7] + s0 + SHA256_W[i9 - 16] | 0;
    }
    let { A: A9, B: B9, C: C10, D: D9, E: E8, F: F8, G: G7, H: H4 } = this;
    for (let i9 = 0; i9 < 64; i9++) {
      const sigma1 = rotr2(E8, 6) ^ rotr2(E8, 11) ^ rotr2(E8, 25);
      const T1 = H4 + sigma1 + Chi(E8, F8, G7) + SHA256_K[i9] + SHA256_W[i9] | 0;
      const sigma0 = rotr2(A9, 2) ^ rotr2(A9, 13) ^ rotr2(A9, 22);
      const T22 = sigma0 + Maj(A9, B9, C10) | 0;
      H4 = G7;
      G7 = F8;
      F8 = E8;
      E8 = D9 + T1 | 0;
      D9 = C10;
      C10 = B9;
      B9 = A9;
      A9 = T1 + T22 | 0;
    }
    A9 = A9 + this.A | 0;
    B9 = B9 + this.B | 0;
    C10 = C10 + this.C | 0;
    D9 = D9 + this.D | 0;
    E8 = E8 + this.E | 0;
    F8 = F8 + this.F | 0;
    G7 = G7 + this.G | 0;
    H4 = H4 + this.H | 0;
    this.set(A9, B9, C10, D9, E8, F8, G7, H4);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2566 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@turnkey/viem/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash2 {
  constructor(hash9, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash2(hash9);
    const key = toBytes13(_key);
    this.iHash = hash9.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad5 = new Uint8Array(blockLen);
    pad5.set(key.length > blockLen ? hash9.create().update(key).digest() : key);
    for (let i9 = 0; i9 < pad5.length; i9++)
      pad5[i9] ^= 54;
    this.iHash.update(pad5);
    this.oHash = hash9.create();
    for (let i9 = 0; i9 < pad5.length; i9++)
      pad5[i9] ^= 54 ^ 92;
    this.oHash.update(pad5);
    pad5.fill(0);
  }
  update(buf) {
    aexists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes3(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to6) {
    to6 || (to6 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to6 = to6;
    to6.finished = finished;
    to6.destroyed = destroyed;
    to6.blockLen = blockLen;
    to6.outputLen = outputLen;
    to6.oHash = oHash._cloneInto(to6.oHash);
    to6.iHash = iHash._cloneInto(to6.iHash);
    return to6;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash9, key, message) => new HMAC(hash9, key).update(message).digest();
hmac2.create = (hash9, key) => new HMAC(hash9, key);

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  aInRange: () => aInRange2,
  abool: () => abool2,
  abytes: () => abytes4,
  bitGet: () => bitGet2,
  bitLen: () => bitLen2,
  bitMask: () => bitMask2,
  bitSet: () => bitSet2,
  bytesToHex: () => bytesToHex4,
  bytesToNumberBE: () => bytesToNumberBE2,
  bytesToNumberLE: () => bytesToNumberLE2,
  concatBytes: () => concatBytes4,
  createHmacDrbg: () => createHmacDrbg2,
  ensureBytes: () => ensureBytes2,
  equalBytes: () => equalBytes3,
  hexToBytes: () => hexToBytes4,
  hexToNumber: () => hexToNumber4,
  inRange: () => inRange2,
  isBytes: () => isBytes5,
  memoized: () => memoized2,
  notImplemented: () => notImplemented2,
  numberToBytesBE: () => numberToBytesBE2,
  numberToBytesLE: () => numberToBytesLE2,
  numberToHexUnpadded: () => numberToHexUnpadded2,
  numberToVarBytesBE: () => numberToVarBytesBE2,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject2
});
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n5 = BigInt(2);
function isBytes5(a6) {
  return a6 instanceof Uint8Array || ArrayBuffer.isView(a6) && a6.constructor.name === "Uint8Array";
}
function abytes4(item) {
  if (!isBytes5(item))
    throw new Error("Uint8Array expected");
}
function abool2(title, value2) {
  if (typeof value2 !== "boolean")
    throw new Error(title + " boolean expected, got " + value2);
}
var hexes3 = Array.from({ length: 256 }, (_6, i9) => i9.toString(16).padStart(2, "0"));
function bytesToHex4(bytes2) {
  abytes4(bytes2);
  let hex2 = "";
  for (let i9 = 0; i9 < bytes2.length; i9++) {
    hex2 += hexes3[bytes2[i9]];
  }
  return hex2;
}
function numberToHexUnpadded2(num3) {
  const hex2 = num3.toString(16);
  return hex2.length & 1 ? "0" + hex2 : hex2;
}
function hexToNumber4(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return hex2 === "" ? _0n5 : BigInt("0x" + hex2);
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch2) {
  if (ch2 >= asciis._0 && ch2 <= asciis._9)
    return ch2 - asciis._0;
  if (ch2 >= asciis.A && ch2 <= asciis.F)
    return ch2 - (asciis.A - 10);
  if (ch2 >= asciis.a && ch2 <= asciis.f)
    return ch2 - (asciis.a - 10);
  return;
}
function hexToBytes4(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl2);
  const array = new Uint8Array(al2);
  for (let ai5 = 0, hi5 = 0; ai5 < al2; ai5++, hi5 += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi5));
    const n22 = asciiToBase16(hex2.charCodeAt(hi5 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi5] + hex2[hi5 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi5);
    }
    array[ai5] = n1 * 16 + n22;
  }
  return array;
}
function bytesToNumberBE2(bytes2) {
  return hexToNumber4(bytesToHex4(bytes2));
}
function bytesToNumberLE2(bytes2) {
  abytes4(bytes2);
  return hexToNumber4(bytesToHex4(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE2(n5, len) {
  return hexToBytes4(n5.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n5, len) {
  return numberToBytesBE2(n5, len).reverse();
}
function numberToVarBytesBE2(n5) {
  return hexToBytes4(numberToHexUnpadded2(n5));
}
function ensureBytes2(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes4(hex2);
    } catch (e11) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e11);
    }
  } else if (isBytes5(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes4(...arrays) {
  let sum = 0;
  for (let i9 = 0; i9 < arrays.length; i9++) {
    const a6 = arrays[i9];
    abytes4(a6);
    sum += a6.length;
  }
  const res = new Uint8Array(sum);
  for (let i9 = 0, pad5 = 0; i9 < arrays.length; i9++) {
    const a6 = arrays[i9];
    res.set(a6, pad5);
    pad5 += a6.length;
  }
  return res;
}
function equalBytes3(a6, b6) {
  if (a6.length !== b6.length)
    return false;
  let diff = 0;
  for (let i9 = 0; i9 < a6.length; i9++)
    diff |= a6[i9] ^ b6[i9];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n5) => typeof n5 === "bigint" && _0n5 <= n5;
function inRange2(n5, min4, max4) {
  return isPosBig(n5) && isPosBig(min4) && isPosBig(max4) && min4 <= n5 && n5 < max4;
}
function aInRange2(title, n5, min4, max4) {
  if (!inRange2(n5, min4, max4))
    throw new Error("expected valid " + title + ": " + min4 + " <= n < " + max4 + ", got " + n5);
}
function bitLen2(n5) {
  let len;
  for (len = 0; n5 > _0n5; n5 >>= _1n5, len += 1)
    ;
  return len;
}
function bitGet2(n5, pos) {
  return n5 >> BigInt(pos) & _1n5;
}
function bitSet2(n5, pos, value2) {
  return n5 | (value2 ? _1n5 : _0n5) << BigInt(pos);
}
var bitMask2 = (n5) => (_2n5 << BigInt(n5 - 1)) - _1n5;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v9 = u8n(hashLen);
  let k11 = u8n(hashLen);
  let i9 = 0;
  const reset3 = () => {
    v9.fill(1);
    k11.fill(0);
    i9 = 0;
  };
  const h9 = (...b6) => hmacFn(k11, v9, ...b6);
  const reseed = (seed = u8n()) => {
    k11 = h9(u8fr([0]), seed);
    v9 = h9();
    if (seed.length === 0)
      return;
    k11 = h9(u8fr([1]), seed);
    v9 = h9();
  };
  const gen = () => {
    if (i9++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v9 = h9();
      const sl2 = v9.slice();
      out.push(sl2);
      len += v9.length;
    }
    return concatBytes4(...out);
  };
  const genUntil = (seed, pred) => {
    reset3();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset3();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes5(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject2(object2, validators5, optValidators = {}) {
  const checkField = (fieldName, type7, isOptional) => {
    const checkVal = validatorFns[type7];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type7 + ", got " + val);
    }
  };
  for (const [fieldName, type7] of Object.entries(validators5))
    checkField(fieldName, type7, false);
  for (const [fieldName, type7] of Object.entries(optValidators))
    checkField(fieldName, type7, true);
  return object2;
}
var notImplemented2 = () => {
  throw new Error("not implemented");
};
function memoized2(fn4) {
  const map36 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map36.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn4(arg, ...args);
    map36.set(arg, computed);
    return computed;
  };
}

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/abstract/modular.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
var _2n6 = BigInt(2);
var _3n4 = BigInt(3);
var _4n2 = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod2(a6, b6) {
  const result = a6 % b6;
  return result >= _0n6 ? result : b6 + result;
}
function pow(num3, power, modulo) {
  if (power < _0n6)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n6)
    throw new Error("invalid modulus");
  if (modulo === _1n6)
    return _0n6;
  let res = _1n6;
  while (power > _0n6) {
    if (power & _1n6)
      res = res * num3 % modulo;
    num3 = num3 * num3 % modulo;
    power >>= _1n6;
  }
  return res;
}
function pow22(x7, power, modulo) {
  let res = x7;
  while (power-- > _0n6) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n6)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n6)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a6 = mod2(number2, modulo);
  let b6 = modulo;
  let x7 = _0n6, y11 = _1n6, u10 = _1n6, v9 = _0n6;
  while (a6 !== _0n6) {
    const q6 = b6 / a6;
    const r8 = b6 % a6;
    const m6 = x7 - u10 * q6;
    const n5 = y11 - v9 * q6;
    b6 = a6, a6 = r8, x7 = u10, y11 = v9, u10 = m6, v9 = n5;
  }
  const gcd2 = b6;
  if (gcd2 !== _1n6)
    throw new Error("invert: does not exist");
  return mod2(x7, modulo);
}
function tonelliShanks(P7) {
  const legendreC = (P7 - _1n6) / _2n6;
  let Q7, S8, Z5;
  for (Q7 = P7 - _1n6, S8 = 0; Q7 % _2n6 === _0n6; Q7 /= _2n6, S8++)
    ;
  for (Z5 = _2n6; Z5 < P7 && pow(Z5, legendreC, P7) !== P7 - _1n6; Z5++) {
    if (Z5 > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S8 === 1) {
    const p1div4 = (P7 + _1n6) / _4n2;
    return function tonelliFast(Fp4, n5) {
      const root = Fp4.pow(n5, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q7 + _1n6) / _2n6;
  return function tonelliSlow(Fp4, n5) {
    if (Fp4.pow(n5, legendreC) === Fp4.neg(Fp4.ONE))
      throw new Error("Cannot find square root");
    let r8 = S8;
    let g4 = Fp4.pow(Fp4.mul(Fp4.ONE, Z5), Q7);
    let x7 = Fp4.pow(n5, Q1div2);
    let b6 = Fp4.pow(n5, Q7);
    while (!Fp4.eql(b6, Fp4.ONE)) {
      if (Fp4.eql(b6, Fp4.ZERO))
        return Fp4.ZERO;
      let m6 = 1;
      for (let t22 = Fp4.sqr(b6); m6 < r8; m6++) {
        if (Fp4.eql(t22, Fp4.ONE))
          break;
        t22 = Fp4.sqr(t22);
      }
      const ge5 = Fp4.pow(g4, _1n6 << BigInt(r8 - m6 - 1));
      g4 = Fp4.sqr(ge5);
      x7 = Fp4.mul(x7, ge5);
      b6 = Fp4.mul(b6, g4);
      r8 = m6;
    }
    return x7;
  };
}
function FpSqrt(P7) {
  if (P7 % _4n2 === _3n4) {
    const p1div4 = (P7 + _1n6) / _4n2;
    return function sqrt3mod4(Fp4, n5) {
      const root = Fp4.pow(n5, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P7 % _8n === _5n) {
    const c1 = (P7 - _5n) / _8n;
    return function sqrt5mod8(Fp4, n5) {
      const n22 = Fp4.mul(n5, _2n6);
      const v9 = Fp4.pow(n22, c1);
      const nv = Fp4.mul(n5, v9);
      const i9 = Fp4.mul(Fp4.mul(nv, _2n6), v9);
      const root = Fp4.mul(nv, Fp4.sub(i9, Fp4.ONE));
      if (!Fp4.eql(Fp4.sqr(root), n5))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P7 % _16n === _9n) {
  }
  return tonelliShanks(P7);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts2 = FIELD_FIELDS.reduce((map36, val) => {
    map36[val] = "function";
    return map36;
  }, initial);
  return validateObject2(field, opts2);
}
function FpPow2(f16, num3, power) {
  if (power < _0n6)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n6)
    return f16.ONE;
  if (power === _1n6)
    return num3;
  let p9 = f16.ONE;
  let d7 = num3;
  while (power > _0n6) {
    if (power & _1n6)
      p9 = f16.mul(p9, d7);
    d7 = f16.sqr(d7);
    power >>= _1n6;
  }
  return p9;
}
function FpInvertBatch2(f16, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num3, i9) => {
    if (f16.is0(num3))
      return acc;
    tmp[i9] = acc;
    return f16.mul(acc, num3);
  }, f16.ONE);
  const inverted = f16.inv(lastMultiplied);
  nums.reduceRight((acc, num3, i9) => {
    if (f16.is0(num3))
      return acc;
    tmp[i9] = f16.mul(acc, tmp[i9]);
    return f16.mul(acc, num3);
  }, inverted);
  return tmp;
}
function nLength(n5, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n5.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field3(ORDER, bitLen3, isLE5 = false, redef = {}) {
  if (ORDER <= _0n6)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f16 = Object.freeze({
    ORDER,
    isLE: isLE5,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n6,
    ONE: _1n6,
    create: (num3) => mod2(num3, ORDER),
    isValid: (num3) => {
      if (typeof num3 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num3);
      return _0n6 <= num3 && num3 < ORDER;
    },
    is0: (num3) => num3 === _0n6,
    isOdd: (num3) => (num3 & _1n6) === _1n6,
    neg: (num3) => mod2(-num3, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num3) => mod2(num3 * num3, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num3, power) => FpPow2(f16, num3, power),
    div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num3) => num3 * num3,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num3) => invert(num3, ORDER),
    sqrt: redef.sqrt || ((n5) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f16, n5);
    }),
    invertBatch: (lst) => FpInvertBatch2(f16, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a6, b6, c9) => c9 ? b6 : a6,
    toBytes: (num3) => isLE5 ? numberToBytesLE2(num3, BYTES) : numberToBytesBE2(num3, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
      return isLE5 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
    }
  });
  return Object.freeze(f16);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField2(key, fieldOrder, isLE5 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num3 = isLE5 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
  const reduced = mod2(num3, fieldOrder - _1n6) + _1n6;
  return isLE5 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/abstract/curve.js
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W6, bits) {
  if (!Number.isSafeInteger(W6) || W6 <= 0 || W6 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W6);
}
function calcWOpts(W6, bits) {
  validateW(W6, bits);
  const windows = Math.ceil(bits / W6) + 1;
  const windowSize = 2 ** (W6 - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c9) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p9, i9) => {
    if (!(p9 instanceof c9))
      throw new Error("invalid point at index " + i9);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s5, i9) => {
    if (!field.isValid(s5))
      throw new Error("invalid scalar at index " + i9);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P7) {
  return pointWindowSizes.get(P7) || 1;
}
function wNAF(c9, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n5, p9 = c9.ZERO) {
      let d7 = elm;
      while (n5 > _0n7) {
        if (n5 & _1n7)
          p9 = p9.add(d7);
        d7 = d7.double();
        n5 >>= _1n7;
      }
      return p9;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W6) {
      const { windows, windowSize } = calcWOpts(W6, bits);
      const points = [];
      let p9 = elm;
      let base4 = p9;
      for (let window2 = 0; window2 < windows; window2++) {
        base4 = p9;
        points.push(base4);
        for (let i9 = 1; i9 < windowSize; i9++) {
          base4 = base4.add(p9);
          points.push(base4);
        }
        p9 = base4.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W6, precomputes, n5) {
      const { windows, windowSize } = calcWOpts(W6, bits);
      let p9 = c9.ZERO;
      let f16 = c9.BASE;
      const mask = BigInt(2 ** W6 - 1);
      const maxNumber = 2 ** W6;
      const shiftBy = BigInt(W6);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n5 & mask);
        n5 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n5 += _1n7;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f16 = f16.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p9 = p9.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p9, f: f16 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W6, precomputes, n5, acc = c9.ZERO) {
      const { windows, windowSize } = calcWOpts(W6, bits);
      const mask = BigInt(2 ** W6 - 1);
      const maxNumber = 2 ** W6;
      const shiftBy = BigInt(W6);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        if (n5 === _0n7)
          break;
        let wbits = Number(n5 & mask);
        n5 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n5 += _1n7;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W6, P7, transform) {
      let comp = pointPrecomputes.get(P7);
      if (!comp) {
        comp = this.precomputeWindow(P7, W6);
        if (W6 !== 1)
          pointPrecomputes.set(P7, transform(comp));
      }
      return comp;
    },
    wNAFCached(P7, n5, transform) {
      const W6 = getW(P7);
      return this.wNAF(W6, this.getPrecomputes(W6, P7, transform), n5);
    },
    wNAFCachedUnsafe(P7, n5, transform, prev) {
      const W6 = getW(P7);
      if (W6 === 1)
        return this.unsafeLadder(P7, n5, prev);
      return this.wNAFUnsafe(W6, this.getPrecomputes(W6, P7, transform), n5, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P7, W6) {
      validateW(W6, bits);
      pointWindowSizes.set(P7, W6);
      pointPrecomputes.delete(P7);
    }
  };
}
function pippenger(c9, fieldN, points, scalars) {
  validateMSMPoints(points, c9);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero7 = c9.ZERO;
  const wbits = bitLen2(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK = (1 << windowSize) - 1;
  const buckets = new Array(MASK + 1).fill(zero7);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero7;
  for (let i9 = lastBits; i9 >= 0; i9 -= windowSize) {
    buckets.fill(zero7);
    for (let j9 = 0; j9 < scalars.length; j9++) {
      const scalar = scalars[j9];
      const wbits2 = Number(scalar >> BigInt(i9) & BigInt(MASK));
      buckets[wbits2] = buckets[wbits2].add(points[j9]);
    }
    let resI = zero7;
    for (let j9 = buckets.length - 1, sumI = zero7; j9 > 0; j9--) {
      sumI = sumI.add(buckets[j9]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i9 !== 0)
      for (let j9 = 0; j9 < windowSize; j9++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts2) {
  if (opts2.lowS !== void 0)
    abool2("lowS", opts2.lowS);
  if (opts2.prehash !== void 0)
    abool2("prehash", opts2.prehash);
}
function validatePointOpts(curve) {
  const opts2 = validateBasic(curve);
  validateObject2(opts2, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp4, a: a6 } = opts2;
  if (endo) {
    if (!Fp4.eql(a6, Fp4.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts2 });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports2;
var DERErr = class extends Error {
  constructor(m6 = "") {
    super(m6);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E8 } = DER;
      if (tag < 0 || tag > 256)
        throw new E8("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E8("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded2(dataLen);
      if (len.length / 2 & 128)
        throw new E8("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
      const t6 = numberToHexUnpadded2(tag);
      return t6 + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E8 } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E8("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E8("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length = 0;
      if (!isLong)
        length = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E8("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E8("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E8("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E8("tlv.decode(long): zero leftmost byte");
        for (const b6 of lengthBytes)
          length = length << 8 | b6;
        pos += lenLen;
        if (length < 128)
          throw new E8("tlv.decode(long): not minimal encoding");
      }
      const v9 = data.subarray(pos, pos + length);
      if (v9.length !== length)
        throw new E8("tlv.decode: wrong value length");
      return { v: v9, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num3) {
      const { Err: E8 } = DER;
      if (num3 < _0n8)
        throw new E8("integer: negative integers are not allowed");
      let hex2 = numberToHexUnpadded2(num3);
      if (Number.parseInt(hex2[0], 16) & 8)
        hex2 = "00" + hex2;
      if (hex2.length & 1)
        throw new E8("unexpected DER parsing assertion: unpadded hex");
      return hex2;
    },
    decode(data) {
      const { Err: E8 } = DER;
      if (data[0] & 128)
        throw new E8("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E8("invalid signature integer: unnecessary leading zero");
      return b2n(data);
    }
  },
  toSig(hex2) {
    const { Err: E8, _int: int, _tlv: tlv } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    abytes4(data);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E8("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E8("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs3 = tlv.encode(2, int.encode(sig.r));
    const ss3 = tlv.encode(2, int.encode(sig.s));
    const seq = rs3 + ss3;
    return tlv.encode(48, seq);
  }
};
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n7 = BigInt(2);
var _3n5 = BigInt(3);
var _4n3 = BigInt(4);
function weierstrassPoints2(opts2) {
  const CURVE = validatePointOpts(opts2);
  const { Fp: Fp4 } = CURVE;
  const Fn4 = Field3(CURVE.n, CURVE.nBitLength);
  const toBytes15 = CURVE.toBytes || ((_c3, point, _isCompressed) => {
    const a6 = point.toAffine();
    return concatBytes4(Uint8Array.from([4]), Fp4.toBytes(a6.x), Fp4.toBytes(a6.y));
  });
  const fromBytes11 = CURVE.fromBytes || ((bytes2) => {
    const tail4 = bytes2.subarray(1);
    const x7 = Fp4.fromBytes(tail4.subarray(0, Fp4.BYTES));
    const y11 = Fp4.fromBytes(tail4.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
    return { x: x7, y: y11 };
  });
  function weierstrassEquation(x7) {
    const { a: a6, b: b6 } = CURVE;
    const x22 = Fp4.sqr(x7);
    const x32 = Fp4.mul(x22, x7);
    return Fp4.add(Fp4.add(x32, Fp4.mul(x7, a6)), b6);
  }
  if (!Fp4.eql(Fp4.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num3) {
    return inRange2(num3, _1n8, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N9 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes5(key))
        key = bytesToHex4(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num3;
    try {
      num3 = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes2("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num3 = mod2(num3, N9);
    aInRange2("private key", num3, _1n8, N9);
    return num3;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized2((p9, iz) => {
    const { px: x7, py: y11, pz: z9 } = p9;
    if (Fp4.eql(z9, Fp4.ONE))
      return { x: x7, y: y11 };
    const is0 = p9.is0();
    if (iz == null)
      iz = is0 ? Fp4.ONE : Fp4.inv(z9);
    const ax = Fp4.mul(x7, iz);
    const ay = Fp4.mul(y11, iz);
    const zz = Fp4.mul(z9, iz);
    if (is0)
      return { x: Fp4.ZERO, y: Fp4.ZERO };
    if (!Fp4.eql(zz, Fp4.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized2((p9) => {
    if (p9.is0()) {
      if (CURVE.allowInfinityPoint && !Fp4.is0(p9.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x7, y: y11 } = p9.toAffine();
    if (!Fp4.isValid(x7) || !Fp4.isValid(y11))
      throw new Error("bad point: x or y not FE");
    const left13 = Fp4.sqr(y11);
    const right13 = weierstrassEquation(x7);
    if (!Fp4.eql(left13, right13))
      throw new Error("bad point: equation left != right");
    if (!p9.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp4.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp4.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp4.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p9) {
      const { x: x7, y: y11 } = p9 || {};
      if (!p9 || !Fp4.isValid(x7) || !Fp4.isValid(y11))
        throw new Error("invalid affine point");
      if (p9 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i9) => Fp4.eql(i9, Fp4.ZERO);
      if (is0(x7) && is0(y11))
        return Point3.ZERO;
      return new Point3(x7, y11, Fp4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp4.invertBatch(points.map((p9) => p9.pz));
      return points.map((p9, i9) => p9.toAffine(toInv[i9])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P7 = Point3.fromAffine(fromBytes11(ensureBytes2("pointHex", hex2)));
      P7.assertValidity();
      return P7;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point3, Fn4, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y11 } = this.toAffine();
      if (Fp4.isOdd)
        return !Fp4.isOdd(y11);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp4.eql(Fp4.mul(X1, Z22), Fp4.mul(X22, Z1));
      const U22 = Fp4.eql(Fp4.mul(Y1, Z22), Fp4.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp4.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a6, b: b6 } = CURVE;
      const b32 = Fp4.mul(b6, _3n5);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp4.ZERO, Y32 = Fp4.ZERO, Z32 = Fp4.ZERO;
      let t0 = Fp4.mul(X1, X1);
      let t1 = Fp4.mul(Y1, Y1);
      let t22 = Fp4.mul(Z1, Z1);
      let t32 = Fp4.mul(X1, Y1);
      t32 = Fp4.add(t32, t32);
      Z32 = Fp4.mul(X1, Z1);
      Z32 = Fp4.add(Z32, Z32);
      X32 = Fp4.mul(a6, Z32);
      Y32 = Fp4.mul(b32, t22);
      Y32 = Fp4.add(X32, Y32);
      X32 = Fp4.sub(t1, Y32);
      Y32 = Fp4.add(t1, Y32);
      Y32 = Fp4.mul(X32, Y32);
      X32 = Fp4.mul(t32, X32);
      Z32 = Fp4.mul(b32, Z32);
      t22 = Fp4.mul(a6, t22);
      t32 = Fp4.sub(t0, t22);
      t32 = Fp4.mul(a6, t32);
      t32 = Fp4.add(t32, Z32);
      Z32 = Fp4.add(t0, t0);
      t0 = Fp4.add(Z32, t0);
      t0 = Fp4.add(t0, t22);
      t0 = Fp4.mul(t0, t32);
      Y32 = Fp4.add(Y32, t0);
      t22 = Fp4.mul(Y1, Z1);
      t22 = Fp4.add(t22, t22);
      t0 = Fp4.mul(t22, t32);
      X32 = Fp4.sub(X32, t0);
      Z32 = Fp4.mul(t22, t1);
      Z32 = Fp4.add(Z32, Z32);
      Z32 = Fp4.add(Z32, Z32);
      return new Point3(X32, Y32, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp4.ZERO, Y32 = Fp4.ZERO, Z32 = Fp4.ZERO;
      const a6 = CURVE.a;
      const b32 = Fp4.mul(CURVE.b, _3n5);
      let t0 = Fp4.mul(X1, X22);
      let t1 = Fp4.mul(Y1, Y22);
      let t22 = Fp4.mul(Z1, Z22);
      let t32 = Fp4.add(X1, Y1);
      let t42 = Fp4.add(X22, Y22);
      t32 = Fp4.mul(t32, t42);
      t42 = Fp4.add(t0, t1);
      t32 = Fp4.sub(t32, t42);
      t42 = Fp4.add(X1, Z1);
      let t52 = Fp4.add(X22, Z22);
      t42 = Fp4.mul(t42, t52);
      t52 = Fp4.add(t0, t22);
      t42 = Fp4.sub(t42, t52);
      t52 = Fp4.add(Y1, Z1);
      X32 = Fp4.add(Y22, Z22);
      t52 = Fp4.mul(t52, X32);
      X32 = Fp4.add(t1, t22);
      t52 = Fp4.sub(t52, X32);
      Z32 = Fp4.mul(a6, t42);
      X32 = Fp4.mul(b32, t22);
      Z32 = Fp4.add(X32, Z32);
      X32 = Fp4.sub(t1, Z32);
      Z32 = Fp4.add(t1, Z32);
      Y32 = Fp4.mul(X32, Z32);
      t1 = Fp4.add(t0, t0);
      t1 = Fp4.add(t1, t0);
      t22 = Fp4.mul(a6, t22);
      t42 = Fp4.mul(b32, t42);
      t1 = Fp4.add(t1, t22);
      t22 = Fp4.sub(t0, t22);
      t22 = Fp4.mul(a6, t22);
      t42 = Fp4.add(t42, t22);
      t0 = Fp4.mul(t1, t42);
      Y32 = Fp4.add(Y32, t0);
      t0 = Fp4.mul(t52, t42);
      X32 = Fp4.mul(t32, X32);
      X32 = Fp4.sub(X32, t0);
      t0 = Fp4.mul(t32, t1);
      Z32 = Fp4.mul(t52, Z32);
      Z32 = Fp4.add(Z32, t0);
      return new Point3(X32, Y32, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n5) {
      return wnaf.wNAFCached(this, n5, Point3.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc3) {
      const { endo, n: N9 } = CURVE;
      aInRange2("scalar", sc3, _0n8, N9);
      const I8 = Point3.ZERO;
      if (sc3 === _0n8)
        return I8;
      if (this.is0() || sc3 === _1n8)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc3, Point3.normalizeZ);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(sc3);
      let k1p = I8;
      let k2p = I8;
      let d7 = this;
      while (k1 > _0n8 || k22 > _0n8) {
        if (k1 & _1n8)
          k1p = k1p.add(d7);
        if (k22 & _1n8)
          k2p = k2p.add(d7);
        d7 = d7.double();
        k1 >>= _1n8;
        k22 >>= _1n8;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N9 } = CURVE;
      aInRange2("scalar", scalar, _1n8, N9);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p9, f: f16 } = this.wNAF(scalar);
        point = p9;
        fake = f16;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q7, a6, b6) {
      const G7 = Point3.BASE;
      const mul3 = (P7, a7) => a7 === _0n8 || a7 === _1n8 || !P7.equals(G7) ? P7.multiplyUnsafe(a7) : P7.multiply(a7);
      const sum = mul3(this, a6).add(mul3(Q7, b6));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n8)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n8)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool2("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes15(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool2("isCompressed", isCompressed);
      return bytesToHex4(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp4.ONE);
  Point3.ZERO = new Point3(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts2 = validateBasic(curve);
  validateObject2(opts2, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts2 });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp4.BYTES + 1;
  const uncompressedLen = 2 * Fp4.BYTES + 1;
  function modN2(a6) {
    return mod2(a6, CURVE_ORDER);
  }
  function invN(a6) {
    return invert(a6, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints2({
    ...CURVE,
    toBytes(_c3, point, isCompressed) {
      const a6 = point.toAffine();
      const x7 = Fp4.toBytes(a6.x);
      const cat = concatBytes4;
      abool2("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x7);
      } else {
        return cat(Uint8Array.from([4]), x7, Fp4.toBytes(a6.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head5 = bytes2[0];
      const tail4 = bytes2.subarray(1);
      if (len === compressedLen && (head5 === 2 || head5 === 3)) {
        const x7 = bytesToNumberBE2(tail4);
        if (!inRange2(x7, _1n8, Fp4.ORDER))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x7);
        let y11;
        try {
          y11 = Fp4.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y11 & _1n8) === _1n8;
        const isHeadOdd = (head5 & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y11 = Fp4.neg(y11);
        return { x: x7, y: y11 };
      } else if (len === uncompressedLen && head5 === 4) {
        const x7 = Fp4.fromBytes(tail4.subarray(0, Fp4.BYTES));
        const y11 = Fp4.fromBytes(tail4.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
        return { x: x7, y: y11 };
      } else {
        const cl2 = compressedLen;
        const ul2 = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl2 + ", or uncompressed " + ul2 + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num3) => bytesToHex4(numberToBytesBE2(num3, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n8;
    return number2 > HALF;
  }
  function normalizeS(s5) {
    return isBiggerThanHalfOrder(s5) ? modN2(-s5) : s5;
  }
  const slcNum = (b6, from40, to6) => bytesToNumberBE2(b6.slice(from40, to6));
  class Signature {
    constructor(r8, s5, recovery) {
      this.r = r8;
      this.s = s5;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l9 = CURVE.nByteLength;
      hex2 = ensureBytes2("compactSignature", hex2, l9 * 2);
      return new Signature(slcNum(hex2, 0, l9), slcNum(hex2, l9, 2 * l9));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r8, s: s5 } = DER.toSig(ensureBytes2("DER", hex2));
      return new Signature(r8, s5);
    }
    assertValidity() {
      aInRange2("r", this.r, _1n8, CURVE_ORDER);
      aInRange2("s", this.s, _1n8, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r8, s: s5, recovery: rec } = this;
      const h9 = bits2int_modN(ensureBytes2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r8 + CURVE.n : r8;
      if (radj >= Fp4.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R6 = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir4 = invN(radj);
      const u1 = modN2(-h9 * ir4);
      const u22 = modN2(s5 * ir4);
      const Q7 = Point3.BASE.multiplyAndAddUnsafe(R6, u1, u22);
      if (!Q7)
        throw new Error("point at infinify");
      Q7.assertValidity();
      return Q7;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes4(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes4(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength2(CURVE.n);
      return mapHashToField2(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey4(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes5(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b6 = Point3.fromHex(publicB);
    return b6.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    if (bytes2.length > 8192)
      throw new Error("input is too large");
    const num3 = bytesToNumberBE2(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num3 >> BigInt(delta) : num3;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN2(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask2(CURVE.nBitLength);
  function int2octets(num3) {
    aInRange2("num < 2^" + CURVE.nBitLength, num3, _0n8, ORDER_MASK);
    return numberToBytesBE2(num3, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts2 = defaultSigOpts) {
    if (["recovered", "canonical"].some((k11) => k11 in opts2))
      throw new Error("sign() legacy options not supported");
    const { hash: hash9, randomBytes: randomBytes6 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts2;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    validateSigVerOpts(opts2);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash9(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d7 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d7), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e11 = ent === true ? randomBytes6(Fp4.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e11));
    }
    const seed = concatBytes4(...seedArgs);
    const m6 = h1int;
    function k2sig(kBytes) {
      const k11 = bits2int(kBytes);
      if (!isWithinCurveOrder(k11))
        return;
      const ik = invN(k11);
      const q6 = Point3.BASE.multiply(k11).toAffine();
      const r8 = modN2(q6.x);
      if (r8 === _0n8)
        return;
      const s5 = modN2(ik * modN2(m6 + r8 * d7));
      if (s5 === _0n8)
        return;
      let recovery = (q6.x === r8 ? 0 : 2) | Number(q6.y & _1n8);
      let normS = s5;
      if (lowS && isBiggerThanHalfOrder(s5)) {
        normS = normalizeS(s5);
        recovery ^= 1;
      }
      return new Signature(r8, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign9(msgHash, privKey, opts2 = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts2);
    const C10 = CURVE;
    const drbg = createHmacDrbg2(C10.hash.outputLen, C10.nByteLength, C10.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify7(signature, msgHash, publicKey, opts2 = defaultVerOpts) {
    var _a14;
    const sg2 = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    const { lowS, prehash, format: format9 } = opts2;
    validateSigVerOpts(opts2);
    if ("strict" in opts2)
      throw new Error("options.strict was renamed to lowS");
    if (format9 !== void 0 && format9 !== "compact" && format9 !== "der")
      throw new Error("format must be compact or der");
    const isHex3 = typeof sg2 === "string" || isBytes5(sg2);
    const isObj = !isHex3 && !format9 && typeof sg2 === "object" && sg2 !== null && typeof sg2.r === "bigint" && typeof sg2.s === "bigint";
    if (!isHex3 && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P7;
    try {
      if (isObj)
        _sig = new Signature(sg2.r, sg2.s);
      if (isHex3) {
        try {
          if (format9 !== "compact")
            _sig = Signature.fromDER(sg2);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format9 !== "der")
          _sig = Signature.fromCompact(sg2);
      }
      P7 = Point3.fromHex(publicKey);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r8, s: s5 } = _sig;
    const h9 = bits2int_modN(msgHash);
    const is3 = invN(s5);
    const u1 = modN2(h9 * is3);
    const u22 = modN2(r8 * is3);
    const R6 = (_a14 = Point3.BASE.multiplyAndAddUnsafe(P7, u1, u22)) == null ? void 0 : _a14.toAffine();
    if (!R6)
      return false;
    const v9 = modN2(R6.x);
    return v9 === r8;
  }
  return {
    CURVE,
    getPublicKey: getPublicKey4,
    getSharedSecret,
    sign: sign9,
    verify: verify7,
    ProjectivePoint: Point3,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp4, Z5) {
  const q6 = Fp4.ORDER;
  let l9 = _0n8;
  for (let o6 = q6 - _1n8; o6 % _2n7 === _0n8; o6 /= _2n7)
    l9 += _1n8;
  const c1 = l9;
  const _2n_pow_c1_1 = _2n7 << c1 - _1n8 - _1n8;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n7;
  const c22 = (q6 - _1n8) / _2n_pow_c1;
  const c32 = (c22 - _1n8) / _2n7;
  const c42 = _2n_pow_c1 - _1n8;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp4.pow(Z5, c22);
  const c72 = Fp4.pow(Z5, (c22 + _1n8) / _2n7);
  let sqrtRatio = (u10, v9) => {
    let tv1 = c62;
    let tv2 = Fp4.pow(v9, c42);
    let tv3 = Fp4.sqr(tv2);
    tv3 = Fp4.mul(tv3, v9);
    let tv5 = Fp4.mul(u10, tv3);
    tv5 = Fp4.pow(tv5, c32);
    tv5 = Fp4.mul(tv5, tv2);
    tv2 = Fp4.mul(tv5, v9);
    tv3 = Fp4.mul(tv5, u10);
    let tv4 = Fp4.mul(tv3, tv2);
    tv5 = Fp4.pow(tv4, c52);
    let isQR = Fp4.eql(tv5, Fp4.ONE);
    tv2 = Fp4.mul(tv3, c72);
    tv5 = Fp4.mul(tv4, tv1);
    tv3 = Fp4.cmov(tv2, tv3, isQR);
    tv4 = Fp4.cmov(tv5, tv4, isQR);
    for (let i9 = c1; i9 > _1n8; i9--) {
      let tv52 = i9 - _2n7;
      tv52 = _2n7 << tv52 - _1n8;
      let tvv5 = Fp4.pow(tv4, tv52);
      const e1 = Fp4.eql(tvv5, Fp4.ONE);
      tv2 = Fp4.mul(tv3, tv1);
      tv1 = Fp4.mul(tv1, tv1);
      tvv5 = Fp4.mul(tv4, tv1);
      tv3 = Fp4.cmov(tv2, tv3, e1);
      tv4 = Fp4.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp4.ORDER % _4n3 === _3n5) {
    const c12 = (Fp4.ORDER - _3n5) / _4n3;
    const c23 = Fp4.sqrt(Fp4.neg(Z5));
    sqrtRatio = (u10, v9) => {
      let tv1 = Fp4.sqr(v9);
      const tv2 = Fp4.mul(u10, v9);
      tv1 = Fp4.mul(tv1, tv2);
      let y1 = Fp4.pow(tv1, c12);
      y1 = Fp4.mul(y1, tv2);
      const y22 = Fp4.mul(y1, c23);
      const tv3 = Fp4.mul(Fp4.sqr(y1), v9);
      const isQR = Fp4.eql(tv3, u10);
      let y11 = Fp4.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y11 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU3(Fp4, opts2) {
  validateField(Fp4);
  if (!Fp4.isValid(opts2.A) || !Fp4.isValid(opts2.B) || !Fp4.isValid(opts2.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp4, opts2.Z);
  if (!Fp4.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u10) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x7, y11;
    tv1 = Fp4.sqr(u10);
    tv1 = Fp4.mul(tv1, opts2.Z);
    tv2 = Fp4.sqr(tv1);
    tv2 = Fp4.add(tv2, tv1);
    tv3 = Fp4.add(tv2, Fp4.ONE);
    tv3 = Fp4.mul(tv3, opts2.B);
    tv4 = Fp4.cmov(opts2.Z, Fp4.neg(tv2), !Fp4.eql(tv2, Fp4.ZERO));
    tv4 = Fp4.mul(tv4, opts2.A);
    tv2 = Fp4.sqr(tv3);
    tv6 = Fp4.sqr(tv4);
    tv5 = Fp4.mul(tv6, opts2.A);
    tv2 = Fp4.add(tv2, tv5);
    tv2 = Fp4.mul(tv2, tv3);
    tv6 = Fp4.mul(tv6, tv4);
    tv5 = Fp4.mul(tv6, opts2.B);
    tv2 = Fp4.add(tv2, tv5);
    x7 = Fp4.mul(tv1, tv3);
    const { isValid, value: value2 } = sqrtRatio(tv2, tv6);
    y11 = Fp4.mul(tv1, u10);
    y11 = Fp4.mul(y11, value2);
    x7 = Fp4.cmov(x7, tv3, isValid);
    y11 = Fp4.cmov(y11, value2, isValid);
    const e1 = Fp4.isOdd(u10) === Fp4.isOdd(y11);
    y11 = Fp4.cmov(Fp4.neg(y11), y11, e1);
    x7 = Fp4.div(x7, tv4);
    return { x: x7, y: y11 };
  };
}

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash9) {
  return {
    hash: hash9,
    hmac: (key, ...msgs) => hmac2(hash9, key, concatBytes3(...msgs)),
    randomBytes: randomBytes2
  };
}
function createCurve3(curveDef, defHash) {
  const create6 = (hash9) => weierstrass({ ...curveDef, ...getHash(hash9) });
  return { ...create6(defHash), create: create6 };
}

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE2;
function i2osp(value2, length) {
  anum(value2);
  anum(length);
  if (value2 < 0 || value2 >= 1 << 8 * length)
    throw new Error("invalid I2OSP input: " + value2);
  const res = Array.from({ length }).fill(0);
  for (let i9 = length - 1; i9 >= 0; i9--) {
    res[i9] = value2 & 255;
    value2 >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a6, b6) {
  const arr = new Uint8Array(a6.length);
  for (let i9 = 0; i9 < a6.length; i9++) {
    arr[i9] = a6[i9] ^ b6[i9];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H4) {
  abytes4(msg);
  abytes4(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H4(concatBytes4(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H4;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (lenInBytes > 65535 || ell > 255)
    throw new Error("expand_message_xmd: invalid lenInBytes");
  const DST_prime = concatBytes4(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b6 = new Array(ell);
  const b_0 = H4(concatBytes4(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b6[0] = H4(concatBytes4(b_0, i2osp(1, 1), DST_prime));
  for (let i9 = 1; i9 <= ell; i9++) {
    const args = [strxor(b_0, b6[i9 - 1]), i2osp(i9 + 1, 1), DST_prime];
    b6[i9] = H4(concatBytes4(...args));
  }
  const pseudo_random_bytes = concatBytes4(...b6);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k11, H4) {
  abytes4(msg);
  abytes4(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k11 / 8);
    DST = H4.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H4.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject2(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p9, k: k11, m: m6, hash: hash9, expand: expand2, DST: _DST } = options;
  abytes4(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes3(_DST) : _DST;
  const log2p = p9.toString(2).length;
  const L7 = Math.ceil((log2p + k11) / 8);
  const len_in_bytes = count * m6 * L7;
  let prb;
  if (expand2 === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash9);
  } else if (expand2 === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k11, hash9);
  } else if (expand2 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u10 = new Array(count);
  for (let i9 = 0; i9 < count; i9++) {
    const e11 = new Array(m6);
    for (let j9 = 0; j9 < m6; j9++) {
      const elm_offset = L7 * (j9 + i9 * m6);
      const tv = prb.subarray(elm_offset, elm_offset + L7);
      e11[j9] = mod2(os2ip(tv), p9);
    }
    u10[i9] = e11;
  }
  return u10;
}
function isogenyMap2(field, map36) {
  const COEFF = map36.map((i9) => Array.from(i9).reverse());
  return (x7, y11) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i9) => field.add(field.mul(acc, x7), i9)));
    x7 = field.div(xNum, xDen);
    y11 = field.mul(y11, field.div(yNum, yDen));
    return { x: x7, y: y11 };
  };
}
function createHasher3(Point3, mapToCurve, def2) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u10 = hash_to_field(msg, 2, { ...def2, DST: def2.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u10[0]));
      const u1 = Point3.fromAffine(mapToCurve(u10[1]));
      const P7 = u0.add(u1).clearCofactor();
      P7.assertValidity();
      return P7;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u10 = hash_to_field(msg, 1, { ...def2, DST: def2.encodeDST, ...options });
      const P7 = Point3.fromAffine(mapToCurve(u10[0])).clearCofactor();
      P7.assertValidity();
      return P7;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i9 of scalars)
        if (typeof i9 !== "bigint")
          throw new Error("mapToCurve: expected array of bigints");
      const P7 = Point3.fromAffine(mapToCurve(scalars)).clearCofactor();
      P7.assertValidity();
      return P7;
    }
  };
}

// node_modules/@turnkey/viem/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n9 = BigInt(1);
var _2n8 = BigInt(2);
var divNearest = (a6, b6) => (a6 + b6 / _2n8) / b6;
function sqrtMod2(y11) {
  const P7 = secp256k1P;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y11 * y11 * y11 % P7;
  const b32 = b22 * b22 * y11 % P7;
  const b6 = pow22(b32, _3n6, P7) * b32 % P7;
  const b9 = pow22(b6, _3n6, P7) * b32 % P7;
  const b11 = pow22(b9, _2n8, P7) * b22 % P7;
  const b222 = pow22(b11, _11n, P7) * b11 % P7;
  const b44 = pow22(b222, _22n, P7) * b222 % P7;
  const b88 = pow22(b44, _44n, P7) * b44 % P7;
  const b176 = pow22(b88, _88n, P7) * b88 % P7;
  const b220 = pow22(b176, _44n, P7) * b44 % P7;
  const b223 = pow22(b220, _3n6, P7) * b32 % P7;
  const t1 = pow22(b223, _23n, P7) * b222 % P7;
  const t22 = pow22(t1, _6n, P7) * b22 % P7;
  const root = pow22(t22, _2n8, P7);
  if (!Fpk12.eql(Fpk12.sqr(root), y11))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk12 = Field3(secp256k1P, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k14 = createCurve3({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  Fp: Fpk12,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k11) => {
      const n5 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n9 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k11, n5);
      const c22 = divNearest(-b1 * k11, n5);
      let k1 = mod2(k11 - c1 * a1 - c22 * a22, n5);
      let k22 = mod2(-c1 * b1 - c22 * b22, n5);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n5 - k1;
      if (k2neg)
        k22 = n5 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k11);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha2566);
var _0n9 = BigInt(0);
var TAGGED_HASH_PREFIXES2 = {};
function taggedHash2(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES2[tag];
  if (tagP === void 0) {
    const tagH = sha2566(Uint8Array.from(tag, (c9) => c9.charCodeAt(0)));
    tagP = concatBytes4(tagH, tagH);
    TAGGED_HASH_PREFIXES2[tag] = tagP;
  }
  return sha2566(concatBytes4(tagP, ...messages));
}
var pointToBytes2 = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n5) => numberToBytesBE2(n5, 32);
var modP = (x7) => mod2(x7, secp256k1P);
var modN = (x7) => mod2(x7, secp256k1N);
var Point2 = secp256k14.ProjectivePoint;
var GmulAdd = (Q7, a6, b6) => Point2.BASE.multiplyAndAddUnsafe(Q7, a6, b6);
function schnorrGetExtPubKey2(priv) {
  let d_ = secp256k14.utils.normPrivateKeyToScalar(priv);
  let p9 = Point2.fromPrivateKey(d_);
  const scalar = p9.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes2(p9) };
}
function lift_x2(x7) {
  aInRange2("x", x7, _1n9, secp256k1P);
  const xx = modP(x7 * x7);
  const c9 = modP(xx * x7 + BigInt(7));
  let y11 = sqrtMod2(c9);
  if (y11 % _2n8 !== _0n9)
    y11 = modP(-y11);
  const p9 = new Point2(x7, y11, _1n9);
  p9.assertValidity();
  return p9;
}
var num2 = bytesToNumberBE2;
function challenge2(...args) {
  return modN(num2(taggedHash2("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey2(privateKey) {
  return schnorrGetExtPubKey2(privateKey).bytes;
}
function schnorrSign2(message, privateKey, auxRand = randomBytes2(32)) {
  const m6 = ensureBytes2("message", message);
  const { bytes: px, scalar: d7 } = schnorrGetExtPubKey2(privateKey);
  const a6 = ensureBytes2("auxRand", auxRand, 32);
  const t6 = numTo32b(d7 ^ num2(taggedHash2("BIP0340/aux", a6)));
  const rand = taggedHash2("BIP0340/nonce", t6, px, m6);
  const k_ = modN(num2(rand));
  if (k_ === _0n9)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k11 } = schnorrGetExtPubKey2(k_);
  const e11 = challenge2(rx, px, m6);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k11 + e11 * d7)), 32);
  if (!schnorrVerify2(sig, m6, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify2(signature, message, publicKey) {
  const sig = ensureBytes2("signature", signature, 64);
  const m6 = ensureBytes2("message", message);
  const pub = ensureBytes2("publicKey", publicKey, 32);
  try {
    const P7 = lift_x2(num2(pub));
    const r8 = num2(sig.subarray(0, 32));
    if (!inRange2(r8, _1n9, secp256k1P))
      return false;
    const s5 = num2(sig.subarray(32, 64));
    if (!inRange2(s5, _1n9, secp256k1N))
      return false;
    const e11 = challenge2(numTo32b(r8), pointToBytes2(P7), m6);
    const R6 = GmulAdd(P7, s5, modN(-e11));
    if (!R6 || !R6.hasEvenY() || R6.toAffine().x !== r8)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr2 = (() => ({
  getPublicKey: schnorrGetPublicKey2,
  sign: schnorrSign2,
  verify: schnorrVerify2,
  utils: {
    randomPrivateKey: secp256k14.utils.randomPrivateKey,
    lift_x: lift_x2,
    pointToBytes: pointToBytes2,
    numberToBytesBE: numberToBytesBE2,
    bytesToNumberBE: bytesToNumberBE2,
    taggedHash: taggedHash2,
    mod: mod2
  }
}))();
var isoMap2 = (() => isogenyMap2(Fpk12, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i9) => i9.map((j9) => BigInt(j9)))))();
var mapSWU2 = (() => mapToCurveSimpleSWU3(Fpk12, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fpk12.create(BigInt("-11"))
}))();
var htf = (() => createHasher3(secp256k14.ProjectivePoint, (scalars) => {
  const { x: x7, y: y11 } = mapSWU2(Fpk12.create(scalars[0]));
  return isoMap2(x7, y11);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fpk12.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2566
}))();
var hashToCurve3 = (() => htf.hashToCurve)();
var encodeToCurve3 = (() => htf.encodeToCurve)();

// node_modules/@turnkey/viem/dist/index.mjs
var TurnkeyConsensusNeededError = class extends BaseError {
  constructor({ message = "Turnkey activity requires consensus.", activityId, activityStatus }) {
    super(message);
    this.name = "TurnkeyConsensusNeededError";
    this.activityId = activityId;
    this.activityStatus = activityStatus;
  }
};
var TurnkeyActivityError2 = class extends BaseError {
  constructor({ message = "Received unexpected Turnkey activity status.", activityId, activityStatus }) {
    super(message);
    this.name = "TurnkeyActivityError";
    this.activityId = activityId;
    this.activityStatus = activityStatus;
  }
};
function createAccountWithAddress(input) {
  const { client, organizationId, signWith } = input;
  let { ethereumAddress } = input;
  if (!signWith) {
    throw new TurnkeyActivityError({
      message: `Missing signWith parameter`
    });
  }
  if (isAddress(signWith)) {
    ethereumAddress = signWith;
  } else if (!ethereumAddress) {
    throw new TurnkeyActivityError2({
      message: `Missing ethereumAddress parameter`
    });
  }
  return toAccount({
    address: ethereumAddress,
    sign: function({ hash: hash9 }) {
      return signMessage5(client, hash9, organizationId, signWith);
    },
    signMessage: function({ message }) {
      const hashedMessage = hashMessage(message);
      return signMessage5(client, hashedMessage, organizationId, signWith);
    },
    signTransaction: function(transaction, options) {
      const serializer = (options == null ? void 0 : options.serializer) ?? serializeTransaction;
      return signTransaction4(client, transaction, serializer, organizationId, signWith);
    },
    signTypedData: function(typedData) {
      return signTypedData5(client, typedData, organizationId, signWith);
    },
    signAuthorization: function(parameters) {
      return signAuthorization4(client, parameters, organizationId, signWith);
    }
  });
}
async function createAccount(input) {
  var _a14;
  const { client, organizationId, signWith } = input;
  let { ethereumAddress } = input;
  if (!signWith) {
    throw new TurnkeyActivityError2({
      message: `Missing signWith parameter`
    });
  }
  if (isAddress(signWith)) {
    ethereumAddress = signWith;
  } else if (!ethereumAddress) {
    const data = await client.getPrivateKey({
      privateKeyId: signWith,
      organizationId
    });
    ethereumAddress = (_a14 = data.privateKey.addresses.find((item) => item.format === "ADDRESS_FORMAT_ETHEREUM")) == null ? void 0 : _a14.address;
    if (typeof ethereumAddress !== "string" || !ethereumAddress) {
      throw new TurnkeyActivityError2({
        message: `Unable to find Ethereum address for key ${signWith} under organization ${organizationId}`
      });
    }
  }
  return createAccountWithAddress({
    client,
    organizationId,
    signWith,
    ethereumAddress
  });
}
async function signAuthorization4(client, parameters, organizationId, signWith) {
  const { chainId, nonce, to: to6 = "object" } = parameters;
  const address = parameters.contractAddress ?? parameters.address;
  if (!address) {
    throw new TurnkeyActivityError2({
      message: "Unable to sign authorization: address is undefined."
    });
  }
  const signature = await signMessageWithErrorWrapping(client, JSON.stringify({
    address,
    chainId,
    nonce
  }), organizationId, signWith, "PAYLOAD_ENCODING_EIP7702_AUTHORIZATION", to6);
  if (to6 === "object")
    return {
      address,
      chainId,
      nonce,
      ...signature,
      yParity: signature.v
    };
  return signature;
}
async function signMessage5(client, message, organizationId, signWith) {
  const signedMessage = await signMessageWithErrorWrapping(client, message, organizationId, signWith);
  return `${signedMessage}`;
}
async function signTransaction4(client, transaction, serializer, organizationId, signWith) {
  const signableTransaction = transaction.type === "eip4844" ? { ...transaction, sidecars: false } : transaction;
  const serializedTx = serializer(signableTransaction);
  const nonHexPrefixedSerializedTx = serializedTx.replace(/^0x/, "");
  const signedTx = await signTransactionWithErrorWrapping(client, nonHexPrefixedSerializedTx, organizationId, signWith);
  if (transaction.type === "eip4844") {
    const { r: r8, s: s5, v: v9 } = parseTransaction(signedTx);
    return serializeTransaction(transaction, {
      r: r8,
      s: s5,
      v: v9
    });
  }
  return signedTx;
}
async function signTypedData5(client, data, organizationId, signWith) {
  return await signMessageWithErrorWrapping(client, serializeTypedData(data), organizationId, signWith, "PAYLOAD_ENCODING_EIP712", "hex");
}
async function signTransactionWithErrorWrapping(client, unsignedTransaction, organizationId, signWith) {
  let signedTx;
  try {
    signedTx = await signTransactionImpl(client, unsignedTransaction, organizationId, signWith);
  } catch (error) {
    if (error instanceof TurnkeyActivityError) {
      throw new TurnkeyActivityError2({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    if (error instanceof TurnkeyActivityConsensusNeededError) {
      throw new TurnkeyConsensusNeededError({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    throw new TurnkeyActivityError2({
      message: `Failed to sign: ${error.message}`
    });
  }
  return `0x${signedTx}`;
}
async function signTransactionImpl(client, unsignedTransaction, organizationId, signWith) {
  var _a14, _b;
  if (isHttpClient(client)) {
    const { activity } = await client.signTransaction({
      type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2",
      organizationId,
      parameters: {
        signWith,
        type: "TRANSACTION_TYPE_ETHEREUM",
        unsignedTransaction
      },
      timestampMs: String(Date.now())
      // millisecond timestamp
    });
    assertActivityCompleted(activity);
    return assertNonNull((_b = (_a14 = activity == null ? void 0 : activity.result) == null ? void 0 : _a14.signTransactionResult) == null ? void 0 : _b.signedTransaction);
  } else {
    const { activity, signedTransaction } = await client.signTransaction({
      organizationId,
      signWith,
      type: "TRANSACTION_TYPE_ETHEREUM",
      unsignedTransaction
    });
    assertActivityCompleted(activity);
    return assertNonNull(signedTransaction);
  }
}
async function signMessageWithErrorWrapping(client, message, organizationId, signWith, payloadEncoding = "PAYLOAD_ENCODING_HEXADECIMAL", to6 = "hex") {
  let signedMessage;
  try {
    signedMessage = await signMessageImpl(client, message, organizationId, signWith, payloadEncoding, to6);
  } catch (error) {
    if (error instanceof TurnkeyActivityError) {
      throw new TurnkeyActivityError2({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    if (error instanceof TurnkeyActivityConsensusNeededError) {
      throw new TurnkeyConsensusNeededError({
        message: error.message,
        activityId: error.activityId,
        activityStatus: error.activityStatus
      });
    }
    throw new TurnkeyActivityError2({
      message: `Failed to sign: ${error.message}`
    });
  }
  return signedMessage;
}
async function signMessageImpl(client, message, organizationId, signWith, payloadEncoding, to6) {
  var _a14;
  let result;
  if (isHttpClient(client)) {
    const { activity } = await client.signRawPayload({
      type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2",
      organizationId,
      parameters: {
        signWith,
        payload: message,
        encoding: payloadEncoding,
        hashFunction: "HASH_FUNCTION_NO_OP"
      },
      timestampMs: String(Date.now())
      // millisecond timestamp
    });
    assertActivityCompleted(activity);
    result = assertNonNull((_a14 = activity == null ? void 0 : activity.result) == null ? void 0 : _a14.signRawPayloadResult);
  } else {
    const { activity, r: r8, s: s5, v: v9 } = await client.signRawPayload({
      organizationId,
      signWith,
      payload: message,
      encoding: payloadEncoding,
      hashFunction: "HASH_FUNCTION_NO_OP"
    });
    assertActivityCompleted(activity);
    result = {
      r: r8,
      s: s5,
      v: v9
    };
  }
  if (to6 === "object") {
    return {
      r: `0x${result.r}`,
      s: `0x${result.s}`,
      v: BigInt(result.v)
    };
  }
  return assertNonNull(serializeSignature3(result, to6));
}
function serializeSignature3(sig, to6 = "hex") {
  const { r: rString, s: sString, v: vString } = sig;
  const r8 = `0x${rString}`;
  const s5 = `0x${sString}`;
  const v9 = BigInt(vString);
  const yParity_ = v9;
  const signature = `0x${new secp256k14.Signature(hexToBigInt(r8), hexToBigInt(s5)).toCompactHex()}${yParity_ === 0n ? "1b" : "1c"}`;
  if (to6 === "hex")
    return signature;
  return hexToBytes(signature);
}

// node_modules/@dynamic-labs/embedded-wallet-evm/src/lib/TurnkeyEVMWalletConnector/TurnkeyEVMWalletConnector.js
var TurnkeyEVMWalletConnector = class _TurnkeyEVMWalletConnector extends TurnkeyWalletConnectorBase {
  constructor(nameAndKey, props) {
    var _a14, _b, _c3;
    super(nameAndKey, props);
    this.walletFallback = {
      brand: {
        alt: "Turnkey Wallet",
        spriteId: "turnkey"
      },
      name: "Turnkey HD"
    };
    this.ChainWallet = EthereumWallet;
    this.connectedChain = "EVM";
    this.supportedChains = ["ETH", "EVM"];
    this.verifiedCredentialChain = "eip155";
    this.evmNetworks = parseEvmNetworks(props.evmNetworks);
    this.walletUiUtils = props.walletUiUtils;
    this._turnkeyAccount = void 0;
    this._selectedChainId = this.getLastUsedChainId();
    this.providersConfig = (_a14 = props.providersConfig) !== null && _a14 !== void 0 ? _a14 : {};
    this.chainRpcProviders = props.chainRpcProviders;
    (_b = this.chainRpcProviders) === null || _b === void 0 ? void 0 : _b.registerEvmProviders((_c3 = this.providersConfig) !== null && _c3 !== void 0 ? _c3 : {});
    this.getTurnkeyClient().then((client) => {
      this.__turnkeyClient = client;
    }).catch((error) => logger4.error("Error getting turnkey client", error));
  }
  getLastUsedChainId() {
    var _a14;
    logger4.logVerboseTroubleshootingMessage("[TurnkeyEVMWalletConnector] getLastUsedChainId", {
      evmNetworks: this.evmNetworks,
      lastUsedChainId: this.lastUsedChainId
    });
    if (this.lastUsedChainId) {
      return this.lastUsedChainId;
    }
    if (!((_a14 = this.evmNetworks) === null || _a14 === void 0 ? void 0 : _a14.length)) {
      return void 0;
    }
    return this.evmNetworks[0].chainId;
  }
  // Public methods
  getNetwork() {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14;
      return (_a14 = yield this.getSigner()) === null || _a14 === void 0 ? void 0 : _a14.getChainId();
    });
  }
  supportsNetworkSwitching() {
    return true;
  }
  switchNetwork(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId) {
        return;
      }
      if (typeof networkChainId === "string") {
        networkChainId = parseInt(networkChainId);
      }
      this.lastUsedChainId = networkChainId;
      this._selectedChainId = networkChainId;
      yield this.refreshTurnkeyAccount();
      this.emit("chainChange", {
        chain: networkChainId.toString()
      });
    });
  }
  setVerifiedCredentials(verifiedCredentials) {
    const turnkeyVerifiedCredentials = findTurnkeyVerifiedCredentialsWithSmartWalletRef(verifiedCredentials, "eip155");
    const [turnkeyVerifiedCredential] = turnkeyVerifiedCredentials;
    const didTurnkeyVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !== JSON.stringify(turnkeyVerifiedCredentials);
    if (!didTurnkeyVerifiedCredentialsChanged) {
      return;
    }
    this.verifiedCredential = turnkeyVerifiedCredential;
    this.verifiedCredentials = turnkeyVerifiedCredentials;
    this.refreshTurnkeyAccount();
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14, _b;
      const activeAddress = ((_a14 = this.verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.address) || "";
      const isWalletActive = isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (!isWalletActive) {
        const targetActiveAccount = (_b = this.verifiedCredentials) === null || _b === void 0 ? void 0 : _b.find((vc3) => (vc3 === null || vc3 === void 0 ? void 0 : vc3.address) === expectedAddress);
        if (!targetActiveAccount) {
          throw new DynamicError("Account not found");
        }
        this.verifiedCredential = targetActiveAccount;
        this.refreshTurnkeyAccount();
      }
    });
  }
  signAuthorization(parameters) {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14;
      const { address: contractAddress, nonce, chainId } = parameters;
      yield this.createOrRestoreSession();
      if (!contractAddress) {
        throw new Error("Contract address not found");
      }
      const [signer, publicClient] = yield Promise.all([
        this.getSigner(),
        this.getPublicClient()
      ]);
      if (!signer || !publicClient) {
        throw new Error("Required clients not found");
      }
      const { turnkeySubOrganizationId } = (_a14 = this.walletProperties) !== null && _a14 !== void 0 ? _a14 : {};
      if (!turnkeySubOrganizationId) {
        throw new Error("Turnkey sub organization id not found");
      }
      const { address } = signer.account;
      const signature = yield this.internalSign({
        address,
        hash: hashAuthorization({
          address: contractAddress,
          chainId,
          nonce
        }),
        turnkeySubOrganizationId
      });
      return {
        address: contractAddress,
        chainId,
        nonce,
        r: signature.r,
        s: signature.s,
        v: BigInt(signature.v),
        yParity: signature.yParity
      };
    });
  }
  getBalance(address) {
    return __awaiter5(this, void 0, void 0, function* () {
      const client = yield this.getPublicClient();
      if (!client) {
        return void 0;
      }
      const balance = yield client.getBalance({
        address
      });
      return formatEther(balance);
    });
  }
  signMessage(messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      const signer = yield this.getSigner();
      if (!signer) {
        throw new Error("Signer not found");
      }
      return signer.signMessage({
        message: messageToSign
      });
    });
  }
  getPublicClient() {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14, _b;
      if (this.evmNetworks.length === 0) {
        return void 0;
      }
      const networkId = (_a14 = yield this.getNetwork()) !== null && _a14 !== void 0 ? _a14 : 1;
      const configurations = {
        cosmos: [],
        evm: this.evmNetworks,
        solana: [],
        starknet: void 0
      };
      if (!this.chainRpcProviders)
        return void 0;
      const providers = this.chainRpcProviders.getProviders(configurations);
      return (_b = this.chainRpcProviders.getEvmProviderByChainId(providers, networkId)) === null || _b === void 0 ? void 0 : _b.provider;
    });
  }
  getSigner() {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.getTurnkeyAccount();
      return this.getWalletClient();
    });
  }
  // decides in runtime which stamper to use and creates the corresponding account
  getAccount() {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14, _b, _c3;
      if (this.isSessionKeyCompatible() && ((_a14 = this.__turnkeyClient) === null || _a14 === void 0 ? void 0 : _a14.stamper) instanceof ApiKeyStamper) {
        return this._turnkeyAccount;
      }
      if (this.getAuthenticatorHandler().recoveryType === "passkey" && ((_b = this.__turnkeyClient) === null || _b === void 0 ? void 0 : _b.stamper) instanceof IframeStamper || this.getAuthenticatorHandler().recoveryType === "email" && ((_c3 = this.__turnkeyClient) === null || _c3 === void 0 ? void 0 : _c3.stamper) instanceof WebauthnStamper || this.__turnkeyClient !== this.getAuthenticatorHandler().client) {
        yield this.refreshTurnkeyAccount();
      }
      return this._turnkeyAccount;
    });
  }
  getWalletClient() {
    const rpcUrl = this.networkRpcUrl;
    const account2 = this._turnkeyAccount;
    const evmNetwork = this.currentEvmNetwork;
    if (!account2 || !rpcUrl || !evmNetwork) {
      return void 0;
    }
    return createWalletClientWithUiConfirmation({
      account: this.getAccount.bind(this),
      address: this.turnkeyAddress,
      chain: getOrMapViemChain(evmNetwork),
      transport: http(rpcUrl, this.providersConfig.httpTransportConfig),
      // TODO: remove this. We should not be passing references to wallet connectors
      walletConnector: this,
      walletUiUtils: this.walletUiUtils
    });
  }
  // Private methods
  get currentChainId() {
    var _a14, _b, _c3;
    return (_a14 = this._selectedChainId) !== null && _a14 !== void 0 ? _a14 : (_c3 = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c3 === void 0 ? void 0 : _c3.chainId;
  }
  get lastUsedChainId() {
    const lastUsedChainIdLS = localStorage.getItem(_TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
    if (!lastUsedChainIdLS)
      return void 0;
    try {
      const chainId = parseInt(lastUsedChainIdLS);
      if (isNaN(chainId)) {
        return void 0;
      }
      const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
      if (!isChainCurrentlyEnabled) {
        const lastUsedChainId = this.evmNetworks[0].chainId;
        this.lastUsedChainId = lastUsedChainId;
        return this.lastUsedChainId;
      }
      return chainId;
    } catch (err) {
      logger4.error(err);
      return void 0;
    }
  }
  set lastUsedChainId(chainId) {
    if (chainId === void 0) {
      localStorage.removeItem(_TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey);
    } else {
      localStorage.setItem(_TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey, chainId.toString());
    }
  }
  get networkRpcUrl() {
    const chainId = this.currentChainId;
    const evmNetwork = this.evmNetworks.find((network) => network.chainId === chainId);
    if (!evmNetwork) {
      return void 0;
    }
    const rpcUrl = getRpcUrlForChain({
      chainId,
      networks: this.evmNetworks
    });
    return rpcUrl;
  }
  get currentEvmNetwork() {
    const chainId = this.currentChainId;
    logger4.logVerboseTroubleshootingMessage("[TurnkeyEVMWalletConnector] currentEvmNetwork", {
      chainId,
      evmNetworks: this.evmNetworks
    });
    return this.evmNetworks.find((network) => network.chainId === chainId);
  }
  internalSign(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ hash: hash9, address, turnkeySubOrganizationId }) {
      var _b;
      const client = yield this.getTurnkeyClient();
      const { activity } = yield client.signRawPayload({
        organizationId: turnkeySubOrganizationId,
        parameters: {
          encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
          hashFunction: "HASH_FUNCTION_NO_OP",
          payload: hash9,
          signWith: address
        },
        timestampMs: Date.now().toString(),
        type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
      });
      const result = (_b = activity === null || activity === void 0 ? void 0 : activity.result) === null || _b === void 0 ? void 0 : _b.signRawPayloadResult;
      if (!result) {
        throw new Error("Sign raw payload result not found");
      }
      return {
        r: `0x${result.r}`,
        s: `0x${result.s}`,
        v: result.v,
        yParity: Number(result.v) % 2
      };
    });
  }
  internalSignTransaction(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ transaction, args, address, turnkeySubOrganizationId }) {
      return this.doRetryableTurnkeyAction({
        action: (turnkeyAccount) => turnkeyAccount.signTransaction(transaction, args),
        activityType: "SignTransaction",
        address,
        turnkeySubOrganizationId
      });
    });
  }
  internalSignTypedData(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ typedData, address, turnkeySubOrganizationId }) {
      return this.doRetryableTurnkeyAction({
        action: (turnkeyAccount) => turnkeyAccount.signTypedData(typedData),
        activityType: "SignTypedData",
        address,
        turnkeySubOrganizationId
      });
    });
  }
  internalSignMessage(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ message, address, turnkeySubOrganizationId }) {
      return this.doRetryableTurnkeyAction({
        action: (turnkeyAccount) => turnkeyAccount.signMessage({ message }),
        activityType: "SignMessage",
        address,
        turnkeySubOrganizationId
      });
    });
  }
  doRetryableTurnkeyAction(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ action, activityType, address, turnkeySubOrganizationId }) {
      yield this.createOrRestoreSession();
      let newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
        address,
        turnkeySubOrganizationId
      });
      try {
        return yield action(newTurnkeyAccountRaw);
      } catch (err) {
        if (TURNKEY_SDK_SESSION_KEY_RETRYABLE_ERRORS.some((errorMsg) => err.message.toLowerCase().includes(errorMsg.toLowerCase()))) {
          yield this.removeSessionKeys();
          yield this.createOrRestoreSession({
            ignoreRestore: true
          });
          newTurnkeyAccountRaw = yield this.createTurnkeyAccount({
            address,
            turnkeySubOrganizationId
          });
          logger4.error(`[TK - removeSessionKeys] failed to perform ${activityType} activity`, {
            activityType,
            address,
            err,
            turnkeySubOrganizationId
          });
          return action(newTurnkeyAccountRaw);
        }
        throw err;
      }
    });
  }
  createTurnkeyAccount(_a14) {
    return __awaiter5(this, arguments, void 0, function* ({ address, turnkeySubOrganizationId }) {
      return createAccount({
        client: yield this.getTurnkeyClient(),
        ethereumAddress: address,
        organizationId: turnkeySubOrganizationId,
        signWith: address
      });
    });
  }
  refreshTurnkeyAccount() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._turnkeyAccount = void 0;
      return this.getTurnkeyAccount();
    });
  }
  getTurnkeyAccount() {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14, _b;
      if (this._turnkeyAccount) {
        return this._turnkeyAccount;
      }
      const { turnkeySubOrganizationId } = (_a14 = this.walletProperties) !== null && _a14 !== void 0 ? _a14 : {};
      const { address } = (_b = this.verifiedCredential) !== null && _b !== void 0 ? _b : {};
      if (!turnkeySubOrganizationId || !address) {
        return;
      }
      this._turnkeyAccount = toAccount({
        address,
        signAuthorization: (...args) => __awaiter5(this, void 0, void 0, function* () {
          return this.signAuthorization(...args);
        }),
        signMessage: (_c3) => __awaiter5(this, [_c3], void 0, function* ({ message }) {
          return this.internalSignMessage({
            address,
            message,
            turnkeySubOrganizationId
          });
        }),
        signTransaction: (transaction, args) => __awaiter5(this, void 0, void 0, function* () {
          return this.internalSignTransaction({
            address,
            args,
            transaction,
            turnkeySubOrganizationId
          });
        }),
        signTypedData: (typedData) => __awaiter5(this, void 0, void 0, function* () {
          return this.internalSignTypedData({
            address,
            turnkeySubOrganizationId,
            typedData
          });
        })
      });
      this.setLoggerMetadata();
      return this._turnkeyAccount;
    });
  }
  createUiTransaction(from40) {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from40);
      const walletClient = this.getWalletClient();
      const publicClient = yield this.getPublicClient();
      if (!publicClient || !walletClient) {
        throw new DynamicError("No public client available");
      }
      return createViemUiTransaction({ from: from40, publicClient, walletClient });
    });
  }
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter5(this, void 0, void 0, function* () {
      var _a14, _b;
      const currentNetwork = yield this.getNetwork();
      return (_b = (_a14 = this.evmNetworks.find((network) => network.chainId.toString() === (currentNetwork === null || currentNetwork === void 0 ? void 0 : currentNetwork.toString()))) === null || _a14 === void 0 ? void 0 : _a14.blockExplorerUrls) !== null && _b !== void 0 ? _b : [];
    });
  }
  getEnabledNetworks() {
    return this.evmNetworks;
  }
  isSignAuthorizationSupported() {
    return true;
  }
};
TurnkeyEVMWalletConnector.lastUsedChainIdStorageKey = "turnkey-last-used-chain-id";

// node_modules/@dynamic-labs/embedded-wallet-evm/src/TurnkeyEVMWalletConnectors.js
var TurnkeyEVMWalletConnectors = (props) => {
  var _a14;
  if ((_a14 = props.apiProviders) === null || _a14 === void 0 ? void 0 : _a14.turnkey) {
    return [
      class extends TurnkeyEVMWalletConnector {
        constructor(innerProps) {
          super(TurnkeyWalletConnectorInfo.TurnkeyHD, Object.assign(Object.assign({}, props), innerProps));
        }
      },
      class extends TurnkeyEVMWalletConnector {
        constructor(innerProps) {
          super(TurnkeyWalletConnectorInfo.Turnkey, Object.assign(Object.assign({}, props), innerProps));
        }
      }
    ];
  }
  return [];
};

// node_modules/@dynamic-labs/embedded-wallet-evm/src/index.js
assertPackageVersion("@dynamic-labs/embedded-wallet-evm", version5);

// node_modules/@dynamic-labs/waas-evm/package.js
var version8 = "4.43.0";

// node_modules/@dynamic-labs/waas-evm/_virtual/_tslib.js
function __awaiter6(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/waas/package.js
var version9 = "4.43.0";

// node_modules/@dynamic-labs/waas/_virtual/_tslib.js
function __awaiter7(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate20(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate20;

// node_modules/uuid/dist/esm-browser/parse.js
function parse3(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v9;
  return Uint8Array.of((v9 = parseInt(uuid.slice(0, 8), 16)) >>> 24, v9 >>> 16 & 255, v9 >>> 8 & 255, v9 & 255, (v9 = parseInt(uuid.slice(9, 13), 16)) >>> 8, v9 & 255, (v9 = parseInt(uuid.slice(14, 18), 16)) >>> 8, v9 & 255, (v9 = parseInt(uuid.slice(19, 23), 16)) >>> 8, v9 & 255, (v9 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v9 / 4294967296 & 255, v9 >>> 24 & 255, v9 >>> 16 & 255, v9 >>> 8 & 255, v9 & 255);
}
var parse_default = parse3;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i9 = 0; i9 < 256; ++i9) {
  byteToHex.push((i9 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  const words = uint8ToUint32(bytes2);
  const md5Bytes = wordsToMd5(words, bytes2.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes2 = new Uint8Array(input.length * 4);
  for (let i9 = 0; i9 < input.length * 4; i9++) {
    bytes2[i9] = input[i9 >> 2] >>> i9 % 4 * 8 & 255;
  }
  return bytes2;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x7, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x7);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x7 = xpad;
  let a6 = 1732584193;
  let b6 = -271733879;
  let c9 = -1732584194;
  let d7 = 271733878;
  for (let i9 = 0; i9 < x7.length; i9 += 16) {
    const olda = a6;
    const oldb = b6;
    const oldc = c9;
    const oldd = d7;
    a6 = md5ff(a6, b6, c9, d7, x7[i9], 7, -680876936);
    d7 = md5ff(d7, a6, b6, c9, x7[i9 + 1], 12, -389564586);
    c9 = md5ff(c9, d7, a6, b6, x7[i9 + 2], 17, 606105819);
    b6 = md5ff(b6, c9, d7, a6, x7[i9 + 3], 22, -1044525330);
    a6 = md5ff(a6, b6, c9, d7, x7[i9 + 4], 7, -176418897);
    d7 = md5ff(d7, a6, b6, c9, x7[i9 + 5], 12, 1200080426);
    c9 = md5ff(c9, d7, a6, b6, x7[i9 + 6], 17, -1473231341);
    b6 = md5ff(b6, c9, d7, a6, x7[i9 + 7], 22, -45705983);
    a6 = md5ff(a6, b6, c9, d7, x7[i9 + 8], 7, 1770035416);
    d7 = md5ff(d7, a6, b6, c9, x7[i9 + 9], 12, -1958414417);
    c9 = md5ff(c9, d7, a6, b6, x7[i9 + 10], 17, -42063);
    b6 = md5ff(b6, c9, d7, a6, x7[i9 + 11], 22, -1990404162);
    a6 = md5ff(a6, b6, c9, d7, x7[i9 + 12], 7, 1804603682);
    d7 = md5ff(d7, a6, b6, c9, x7[i9 + 13], 12, -40341101);
    c9 = md5ff(c9, d7, a6, b6, x7[i9 + 14], 17, -1502002290);
    b6 = md5ff(b6, c9, d7, a6, x7[i9 + 15], 22, 1236535329);
    a6 = md5gg(a6, b6, c9, d7, x7[i9 + 1], 5, -165796510);
    d7 = md5gg(d7, a6, b6, c9, x7[i9 + 6], 9, -1069501632);
    c9 = md5gg(c9, d7, a6, b6, x7[i9 + 11], 14, 643717713);
    b6 = md5gg(b6, c9, d7, a6, x7[i9], 20, -373897302);
    a6 = md5gg(a6, b6, c9, d7, x7[i9 + 5], 5, -701558691);
    d7 = md5gg(d7, a6, b6, c9, x7[i9 + 10], 9, 38016083);
    c9 = md5gg(c9, d7, a6, b6, x7[i9 + 15], 14, -660478335);
    b6 = md5gg(b6, c9, d7, a6, x7[i9 + 4], 20, -405537848);
    a6 = md5gg(a6, b6, c9, d7, x7[i9 + 9], 5, 568446438);
    d7 = md5gg(d7, a6, b6, c9, x7[i9 + 14], 9, -1019803690);
    c9 = md5gg(c9, d7, a6, b6, x7[i9 + 3], 14, -187363961);
    b6 = md5gg(b6, c9, d7, a6, x7[i9 + 8], 20, 1163531501);
    a6 = md5gg(a6, b6, c9, d7, x7[i9 + 13], 5, -1444681467);
    d7 = md5gg(d7, a6, b6, c9, x7[i9 + 2], 9, -51403784);
    c9 = md5gg(c9, d7, a6, b6, x7[i9 + 7], 14, 1735328473);
    b6 = md5gg(b6, c9, d7, a6, x7[i9 + 12], 20, -1926607734);
    a6 = md5hh(a6, b6, c9, d7, x7[i9 + 5], 4, -378558);
    d7 = md5hh(d7, a6, b6, c9, x7[i9 + 8], 11, -2022574463);
    c9 = md5hh(c9, d7, a6, b6, x7[i9 + 11], 16, 1839030562);
    b6 = md5hh(b6, c9, d7, a6, x7[i9 + 14], 23, -35309556);
    a6 = md5hh(a6, b6, c9, d7, x7[i9 + 1], 4, -1530992060);
    d7 = md5hh(d7, a6, b6, c9, x7[i9 + 4], 11, 1272893353);
    c9 = md5hh(c9, d7, a6, b6, x7[i9 + 7], 16, -155497632);
    b6 = md5hh(b6, c9, d7, a6, x7[i9 + 10], 23, -1094730640);
    a6 = md5hh(a6, b6, c9, d7, x7[i9 + 13], 4, 681279174);
    d7 = md5hh(d7, a6, b6, c9, x7[i9], 11, -358537222);
    c9 = md5hh(c9, d7, a6, b6, x7[i9 + 3], 16, -722521979);
    b6 = md5hh(b6, c9, d7, a6, x7[i9 + 6], 23, 76029189);
    a6 = md5hh(a6, b6, c9, d7, x7[i9 + 9], 4, -640364487);
    d7 = md5hh(d7, a6, b6, c9, x7[i9 + 12], 11, -421815835);
    c9 = md5hh(c9, d7, a6, b6, x7[i9 + 15], 16, 530742520);
    b6 = md5hh(b6, c9, d7, a6, x7[i9 + 2], 23, -995338651);
    a6 = md5ii(a6, b6, c9, d7, x7[i9], 6, -198630844);
    d7 = md5ii(d7, a6, b6, c9, x7[i9 + 7], 10, 1126891415);
    c9 = md5ii(c9, d7, a6, b6, x7[i9 + 14], 15, -1416354905);
    b6 = md5ii(b6, c9, d7, a6, x7[i9 + 5], 21, -57434055);
    a6 = md5ii(a6, b6, c9, d7, x7[i9 + 12], 6, 1700485571);
    d7 = md5ii(d7, a6, b6, c9, x7[i9 + 3], 10, -1894986606);
    c9 = md5ii(c9, d7, a6, b6, x7[i9 + 10], 15, -1051523);
    b6 = md5ii(b6, c9, d7, a6, x7[i9 + 1], 21, -2054922799);
    a6 = md5ii(a6, b6, c9, d7, x7[i9 + 8], 6, 1873313359);
    d7 = md5ii(d7, a6, b6, c9, x7[i9 + 15], 10, -30611744);
    c9 = md5ii(c9, d7, a6, b6, x7[i9 + 6], 15, -1560198380);
    b6 = md5ii(b6, c9, d7, a6, x7[i9 + 13], 21, 1309151649);
    a6 = md5ii(a6, b6, c9, d7, x7[i9 + 4], 6, -145523070);
    d7 = md5ii(d7, a6, b6, c9, x7[i9 + 11], 10, -1120210379);
    c9 = md5ii(c9, d7, a6, b6, x7[i9 + 2], 15, 718787259);
    b6 = md5ii(b6, c9, d7, a6, x7[i9 + 9], 21, -343485551);
    a6 = safeAdd(a6, olda);
    b6 = safeAdd(b6, oldb);
    c9 = safeAdd(c9, oldc);
    d7 = safeAdd(d7, oldd);
  }
  return Uint32Array.of(a6, b6, c9, d7);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output2 = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i9 = 0; i9 < input.length; i9++) {
    output2[i9 >> 2] |= (input[i9] & 255) << i9 % 4 * 8;
  }
  return output2;
}
function safeAdd(x7, y11) {
  const lsw = (x7 & 65535) + (y11 & 65535);
  const msw = (x7 >> 16) + (y11 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num3, cnt) {
  return num3 << cnt | num3 >>> 32 - cnt;
}
function md5cmn(q6, a6, b6, x7, s5, t6) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a6, q6), safeAdd(x7, t6)), s5), b6);
}
function md5ff(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn(b6 & c9 | ~b6 & d7, a6, b6, x7, s5, t6);
}
function md5gg(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn(b6 & d7 | c9 & ~d7, a6, b6, x7, s5, t6);
}
function md5hh(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn(b6 ^ c9 ^ d7, a6, b6, x7, s5, t6);
}
function md5ii(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn(c9 ^ (b6 | ~d7), a6, b6, x7, s5, t6);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes3(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = new Uint8Array(str.length);
  for (let i9 = 0; i9 < str.length; ++i9) {
    bytes2[i9] = str.charCodeAt(i9);
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version11, hash9, value2, namespace, buf, offset) {
  const valueBytes = typeof value2 === "string" ? stringToBytes3(value2) : value2;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes2 = new Uint8Array(16 + valueBytes.length);
  bytes2.set(namespaceBytes);
  bytes2.set(valueBytes, namespaceBytes.length);
  bytes2 = hash9(bytes2);
  bytes2[6] = bytes2[6] & 15 | version11;
  bytes2[8] = bytes2[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i9 = 0; i9 < 16; ++i9) {
      buf[offset + i9] = bytes2[i9];
    }
    return buf;
  }
  return unsafeStringify(bytes2);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v32(value2, namespace, buf, offset) {
  return v35(48, md5_default, value2, namespace, buf, offset);
}
v32.DNS = DNS;
v32.URL = URL2;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v42(options, buf, offset) {
  var _a14;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a14 = options.rng) == null ? void 0 : _a14.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i9 = 0; i9 < 16; ++i9) {
      buf[offset + i9] = rnds[i9];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v42;

// node_modules/uuid/dist/esm-browser/sha1.js
function f11(s5, x7, y11, z9) {
  switch (s5) {
    case 0:
      return x7 & y11 ^ ~x7 & z9;
    case 1:
      return x7 ^ y11 ^ z9;
    case 2:
      return x7 & y11 ^ x7 & z9 ^ y11 & z9;
    case 3:
      return x7 ^ y11 ^ z9;
  }
}
function ROTL(x7, n5) {
  return x7 << n5 | x7 >>> 32 - n5;
}
function sha1(bytes2) {
  const K5 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes2.length + 1);
  newBytes.set(bytes2);
  newBytes[bytes2.length] = 128;
  bytes2 = newBytes;
  const l9 = bytes2.length / 4 + 2;
  const N9 = Math.ceil(l9 / 16);
  const M8 = new Array(N9);
  for (let i9 = 0; i9 < N9; ++i9) {
    const arr = new Uint32Array(16);
    for (let j9 = 0; j9 < 16; ++j9) {
      arr[j9] = bytes2[i9 * 64 + j9 * 4] << 24 | bytes2[i9 * 64 + j9 * 4 + 1] << 16 | bytes2[i9 * 64 + j9 * 4 + 2] << 8 | bytes2[i9 * 64 + j9 * 4 + 3];
    }
    M8[i9] = arr;
  }
  M8[N9 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M8[N9 - 1][14] = Math.floor(M8[N9 - 1][14]);
  M8[N9 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i9 = 0; i9 < N9; ++i9) {
    const W6 = new Uint32Array(80);
    for (let t6 = 0; t6 < 16; ++t6) {
      W6[t6] = M8[i9][t6];
    }
    for (let t6 = 16; t6 < 80; ++t6) {
      W6[t6] = ROTL(W6[t6 - 3] ^ W6[t6 - 8] ^ W6[t6 - 14] ^ W6[t6 - 16], 1);
    }
    let a6 = H4[0];
    let b6 = H4[1];
    let c9 = H4[2];
    let d7 = H4[3];
    let e11 = H4[4];
    for (let t6 = 0; t6 < 80; ++t6) {
      const s5 = Math.floor(t6 / 20);
      const T8 = ROTL(a6, 5) + f11(s5, b6, c9, d7) + e11 + K5[s5] + W6[t6] >>> 0;
      e11 = d7;
      d7 = c9;
      c9 = ROTL(b6, 30) >>> 0;
      b6 = a6;
      a6 = T8;
    }
    H4[0] = H4[0] + a6 >>> 0;
    H4[1] = H4[1] + b6 >>> 0;
    H4[2] = H4[2] + c9 >>> 0;
    H4[3] = H4[3] + d7 >>> 0;
    H4[4] = H4[4] + e11 >>> 0;
  }
  return Uint8Array.of(H4[0] >> 24, H4[0] >> 16, H4[0] >> 8, H4[0], H4[1] >> 24, H4[1] >> 16, H4[1] >> 8, H4[1], H4[2] >> 24, H4[2] >> 16, H4[2] >> 8, H4[2], H4[3] >> 24, H4[3] >> 16, H4[3] >> 8, H4[3], H4[4] >> 24, H4[4] >> 16, H4[4] >> 8, H4[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v52(value2, namespace, buf, offset) {
  return v35(80, sha1_default, value2, namespace, buf, offset);
}
v52.DNS = DNS;
v52.URL = URL2;

// node_modules/axios/lib/helpers/bind.js
function bind(fn4, thisArg) {
  return function wrap() {
    return fn4.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString8 } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString8.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type7) => {
  type7 = type7.toLowerCase();
  return (thing) => kindOf(thing) === type7;
};
var typeOfTest = (type7) => (thing) => typeof thing === type7;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype5 = getPrototypeOf(val);
  return (prototype5 === null || prototype5 === Object.prototype || Object.getPrototypeOf(prototype5) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e11) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim5 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn4, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i9;
  let l9;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i9 = 0, l9 = obj.length; i9 < l9; i9++) {
      fn4.call(null, obj[i9], i9, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys5 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys5.length;
    let key;
    for (i9 = 0; i9 < len; i9++) {
      key = keys5[i9];
      fn4.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys5 = Object.keys(obj);
  let i9 = keys5.length;
  let _key;
  while (i9-- > 0) {
    _key = keys5[i9];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i9 = 0, l9 = arguments.length; i9 < l9; i9++) {
    arguments[i9] && forEach(arguments[i9], assignValue);
  }
  return result;
}
var extend = (a6, b6, thisArg, { allOwnKeys } = {}) => {
  forEach(b6, (val, key) => {
    if (thisArg && isFunction(val)) {
      a6[key] = bind(val, thisArg);
    } else {
      a6[key] = val;
    }
  }, { allOwnKeys });
  return a6;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors3) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors3);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter10, propFilter) => {
  let props;
  let i9;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i9 = props.length;
    while (i9-- > 0) {
      prop = props[i9];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter10 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter10 || filter10(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i9 = thing.length;
  if (!isNumber(i9)) return null;
  const arr = new Array(i9);
  while (i9-- > 0) {
    arr[i9] = thing[i9];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn4) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn4.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m6, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty7 }) => (obj, prop) => hasOwnProperty7.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors3 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors3, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value2 = obj[name];
    if (!isFunction(value2)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value2, defaultValue) => {
  return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i9) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i9] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value2, key) => {
          const reducedValue = visit(value2, i9 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i9] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim: trim5,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter10(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError.call(axiosError, msg, errCode, config2, request2, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i9) {
    token = removeBrackets(token);
    return !dots && i9 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue3(value2) {
    if (value2 === null) return "";
    if (utils_default.isDate(value2)) {
      return value2.toISOString();
    }
    if (utils_default.isBoolean(value2)) {
      return value2.toString();
    }
    if (!useBlob && utils_default.isBlob(value2)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value2) || utils_default.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path2) {
    let arr = value2;
    if (value2 && !path2 && typeof value2 === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils_default.isArray(value2) && isFlatArray(value2) || (utils_default.isFileList(value2) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value2))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index2) {
          !(utils_default.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue3(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue3(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue: convertValue3,
    isVisitable
  });
  function build(value2, path2) {
    if (utils_default.isUndefined(value2)) return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value2);
    utils_default.forEach(value2, function each(el2, key) {
      const result = !(utils_default.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode15(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match14) {
    return charMap[match14];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value2) {
  this._pairs.push([name, value2]);
};
prototype2.toString = function toString9(encoder5) {
  const _encode = encoder5 ? function(value2) {
    return encoder5.call(this, value2, encode15);
  } : encode15;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode16(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode16;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn4) {
    utils_default.forEach(this.handlers, function forEachHandler(h9) {
      if (h9 !== null) {
        fn4(h9);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports3,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
    visitor: function(value2, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match14) => {
    return match14[0] === "[]" ? "" : match14[1] || match14[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys5 = Object.keys(arr);
  let i9;
  const len = keys5.length;
  let key;
  for (i9 = 0; i9 < len; i9++) {
    key = keys5[i9];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value2, target, index2) {
    let name = path2[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value2];
      } else {
        target[name] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value2, target[name], index2);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value2) => {
      buildPath(parsePropPath(name), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder5) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e11) {
      if (e11.name !== "SyntaxError") {
        throw e11;
      }
    }
  }
  return (encoder5 || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData3 = utils_default.isFormData(data);
    if (isFormData3) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList3;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList3 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList3 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional3 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e11) {
        if (strictJSONParsing) {
          if (e11.name === "SyntaxError") {
            throw AxiosError_default.from(e11, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e11;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i9;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i9 = line.indexOf(":");
    key = line.substring(0, i9).trim().toLowerCase();
    val = line.substring(i9 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils_default.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match14;
  while (match14 = tokensRE.exec(str)) {
    tokens[match14[1]] = match14[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value2, header, filter10, isHeaderNameFilter) {
  if (utils_default.isFunction(filter10)) {
    return filter10.call(this, value2, header);
  }
  if (isHeaderNameFilter) {
    value2 = header;
  }
  if (!utils_default.isString(value2)) return;
  if (utils_default.isString(filter10)) {
    return value2.indexOf(filter10) !== -1;
  }
  if (utils_default.isRegExp(filter10)) {
    return filter10.test(value2);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w8, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value2 = this[key];
        if (!parser) {
          return value2;
        }
        if (parser === true) {
          return parseTokens(value2);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value2, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys5 = Object.keys(this);
    let i9 = keys5.length;
    let deleted = false;
    while (i9--) {
      const key = keys5[i9];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format9) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value2, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value2);
        delete self2[header];
        return;
      }
      const normalized = format9 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils_default.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype5 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype5, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value: value2 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value2,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config2 = this || defaults_default;
  const context = response || config2;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn4) {
    data = fn4.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config2, request2) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus3 = response.config.validateStatus;
  if (!response.status || !validateStatus3 || validateStatus3(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
  const match14 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match14 && match14[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min4) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head5 = 0;
  let tail4 = 0;
  let firstSampleTS;
  min4 = min4 !== void 0 ? min4 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail4];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head5] = chunkLength;
    timestamps[head5] = now;
    let i9 = tail4;
    let bytesCount = 0;
    while (i9 !== head5) {
      bytesCount += bytes2[i9++];
      i9 = i9 % samplesCount;
    }
    head5 = (head5 + 1) % samplesCount;
    if (head5 === tail4) {
      tail4 = (tail4 + 1) % samplesCount;
    }
    if (now - firstSampleTS < min4) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn4, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn4(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e11) => {
    const loaded = e11.loaded;
    const total = e11.lengthComputable ? e11.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange3 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange3 ? (total - loaded) / rate : void 0,
      event: e11,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn4) => (...args) => utils_default.asap(() => fn4(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin3, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default.origin);
  return origin3.protocol === url2.protocol && origin3.host === url2.host && (isMSIE || origin3.port === url2.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value2, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value2)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path2) && cookie.push("path=" + path2);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match14 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match14 ? decodeURIComponent(match14[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a6, b6, prop, caseless) {
    if (!utils_default.isUndefined(b6)) {
      return getMergedValue(a6, b6, prop, caseless);
    } else if (!utils_default.isUndefined(a6)) {
      return getMergedValue(void 0, a6, prop, caseless);
    }
  }
  function valueFromConfig2(a6, b6) {
    if (!utils_default.isUndefined(b6)) {
      return getMergedValue(void 0, b6);
    }
  }
  function defaultToConfig2(a6, b6) {
    if (!utils_default.isUndefined(b6)) {
      return getMergedValue(void 0, b6);
    } else if (!utils_default.isUndefined(a6)) {
      return getMergedValue(void 0, a6);
    }
  }
  function mergeDirectKeys(a6, b6, prop) {
    if (prop in config2) {
      return getMergedValue(a6, b6);
    } else if (prop in config1) {
      return getMergedValue(void 0, a6);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a6, b6, prop) => mergeDeepProperties(headersToObject(a6), headersToObject(b6), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value2) {
        resolve(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config2, request2);
      err.event = event || null;
      reject(err);
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional3 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional3.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol4 = parseProtocol(_config.url);
    if (protocol4 && platform_default.protocols.indexOf(protocol4) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol4 + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value: value2 } = await reader.read();
      if (done) {
        break;
      }
      yield value2;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator4 = readBytes(stream, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e11) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e11);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value: value2 } = await iterator4.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value2.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value2));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator4.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request: Request3, Response: Response2 }) => ({
  Request: Request3,
  Response: Response2
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn4, ...args) => {
  try {
    return !!fn4(...args);
  } catch (e11) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request: Request3, Response: Response2 } = env;
  const isFetchSupported2 = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request3);
  const isResponseSupported = isFunction2(Response2);
  if (!isFetchSupported2) {
    return false;
  }
  const isReadableStreamSupported2 = isFetchSupported2 && isFunction2(ReadableStream2);
  const encodeText2 = isFetchSupported2 && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder5) => (str) => encoder5.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request3(str).arrayBuffer()));
  const supportsRequestStream2 = isRequestSupported && isReadableStreamSupported2 && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request3(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream2 = isResponseSupported && isReadableStreamSupported2 && test(() => utils_default.isReadableStream(new Response2("").body));
  const resolvers2 = {
    stream: supportsResponseStream2 && ((res) => res.body)
  };
  isFetchSupported2 && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type7) => {
      !resolvers2[type7] && (resolvers2[type7] = (res, config2) => {
        let method = res && res[type7];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type7}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config2);
      });
    });
  })();
  const getBodyLength2 = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request3(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText2(body)).byteLength;
    }
  };
  const resolveBodyLength2 = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength2(body) : length;
  };
  return async (config2) => {
    let {
      url: url2,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config2);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request2 = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream2 && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength2(headers, data)) !== 0) {
        let _request = new Request3(url2, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request3.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request2 = isRequestSupported && new Request3(url2, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request2, fetchOptions) : _fetch(url2, resolvedOptions));
      const isStreamResponse = supportsResponseStream2 && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream2 && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response2(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers2[utils_default.findKey(resolvers2, responseType) || "text"](response, config2);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config: config2,
          request: request2
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request2),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config2, request2);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config2) => {
  let env = config2 ? config2.env : {};
  const { fetch: fetch3, Request: Request3, Response: Response2 } = env;
  const seeds = [
    Request3,
    Response2,
    fetch3
  ];
  let len = seeds.length, i9 = len, seed, target, map36 = seedCache;
  while (i9--) {
    seed = seeds[i9];
    target = map36.get(seed);
    target === void 0 && map36.set(seed, target = i9 ? /* @__PURE__ */ new Map() : factory(env));
    map36 = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn4, value2) => {
  if (fn4) {
    try {
      Object.defineProperty(fn4, "name", { value: value2 });
    } catch (e11) {
    }
    Object.defineProperty(fn4, "adapterName", { value: value2 });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
var adapters_default = {
  getAdapter: (adapters, config2) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i9 = 0; i9 < length; i9++) {
      nameOrAdapter = adapters[i9];
      let id2;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter2 = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config2)))) {
        break;
      }
      rejectedReasons[id2 || "#" + i9] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s5 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s5,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders_default.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config2.adapter || defaults_default.adapter, config2);
  return adapter2(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION2 = "1.12.2";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type7, i9) => {
  validators[type7] = function validator(thing) {
    return typeof thing === type7 || "a" + (i9 < 1 ? "n " : " ") + type7;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version11, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value2, opt, opts2) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version11 ? " in " + version11 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version11 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version11 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value2, opt, opts2) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value2, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys5 = Object.keys(options);
  let i9 = keys5.length;
  while (i9-- > 0) {
    const opt = keys5[i9];
    const validator = schema[opt];
    if (validator) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator(value2, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e11) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional3, paramsSerializer, headers } = config2;
    if (transitional3 !== void 0) {
      validator_default.assertOptions(transitional3, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config2, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i9 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain6 = [dispatchRequest.bind(this), void 0];
      chain6.unshift(...requestInterceptorChain);
      chain6.push(...responseInterceptorChain);
      len = chain6.length;
      promise = Promise.resolve(config2);
      while (i9 < len) {
        promise = promise.then(chain6[i9++], chain6[i9++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    while (i9 < len) {
      const onFulfilled = requestInterceptorChain[i9++];
      const onRejected = requestInterceptorChain[i9++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i9 = 0;
    len = responseInterceptorChain.length;
    while (i9 < len) {
      promise = promise.then(responseInterceptorChain[i9++], responseInterceptorChain[i9++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i9 = token._listeners.length;
      while (i9-- > 0) {
        token._listeners[i9](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c9) {
      cancel = c9;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value2]) => {
  HttpStatusCode[value2] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create6(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION2;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION3,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-client/dist/index.js
var ws3 = __toESM(require_browser());

// node_modules/fp-ts/es6/function.js
var __spreadArray = function(to6, from40, pack) {
  if (pack || arguments.length === 2) for (var i9 = 0, l9 = from40.length, ar3; i9 < l9; i9++) {
    if (ar3 || !(i9 in from40)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from40, 0, i9);
      ar3[i9] = from40[i9];
    }
  }
  return to6.concat(ar3 || Array.prototype.slice.call(from40));
};
function identity(a6) {
  return a6;
}
var unsafeCoerce = identity;
function constant(a6) {
  return function() {
    return a6;
  };
}
var constTrue = constant(true);
var constFalse = constant(false);
var constNull = constant(null);
var constUndefined = constant(void 0);
function flow(ab, bc3, cd2, de5, ef3, fg2, gh2, hi5, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc3(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd2(bc3(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de5(cd2(bc3(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef3(de5(cd2(bc3(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg2(ef3(de5(cd2(bc3(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh2(fg2(ef3(de5(cd2(bc3(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi5(gh2(fg2(ef3(de5(cd2(bc3(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi5(gh2(fg2(ef3(de5(cd2(bc3(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a6, ab, bc3, cd2, de5, ef3, fg2, gh2, hi5) {
  switch (arguments.length) {
    case 1:
      return a6;
    case 2:
      return ab(a6);
    case 3:
      return bc3(ab(a6));
    case 4:
      return cd2(bc3(ab(a6)));
    case 5:
      return de5(cd2(bc3(ab(a6))));
    case 6:
      return ef3(de5(cd2(bc3(ab(a6)))));
    case 7:
      return fg2(ef3(de5(cd2(bc3(ab(a6))))));
    case 8:
      return gh2(fg2(ef3(de5(cd2(bc3(ab(a6)))))));
    case 9:
      return hi5(gh2(fg2(ef3(de5(cd2(bc3(ab(a6))))))));
    default: {
      var ret = arguments[0];
      for (var i9 = 1; i9 < arguments.length; i9++) {
        ret = arguments[i9](ret);
      }
      return ret;
    }
  }
}
var SK = function(_6, b6) {
  return b6;
};
var dual = function(arity, body) {
  var isDataFirst = typeof arity === "number" ? function(args) {
    return args.length >= arity;
  } : arity;
  return function() {
    var args = Array.from(arguments);
    if (isDataFirst(arguments)) {
      return body.apply(this, args);
    }
    return function(self2) {
      return body.apply(void 0, __spreadArray([self2], args, false));
    };
  };
};

// node_modules/fp-ts/es6/internal.js
var __spreadArray2 = function(to6, from40, pack) {
  if (pack || arguments.length === 2) for (var i9 = 0, l9 = from40.length, ar3; i9 < l9; i9++) {
    if (ar3 || !(i9 in from40)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from40, 0, i9);
      ar3[i9] = from40[i9];
    }
  }
  return to6.concat(ar3 || Array.prototype.slice.call(from40));
};
var isNone = function(fa3) {
  return fa3._tag === "None";
};
var isSome = function(fa3) {
  return fa3._tag === "Some";
};
var none = { _tag: "None" };
var some = function(a6) {
  return { _tag: "Some", value: a6 };
};
var isLeft = function(ma3) {
  return ma3._tag === "Left";
};
var isRight = function(ma3) {
  return ma3._tag === "Right";
};
var left = function(e11) {
  return { _tag: "Left", left: e11 };
};
var right = function(a6) {
  return { _tag: "Right", right: a6 };
};
var singleton = function(a6) {
  return [a6];
};
var isNonEmpty = function(as17) {
  return as17.length > 0;
};
var head = function(as17) {
  return as17[0];
};
var tail = function(as17) {
  return as17.slice(1);
};
var emptyReadonlyArray = [];
var emptyRecord = {};
var has = Object.prototype.hasOwnProperty;
var fromReadonlyNonEmptyArray = function(as17) {
  return __spreadArray2([as17[0]], as17.slice(1), true);
};
var liftNullable = function(F8) {
  return function(f16, onNullable) {
    return function() {
      var a6 = [];
      for (var _i4 = 0; _i4 < arguments.length; _i4++) {
        a6[_i4] = arguments[_i4];
      }
      var o6 = f16.apply(void 0, a6);
      return F8.fromEither(o6 == null ? left(onNullable.apply(void 0, a6)) : right(o6));
    };
  };
};
var liftOption = function(F8) {
  return function(f16, onNone) {
    return function() {
      var a6 = [];
      for (var _i4 = 0; _i4 < arguments.length; _i4++) {
        a6[_i4] = arguments[_i4];
      }
      var o6 = f16.apply(void 0, a6);
      return F8.fromEither(isNone(o6) ? left(onNone.apply(void 0, a6)) : right(o6.value));
    };
  };
};
var flatMapNullable = function(F8, M8) {
  return dual(3, function(self2, f16, onNullable) {
    return M8.flatMap(self2, liftNullable(F8)(f16, onNullable));
  });
};
var flatMapOption = function(F8, M8) {
  return dual(3, function(self2, f16, onNone) {
    return M8.flatMap(self2, liftOption(F8)(f16, onNone));
  });
};
var flatMapEither = function(F8, M8) {
  return dual(2, function(self2, f16) {
    return M8.flatMap(self2, function(a6) {
      return F8.fromEither(f16(a6));
    });
  });
};
var flatMapIO = function(F8, M8) {
  return dual(2, function(self2, f16) {
    return M8.flatMap(self2, function(a6) {
      return F8.fromIO(f16(a6));
    });
  });
};
var flatMapTask = function(F8, M8) {
  return dual(2, function(self2, f16) {
    return M8.flatMap(self2, function(a6) {
      return F8.fromTask(f16(a6));
    });
  });
};
var flatMapReader = function(F8, M8) {
  return dual(2, function(self2, f16) {
    return M8.flatMap(self2, function(a6) {
      return F8.fromReader(f16(a6));
    });
  });
};

// node_modules/fp-ts/es6/Apply.js
function ap(F8, G7) {
  return function(fa3) {
    return function(fab) {
      return F8.ap(F8.map(fab, function(gab) {
        return function(ga3) {
          return G7.ap(gab, ga3);
        };
      }), fa3);
    };
  };
}
function apFirst(A9) {
  return function(second) {
    return function(first2) {
      return A9.ap(A9.map(first2, function(a6) {
        return function() {
          return a6;
        };
      }), second);
    };
  };
}
function apSecond(A9) {
  return function(second) {
    return function(first2) {
      return A9.ap(A9.map(first2, function() {
        return function(b6) {
          return b6;
        };
      }), second);
    };
  };
}
function apS(F8) {
  return function(name, fb) {
    return function(fa3) {
      return F8.ap(F8.map(fa3, function(a6) {
        return function(b6) {
          var _a14;
          return Object.assign({}, a6, (_a14 = {}, _a14[name] = b6, _a14));
        };
      }), fb);
    };
  };
}
function getApplySemigroup(F8) {
  return function(S8) {
    return {
      concat: function(first2, second) {
        return F8.ap(F8.map(first2, function(x7) {
          return function(y11) {
            return S8.concat(x7, y11);
          };
        }), second);
      }
    };
  };
}

// node_modules/fp-ts/es6/Functor.js
function map(F8, G7) {
  return function(f16) {
    return function(fa3) {
      return F8.map(fa3, function(ga3) {
        return G7.map(ga3, f16);
      });
    };
  };
}
function flap(F8) {
  return function(a6) {
    return function(fab) {
      return F8.map(fab, function(f16) {
        return f16(a6);
      });
    };
  };
}
function bindTo(F8) {
  return function(name) {
    return function(fa3) {
      return F8.map(fa3, function(a6) {
        var _a14;
        return _a14 = {}, _a14[name] = a6, _a14;
      });
    };
  };
}
function let_(F8) {
  return function(name, f16) {
    return function(fa3) {
      return F8.map(fa3, function(a6) {
        var _a14;
        return Object.assign({}, a6, (_a14 = {}, _a14[name] = f16(a6), _a14));
      });
    };
  };
}
function as2(F8) {
  return function(self2, b6) {
    return F8.map(self2, function() {
      return b6;
    });
  };
}
function asUnit(F8) {
  var asM = as2(F8);
  return function(self2) {
    return asM(self2, void 0);
  };
}

// node_modules/fp-ts/es6/Applicative.js
function getApplicativeMonoid(F8) {
  var f16 = getApplySemigroup(F8);
  return function(M8) {
    return {
      concat: f16(M8).concat,
      empty: F8.of(M8.empty)
    };
  };
}

// node_modules/fp-ts/es6/Chain.js
function chainFirst(M8) {
  var tapM = tap(M8);
  return function(f16) {
    return function(first2) {
      return tapM(first2, f16);
    };
  };
}
function tap(M8) {
  return function(first2, f16) {
    return M8.chain(first2, function(a6) {
      return M8.map(f16(a6), function() {
        return a6;
      });
    });
  };
}
function bind2(M8) {
  return function(name, f16) {
    return function(ma3) {
      return M8.chain(ma3, function(a6) {
        return M8.map(f16(a6), function(b6) {
          var _a14;
          return Object.assign({}, a6, (_a14 = {}, _a14[name] = b6, _a14));
        });
      });
    };
  };
}

// node_modules/fp-ts/es6/FromEither.js
function fromOption(F8) {
  return function(onNone) {
    return function(ma3) {
      return F8.fromEither(isNone(ma3) ? left(onNone()) : right(ma3.value));
    };
  };
}
function fromPredicate(F8) {
  return function(predicate, onFalse) {
    return function(a6) {
      return F8.fromEither(predicate(a6) ? right(a6) : left(onFalse(a6)));
    };
  };
}
function fromOptionK(F8) {
  var fromOptionF = fromOption(F8);
  return function(onNone) {
    var from40 = fromOptionF(onNone);
    return function(f16) {
      return flow(f16, from40);
    };
  };
}
function chainOptionK(F8, M8) {
  var fromOptionKF = fromOptionK(F8);
  return function(onNone) {
    var from40 = fromOptionKF(onNone);
    return function(f16) {
      return function(ma3) {
        return M8.chain(ma3, from40(f16));
      };
    };
  };
}
function fromEitherK(F8) {
  return function(f16) {
    return flow(f16, F8.fromEither);
  };
}
function chainEitherK(F8, M8) {
  var fromEitherKF = fromEitherK(F8);
  return function(f16) {
    return function(ma3) {
      return M8.chain(ma3, fromEitherKF(f16));
    };
  };
}
function filterOrElse(F8, M8) {
  return function(predicate, onFalse) {
    return function(ma3) {
      return M8.chain(ma3, function(a6) {
        return F8.fromEither(predicate(a6) ? right(a6) : left(onFalse(a6)));
      });
    };
  };
}
function tapEither(F8, M8) {
  var fromEither13 = fromEitherK(F8);
  var tapM = tap(M8);
  return function(self2, f16) {
    return tapM(self2, fromEither13(f16));
  };
}

// node_modules/fp-ts/es6/Eq.js
var eqStrict = {
  equals: function(a6, b6) {
    return a6 === b6;
  }
};
var strictEqual = eqStrict.equals;

// node_modules/fp-ts/es6/Ord.js
var equalsDefault = function(compare3) {
  return function(first2, second) {
    return first2 === second || compare3(first2, second) === 0;
  };
};
var fromCompare = function(compare3) {
  return {
    equals: equalsDefault(compare3),
    compare: function(first2, second) {
      return first2 === second ? 0 : compare3(first2, second);
    }
  };
};
var contramap = function(f16) {
  return function(fa3) {
    return fromCompare(function(first2, second) {
      return fa3.compare(f16(first2), f16(second));
    });
  };
};
var trivial = {
  equals: constTrue,
  compare: constant(0)
};
function compare2(first2, second) {
  return first2 < second ? -1 : first2 > second ? 1 : 0;
}
var strictOrd = {
  equals: eqStrict.equals,
  compare: compare2
};
var ordNumber = strictOrd;
var ordDate = pipe(
  ordNumber,
  contramap(function(date) {
    return date.valueOf();
  })
);

// node_modules/fp-ts/es6/Semigroup.js
var constant2 = function(a6) {
  return {
    concat: function() {
      return a6;
    }
  };
};
var semigroupVoid = constant2(void 0);
var semigroupAll = {
  concat: function(x7, y11) {
    return x7 && y11;
  }
};
var semigroupAny = {
  concat: function(x7, y11) {
    return x7 || y11;
  }
};
var semigroupString = {
  concat: function(x7, y11) {
    return x7 + y11;
  }
};
var semigroupSum = {
  concat: function(x7, y11) {
    return x7 + y11;
  }
};
var semigroupProduct = {
  concat: function(x7, y11) {
    return x7 * y11;
  }
};

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray3 = function(to6, from40, pack) {
  if (pack || arguments.length === 2) for (var i9 = 0, l9 = from40.length, ar3; i9 < l9; i9++) {
    if (ar3 || !(i9 in from40)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from40, 0, i9);
      ar3[i9] = from40[i9];
    }
  }
  return to6.concat(ar3 || Array.prototype.slice.call(from40));
};
var empty = emptyReadonlyArray;
var isNonEmpty2 = isNonEmpty;
var appendW = function(end) {
  return function(init4) {
    return __spreadArray3(__spreadArray3([], init4, true), [end], false);
  };
};
var append2 = appendW;
var chainWithIndex = function(f16) {
  return function(as17) {
    var out = fromReadonlyNonEmptyArray(f16(0, head2(as17)));
    for (var i9 = 1; i9 < as17.length; i9++) {
      var bs4 = f16(i9, as17[i9]);
      for (var j9 = 0; j9 < bs4.length; j9++) {
        out.push(bs4[j9]);
      }
    }
    return out;
  };
};
var _map = function(fa3, f16) {
  return pipe(fa3, map2(f16));
};
var _ap = function(fab, fa3) {
  return pipe(fab, ap2(fa3));
};
var of2 = singleton;
var ap2 = function(as17) {
  return flatMap(function(f16) {
    return pipe(as17, map2(f16));
  });
};
var flatMap = dual(2, function(ma3, f16) {
  return pipe(ma3, chainWithIndex(function(i9, a6) {
    return f16(a6, i9);
  }));
});
var extend2 = function(f16) {
  return function(as17) {
    var next = tail2(as17);
    var out = [f16(as17)];
    while (isNonEmpty2(next)) {
      out.push(f16(next));
      next = tail2(next);
    }
    return out;
  };
};
var duplicate = extend2(identity);
var flatten = flatMap(identity);
var map2 = function(f16) {
  return mapWithIndex(function(_6, a6) {
    return f16(a6);
  });
};
var mapWithIndex = function(f16) {
  return function(as17) {
    var out = [f16(0, head2(as17))];
    for (var i9 = 1; i9 < as17.length; i9++) {
      out.push(f16(i9, as17[i9]));
    }
    return out;
  };
};
var extract3 = head;
var URI = "ReadonlyNonEmptyArray";
var Functor = {
  URI,
  map: _map
};
var flap2 = flap(Functor);
var Apply = {
  URI,
  map: _map,
  ap: _ap
};
var apFirst2 = apFirst(Apply);
var apSecond2 = apSecond(Apply);
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var chainFirst2 = chainFirst(Chain);
var Do3 = of2(emptyRecord);
var bindTo2 = bindTo(Functor);
var let_2 = let_(Functor);
var bind3 = bind2(Chain);
var apS2 = apS(Apply);
var head2 = extract3;
var tail2 = tail;

// node_modules/fp-ts/es6/NonEmptyArray.js
var __spreadArray4 = function(to6, from40, pack) {
  if (pack || arguments.length === 2) for (var i9 = 0, l9 = from40.length, ar3; i9 < l9; i9++) {
    if (ar3 || !(i9 in from40)) {
      if (!ar3) ar3 = Array.prototype.slice.call(from40, 0, i9);
      ar3[i9] = from40[i9];
    }
  }
  return to6.concat(ar3 || Array.prototype.slice.call(from40));
};
var isNonEmpty3 = function(as17) {
  return as17.length > 0;
};
var appendW2 = function(end) {
  return function(init4) {
    return __spreadArray4(__spreadArray4([], init4, true), [end], false);
  };
};
var append3 = appendW2;
var fromReadonlyNonEmptyArray2 = fromReadonlyNonEmptyArray;
var of3 = function(a6) {
  return [a6];
};
var chainWithIndex2 = function(f16) {
  return function(as17) {
    var out = fromReadonlyNonEmptyArray2(f16(0, head3(as17)));
    for (var i9 = 1; i9 < as17.length; i9++) {
      var bs4 = f16(i9, as17[i9]);
      for (var j9 = 0; j9 < bs4.length; j9++) {
        out.push(bs4[j9]);
      }
    }
    return out;
  };
};
var _map2 = function(fa3, f16) {
  return pipe(fa3, map3(f16));
};
var _ap2 = function(fab, fa3) {
  return pipe(fab, ap3(fa3));
};
var ap3 = function(as17) {
  return flatMap2(function(f16) {
    return pipe(as17, map3(f16));
  });
};
var flatMap2 = dual(2, function(ma3, f16) {
  return pipe(ma3, chainWithIndex2(function(i9, a6) {
    return f16(a6, i9);
  }));
});
var extend3 = function(f16) {
  return function(as17) {
    var next = tail3(as17);
    var out = [f16(as17)];
    while (isNonEmpty3(next)) {
      out.push(f16(next));
      next = tail3(next);
    }
    return out;
  };
};
var duplicate2 = extend3(identity);
var flatten2 = flatMap2(identity);
var map3 = function(f16) {
  return mapWithIndex2(function(_6, a6) {
    return f16(a6);
  });
};
var mapWithIndex2 = function(f16) {
  return function(as17) {
    var out = [f16(0, head3(as17))];
    for (var i9 = 1; i9 < as17.length; i9++) {
      out.push(f16(i9, as17[i9]));
    }
    return out;
  };
};
var URI2 = "NonEmptyArray";
var Functor2 = {
  URI: URI2,
  map: _map2
};
var flap3 = flap(Functor2);
var Apply2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2
};
var apFirst3 = apFirst(Apply2);
var apSecond3 = apSecond(Apply2);
var Chain2 = {
  URI: URI2,
  map: _map2,
  ap: _ap2,
  chain: flatMap2
};
var chainFirst3 = chainFirst(Chain2);
var Do4 = of3(emptyRecord);
var bindTo3 = bindTo(Functor2);
var let_3 = let_(Functor2);
var bind4 = bind2(Chain2);
var apS3 = apS(Apply2);
var head3 = head2;
var tail3 = function(as17) {
  return as17.slice(1);
};

// node_modules/fp-ts/es6/number.js
var Eq = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var Ord = {
  equals: Eq.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};
var Bounded = {
  equals: Eq.equals,
  compare: Ord.compare,
  top: Infinity,
  bottom: -Infinity
};
var MagmaSub = {
  concat: function(first2, second) {
    return first2 - second;
  }
};
var SemigroupSum = {
  concat: function(first2, second) {
    return first2 + second;
  }
};
var SemigroupProduct = {
  concat: function(first2, second) {
    return first2 * second;
  }
};
var MonoidSum = {
  concat: SemigroupSum.concat,
  empty: 0
};
var MonoidProduct = {
  concat: SemigroupProduct.concat,
  empty: 1
};
var Field4 = {
  add: SemigroupSum.concat,
  zero: 0,
  mul: SemigroupProduct.concat,
  one: 1,
  sub: MagmaSub.concat,
  degree: function(_6) {
    return 1;
  },
  div: function(first2, second) {
    return first2 / second;
  },
  mod: function(first2, second) {
    return first2 % second;
  }
};

// node_modules/fp-ts/es6/Separated.js
var separated = function(left13, right13) {
  return { left: left13, right: right13 };
};
var _map3 = function(fa3, f16) {
  return pipe(fa3, map4(f16));
};
var map4 = function(f16) {
  return function(fa3) {
    return separated(left2(fa3), f16(right2(fa3)));
  };
};
var URI3 = "Separated";
var Functor3 = {
  URI: URI3,
  map: _map3
};
var flap4 = flap(Functor3);
var left2 = function(s5) {
  return s5.left;
};
var right2 = function(s5) {
  return s5.right;
};

// node_modules/fp-ts/es6/Witherable.js
function wiltDefault(T8, C10) {
  return function(F8) {
    var traverseF = T8.traverse(F8);
    return function(wa3, f16) {
      return F8.map(traverseF(wa3, f16), C10.separate);
    };
  };
}
function witherDefault(T8, C10) {
  return function(F8) {
    var traverseF = T8.traverse(F8);
    return function(wa3, f16) {
      return F8.map(traverseF(wa3, f16), C10.compact);
    };
  };
}
function filterE(W6) {
  return function(F8) {
    var witherF = W6.wither(F8);
    return function(predicate) {
      return function(ga3) {
        return witherF(ga3, function(a6) {
          return F8.map(predicate(a6), function(b6) {
            return b6 ? some(a6) : none;
          });
        });
      };
    };
  };
}

// node_modules/fp-ts/es6/Zero.js
function guard(F8, P7) {
  return function(b6) {
    return b6 ? P7.of(void 0) : F8.zero();
  };
}

// node_modules/fp-ts/es6/ReadonlyArray.js
var isEmpty = function(as17) {
  return as17.length === 0;
};
var append4 = append2;
var fromEither = function(e11) {
  return isLeft(e11) ? empty2 : [e11.right];
};
var chainWithIndex3 = function(f16) {
  return function(as17) {
    if (isEmpty(as17)) {
      return empty2;
    }
    var out = [];
    for (var i9 = 0; i9 < as17.length; i9++) {
      var bs4 = f16(i9, as17[i9]);
      for (var j9 = 0; j9 < bs4.length; j9++) {
        out.push(bs4[j9]);
      }
    }
    return out;
  };
};
var _map4 = function(fa3, f16) {
  return pipe(fa3, map5(f16));
};
var _ap3 = function(fab, fa3) {
  return pipe(fab, ap4(fa3));
};
var _filter = function(fa3, predicate) {
  return pipe(fa3, filter2(predicate));
};
var _filterMap = function(fa3, f16) {
  return pipe(fa3, filterMap(f16));
};
var _partition = function(fa3, predicate) {
  return pipe(fa3, partition(predicate));
};
var _partitionMap = function(fa3, f16) {
  return pipe(fa3, partitionMap(f16));
};
var _reduce = function(fa3, b6, f16) {
  return pipe(fa3, reduce2(b6, f16));
};
var _foldMap = function(M8) {
  var foldMapM = foldMap2(M8);
  return function(fa3, f16) {
    return pipe(fa3, foldMapM(f16));
  };
};
var _reduceRight = function(fa3, b6, f16) {
  return pipe(fa3, reduceRight2(b6, f16));
};
var _traverse = function(F8) {
  var traverseF = traverse(F8);
  return function(ta3, f16) {
    return pipe(ta3, traverseF(f16));
  };
};
var of4 = of2;
var zero = function() {
  return empty2;
};
var ap4 = function(fa3) {
  return flatMap3(function(f16) {
    return pipe(fa3, map5(f16));
  });
};
var flatMap3 = dual(2, function(ma3, f16) {
  return pipe(ma3, chainWithIndex3(function(i9, a6) {
    return f16(a6, i9);
  }));
});
var flatten3 = flatMap3(identity);
var map5 = function(f16) {
  return function(fa3) {
    return fa3.map(function(a6) {
      return f16(a6);
    });
  };
};
var separate = function(fa3) {
  var left13 = [];
  var right13 = [];
  for (var _i4 = 0, fa_1 = fa3; _i4 < fa_1.length; _i4++) {
    var e11 = fa_1[_i4];
    if (e11._tag === "Left") {
      left13.push(e11.left);
    } else {
      right13.push(e11.right);
    }
  }
  return separated(left13, right13);
};
var filter2 = function(predicate) {
  return function(as17) {
    return as17.filter(predicate);
  };
};
var filterMapWithIndex = function(f16) {
  return function(fa3) {
    var out = [];
    for (var i9 = 0; i9 < fa3.length; i9++) {
      var optionB = f16(i9, fa3[i9]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap = function(f16) {
  return filterMapWithIndex(function(_6, a6) {
    return f16(a6);
  });
};
var compact = filterMap(identity);
var partition = function(predicate) {
  return partitionWithIndex(function(_6, a6) {
    return predicate(a6);
  });
};
var partitionWithIndex = function(predicateWithIndex) {
  return function(as17) {
    var left13 = [];
    var right13 = [];
    for (var i9 = 0; i9 < as17.length; i9++) {
      var a6 = as17[i9];
      if (predicateWithIndex(i9, a6)) {
        right13.push(a6);
      } else {
        left13.push(a6);
      }
    }
    return separated(left13, right13);
  };
};
var partitionMap = function(f16) {
  return partitionMapWithIndex(function(_6, a6) {
    return f16(a6);
  });
};
var partitionMapWithIndex = function(f16) {
  return function(fa3) {
    var left13 = [];
    var right13 = [];
    for (var i9 = 0; i9 < fa3.length; i9++) {
      var e11 = f16(i9, fa3[i9]);
      if (e11._tag === "Left") {
        left13.push(e11.left);
      } else {
        right13.push(e11.right);
      }
    }
    return separated(left13, right13);
  };
};
var extend4 = function(f16) {
  return function(wa3) {
    return wa3.map(function(_6, i9) {
      return f16(wa3.slice(i9));
    });
  };
};
var duplicate3 = extend4(identity);
var foldMapWithIndex2 = function(M8) {
  return function(f16) {
    return function(fa3) {
      return fa3.reduce(function(b6, a6, i9) {
        return M8.concat(b6, f16(i9, a6));
      }, M8.empty);
    };
  };
};
var reduce2 = function(b6, f16) {
  return reduceWithIndex2(b6, function(_6, b7, a6) {
    return f16(b7, a6);
  });
};
var foldMap2 = function(M8) {
  var foldMapWithIndexM = foldMapWithIndex2(M8);
  return function(f16) {
    return foldMapWithIndexM(function(_6, a6) {
      return f16(a6);
    });
  };
};
var reduceWithIndex2 = function(b6, f16) {
  return function(fa3) {
    var len = fa3.length;
    var out = b6;
    for (var i9 = 0; i9 < len; i9++) {
      out = f16(i9, out, fa3[i9]);
    }
    return out;
  };
};
var reduceRight2 = function(b6, f16) {
  return reduceRightWithIndex2(b6, function(_6, a6, b7) {
    return f16(a6, b7);
  });
};
var reduceRightWithIndex2 = function(b6, f16) {
  return function(fa3) {
    return fa3.reduceRight(function(b7, a6, i9) {
      return f16(i9, a6, b7);
    }, b6);
  };
};
var traverse = function(F8) {
  var traverseWithIndexF = traverseWithIndex(F8);
  return function(f16) {
    return traverseWithIndexF(function(_6, a6) {
      return f16(a6);
    });
  };
};
var sequence = function(F8) {
  return function(ta3) {
    return _reduce(ta3, F8.of(zero()), function(fas, fa3) {
      return F8.ap(F8.map(fas, function(as17) {
        return function(a6) {
          return pipe(as17, append4(a6));
        };
      }), fa3);
    });
  };
};
var traverseWithIndex = function(F8) {
  return function(f16) {
    return reduceWithIndex2(F8.of(zero()), function(i9, fbs, a6) {
      return F8.ap(F8.map(fbs, function(bs4) {
        return function(b6) {
          return pipe(bs4, append4(b6));
        };
      }), f16(i9, a6));
    });
  };
};
var URI4 = "ReadonlyArray";
var Functor4 = {
  URI: URI4,
  map: _map4
};
var flap5 = flap(Functor4);
var Pointed = {
  URI: URI4,
  of: of4
};
var Apply3 = {
  URI: URI4,
  map: _map4,
  ap: _ap3
};
var apFirst4 = apFirst(Apply3);
var apSecond4 = apSecond(Apply3);
var Chain3 = {
  URI: URI4,
  map: _map4,
  ap: _ap3,
  chain: flatMap3
};
var chainFirst4 = chainFirst(Chain3);
var Zero = {
  URI: URI4,
  zero
};
var guard2 = guard(Zero, Pointed);
var Compactable = {
  URI: URI4,
  compact,
  separate
};
var Traversable = {
  URI: URI4,
  map: _map4,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence
};
var _wither = witherDefault(Traversable, Compactable);
var _wilt = wiltDefault(Traversable, Compactable);
var Witherable = {
  URI: URI4,
  map: _map4,
  compact,
  separate,
  filter: _filter,
  filterMap: _filterMap,
  partition: _partition,
  partitionMap: _partitionMap,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight,
  traverse: _traverse,
  sequence,
  wither: _wither,
  wilt: _wilt
};
var filterE2 = filterE(Witherable);
var FromEither = {
  URI: URI4,
  fromEither
};
var fromEitherK2 = fromEitherK(FromEither);
var empty2 = empty;
var Do5 = of4(emptyRecord);
var bindTo4 = bindTo(Functor4);
var let_4 = let_(Functor4);
var bind5 = bind2(Chain3);
var apS4 = apS(Apply3);

// node_modules/fp-ts/es6/Array.js
var append5 = append3;
var fromEither2 = function(e11) {
  return isLeft(e11) ? [] : [e11.right];
};
var chainWithIndex4 = function(f16) {
  return function(as17) {
    var out = [];
    for (var i9 = 0; i9 < as17.length; i9++) {
      var bs4 = f16(i9, as17[i9]);
      for (var j9 = 0; j9 < bs4.length; j9++) {
        out.push(bs4[j9]);
      }
    }
    return out;
  };
};
var _map5 = function(fa3, f16) {
  return pipe(fa3, map6(f16));
};
var _ap4 = function(fab, fa3) {
  return pipe(fab, ap5(fa3));
};
var _filter2 = function(fa3, predicate) {
  return pipe(fa3, filter3(predicate));
};
var _filterMap2 = function(fa3, f16) {
  return pipe(fa3, filterMap2(f16));
};
var _partition2 = function(fa3, predicate) {
  return pipe(fa3, partition2(predicate));
};
var _partitionMap2 = function(fa3, f16) {
  return pipe(fa3, partitionMap2(f16));
};
var _reduce2 = function(fa3, b6, f16) {
  return pipe(fa3, reduce3(b6, f16));
};
var _foldMap2 = function(M8) {
  var foldMapM = foldMap3(M8);
  return function(fa3, f16) {
    return pipe(fa3, foldMapM(f16));
  };
};
var _reduceRight2 = function(fa3, b6, f16) {
  return pipe(fa3, reduceRight3(b6, f16));
};
var _traverse2 = function(F8) {
  var traverseF = traverse2(F8);
  return function(ta3, f16) {
    return pipe(ta3, traverseF(f16));
  };
};
var of5 = of3;
var zero2 = function() {
  return [];
};
var map6 = function(f16) {
  return function(fa3) {
    return fa3.map(function(a6) {
      return f16(a6);
    });
  };
};
var ap5 = function(fa3) {
  return flatMap4(function(f16) {
    return pipe(fa3, map6(f16));
  });
};
var flatMap4 = dual(2, function(ma3, f16) {
  return pipe(ma3, chainWithIndex4(function(i9, a6) {
    return f16(a6, i9);
  }));
});
var flatten4 = flatMap4(identity);
var filterMapWithIndex2 = function(f16) {
  return function(fa3) {
    var out = [];
    for (var i9 = 0; i9 < fa3.length; i9++) {
      var optionB = f16(i9, fa3[i9]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap2 = function(f16) {
  return filterMapWithIndex2(function(_6, a6) {
    return f16(a6);
  });
};
var compact2 = filterMap2(identity);
var separate2 = function(fa3) {
  var left13 = [];
  var right13 = [];
  for (var _i4 = 0, fa_1 = fa3; _i4 < fa_1.length; _i4++) {
    var e11 = fa_1[_i4];
    if (e11._tag === "Left") {
      left13.push(e11.left);
    } else {
      right13.push(e11.right);
    }
  }
  return separated(left13, right13);
};
var filter3 = function(predicate) {
  return function(as17) {
    return as17.filter(predicate);
  };
};
var partition2 = function(predicate) {
  return partitionWithIndex2(function(_6, a6) {
    return predicate(a6);
  });
};
var partitionWithIndex2 = function(predicateWithIndex) {
  return function(as17) {
    var left13 = [];
    var right13 = [];
    for (var i9 = 0; i9 < as17.length; i9++) {
      var b6 = as17[i9];
      if (predicateWithIndex(i9, b6)) {
        right13.push(b6);
      } else {
        left13.push(b6);
      }
    }
    return separated(left13, right13);
  };
};
var partitionMap2 = function(f16) {
  return partitionMapWithIndex2(function(_6, a6) {
    return f16(a6);
  });
};
var partitionMapWithIndex2 = function(f16) {
  return function(fa3) {
    var left13 = [];
    var right13 = [];
    for (var i9 = 0; i9 < fa3.length; i9++) {
      var e11 = f16(i9, fa3[i9]);
      if (e11._tag === "Left") {
        left13.push(e11.left);
      } else {
        right13.push(e11.right);
      }
    }
    return separated(left13, right13);
  };
};
var extend5 = function(f16) {
  return function(wa3) {
    return wa3.map(function(_6, i9) {
      return f16(wa3.slice(i9));
    });
  };
};
var duplicate4 = extend5(identity);
var foldMap3 = foldMap2;
var reduce3 = reduce2;
var reduceWithIndex3 = reduceWithIndex2;
var reduceRight3 = reduceRight2;
var traverse2 = function(F8) {
  var traverseWithIndexF = traverseWithIndex2(F8);
  return function(f16) {
    return traverseWithIndexF(function(_6, a6) {
      return f16(a6);
    });
  };
};
var sequence2 = function(F8) {
  return function(ta3) {
    return _reduce2(ta3, F8.of(zero2()), function(fas, fa3) {
      return F8.ap(F8.map(fas, function(as17) {
        return function(a6) {
          return pipe(as17, append5(a6));
        };
      }), fa3);
    });
  };
};
var traverseWithIndex2 = function(F8) {
  return function(f16) {
    return reduceWithIndex3(F8.of(zero2()), function(i9, fbs, a6) {
      return F8.ap(F8.map(fbs, function(bs4) {
        return function(b6) {
          return pipe(bs4, append5(b6));
        };
      }), f16(i9, a6));
    });
  };
};
var URI5 = "Array";
var getSemigroup2 = function() {
  return {
    concat: function(first2, second) {
      return first2.concat(second);
    }
  };
};
var getMonoid2 = function() {
  return {
    concat: getSemigroup2().concat,
    empty: []
  };
};
var Functor5 = {
  URI: URI5,
  map: _map5
};
var flap6 = flap(Functor5);
var Pointed2 = {
  URI: URI5,
  of: of5
};
var Apply4 = {
  URI: URI5,
  map: _map5,
  ap: _ap4
};
var apFirst5 = apFirst(Apply4);
var apSecond5 = apSecond(Apply4);
var Chain4 = {
  URI: URI5,
  map: _map5,
  ap: _ap4,
  chain: flatMap4
};
var chainFirst5 = chainFirst(Chain4);
var Zero2 = {
  URI: URI5,
  zero: zero2
};
var guard3 = guard(Zero2, Pointed2);
var Compactable2 = {
  URI: URI5,
  compact: compact2,
  separate: separate2
};
var Traversable2 = {
  URI: URI5,
  map: _map5,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2,
  traverse: _traverse2,
  sequence: sequence2
};
var _wither2 = witherDefault(Traversable2, Compactable2);
var _wilt2 = wiltDefault(Traversable2, Compactable2);
var Witherable2 = {
  URI: URI5,
  map: _map5,
  compact: compact2,
  separate: separate2,
  filter: _filter2,
  filterMap: _filterMap2,
  partition: _partition2,
  partitionMap: _partitionMap2,
  reduce: _reduce2,
  foldMap: _foldMap2,
  reduceRight: _reduceRight2,
  traverse: _traverse2,
  sequence: sequence2,
  wither: _wither2,
  wilt: _wilt2
};
var filterE3 = filterE(Witherable2);
var FromEither2 = {
  URI: URI5,
  fromEither: fromEither2
};
var fromEitherK3 = fromEitherK(FromEither2);
var Do6 = of5(emptyRecord);
var bindTo5 = bindTo(Functor5);
var let_5 = let_(Functor5);
var bind6 = bind2(Chain4);
var apS5 = apS(Apply4);

// node_modules/fp-ts/es6/boolean.js
var Eq2 = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var SemigroupAll = {
  concat: function(first2, second) {
    return first2 && second;
  }
};
var SemigroupAny = {
  concat: function(first2, second) {
    return first2 || second;
  }
};
var MonoidAll = {
  concat: SemigroupAll.concat,
  empty: true
};
var MonoidAny = {
  concat: SemigroupAny.concat,
  empty: false
};
var Ord2 = {
  equals: Eq2.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};

// node_modules/fp-ts/es6/Bounded.js
var boundedNumber = {
  equals: ordNumber.equals,
  compare: ordNumber.compare,
  top: Infinity,
  bottom: -Infinity
};

// node_modules/fp-ts/es6/ChainRec.js
var tailRec = function(startWith, f16) {
  var ab = f16(startWith);
  while (ab._tag === "Left") {
    ab = f16(ab.left);
  }
  return ab.right;
};

// node_modules/fp-ts/es6/Predicate.js
var not = function(predicate) {
  return function(a6) {
    return !predicate(a6);
  };
};

// node_modules/fp-ts/es6/Option.js
var none2 = none;
var some2 = some;
function fromPredicate2(predicate) {
  return function(a6) {
    return predicate(a6) ? some2(a6) : none2;
  };
}
var getLeft = function(ma3) {
  return ma3._tag === "Right" ? none2 : some2(ma3.left);
};
var getRight = function(ma3) {
  return ma3._tag === "Left" ? none2 : some2(ma3.right);
};
var _map6 = function(fa3, f16) {
  return pipe(fa3, map7(f16));
};
var _ap5 = function(fab, fa3) {
  return pipe(fab, ap6(fa3));
};
var _reduce3 = function(fa3, b6, f16) {
  return pipe(fa3, reduce4(b6, f16));
};
var _foldMap3 = function(M8) {
  var foldMapM = foldMap4(M8);
  return function(fa3, f16) {
    return pipe(fa3, foldMapM(f16));
  };
};
var _reduceRight3 = function(fa3, b6, f16) {
  return pipe(fa3, reduceRight4(b6, f16));
};
var _traverse3 = function(F8) {
  var traverseF = traverse3(F8);
  return function(ta3, f16) {
    return pipe(ta3, traverseF(f16));
  };
};
var _filter3 = function(fa3, predicate) {
  return pipe(fa3, filter4(predicate));
};
var _filterMap3 = function(fa3, f16) {
  return pipe(fa3, filterMap3(f16));
};
var _partition3 = function(fa3, predicate) {
  return pipe(fa3, partition3(predicate));
};
var _partitionMap3 = function(fa3, f16) {
  return pipe(fa3, partitionMap3(f16));
};
var URI6 = "Option";
var map7 = function(f16) {
  return function(fa3) {
    return isNone2(fa3) ? none2 : some2(f16(fa3.value));
  };
};
var Functor6 = {
  URI: URI6,
  map: _map6
};
var as3 = dual(2, as2(Functor6));
var asUnit2 = asUnit(Functor6);
var of6 = some2;
var Pointed3 = {
  URI: URI6,
  of: of6
};
var ap6 = function(fa3) {
  return function(fab) {
    return isNone2(fab) ? none2 : isNone2(fa3) ? none2 : some2(fab.value(fa3.value));
  };
};
var Apply5 = {
  URI: URI6,
  map: _map6,
  ap: _ap5
};
var Applicative = {
  URI: URI6,
  map: _map6,
  ap: _ap5,
  of: of6
};
var flatMap5 = dual(2, function(ma3, f16) {
  return isNone2(ma3) ? none2 : f16(ma3.value);
});
var Chain5 = {
  URI: URI6,
  map: _map6,
  ap: _ap5,
  chain: flatMap5
};
var reduce4 = function(b6, f16) {
  return function(fa3) {
    return isNone2(fa3) ? b6 : f16(b6, fa3.value);
  };
};
var foldMap4 = function(M8) {
  return function(f16) {
    return function(fa3) {
      return isNone2(fa3) ? M8.empty : f16(fa3.value);
    };
  };
};
var reduceRight4 = function(b6, f16) {
  return function(fa3) {
    return isNone2(fa3) ? b6 : f16(fa3.value, b6);
  };
};
var orElse = dual(2, function(self2, that) {
  return isNone2(self2) ? that() : self2;
});
var zero3 = function() {
  return none2;
};
var Zero3 = {
  URI: URI6,
  zero: zero3
};
var guard4 = guard(Zero3, Pointed3);
var extend6 = function(f16) {
  return function(wa3) {
    return isNone2(wa3) ? none2 : some2(f16(wa3));
  };
};
var compact3 = flatMap5(identity);
var defaultSeparated = separated(none2, none2);
var separate3 = function(ma3) {
  return isNone2(ma3) ? defaultSeparated : separated(getLeft(ma3.value), getRight(ma3.value));
};
var Compactable3 = {
  URI: URI6,
  compact: compact3,
  separate: separate3
};
var filter4 = function(predicate) {
  return function(fa3) {
    return isNone2(fa3) ? none2 : predicate(fa3.value) ? fa3 : none2;
  };
};
var filterMap3 = function(f16) {
  return function(fa3) {
    return isNone2(fa3) ? none2 : f16(fa3.value);
  };
};
var partition3 = function(predicate) {
  return function(fa3) {
    return separated(_filter3(fa3, not(predicate)), _filter3(fa3, predicate));
  };
};
var partitionMap3 = function(f16) {
  return flow(map7(f16), separate3);
};
var Filterable = {
  URI: URI6,
  map: _map6,
  compact: compact3,
  separate: separate3,
  filter: _filter3,
  filterMap: _filterMap3,
  partition: _partition3,
  partitionMap: _partitionMap3
};
var traverse3 = function(F8) {
  return function(f16) {
    return function(ta3) {
      return isNone2(ta3) ? F8.of(none2) : F8.map(f16(ta3.value), some2);
    };
  };
};
var sequence3 = function(F8) {
  return function(ta3) {
    return isNone2(ta3) ? F8.of(none2) : F8.map(ta3.value, some2);
  };
};
var Traversable3 = {
  URI: URI6,
  map: _map6,
  reduce: _reduce3,
  foldMap: _foldMap3,
  reduceRight: _reduceRight3,
  traverse: _traverse3,
  sequence: sequence3
};
var _wither3 = witherDefault(Traversable3, Compactable3);
var _wilt3 = wiltDefault(Traversable3, Compactable3);
var fromEither3 = getRight;
var FromEither3 = {
  URI: URI6,
  fromEither: fromEither3
};
var isNone2 = function(fa3) {
  return fa3._tag === "None";
};
var matchW = function(onNone, onSome) {
  return function(ma3) {
    return isNone2(ma3) ? onNone() : onSome(ma3.value);
  };
};
var match = matchW;
var flap7 = flap(Functor6);
var apFirst6 = apFirst(Apply5);
var apSecond6 = apSecond(Apply5);
var tap2 = dual(2, tap(Chain5));
var tapEither2 = dual(2, tapEither(FromEither3, Chain5));
var duplicate5 = extend6(identity);
var fromEitherK4 = fromEitherK(FromEither3);
var chainEitherK2 = chainEitherK(FromEither3, Chain5);
var fromNullable = function(a6) {
  return a6 == null ? none2 : some2(a6);
};
var toNullable = match(constNull, identity);
var toUndefined = match(constUndefined, identity);
var Do7 = of6(emptyRecord);
var bindTo6 = bindTo(Functor6);
var let_6 = let_(Functor6);
var bind7 = bind2(Chain5);
var apS6 = apS(Apply5);
var ApT = of6(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex = function(f16) {
  return function(as17) {
    var o6 = f16(0, head(as17));
    if (isNone2(o6)) {
      return none2;
    }
    var out = [o6.value];
    for (var i9 = 1; i9 < as17.length; i9++) {
      var o_1 = f16(i9, as17[i9]);
      if (isNone2(o_1)) {
        return none2;
      }
      out.push(o_1.value);
    }
    return some2(out);
  };
};
var traverseReadonlyArrayWithIndex = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT;
  };
};
var traverseArray = function(f16) {
  return traverseReadonlyArrayWithIndex(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray = traverseArray(identity);
var getApplySemigroup2 = getApplySemigroup(Apply5);
var getApplyMonoid = getApplicativeMonoid(Applicative);

// node_modules/fp-ts/es6/Compactable.js
function compact4(F8, G7) {
  return function(fga) {
    return F8.map(fga, G7.compact);
  };
}
function separate4(F8, C10, G7) {
  var _compact = compact4(F8, C10);
  var _map35 = map(F8, G7);
  return function(fge) {
    return separated(_compact(pipe(fge, _map35(getLeft))), _compact(pipe(fge, _map35(getRight))));
  };
}

// node_modules/fp-ts/es6/Const.js
var _map7 = function(fa3, f16) {
  return pipe(fa3, map8(f16));
};
var map8 = function() {
  return unsafeCoerce;
};
var URI7 = "Const";
var Functor7 = {
  URI: URI7,
  map: _map7
};
var flap8 = flap(Functor7);

// node_modules/fp-ts/es6/Date.js
var Ord3 = pipe(
  Ord,
  contramap(function(date) {
    return date.valueOf();
  })
);

// node_modules/fp-ts/es6/Either.js
var Either_exports = {};
__export(Either_exports, {
  Alt: () => Alt,
  ApT: () => ApT2,
  Applicative: () => Applicative2,
  Apply: () => Apply6,
  Bifunctor: () => Bifunctor,
  Chain: () => Chain6,
  ChainRec: () => ChainRec,
  Do: () => Do8,
  Extend: () => Extend,
  Foldable: () => Foldable,
  FromEither: () => FromEither4,
  Functor: () => Functor8,
  Monad: () => Monad,
  MonadThrow: () => MonadThrow,
  Pointed: () => Pointed4,
  Traversable: () => Traversable4,
  URI: () => URI8,
  alt: () => alt,
  altW: () => altW,
  ap: () => ap7,
  apFirst: () => apFirst7,
  apFirstW: () => apFirstW,
  apS: () => apS7,
  apSW: () => apSW,
  apSecond: () => apSecond7,
  apSecondW: () => apSecondW,
  apW: () => apW,
  as: () => as4,
  asUnit: () => asUnit3,
  bimap: () => bimap,
  bind: () => bind8,
  bindTo: () => bindTo7,
  bindW: () => bindW,
  chain: () => chain2,
  chainFirst: () => chainFirst6,
  chainFirstW: () => chainFirstW,
  chainNullableK: () => chainNullableK,
  chainOptionK: () => chainOptionK2,
  chainOptionKW: () => chainOptionKW,
  chainW: () => chainW,
  duplicate: () => duplicate6,
  either: () => either,
  elem: () => elem2,
  exists: () => exists,
  extend: () => extend7,
  filterOrElse: () => filterOrElse2,
  filterOrElseW: () => filterOrElseW,
  flap: () => flap9,
  flatMap: () => flatMap6,
  flatMapNullable: () => flatMapNullable2,
  flatMapOption: () => flatMapOption2,
  flatten: () => flatten5,
  flattenW: () => flattenW,
  fold: () => fold,
  foldMap: () => foldMap5,
  foldW: () => foldW,
  fromNullable: () => fromNullable2,
  fromNullableK: () => fromNullableK,
  fromOption: () => fromOption2,
  fromOptionK: () => fromOptionK2,
  fromPredicate: () => fromPredicate3,
  getAltValidation: () => getAltValidation,
  getApplicativeValidation: () => getApplicativeValidation,
  getApplyMonoid: () => getApplyMonoid2,
  getApplySemigroup: () => getApplySemigroup3,
  getCompactable: () => getCompactable,
  getEq: () => getEq3,
  getFilterable: () => getFilterable,
  getOrElse: () => getOrElse,
  getOrElseW: () => getOrElseW,
  getSemigroup: () => getSemigroup3,
  getShow: () => getShow3,
  getValidation: () => getValidation,
  getValidationMonoid: () => getValidationMonoid,
  getValidationSemigroup: () => getValidationSemigroup,
  getWitherable: () => getWitherable,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left3,
  let: () => let_7,
  liftNullable: () => liftNullable2,
  liftOption: () => liftOption2,
  map: () => map9,
  mapLeft: () => mapLeft,
  match: () => match2,
  matchW: () => matchW2,
  of: () => of7,
  orElse: () => orElse2,
  orElseW: () => orElseW,
  parseJSON: () => parseJSON,
  reduce: () => reduce5,
  reduceRight: () => reduceRight5,
  right: () => right3,
  sequence: () => sequence4,
  sequenceArray: () => sequenceArray2,
  stringifyJSON: () => stringifyJSON,
  swap: () => swap,
  tap: () => tap3,
  throwError: () => throwError,
  toError: () => toError,
  toUnion: () => toUnion,
  traverse: () => traverse4,
  traverseArray: () => traverseArray2,
  traverseArrayWithIndex: () => traverseArrayWithIndex,
  traverseReadonlyArrayWithIndex: () => traverseReadonlyArrayWithIndex2,
  traverseReadonlyNonEmptyArrayWithIndex: () => traverseReadonlyNonEmptyArrayWithIndex2,
  tryCatch: () => tryCatch,
  tryCatchK: () => tryCatchK
});
var left3 = left;
var right3 = right;
var flatMap6 = dual(2, function(ma3, f16) {
  return isLeft2(ma3) ? ma3 : f16(ma3.right);
});
var _map8 = function(fa3, f16) {
  return pipe(fa3, map9(f16));
};
var _ap6 = function(fab, fa3) {
  return pipe(fab, ap7(fa3));
};
var _reduce4 = function(fa3, b6, f16) {
  return pipe(fa3, reduce5(b6, f16));
};
var _foldMap4 = function(M8) {
  return function(fa3, f16) {
    var foldMapM = foldMap5(M8);
    return pipe(fa3, foldMapM(f16));
  };
};
var _reduceRight4 = function(fa3, b6, f16) {
  return pipe(fa3, reduceRight5(b6, f16));
};
var _traverse4 = function(F8) {
  var traverseF = traverse4(F8);
  return function(ta3, f16) {
    return pipe(ta3, traverseF(f16));
  };
};
var _bimap = function(fa3, f16, g4) {
  return pipe(fa3, bimap(f16, g4));
};
var _mapLeft = function(fa3, f16) {
  return pipe(fa3, mapLeft(f16));
};
var _alt = function(fa3, that) {
  return pipe(fa3, alt(that));
};
var _extend = function(wa3, f16) {
  return pipe(wa3, extend7(f16));
};
var _chainRec = function(a6, f16) {
  return tailRec(f16(a6), function(e11) {
    return isLeft2(e11) ? right3(left3(e11.left)) : isLeft2(e11.right) ? left3(f16(e11.right.left)) : right3(right3(e11.right.right));
  });
};
var URI8 = "Either";
var getShow3 = function(SE, SA) {
  return {
    show: function(ma3) {
      return isLeft2(ma3) ? "left(".concat(SE.show(ma3.left), ")") : "right(".concat(SA.show(ma3.right), ")");
    }
  };
};
var getEq3 = function(EL, EA) {
  return {
    equals: function(x7, y11) {
      return x7 === y11 || (isLeft2(x7) ? isLeft2(y11) && EL.equals(x7.left, y11.left) : isRight2(y11) && EA.equals(x7.right, y11.right));
    }
  };
};
var getSemigroup3 = function(S8) {
  return {
    concat: function(x7, y11) {
      return isLeft2(y11) ? x7 : isLeft2(x7) ? y11 : right3(S8.concat(x7.right, y11.right));
    }
  };
};
var getCompactable = function(M8) {
  var empty6 = left3(M8.empty);
  return {
    URI: URI8,
    _E: void 0,
    compact: function(ma3) {
      return isLeft2(ma3) ? ma3 : ma3.right._tag === "None" ? empty6 : right3(ma3.right.value);
    },
    separate: function(ma3) {
      return isLeft2(ma3) ? separated(ma3, ma3) : isLeft2(ma3.right) ? separated(right3(ma3.right.left), empty6) : separated(empty6, right3(ma3.right.right));
    }
  };
};
var getFilterable = function(M8) {
  var empty6 = left3(M8.empty);
  var _a14 = getCompactable(M8), compact9 = _a14.compact, separate9 = _a14.separate;
  var filter10 = function(ma3, predicate) {
    return isLeft2(ma3) ? ma3 : predicate(ma3.right) ? ma3 : empty6;
  };
  var partition8 = function(ma3, p9) {
    return isLeft2(ma3) ? separated(ma3, ma3) : p9(ma3.right) ? separated(empty6, right3(ma3.right)) : separated(right3(ma3.right), empty6);
  };
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    compact: compact9,
    separate: separate9,
    filter: filter10,
    filterMap: function(ma3, f16) {
      if (isLeft2(ma3)) {
        return ma3;
      }
      var ob = f16(ma3.right);
      return ob._tag === "None" ? empty6 : right3(ob.value);
    },
    partition: partition8,
    partitionMap: function(ma3, f16) {
      if (isLeft2(ma3)) {
        return separated(ma3, ma3);
      }
      var e11 = f16(ma3.right);
      return isLeft2(e11) ? separated(right3(e11.left), empty6) : separated(empty6, right3(e11.right));
    }
  };
};
var getWitherable = function(M8) {
  var F_ = getFilterable(M8);
  var C10 = getCompactable(M8);
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    compact: F_.compact,
    separate: F_.separate,
    filter: F_.filter,
    filterMap: F_.filterMap,
    partition: F_.partition,
    partitionMap: F_.partitionMap,
    traverse: _traverse4,
    sequence: sequence4,
    reduce: _reduce4,
    foldMap: _foldMap4,
    reduceRight: _reduceRight4,
    wither: witherDefault(Traversable4, C10),
    wilt: wiltDefault(Traversable4, C10)
  };
};
var getApplicativeValidation = function(SE) {
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    ap: function(fab, fa3) {
      return isLeft2(fab) ? isLeft2(fa3) ? left3(SE.concat(fab.left, fa3.left)) : fab : isLeft2(fa3) ? fa3 : right3(fab.right(fa3.right));
    },
    of: of7
  };
};
var getAltValidation = function(SE) {
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    alt: function(me5, that) {
      if (isRight2(me5)) {
        return me5;
      }
      var ea3 = that();
      return isLeft2(ea3) ? left3(SE.concat(me5.left, ea3.left)) : ea3;
    }
  };
};
var map9 = function(f16) {
  return function(fa3) {
    return isLeft2(fa3) ? fa3 : right3(f16(fa3.right));
  };
};
var Functor8 = {
  URI: URI8,
  map: _map8
};
var as4 = dual(2, as2(Functor8));
var asUnit3 = asUnit(Functor8);
var of7 = right3;
var Pointed4 = {
  URI: URI8,
  of: of7
};
var apW = function(fa3) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa3) ? fa3 : right3(fab.right(fa3.right));
  };
};
var ap7 = apW;
var Apply6 = {
  URI: URI8,
  map: _map8,
  ap: _ap6
};
var Applicative2 = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  of: of7
};
var Chain6 = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  chain: flatMap6
};
var Monad = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  of: of7,
  chain: flatMap6
};
var reduce5 = function(b6, f16) {
  return function(fa3) {
    return isLeft2(fa3) ? b6 : f16(b6, fa3.right);
  };
};
var foldMap5 = function(M8) {
  return function(f16) {
    return function(fa3) {
      return isLeft2(fa3) ? M8.empty : f16(fa3.right);
    };
  };
};
var reduceRight5 = function(b6, f16) {
  return function(fa3) {
    return isLeft2(fa3) ? b6 : f16(fa3.right, b6);
  };
};
var Foldable = {
  URI: URI8,
  reduce: _reduce4,
  foldMap: _foldMap4,
  reduceRight: _reduceRight4
};
var traverse4 = function(F8) {
  return function(f16) {
    return function(ta3) {
      return isLeft2(ta3) ? F8.of(left3(ta3.left)) : F8.map(f16(ta3.right), right3);
    };
  };
};
var sequence4 = function(F8) {
  return function(ma3) {
    return isLeft2(ma3) ? F8.of(left3(ma3.left)) : F8.map(ma3.right, right3);
  };
};
var Traversable4 = {
  URI: URI8,
  map: _map8,
  reduce: _reduce4,
  foldMap: _foldMap4,
  reduceRight: _reduceRight4,
  traverse: _traverse4,
  sequence: sequence4
};
var bimap = function(f16, g4) {
  return function(fa3) {
    return isLeft2(fa3) ? left3(f16(fa3.left)) : right3(g4(fa3.right));
  };
};
var mapLeft = function(f16) {
  return function(fa3) {
    return isLeft2(fa3) ? left3(f16(fa3.left)) : fa3;
  };
};
var Bifunctor = {
  URI: URI8,
  bimap: _bimap,
  mapLeft: _mapLeft
};
var altW = function(that) {
  return function(fa3) {
    return isLeft2(fa3) ? that() : fa3;
  };
};
var alt = altW;
var Alt = {
  URI: URI8,
  map: _map8,
  alt: _alt
};
var extend7 = function(f16) {
  return function(wa3) {
    return isLeft2(wa3) ? wa3 : right3(f16(wa3));
  };
};
var Extend = {
  URI: URI8,
  map: _map8,
  extend: _extend
};
var ChainRec = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  chain: flatMap6,
  chainRec: _chainRec
};
var throwError = left3;
var MonadThrow = {
  URI: URI8,
  map: _map8,
  ap: _ap6,
  of: of7,
  chain: flatMap6,
  throwError
};
var FromEither4 = {
  URI: URI8,
  fromEither: identity
};
var fromPredicate3 = fromPredicate(FromEither4);
var fromOption2 = fromOption(FromEither4);
var isLeft2 = isLeft;
var isRight2 = isRight;
var matchW2 = function(onLeft, onRight) {
  return function(ma3) {
    return isLeft2(ma3) ? onLeft(ma3.left) : onRight(ma3.right);
  };
};
var foldW = matchW2;
var match2 = matchW2;
var fold = match2;
var getOrElseW = function(onLeft) {
  return function(ma3) {
    return isLeft2(ma3) ? onLeft(ma3.left) : ma3.right;
  };
};
var getOrElse = getOrElseW;
var flap9 = flap(Functor8);
var apFirst7 = apFirst(Apply6);
var apFirstW = apFirst7;
var apSecond7 = apSecond(Apply6);
var apSecondW = apSecond7;
var tap3 = dual(2, tap(Chain6));
var flattenW = flatMap6(identity);
var flatten5 = flattenW;
var duplicate6 = extend7(identity);
var fromOptionK2 = fromOptionK(FromEither4);
var chainOptionK2 = chainOptionK(FromEither4, Chain6);
var chainOptionKW = chainOptionK2;
var _FromEither = {
  fromEither: FromEither4.fromEither
};
var liftNullable2 = liftNullable(_FromEither);
var liftOption2 = liftOption(_FromEither);
var _FlatMap = {
  flatMap: flatMap6
};
var flatMapNullable2 = flatMapNullable(_FromEither, _FlatMap);
var flatMapOption2 = flatMapOption(_FromEither, _FlatMap);
var filterOrElse2 = filterOrElse(FromEither4, Chain6);
var filterOrElseW = filterOrElse2;
var swap = function(ma3) {
  return isLeft2(ma3) ? right3(ma3.left) : left3(ma3.right);
};
var orElseW = function(onLeft) {
  return function(ma3) {
    return isLeft2(ma3) ? onLeft(ma3.left) : ma3;
  };
};
var orElse2 = orElseW;
var fromNullable2 = function(e11) {
  return function(a6) {
    return a6 == null ? left3(e11) : right3(a6);
  };
};
var tryCatch = function(f16, onThrow) {
  try {
    return right3(f16());
  } catch (e11) {
    return left3(onThrow(e11));
  }
};
var tryCatchK = function(f16, onThrow) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return tryCatch(function() {
      return f16.apply(void 0, a6);
    }, onThrow);
  };
};
var fromNullableK = function(e11) {
  var from40 = fromNullable2(e11);
  return function(f16) {
    return flow(f16, from40);
  };
};
var chainNullableK = function(e11) {
  var from40 = fromNullableK(e11);
  return function(f16) {
    return flatMap6(from40(f16));
  };
};
var toUnion = foldW(identity, identity);
function toError(e11) {
  try {
    return e11 instanceof Error ? e11 : new Error(String(e11));
  } catch (error) {
    return new Error();
  }
}
function elem2(E8) {
  return function(a6, ma3) {
    if (ma3 === void 0) {
      var elemE_1 = elem2(E8);
      return function(ma4) {
        return elemE_1(a6, ma4);
      };
    }
    return isLeft2(ma3) ? false : E8.equals(a6, ma3.right);
  };
}
var exists = function(predicate) {
  return function(ma3) {
    return isLeft2(ma3) ? false : predicate(ma3.right);
  };
};
var Do8 = of7(emptyRecord);
var bindTo7 = bindTo(Functor8);
var let_7 = let_(Functor8);
var bind8 = bind2(Chain6);
var bindW = bind8;
var apS7 = apS(Apply6);
var apSW = apS7;
var ApT2 = of7(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex2 = function(f16) {
  return function(as17) {
    var e11 = f16(0, head(as17));
    if (isLeft2(e11)) {
      return e11;
    }
    var out = [e11.right];
    for (var i9 = 1; i9 < as17.length; i9++) {
      var e_1 = f16(i9, as17[i9]);
      if (isLeft2(e_1)) {
        return e_1;
      }
      out.push(e_1.right);
    }
    return right3(out);
  };
};
var traverseReadonlyArrayWithIndex2 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex2(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT2;
  };
};
var traverseArrayWithIndex = traverseReadonlyArrayWithIndex2;
var traverseArray2 = function(f16) {
  return traverseReadonlyArrayWithIndex2(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray2 = traverseArray2(identity);
var chainW = flatMap6;
var chain2 = flatMap6;
var chainFirst6 = tap3;
var chainFirstW = tap3;
function parseJSON(s5, onError) {
  return tryCatch(function() {
    return JSON.parse(s5);
  }, onError);
}
var stringifyJSON = function(u10, onError) {
  return tryCatch(function() {
    var s5 = JSON.stringify(u10);
    if (typeof s5 !== "string") {
      throw new Error("Converting unsupported structure to JSON");
    }
    return s5;
  }, onError);
};
var either = {
  URI: URI8,
  map: _map8,
  of: of7,
  ap: _ap6,
  chain: flatMap6,
  reduce: _reduce4,
  foldMap: _foldMap4,
  reduceRight: _reduceRight4,
  traverse: _traverse4,
  sequence: sequence4,
  bimap: _bimap,
  mapLeft: _mapLeft,
  alt: _alt,
  extend: _extend,
  chainRec: _chainRec,
  throwError
};
var getApplySemigroup3 = getApplySemigroup(Apply6);
var getApplyMonoid2 = getApplicativeMonoid(Applicative2);
var getValidationSemigroup = function(SE, SA) {
  return getApplySemigroup(getApplicativeValidation(SE))(SA);
};
var getValidationMonoid = function(SE, MA) {
  return getApplicativeMonoid(getApplicativeValidation(SE))(MA);
};
function getValidation(SE) {
  var ap27 = getApplicativeValidation(SE).ap;
  var alt10 = getAltValidation(SE).alt;
  return {
    URI: URI8,
    _E: void 0,
    map: _map8,
    of: of7,
    chain: flatMap6,
    bimap: _bimap,
    mapLeft: _mapLeft,
    reduce: _reduce4,
    foldMap: _foldMap4,
    reduceRight: _reduceRight4,
    extend: _extend,
    traverse: _traverse4,
    sequence: sequence4,
    chainRec: _chainRec,
    throwError,
    ap: ap27,
    alt: alt10
  };
}

// node_modules/fp-ts/es6/EitherT.js
function right4(F8) {
  return flow(right3, F8.of);
}
function left4(F8) {
  return flow(left3, F8.of);
}
function rightF(F8) {
  return function(fa3) {
    return F8.map(fa3, right3);
  };
}
function leftF(F8) {
  return function(fe5) {
    return F8.map(fe5, left3);
  };
}
function fromNullable3(F8) {
  return function(e11) {
    return flow(fromNullable2(e11), F8.of);
  };
}
function fromNullableK2(F8) {
  var fromNullableF = fromNullable3(F8);
  return function(e11) {
    var fromNullableFE = fromNullableF(e11);
    return function(f16) {
      return flow(f16, fromNullableFE);
    };
  };
}
function chainNullableK2(M8) {
  var chainM = chain3(M8);
  var fromNullableKM = fromNullableK2(M8);
  return function(e11) {
    var fromNullableKMe = fromNullableKM(e11);
    return function(f16) {
      return chainM(fromNullableKMe(f16));
    };
  };
}
function map10(F8) {
  return map(F8, Functor8);
}
function ap8(F8) {
  return ap(F8, Apply6);
}
function chain3(M8) {
  var flatMapM = flatMap7(M8);
  return function(f16) {
    return function(ma3) {
      return flatMapM(ma3, f16);
    };
  };
}
function flatMap7(M8) {
  return function(ma3, f16) {
    return M8.chain(ma3, function(e11) {
      return isLeft2(e11) ? M8.of(e11) : f16(e11.right);
    });
  };
}
function alt2(M8) {
  return function(second) {
    return function(first2) {
      return M8.chain(first2, function(e11) {
        return isLeft2(e11) ? second() : M8.of(e11);
      });
    };
  };
}
function mapBoth(F8) {
  return function(self2, f16, g4) {
    return F8.map(self2, bimap(f16, g4));
  };
}
function mapError(F8) {
  return function(self2, f16) {
    return F8.map(self2, mapLeft(f16));
  };
}
function match3(F8) {
  return function(onLeft, onRight) {
    return function(ma3) {
      return F8.map(ma3, match2(onLeft, onRight));
    };
  };
}
function matchE(M8) {
  return function(onLeft, onRight) {
    return function(ma3) {
      return M8.chain(ma3, match2(onLeft, onRight));
    };
  };
}
function getOrElse2(M8) {
  return function(onLeft) {
    return function(ma3) {
      return M8.chain(ma3, match2(onLeft, M8.of));
    };
  };
}
function orElse3(M8) {
  return function(onLeft) {
    return function(ma3) {
      return M8.chain(ma3, function(e11) {
        return isLeft2(e11) ? onLeft(e11.left) : M8.of(e11);
      });
    };
  };
}
function tapError(M8) {
  var orElseM = orElse3(M8);
  return function(ma3, onLeft) {
    return pipe(ma3, orElseM(function(e11) {
      return M8.map(onLeft(e11), function(eb) {
        return isLeft2(eb) ? eb : left3(e11);
      });
    }));
  };
}
function orLeft(M8) {
  return function(onLeft) {
    return function(ma3) {
      return M8.chain(ma3, match2(function(e11) {
        return M8.map(onLeft(e11), left3);
      }, function(a6) {
        return M8.of(right3(a6));
      }));
    };
  };
}
function swap2(F8) {
  return function(ma3) {
    return F8.map(ma3, swap);
  };
}
function toUnion2(F8) {
  return function(fa3) {
    return F8.map(fa3, toUnion);
  };
}

// node_modules/fp-ts/es6/Filterable.js
function filter5(F8, G7) {
  return function(predicate) {
    return function(fga) {
      return F8.map(fga, function(ga3) {
        return G7.filter(ga3, predicate);
      });
    };
  };
}
function filterMap4(F8, G7) {
  return function(f16) {
    return function(fga) {
      return F8.map(fga, function(ga3) {
        return G7.filterMap(ga3, f16);
      });
    };
  };
}
function partition4(F8, G7) {
  var _filter6 = filter5(F8, G7);
  return function(predicate) {
    var left13 = _filter6(not(predicate));
    var right13 = _filter6(predicate);
    return function(fgb) {
      return separated(left13(fgb), right13(fgb));
    };
  };
}
function partitionMap4(F8, G7) {
  var _filterMap6 = filterMap4(F8, G7);
  return function(f16) {
    return function(fga) {
      return separated(pipe(fga, _filterMap6(function(a6) {
        return getLeft(f16(a6));
      })), pipe(fga, _filterMap6(function(a6) {
        return getRight(f16(a6));
      })));
    };
  };
}

// node_modules/fp-ts/es6/FromIO.js
function fromIOK(F8) {
  return function(f16) {
    return flow(f16, F8.fromIO);
  };
}
function tapIO(F8, M8) {
  var chainFirstM = tap(M8);
  return function(self2, f16) {
    return chainFirstM(self2, flow(f16, F8.fromIO));
  };
}

// node_modules/fp-ts/es6/Reader.js
var ask = function() {
  return identity;
};
var _map9 = function(fa3, f16) {
  return pipe(fa3, map11(f16));
};
var _ap7 = function(fab, fa3) {
  return pipe(fab, ap9(fa3));
};
var map11 = function(f16) {
  return function(fa3) {
    return function(r8) {
      return f16(fa3(r8));
    };
  };
};
var apW2 = function(fa3) {
  return function(fab) {
    return function(r8) {
      return fab(r8)(fa3(r8));
    };
  };
};
var ap9 = apW2;
var of8 = constant;
var flatMap8 = dual(2, function(ma3, f16) {
  return function(r8) {
    return f16(ma3(r8))(r8);
  };
});
var flattenW2 = flatMap8(identity);
var URI9 = "Reader";
var Functor9 = {
  URI: URI9,
  map: _map9
};
var flap10 = flap(Functor9);
var Pointed5 = {
  URI: URI9,
  of: of8
};
var Apply7 = {
  URI: URI9,
  map: _map9,
  ap: _ap7
};
var apFirst8 = apFirst(Apply7);
var apSecond8 = apSecond(Apply7);
var Applicative3 = {
  URI: URI9,
  map: _map9,
  ap: _ap7,
  of: of8
};
var Chain7 = {
  URI: URI9,
  map: _map9,
  ap: _ap7,
  chain: flatMap8
};
var Monad2 = {
  URI: URI9,
  map: _map9,
  of: of8,
  ap: _ap7,
  chain: flatMap8
};
var tap4 = dual(2, tap(Chain7));
var bindTo8 = bindTo(Functor9);
var let_8 = let_(Functor9);
var bind9 = bind2(Chain7);
var Do9 = of8(emptyRecord);
var apS8 = apS(Apply7);
var ApT3 = of8(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex3 = function(f16) {
  return function(as17) {
    return function(r8) {
      var out = [f16(0, head(as17))(r8)];
      for (var i9 = 1; i9 < as17.length; i9++) {
        out.push(f16(i9, as17[i9])(r8));
      }
      return out;
    };
  };
};
var traverseReadonlyArrayWithIndex3 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex3(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT3;
  };
};
var traverseArray3 = function(f16) {
  return traverseReadonlyArrayWithIndex3(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray3 = traverseArray3(identity);
var getSemigroup4 = getApplySemigroup(Apply7);
var getMonoid3 = getApplicativeMonoid(Applicative3);

// node_modules/fp-ts/es6/FromReader.js
function ask2(F8) {
  return function() {
    return F8.fromReader(ask());
  };
}
function asks(F8) {
  return F8.fromReader;
}
function fromReaderK(F8) {
  return function(f16) {
    return flow(f16, F8.fromReader);
  };
}
function tapReader(F8, M8) {
  var tapM = tap(M8);
  return function(self2, f16) {
    return tapM(self2, flow(f16, F8.fromReader));
  };
}

// node_modules/fp-ts/es6/State.js
var get5 = function() {
  return function(s5) {
    return [s5, s5];
  };
};
var put = function(s5) {
  return function() {
    return [void 0, s5];
  };
};
var modify = function(f16) {
  return function(s5) {
    return [void 0, f16(s5)];
  };
};
var gets = function(f16) {
  return function(s5) {
    return [f16(s5), s5];
  };
};
var _map10 = function(fa3, f16) {
  return pipe(fa3, map12(f16));
};
var _ap8 = function(fab, fa3) {
  return pipe(fab, ap10(fa3));
};
var map12 = function(f16) {
  return function(fa3) {
    return function(s1) {
      var _a14 = fa3(s1), a6 = _a14[0], s22 = _a14[1];
      return [f16(a6), s22];
    };
  };
};
var ap10 = function(fa3) {
  return function(fab) {
    return function(s1) {
      var _a14 = fab(s1), f16 = _a14[0], s22 = _a14[1];
      var _b = fa3(s22), a6 = _b[0], s32 = _b[1];
      return [f16(a6), s32];
    };
  };
};
var of9 = function(a6) {
  return function(s5) {
    return [a6, s5];
  };
};
var flatMap9 = dual(2, function(ma3, f16) {
  return function(s1) {
    var _a14 = ma3(s1), a6 = _a14[0], s22 = _a14[1];
    return f16(a6)(s22);
  };
});
var flatten6 = flatMap9(identity);
var URI10 = "State";
var Functor10 = {
  URI: URI10,
  map: _map10
};
var flap11 = flap(Functor10);
var Apply8 = {
  URI: URI10,
  map: _map10,
  ap: _ap8
};
var apFirst9 = apFirst(Apply8);
var apSecond9 = apSecond(Apply8);
var Chain8 = {
  URI: URI10,
  map: _map10,
  ap: _ap8,
  chain: flatMap9
};
var tap5 = dual(2, tap(Chain8));
var bindTo9 = bindTo(Functor10);
var let_9 = let_(Functor10);
var bind10 = bind2(Chain8);
var apS9 = apS(Apply8);
var traverseReadonlyNonEmptyArrayWithIndex4 = function(f16) {
  return function(as17) {
    return function(s5) {
      var _a14 = f16(0, head(as17))(s5), b6 = _a14[0], s22 = _a14[1];
      var bs4 = [b6];
      var out = s22;
      for (var i9 = 1; i9 < as17.length; i9++) {
        var _b = f16(i9, as17[i9])(out), b_1 = _b[0], s2_1 = _b[1];
        bs4.push(b_1);
        out = s2_1;
      }
      return [bs4, out];
    };
  };
};
var traverseReadonlyArrayWithIndex4 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex4(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : of9(emptyReadonlyArray);
  };
};
var traverseArray4 = function(f16) {
  return traverseReadonlyArrayWithIndex4(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray4 = traverseArray4(identity);

// node_modules/fp-ts/es6/FromState.js
function get6(F8) {
  return function() {
    return F8.fromState(get5());
  };
}
function put2(F8) {
  return function(s5) {
    return F8.fromState(put(s5));
  };
}
function modify2(F8) {
  return flow(modify, F8.fromState);
}
function gets2(F8) {
  return flow(gets, F8.fromState);
}
function fromStateK(F8) {
  return function(f16) {
    return flow(f16, F8.fromState);
  };
}
function chainStateK(F8, M8) {
  var fromStateKF = fromStateK(F8);
  return function(f16) {
    return function(ma3) {
      return M8.chain(ma3, fromStateKF(f16));
    };
  };
}

// node_modules/fp-ts/es6/FromTask.js
function fromTaskK(F8) {
  return function(f16) {
    return flow(f16, F8.fromTask);
  };
}
function tapTask(F8, M8) {
  var tapM = tap(M8);
  return function(self2, f16) {
    return tapM(self2, flow(f16, F8.fromTask));
  };
}

// node_modules/fp-ts/es6/FromThese.js
function fromTheseK(F8) {
  return function(f16) {
    return flow(f16, F8.fromThese);
  };
}

// node_modules/fp-ts/es6/Identity.js
var _map11 = function(fa3, f16) {
  return pipe(fa3, map13(f16));
};
var _ap9 = function(fab, fa3) {
  return pipe(fab, ap11(fa3));
};
var map13 = function(f16) {
  return function(fa3) {
    return f16(fa3);
  };
};
var ap11 = function(fa3) {
  return function(fab) {
    return fab(fa3);
  };
};
var of10 = identity;
var flatMap10 = dual(2, function(ma3, f16) {
  return f16(ma3);
});
var extend8 = function(f16) {
  return function(wa3) {
    return f16(wa3);
  };
};
var duplicate7 = extend8(identity);
var flatten7 = flatMap10(identity);
var URI11 = "Identity";
var Functor11 = {
  URI: URI11,
  map: _map11
};
var flap12 = flap(Functor11);
var Apply9 = {
  URI: URI11,
  map: _map11,
  ap: _ap9
};
var apFirst10 = apFirst(Apply9);
var apSecond10 = apSecond(Apply9);
var Chain9 = {
  URI: URI11,
  map: _map11,
  ap: _ap9,
  chain: flatMap10
};
var tap6 = dual(2, tap(Chain9));
var Do10 = of10(emptyRecord);
var bindTo10 = bindTo(Functor11);
var let_10 = let_(Functor11);
var bind11 = bind2(Chain9);
var apS10 = apS(Apply9);

// node_modules/fp-ts/es6/IO.js
var _map12 = function(ma3, f16) {
  return function() {
    return f16(ma3());
  };
};
var _ap10 = function(mab, ma3) {
  return function() {
    return mab()(ma3());
  };
};
var map14 = function(f16) {
  return function(fa3) {
    return _map12(fa3, f16);
  };
};
var of11 = constant;
var flatMap11 = dual(2, function(ma3, f16) {
  return function() {
    return f16(ma3())();
  };
});
var flatten8 = flatMap11(identity);
var URI12 = "IO";
var Functor12 = {
  URI: URI12,
  map: _map12
};
var as5 = dual(2, as2(Functor12));
var asUnit4 = asUnit(Functor12);
var flap13 = flap(Functor12);
var Pointed6 = {
  URI: URI12,
  of: of11
};
var Apply10 = {
  URI: URI12,
  map: _map12,
  ap: _ap10
};
var apFirst11 = apFirst(Apply10);
var apSecond11 = apSecond(Apply10);
var Applicative4 = {
  URI: URI12,
  map: _map12,
  ap: _ap10,
  of: of11
};
var Chain10 = {
  URI: URI12,
  map: _map12,
  ap: _ap10,
  chain: flatMap11
};
var Monad3 = {
  URI: URI12,
  map: _map12,
  ap: _ap10,
  of: of11,
  chain: flatMap11
};
var tap7 = dual(2, tap(Chain10));
var Do11 = of11(emptyRecord);
var bindTo11 = bindTo(Functor12);
var let_11 = let_(Functor12);
var bind12 = bind2(Chain10);
var apS11 = apS(Apply10);
var ApT4 = of11(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex5 = function(f16) {
  return function(as17) {
    return function() {
      var out = [f16(0, head(as17))()];
      for (var i9 = 1; i9 < as17.length; i9++) {
        out.push(f16(i9, as17[i9])());
      }
      return out;
    };
  };
};
var traverseReadonlyArrayWithIndex5 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex5(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT4;
  };
};
var traverseArray5 = function(f16) {
  return traverseReadonlyArrayWithIndex5(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray5 = traverseArray5(identity);
var getSemigroup5 = getApplySemigroup(Apply10);
var getMonoid4 = getApplicativeMonoid(Applicative4);

// node_modules/fp-ts/es6/IOEither.js
var left5 = left4(Pointed6);
var right5 = right4(Pointed6);
var rightIO = rightF(Functor12);
var leftIO = leftF(Functor12);
var fromEither4 = of11;
var fromIO = rightIO;
var match4 = match3(Functor12);
var matchE2 = matchE(Monad3);
var getOrElse3 = getOrElse2(Monad3);
var toUnion3 = toUnion2(Functor12);
var orElse4 = orElse3(Monad3);
var tapError2 = dual(2, tapError(Monad3));
var orLeft2 = orLeft(Monad3);
var swap3 = swap2(Functor12);
var _map13 = function(fa3, f16) {
  return pipe(fa3, map15(f16));
};
var _ap11 = function(fab, fa3) {
  return pipe(fab, ap12(fa3));
};
var map15 = map10(Functor12);
var mapBoth2 = dual(3, mapBoth(Functor12));
var mapError2 = dual(2, mapError(Functor12));
var ap12 = ap8(Apply10);
var of12 = right5;
var flatMap12 = dual(2, flatMap7(Monad3));
var flattenW3 = flatMap12(identity);
var alt3 = alt2(Monad3);
var URI13 = "IOEither";
var Functor13 = {
  URI: URI13,
  map: _map13
};
var as6 = dual(2, as2(Functor13));
var asUnit5 = asUnit(Functor13);
var flap14 = flap(Functor13);
var ApplyPar = {
  URI: URI13,
  map: _map13,
  ap: _ap11
};
var apFirst12 = apFirst(ApplyPar);
var apSecond12 = apSecond(ApplyPar);
var ApplicativePar = {
  URI: URI13,
  map: _map13,
  ap: _ap11,
  of: of12
};
var Chain11 = {
  URI: URI13,
  map: _map13,
  ap: _ap11,
  chain: flatMap12
};
var FromEither5 = {
  URI: URI13,
  fromEither: fromEither4
};
var FromIO = {
  URI: URI13,
  fromIO
};
var tap8 = dual(2, tap(Chain11));
var tapEither3 = dual(2, tapEither(FromEither5, Chain11));
var tapIO2 = dual(2, tapIO(FromIO, Chain11));
var fromIOK2 = fromIOK(FromIO);
var fromOption3 = fromOption(FromEither5);
var fromOptionK3 = fromOptionK(FromEither5);
var chainOptionK3 = chainOptionK(FromEither5, Chain11);
var _FromEither2 = {
  fromEither: FromEither5.fromEither
};
var _FromIO = {
  fromIO
};
var liftNullable3 = liftNullable(_FromEither2);
var liftOption3 = liftOption(_FromEither2);
var _FlatMap2 = {
  flatMap: flatMap12
};
var flatMapNullable3 = flatMapNullable(_FromEither2, _FlatMap2);
var flatMapOption3 = flatMapOption(_FromEither2, _FlatMap2);
var flatMapEither2 = flatMapEither(_FromEither2, _FlatMap2);
var flatMapIO2 = flatMapIO(_FromIO, _FlatMap2);
var fromPredicate4 = fromPredicate(FromEither5);
var filterOrElse3 = filterOrElse(FromEither5, Chain11);
var fromEitherK5 = fromEitherK(FromEither5);
var Do12 = of12(emptyRecord);
var bindTo12 = bindTo(Functor13);
var let_12 = let_(Functor13);
var bind13 = bind2(Chain11);
var apS12 = apS(ApplyPar);
var ApT5 = of12(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex6 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex5(f16), map14(traverseReadonlyNonEmptyArrayWithIndex2(SK)));
};
var traverseReadonlyArrayWithIndex6 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex6(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT5;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq = function(f16) {
  return function(as17) {
    return function() {
      var e11 = f16(0, head(as17))();
      if (isLeft(e11)) {
        return e11;
      }
      var out = [e11.right];
      for (var i9 = 1; i9 < as17.length; i9++) {
        var e_1 = f16(i9, as17[i9])();
        if (isLeft(e_1)) {
          return e_1;
        }
        out.push(e_1.right);
      }
      return right(out);
    };
  };
};
var traverseReadonlyArrayWithIndexSeq = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndexSeq(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT5;
  };
};
var traverseArray6 = function(f16) {
  return traverseReadonlyArrayWithIndex6(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray6 = traverseArray6(identity);
var traverseSeqArray = function(f16) {
  return traverseReadonlyArrayWithIndexSeq(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceSeqArray = traverseSeqArray(identity);
var getApplySemigroup4 = getApplySemigroup(ApplyPar);
var getApplyMonoid3 = getApplicativeMonoid(ApplicativePar);

// node_modules/fp-ts/es6/OptionT.js
function some3(F8) {
  return flow(some2, F8.of);
}
function zero4(F8) {
  return constant(F8.of(none2));
}
function fromF(F8) {
  return function(ma3) {
    return F8.map(ma3, some2);
  };
}
function fromNullable4(F8) {
  return flow(fromNullable, F8.of);
}
function fromNullableK3(F8) {
  var fromNullableF = fromNullable4(F8);
  return function(f16) {
    return flow(f16, fromNullableF);
  };
}
function chainNullableK3(M8) {
  var chainM = chain4(M8);
  var fromNullableKM = fromNullableK3(M8);
  return function(f16) {
    return chainM(fromNullableKM(f16));
  };
}
function fromOptionK4(F8) {
  return function(f16) {
    return flow(f16, F8.of);
  };
}
function chainOptionK4(M8) {
  var chainM = chain4(M8);
  var fromOptionKM = fromOptionK4(M8);
  return function(f16) {
    return chainM(fromOptionKM(f16));
  };
}
function fromPredicate5(F8) {
  return function(predicate) {
    return function(a6) {
      return F8.of(fromPredicate2(predicate)(a6));
    };
  };
}
function fromEither5(F8) {
  return flow(fromEither3, F8.of);
}
function match5(F8) {
  return function(onNone, onSome) {
    return function(ma3) {
      return F8.map(ma3, match(onNone, onSome));
    };
  };
}
function matchE3(M8) {
  return function(onNone, onSome) {
    return function(ma3) {
      return M8.chain(ma3, match(onNone, onSome));
    };
  };
}
function getOrElse4(M8) {
  return function(onNone) {
    return function(fa3) {
      return M8.chain(fa3, match(onNone, M8.of));
    };
  };
}
function map16(F8) {
  return map(F8, Functor6);
}
function ap13(F8) {
  return ap(F8, Apply5);
}
function chain4(M8) {
  var flatMapM = flatMap13(M8);
  return function(f16) {
    return function(ma3) {
      return flatMapM(ma3, f16);
    };
  };
}
function flatMap13(M8) {
  var zeroM = zero4(M8);
  return function(ma3, f16) {
    return M8.chain(ma3, match(function() {
      return zeroM();
    }, f16));
  };
}
function alt4(M8) {
  var _some = some3(M8);
  return function(second) {
    return function(first2) {
      return M8.chain(first2, match(second, _some));
    };
  };
}

// node_modules/fp-ts/es6/IOOption.js
var some4 = some3(Pointed6);
var fromPredicate6 = fromPredicate5(Pointed6);
var fromEither6 = fromEither5(Pointed6);
var fromIO2 = fromF(Functor12);
var fromIOEither = map14(fromEither3);
var match6 = match5(Functor12);
var matchE4 = matchE3(Chain10);
var getOrElse5 = getOrElse4(Monad3);
var toUndefined2 = map14(toUndefined);
var toNullable2 = map14(toNullable);
var fromNullable5 = fromNullable4(Pointed6);
var fromNullableK4 = fromNullableK3(Pointed6);
var chainNullableK4 = chainNullableK3(Monad3);
var fromOptionK5 = fromOptionK4(Pointed6);
var map17 = map16(Functor12);
var ap14 = ap13(Apply10);
var of13 = some4;
var flatMap14 = dual(2, flatMap13(Monad3));
var flatten9 = flatMap14(identity);
var alt5 = alt4(Monad3);
var zero5 = zero4(Pointed6);
var none3 = zero5();
var compact5 = compact4(Functor12, Compactable3);
var separate5 = separate4(Functor12, Compactable3, Functor6);
var filter6 = filter5(Functor12, Filterable);
var filterMap5 = filterMap4(Functor12, Filterable);
var partition5 = partition4(Functor12, Filterable);
var partitionMap5 = partitionMap4(Functor12, Filterable);
var _map14 = function(fa3, f16) {
  return pipe(fa3, map17(f16));
};
var _ap12 = function(fab, fa3) {
  return pipe(fab, ap14(fa3));
};
var URI14 = "IOOption";
var Functor14 = {
  URI: URI14,
  map: _map14
};
var as7 = dual(2, as2(Functor14));
var asUnit6 = asUnit(Functor14);
var flap15 = flap(Functor14);
var Pointed7 = {
  URI: URI14,
  of: of13
};
var Apply11 = {
  URI: URI14,
  map: _map14,
  ap: _ap12
};
var apFirst13 = apFirst(Apply11);
var apSecond13 = apSecond(Apply11);
var Chain12 = {
  URI: URI14,
  map: _map14,
  ap: _ap12,
  chain: flatMap14
};
var FromEither6 = {
  URI: URI14,
  fromEither: fromEither6
};
var FromIO2 = {
  URI: URI14,
  fromIO: fromIO2
};
var tap9 = dual(2, tap(Chain12));
var tapEither4 = dual(2, tapEither(FromEither6, Chain12));
var tapIO3 = dual(2, tapIO(FromIO2, Chain12));
var Zero4 = {
  URI: URI14,
  zero: zero5
};
var guard5 = guard(Zero4, Pointed7);
var _FlatMap3 = {
  flatMap: flatMap14
};
var _FromIO2 = {
  fromIO: FromIO2.fromIO
};
var _FromEither3 = {
  fromEither: fromEither6
};
var flatMapIO3 = flatMapIO(_FromIO2, _FlatMap3);
var flatMapOption4 = dual(2, function(self2, f16) {
  return flatMap14(self2, fromOptionK5(f16));
});
var flatMapEither3 = flatMapEither(_FromEither3, _FlatMap3);
var flatMapNullable4 = dual(2, function(self2, f16) {
  return flatMap14(self2, fromNullableK4(f16));
});
var fromIOK3 = fromIOK(FromIO2);
var fromEitherK6 = fromEitherK(FromEither6);
var Do13 = of13(emptyRecord);
var bindTo13 = bindTo(Functor14);
var let_13 = let_(Functor14);
var bind14 = bind2(Chain12);
var apS13 = apS(Apply11);
var ApT6 = of13(emptyReadonlyArray);

// node_modules/fp-ts/es6/IORef.js
var IORef = (
  /** @class */
  function() {
    function IORef2(value2) {
      var _this = this;
      this.value = value2;
      this.read = function() {
        return _this.value;
      };
      this.write = this.write.bind(this);
      this.modify = this.modify.bind(this);
    }
    IORef2.prototype.write = function(a6) {
      var _this = this;
      return function() {
        _this.value = a6;
      };
    };
    IORef2.prototype.modify = function(f16) {
      var _this = this;
      return function() {
        _this.value = f16(_this.value);
      };
    };
    return IORef2;
  }()
);

// node_modules/fp-ts/es6/ReadonlyMap.js
var _mapWithIndex = function(fa3, f16) {
  var m6 = /* @__PURE__ */ new Map();
  var entries = fa3.entries();
  var e11;
  while (!(e11 = entries.next()).done) {
    var _a14 = e11.value, key = _a14[0], a6 = _a14[1];
    m6.set(key, f16(key, a6));
  }
  return m6;
};
var _map15 = function(fa3, f16) {
  return _mapWithIndex(fa3, function(_6, a6) {
    return f16(a6);
  });
};
var URI15 = "ReadonlyMap";
var Functor15 = {
  URI: URI15,
  map: _map15
};
var flap16 = flap(Functor15);

// node_modules/fp-ts/es6/Map.js
var _mapWithIndex2 = function(fa3, f16) {
  var m6 = /* @__PURE__ */ new Map();
  var entries = fa3.entries();
  var e11;
  while (!(e11 = entries.next()).done) {
    var _a14 = e11.value, key = _a14[0], a6 = _a14[1];
    m6.set(key, f16(key, a6));
  }
  return m6;
};
var _map16 = function(fa3, f16) {
  return _mapWithIndex2(fa3, function(_6, a6) {
    return f16(a6);
  });
};
var URI16 = "Map";
var Functor16 = {
  URI: URI16,
  map: _map16
};
var flap17 = flap(Functor16);

// node_modules/fp-ts/es6/Monoid.js
var monoidVoid = {
  concat: semigroupVoid.concat,
  empty: void 0
};
var monoidAll = {
  concat: semigroupAll.concat,
  empty: true
};
var monoidAny = {
  concat: semigroupAny.concat,
  empty: false
};
var monoidString = {
  concat: semigroupString.concat,
  empty: ""
};
var monoidSum = {
  concat: semigroupSum.concat,
  empty: 0
};
var monoidProduct = {
  concat: semigroupProduct.concat,
  empty: 1
};

// node_modules/fp-ts/es6/Ordering.js
var Semigroup = {
  concat: function(x7, y11) {
    return x7 !== 0 ? x7 : y11;
  }
};
var Monoid = {
  concat: Semigroup.concat,
  empty: 0
};

// node_modules/fp-ts/es6/Random.js
var random4 = function() {
  return Math.random();
};
var randomBool = pipe(random4, map14(function(n5) {
  return n5 < 0.5;
}));

// node_modules/fp-ts/es6/ReaderEither.js
var left6 = left4(Pointed5);
var right6 = right4(Pointed5);
var rightReader = rightF(Functor9);
var leftReader = leftF(Functor9);
var fromEither7 = of8;
var fromReader = rightReader;
var match7 = match3(Functor9);
var matchE5 = matchE(Monad2);
var getOrElse6 = getOrElse2(Monad2);
var toUnion4 = toUnion2(Functor9);
var orElse5 = orElse3(Monad2);
var tapError3 = dual(2, tapError(Monad2));
var orLeft3 = orLeft(Monad2);
var swap4 = swap2(Functor9);
var _map17 = function(fa3, f16) {
  return pipe(fa3, map18(f16));
};
var _ap13 = function(fab, fa3) {
  return pipe(fab, ap15(fa3));
};
var map18 = map10(Functor9);
var mapBoth3 = dual(3, mapBoth(Functor9));
var mapError3 = dual(2, mapError(Functor9));
var ap15 = ap8(Apply7);
var of14 = right6;
var flatMap15 = dual(2, flatMap7(Monad2));
var flattenW4 = flatMap15(identity);
var alt6 = alt2(Monad2);
var URI17 = "ReaderEither";
var Functor17 = {
  URI: URI17,
  map: _map17
};
var as8 = dual(2, as2(Functor17));
var asUnit7 = asUnit(Functor17);
var flap18 = flap(Functor17);
var Apply12 = {
  URI: URI17,
  map: _map17,
  ap: _ap13
};
var apFirst14 = apFirst(Apply12);
var apSecond14 = apSecond(Apply12);
var Applicative5 = {
  URI: URI17,
  map: _map17,
  ap: _ap13,
  of: of14
};
var Chain13 = {
  URI: URI17,
  map: _map17,
  ap: _ap13,
  chain: flatMap15
};
var FromEither7 = {
  URI: URI17,
  fromEither: fromEither7
};
var FromReader = {
  URI: URI17,
  fromReader
};
var tap10 = dual(2, tap(Chain13));
var tapEither5 = dual(2, tapEither(FromEither7, Chain13));
var tapReader2 = dual(2, tapReader(FromReader, Chain13));
var ask3 = ask2(FromReader);
var asks2 = asks(FromReader);
var fromReaderK2 = fromReaderK(FromReader);
var fromOption4 = fromOption(FromEither7);
var fromOptionK6 = fromOptionK(FromEither7);
var chainOptionK5 = chainOptionK(FromEither7, Chain13);
var _FromEither4 = {
  fromEither: FromEither7.fromEither
};
var _FromReader = {
  fromReader: FromReader.fromReader
};
var liftNullable4 = liftNullable(_FromEither4);
var liftOption4 = liftOption(_FromEither4);
var _FlatMap4 = {
  flatMap: flatMap15
};
var flatMapNullable5 = flatMapNullable(_FromEither4, _FlatMap4);
var flatMapOption5 = flatMapOption(_FromEither4, _FlatMap4);
var flatMapEither4 = flatMapEither(_FromEither4, _FlatMap4);
var flatMapReader2 = flatMapReader(_FromReader, _FlatMap4);
var fromPredicate7 = fromPredicate(FromEither7);
var filterOrElse4 = filterOrElse(FromEither7, Chain13);
var fromEitherK7 = fromEitherK(FromEither7);
var Do14 = of14(emptyRecord);
var bindTo14 = bindTo(Functor17);
var let_14 = let_(Functor17);
var bind15 = bind2(Chain13);
var apS14 = apS(Apply12);
var ApT7 = of14(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex7 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f16), map11(traverseReadonlyNonEmptyArrayWithIndex2(SK)));
};
var traverseReadonlyArrayWithIndex7 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex7(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT7;
  };
};
var traverseArray7 = function(f16) {
  return traverseReadonlyArrayWithIndex7(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray7 = traverseArray7(identity);
var getApplySemigroup5 = getApplySemigroup(Apply12);
var getApplyMonoid4 = getApplicativeMonoid(Applicative5);

// node_modules/fp-ts/es6/ReaderT.js
function of15(F8) {
  return function(a6) {
    return function() {
      return F8.of(a6);
    };
  };
}
function map19(F8) {
  return function(f16) {
    return function(fa3) {
      return function(r8) {
        return F8.map(fa3(r8), f16);
      };
    };
  };
}
function ap16(F8) {
  return function(fa3) {
    return function(fab) {
      return function(r8) {
        return F8.ap(fab(r8), fa3(r8));
      };
    };
  };
}
function flatMap16(M8) {
  return function(ma3, f16) {
    return function(r8) {
      return M8.chain(ma3(r8), function(a6) {
        return f16(a6)(r8);
      });
    };
  };
}
function fromReader2(F8) {
  return function(ma3) {
    return flow(ma3, F8.of);
  };
}

// node_modules/fp-ts/es6/ReaderIO.js
var fromReader3 = fromReader2(Pointed6);
var fromIO3 = of8;
var _map18 = function(fa3, f16) {
  return pipe(fa3, map20(f16));
};
var _ap14 = function(fab, fa3) {
  return pipe(fab, ap17(fa3));
};
var map20 = map19(Functor12);
var ap17 = ap16(Apply10);
var of16 = of15(Pointed6);
var flatMap17 = dual(2, flatMap16(Monad3));
var flattenW5 = flatMap17(identity);
var URI18 = "ReaderIO";
var Functor18 = {
  URI: URI18,
  map: _map18
};
var as9 = dual(2, as2(Functor18));
var asUnit8 = asUnit(Functor18);
var flap19 = flap(Functor18);
var Apply13 = {
  URI: URI18,
  map: _map18,
  ap: _ap14
};
var apFirst15 = apFirst(Apply13);
var apSecond15 = apSecond(Apply13);
var Chain14 = {
  URI: URI18,
  map: _map18,
  ap: _ap14,
  chain: flatMap17
};
var FromIO3 = {
  URI: URI18,
  fromIO: fromIO3
};
var FromReader2 = {
  URI: URI18,
  fromReader: fromReader3
};
var _FlatMap5 = {
  flatMap: flatMap17
};
var _FromIO3 = {
  fromIO: FromIO3.fromIO
};
var _FromReader2 = {
  fromReader: fromReader3
};
var flatMapIO4 = flatMapIO(_FromIO3, _FlatMap5);
var flatMapReader3 = flatMapReader(_FromReader2, _FlatMap5);
var tap11 = dual(2, tap(Chain14));
var tapIO4 = dual(2, tapIO(FromIO3, Chain14));
var tapReader3 = dual(2, tapReader(FromReader2, Chain14));
var fromIOK4 = fromIOK(FromIO3);
var ask4 = ask2(FromReader2);
var asks3 = asks(FromReader2);
var fromReaderK3 = fromReaderK(FromReader2);
var Do15 = of16(emptyRecord);
var bindTo15 = bindTo(Functor18);
var bind16 = bind2(Chain14);
var apS15 = apS(Apply13);
var ApT8 = of16(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex8 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f16), map11(traverseReadonlyNonEmptyArrayWithIndex5(SK)));
};
var traverseReadonlyArrayWithIndex8 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex8(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT8;
  };
};
var traverseArray8 = function(f16) {
  return traverseReadonlyArrayWithIndex8(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray8 = traverseArray8(identity);

// node_modules/fp-ts/es6/Task.js
var fromIO4 = function(ma3) {
  return function() {
    return Promise.resolve().then(ma3);
  };
};
var _map19 = function(fa3, f16) {
  return pipe(fa3, map21(f16));
};
var _apPar = function(fab, fa3) {
  return pipe(fab, ap18(fa3));
};
var _apSeq = function(fab, fa3) {
  return flatMap18(fab, function(f16) {
    return pipe(fa3, map21(f16));
  });
};
var map21 = function(f16) {
  return function(fa3) {
    return function() {
      return Promise.resolve().then(fa3).then(f16);
    };
  };
};
var ap18 = function(fa3) {
  return function(fab) {
    return function() {
      return Promise.all([Promise.resolve().then(fab), Promise.resolve().then(fa3)]).then(function(_a14) {
        var f16 = _a14[0], a6 = _a14[1];
        return f16(a6);
      });
    };
  };
};
var of17 = function(a6) {
  return function() {
    return Promise.resolve(a6);
  };
};
var flatMap18 = dual(2, function(ma3, f16) {
  return function() {
    return Promise.resolve().then(ma3).then(function(a6) {
      return f16(a6)();
    });
  };
});
var flatten10 = flatMap18(identity);
var URI19 = "Task";
var Functor19 = {
  URI: URI19,
  map: _map19
};
var as10 = dual(2, as2(Functor19));
var asUnit9 = asUnit(Functor19);
var flap20 = flap(Functor19);
var Pointed8 = {
  URI: URI19,
  of: of17
};
var ApplyPar2 = {
  URI: URI19,
  map: _map19,
  ap: _apPar
};
var apFirst16 = apFirst(ApplyPar2);
var apSecond16 = apSecond(ApplyPar2);
var ApplySeq = {
  URI: URI19,
  map: _map19,
  ap: _apSeq
};
var ApplicativeSeq = {
  URI: URI19,
  map: _map19,
  ap: _apSeq,
  of: of17
};
var Chain15 = {
  URI: URI19,
  map: _map19,
  ap: _apPar,
  chain: flatMap18
};
var Monad4 = {
  URI: URI19,
  map: _map19,
  of: of17,
  ap: _apPar,
  chain: flatMap18
};
var FromIO4 = {
  URI: URI19,
  fromIO: fromIO4
};
var _FlatMap6 = {
  flatMap: flatMap18
};
var _FromIO4 = {
  fromIO: FromIO4.fromIO
};
var flatMapIO5 = flatMapIO(_FromIO4, _FlatMap6);
var tap12 = dual(2, tap(Chain15));
var tapIO5 = dual(2, tapIO(FromIO4, Chain15));
var fromIOK5 = fromIOK(FromIO4);
var Do16 = of17(emptyRecord);
var bindTo16 = bindTo(Functor19);
var let_15 = let_(Functor19);
var bind17 = bind2(Chain15);
var apS16 = apS(ApplyPar2);
var ApT9 = of17(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex9 = function(f16) {
  return function(as17) {
    return function() {
      return Promise.all(as17.map(function(a6, i9) {
        return Promise.resolve().then(function() {
          return f16(i9, a6)();
        });
      }));
    };
  };
};
var traverseReadonlyArrayWithIndex9 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex9(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT9;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq2 = function(f16) {
  return function(as17) {
    return function() {
      return tail(as17).reduce(function(acc, a6, i9) {
        return acc.then(function(bs4) {
          return Promise.resolve().then(f16(i9 + 1, a6)).then(function(b6) {
            bs4.push(b6);
            return bs4;
          });
        });
      }, Promise.resolve().then(f16(0, head(as17))).then(singleton));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq2 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndexSeq2(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT9;
  };
};
var traverseArray9 = function(f16) {
  return traverseReadonlyArrayWithIndex9(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray9 = traverseArray9(identity);
var traverseSeqArray2 = function(f16) {
  return traverseReadonlyArrayWithIndexSeq2(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceSeqArray2 = traverseSeqArray2(identity);
var getSemigroup6 = getApplySemigroup(ApplySeq);
var getMonoid7 = getApplicativeMonoid(ApplicativeSeq);

// node_modules/fp-ts/es6/ReaderTask.js
var fromReader4 = fromReader2(Pointed8);
var fromTask = of8;
var fromIO5 = flow(fromIO4, fromTask);
var fromReaderIO = map11(fromIO4);
var _map20 = function(fa3, f16) {
  return pipe(fa3, map22(f16));
};
var _apPar2 = function(fab, fa3) {
  return pipe(fab, ap19(fa3));
};
var _apSeq2 = function(fab, fa3) {
  return flatMap19(fab, function(f16) {
    return pipe(fa3, map22(f16));
  });
};
var map22 = map19(Functor19);
var ap19 = ap16(ApplyPar2);
var of18 = of15(Pointed8);
var flatMap19 = dual(2, flatMap16(Monad4));
var flattenW6 = flatMap19(identity);
var URI20 = "ReaderTask";
var Functor20 = {
  URI: URI20,
  map: _map20
};
var as11 = dual(2, as2(Functor20));
var asUnit10 = asUnit(Functor20);
var flap21 = flap(Functor20);
var Pointed9 = {
  URI: URI20,
  of: of18
};
var ApplyPar3 = {
  URI: URI20,
  map: _map20,
  ap: _apPar2
};
var apFirst17 = apFirst(ApplyPar3);
var apSecond17 = apSecond(ApplyPar3);
var ApplySeq2 = {
  URI: URI20,
  map: _map20,
  ap: _apSeq2
};
var ApplicativeSeq2 = {
  URI: URI20,
  map: _map20,
  ap: _apSeq2,
  of: of18
};
var Chain16 = {
  URI: URI20,
  map: _map20,
  ap: _apPar2,
  chain: flatMap19
};
var Monad5 = {
  URI: URI20,
  map: _map20,
  of: of18,
  ap: _apPar2,
  chain: flatMap19
};
var FromIO5 = {
  URI: URI20,
  fromIO: fromIO5
};
var FromTask = {
  URI: URI20,
  fromIO: fromIO5,
  fromTask
};
var FromReader3 = {
  URI: URI20,
  fromReader: fromReader4
};
var _FlatMap7 = {
  flatMap: flatMap19
};
var _FromIO5 = {
  fromIO: FromIO5.fromIO
};
var _FromTask = {
  fromTask
};
var _FromReader3 = {
  fromReader: fromReader4
};
var flatMapIO6 = flatMapIO(_FromIO5, _FlatMap7);
var flatMapTask2 = flatMapTask(_FromTask, _FlatMap7);
var flatMapReader4 = flatMapReader(_FromReader3, _FlatMap7);
var flatMapReaderIO = dual(2, function(self2, f16) {
  return flatMap19(self2, fromReaderIOK(f16));
});
var tap13 = dual(2, tap(Chain16));
var tapIO6 = dual(2, tapIO(FromIO5, Chain16));
var tapReader4 = dual(2, tapReader(FromReader3, Chain16));
var tapTask2 = dual(2, tapTask(FromTask, Chain16));
var tapReaderIO = dual(2, function(self2, f16) {
  return tap13(self2, fromReaderIOK(f16));
});
var fromIOK6 = fromIOK(FromIO5);
var ask5 = ask2(FromReader3);
var asks4 = asks(FromReader3);
var fromReaderK4 = fromReaderK(FromReader3);
var fromReaderIOK = function(f16) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return fromReaderIO(f16.apply(void 0, a6));
  };
};
var fromTaskK2 = fromTaskK(FromTask);
var Do17 = of18(emptyRecord);
var bindTo17 = bindTo(Functor20);
var let_16 = let_(Functor20);
var bind18 = bind2(Chain16);
var apS17 = apS(ApplyPar3);
var ApT10 = of18(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex10 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f16), map11(traverseReadonlyNonEmptyArrayWithIndex9(SK)));
};
var traverseReadonlyArrayWithIndex10 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex10(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT10;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq3 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f16), map11(traverseReadonlyNonEmptyArrayWithIndexSeq2(SK)));
};
var traverseReadonlyArrayWithIndexSeq3 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndexSeq3(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT10;
  };
};
var traverseArray10 = function(f16) {
  return traverseReadonlyArrayWithIndex10(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray10 = traverseArray10(identity);
var traverseSeqArray3 = function(f16) {
  return traverseReadonlyArrayWithIndexSeq3(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceSeqArray3 = traverseSeqArray3(identity);
var getSemigroup7 = getApplySemigroup(ApplySeq2);
var getMonoid8 = getApplicativeMonoid(ApplicativeSeq2);

// node_modules/fp-ts/es6/TaskEither.js
var left7 = left4(Pointed8);
var right7 = right4(Pointed8);
var rightTask = rightF(Functor19);
var leftTask = leftF(Functor19);
var rightIO2 = flow(fromIO4, rightTask);
var leftIO2 = flow(fromIO4, leftTask);
var fromIO6 = rightIO2;
var fromTask2 = rightTask;
var fromEither8 = of17;
var fromIOEither2 = fromIO4;
var fromTaskOption = function(onNone) {
  return map21(fromOption2(onNone));
};
var match8 = match3(Functor19);
var matchE6 = matchE(Monad4);
var getOrElse7 = getOrElse2(Monad4);
var toUnion5 = toUnion2(Functor19);
var fromNullable6 = fromNullable3(Pointed8);
var fromNullableK5 = fromNullableK2(Pointed8);
var chainNullableK5 = chainNullableK2(Monad4);
var orElse6 = orElse3(Monad4);
var tapError4 = dual(2, tapError(Monad4));
var orLeft4 = orLeft(Monad4);
var swap5 = swap2(Functor19);
var fromIOEitherK = function(f16) {
  return flow(f16, fromIOEither2);
};
var _map21 = function(fa3, f16) {
  return pipe(fa3, map23(f16));
};
var _apPar3 = function(fab, fa3) {
  return pipe(fab, ap20(fa3));
};
var _apSeq3 = function(fab, fa3) {
  return flatMap20(fab, function(f16) {
    return pipe(fa3, map23(f16));
  });
};
var map23 = map10(Functor19);
var mapBoth4 = dual(3, mapBoth(Functor19));
var mapError4 = dual(2, mapError(Functor19));
var ap20 = ap8(ApplyPar2);
var flatMap20 = dual(2, flatMap7(Monad4));
var flattenW7 = flatMap20(identity);
var alt7 = alt2(Monad4);
var of19 = right7;
var URI21 = "TaskEither";
var Functor21 = {
  URI: URI21,
  map: _map21
};
var as12 = dual(2, as2(Functor21));
var asUnit11 = asUnit(Functor21);
var flap22 = flap(Functor21);
var ApplyPar4 = {
  URI: URI21,
  map: _map21,
  ap: _apPar3
};
var apFirst18 = apFirst(ApplyPar4);
var apSecond18 = apSecond(ApplyPar4);
var ApplySeq3 = {
  URI: URI21,
  map: _map21,
  ap: _apSeq3
};
var ApplicativeSeq3 = {
  URI: URI21,
  map: _map21,
  ap: _apSeq3,
  of: of19
};
var Chain17 = {
  URI: URI21,
  map: _map21,
  ap: _apPar3,
  chain: flatMap20
};
var FromEither8 = {
  URI: URI21,
  fromEither: fromEither8
};
var FromIO6 = {
  URI: URI21,
  fromIO: fromIO6
};
var FromTask2 = {
  URI: URI21,
  fromIO: fromIO6,
  fromTask: fromTask2
};
var tap14 = dual(2, tap(Chain17));
var tapEither6 = dual(2, tapEither(FromEither8, Chain17));
var tapIO7 = dual(2, tapIO(FromIO6, Chain17));
var tapTask3 = dual(2, tapTask(FromTask2, Chain17));
var fromOption5 = fromOption(FromEither8);
var fromOptionK7 = fromOptionK(FromEither8);
var chainOptionK6 = chainOptionK(FromEither8, Chain17);
var _FromEither5 = {
  fromEither: FromEither8.fromEither
};
var liftNullable5 = liftNullable(_FromEither5);
var liftOption5 = liftOption(_FromEither5);
var _FlatMap8 = {
  flatMap: flatMap20
};
var _FromIO6 = {
  fromIO: FromIO6.fromIO
};
var _FromTask2 = {
  fromTask: fromTask2
};
var flatMapNullable6 = flatMapNullable(_FromEither5, _FlatMap8);
var flatMapOption6 = flatMapOption(_FromEither5, _FlatMap8);
var flatMapEither5 = flatMapEither(_FromEither5, _FlatMap8);
var flatMapIO7 = flatMapIO(_FromIO6, _FlatMap8);
var flatMapTask3 = flatMapTask(_FromTask2, _FlatMap8);
var flatMapIOEither = dual(2, function(self2, f16) {
  return flatMap20(self2, fromIOEitherK(f16));
});
var flatMapTaskOption = dual(3, function(self2, f16, onNone) {
  return flatMap20(self2, function(a6) {
    return fromTaskOption(function() {
      return onNone(a6);
    })(f16(a6));
  });
});
var fromPredicate8 = fromPredicate(FromEither8);
var filterOrElse5 = filterOrElse(FromEither8, Chain17);
var fromEitherK8 = fromEitherK(FromEither8);
var fromIOK7 = fromIOK(FromIO6);
var fromTaskK3 = fromTaskK(FromTask2);
var Do18 = of19(emptyRecord);
var bindTo18 = bindTo(Functor21);
var let_17 = let_(Functor21);
var bind19 = bind2(Chain17);
var apS18 = apS(ApplyPar4);
var ApT11 = of19(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex11 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex9(f16), map21(traverseReadonlyNonEmptyArrayWithIndex2(SK)));
};
var traverseReadonlyArrayWithIndex11 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex11(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT11;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq4 = function(f16) {
  return function(as17) {
    return function() {
      return tail(as17).reduce(function(acc, a6, i9) {
        return acc.then(function(ebs) {
          return isLeft(ebs) ? acc : f16(i9 + 1, a6)().then(function(eb) {
            if (isLeft(eb)) {
              return eb;
            }
            ebs.right.push(eb.right);
            return ebs;
          });
        });
      }, f16(0, head(as17))().then(map9(singleton)));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq4 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndexSeq4(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT11;
  };
};
var traverseArray11 = function(f16) {
  return traverseReadonlyArrayWithIndex11(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray11 = traverseArray11(identity);
var traverseSeqArray4 = function(f16) {
  return traverseReadonlyArrayWithIndexSeq4(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceSeqArray4 = traverseSeqArray4(identity);
var getApplySemigroup6 = getApplySemigroup(ApplySeq3);
var getApplyMonoid5 = getApplicativeMonoid(ApplicativeSeq3);

// node_modules/fp-ts/es6/ReaderTaskEither.js
var fromTaskEither = of8;
var left8 = left4(Pointed9);
var right8 = right4(Pointed9);
var rightTask2 = flow(rightTask, fromTaskEither);
var leftTask2 = flow(leftTask, fromTaskEither);
var rightReader2 = function(ma3) {
  return flow(ma3, right7);
};
var rightReaderTask = rightF(Functor20);
var leftReaderTask = leftF(Functor20);
var rightIO3 = flow(rightIO2, fromTaskEither);
var leftIO3 = flow(leftIO2, fromTaskEither);
var rightReaderIO = function(ma3) {
  return flow(ma3, rightIO2);
};
var fromEither9 = of18;
var fromReader5 = rightReader2;
var fromIO7 = rightIO3;
var fromTask3 = rightTask2;
var fromIOEither3 = flow(fromIOEither2, fromTaskEither);
var fromReaderEither = function(ma3) {
  return flow(ma3, fromEither8);
};
var match9 = match3(Functor20);
var matchE7 = matchE(Chain16);
var getOrElse8 = getOrElse2(Monad5);
var toUnion6 = toUnion2(Functor20);
var fromNullable7 = fromNullable3(Pointed9);
var fromNullableK6 = fromNullableK2(Pointed9);
var chainNullableK6 = chainNullableK2(Monad5);
var orElse7 = orElse3(Monad5);
var tapError5 = dual(2, tapError(Monad5));
var orLeft5 = orLeft(Monad5);
var swap6 = swap2(Functor20);
var fromIOEitherK2 = function(f16) {
  return flow(f16, fromIOEither3);
};
var fromTaskEitherK = function(f16) {
  return flow(f16, fromTaskEither);
};
var fromReaderEitherK = function(f16) {
  return flow(f16, fromReaderEither);
};
var _map22 = function(fa3, f16) {
  return pipe(fa3, map24(f16));
};
var _apPar4 = function(fab, fa3) {
  return pipe(fab, ap21(fa3));
};
var _apSeq4 = function(fab, fa3) {
  return flatMap21(fab, function(f16) {
    return pipe(fa3, map24(f16));
  });
};
var map24 = map10(Functor20);
var mapBoth5 = dual(3, mapBoth(Functor20));
var mapError5 = dual(2, mapError(Functor20));
var ap21 = ap8(ApplyPar3);
var of20 = right8;
var flatMap21 = dual(2, flatMap7(Monad5));
var flattenW8 = flatMap21(identity);
var alt8 = alt2(Monad5);
var URI22 = "ReaderTaskEither";
var Functor22 = {
  URI: URI22,
  map: _map22
};
var as13 = dual(2, as2(Functor22));
var asUnit12 = asUnit(Functor22);
var flap23 = flap(Functor22);
var Pointed10 = {
  URI: URI22,
  of: of20
};
var ApplyPar5 = {
  URI: URI22,
  map: _map22,
  ap: _apPar4
};
var apFirst19 = apFirst(ApplyPar5);
var apSecond19 = apSecond(ApplyPar5);
var ApplySeq4 = {
  URI: URI22,
  map: _map22,
  ap: _apSeq4
};
var ApplicativeSeq4 = {
  URI: URI22,
  map: _map22,
  ap: _apSeq4,
  of: of20
};
var Chain18 = {
  URI: URI22,
  map: _map22,
  ap: _apPar4,
  chain: flatMap21
};
var Monad6 = {
  URI: URI22,
  map: _map22,
  ap: _apPar4,
  chain: flatMap21,
  of: of20
};
var FromEither9 = {
  URI: URI22,
  fromEither: fromEither9
};
var FromIO7 = {
  URI: URI22,
  fromIO: fromIO7
};
var FromTask3 = {
  URI: URI22,
  fromIO: fromIO7,
  fromTask: fromTask3
};
var FromReader4 = {
  URI: URI22,
  fromReader: fromReader5
};
var tap15 = dual(2, tap(Chain18));
var tapEither7 = dual(2, tapEither(FromEither9, Chain18));
var tapIO8 = dual(2, tapIO(FromIO7, Chain18));
var tapTask4 = dual(2, tapTask(FromTask3, Chain18));
var tapReader5 = dual(2, tapReader(FromReader4, Chain18));
var tapReaderEither = dual(2, function(self2, f16) {
  return tap15(self2, fromReaderEitherK(f16));
});
var tapTaskEither = dual(2, function(self2, f16) {
  return tap15(self2, fromTaskEitherK(f16));
});
var tapReaderTask = dual(2, function(self2, f16) {
  return tap15(self2, fromReaderTaskK(f16));
});
var tapReaderIO2 = dual(2, function(self2, f16) {
  return tap15(self2, fromReaderIOK2(f16));
});
var ask6 = ask2(FromReader4);
var asks5 = asks(FromReader4);
var fromReaderK5 = fromReaderK(FromReader4);
var fromReaderTaskK = function(f16) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return rightReaderTask(f16.apply(void 0, a6));
  };
};
var fromReaderIOK2 = function(f16) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return rightReaderIO(f16.apply(void 0, a6));
  };
};
var fromOption6 = fromOption(FromEither9);
var fromOptionK8 = fromOptionK(FromEither9);
var chainOptionK7 = chainOptionK(FromEither9, Chain18);
var _FromEither6 = {
  fromEither: FromEither9.fromEither
};
var liftNullable6 = liftNullable(_FromEither6);
var liftOption6 = liftOption(_FromEither6);
var _FlatMap9 = {
  flatMap: flatMap21
};
var _FromIO7 = {
  fromIO: fromIO7
};
var _FromTask3 = {
  fromTask: fromTask3
};
var _FromReader4 = {
  fromReader: fromReader5
};
var flatMapNullable7 = flatMapNullable(_FromEither6, _FlatMap9);
var flatMapOption7 = flatMapOption(_FromEither6, _FlatMap9);
var flatMapEither6 = flatMapEither(_FromEither6, _FlatMap9);
var flatMapTaskEither = dual(2, function(self2, f16) {
  return flatMap21(self2, fromTaskEitherK(f16));
});
var flatMapReaderTask = dual(2, function(self2, f16) {
  return flatMap21(self2, fromReaderTaskK(f16));
});
var flatMapIO8 = flatMapIO(_FromIO7, _FlatMap9);
var flatMapTask4 = flatMapTask(_FromTask3, _FlatMap9);
var flatMapReader5 = flatMapReader(_FromReader4, _FlatMap9);
var flatMapReaderIO2 = dual(2, function(self2, f16) {
  return flatMap21(self2, fromReaderIOK2(f16));
});
var flatMapIOEither2 = dual(2, function(self2, f16) {
  return flatMap21(self2, fromIOEitherK2(f16));
});
var flatMapReaderEither = dual(2, function(self2, f16) {
  return flatMap21(self2, fromReaderEitherK(f16));
});
var fromPredicate9 = fromPredicate(FromEither9);
var filterOrElse6 = filterOrElse(FromEither9, Chain18);
var fromEitherK9 = fromEitherK(FromEither9);
var fromIOK8 = fromIOK(FromIO7);
var fromTaskK4 = fromTaskK(FromTask3);
var Do19 = of20(emptyRecord);
var bindTo19 = bindTo(Functor22);
var let_18 = let_(Functor22);
var bind20 = bind2(Chain18);
var apS19 = apS(ApplyPar5);
var ApT12 = of20(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex12 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f16), map11(traverseReadonlyNonEmptyArrayWithIndex11(SK)));
};
var traverseReadonlyArrayWithIndex12 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex12(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT12;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq5 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex3(f16), map11(traverseReadonlyNonEmptyArrayWithIndexSeq4(SK)));
};
var traverseReadonlyArrayWithIndexSeq5 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndexSeq5(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT12;
  };
};
var traverseArray12 = function(f16) {
  return traverseReadonlyArrayWithIndex12(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray12 = traverseArray12(identity);
var traverseSeqArray5 = function(f16) {
  return traverseReadonlyArrayWithIndexSeq5(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceSeqArray5 = traverseSeqArray5(identity);
var getApplySemigroup7 = getApplySemigroup(ApplySeq4);
var getApplyMonoid6 = getApplicativeMonoid(ApplicativeSeq4);

// node_modules/fp-ts/es6/string.js
var Eq3 = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var Semigroup2 = {
  concat: function(first2, second) {
    return first2 + second;
  }
};
var empty3 = "";
var Monoid2 = {
  concat: Semigroup2.concat,
  empty: empty3
};
var Ord4 = {
  equals: Eq3.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};

// node_modules/fp-ts/es6/ReadonlyRecord.js
var keys_ = function(O8) {
  return function(r8) {
    return Object.keys(r8).sort(O8.compare);
  };
};
var keys3 = keys_(Ord4);
function collect(O8) {
  if (typeof O8 === "function") {
    return collect(Ord4)(O8);
  }
  var keysO = keys_(O8);
  return function(f16) {
    return function(r8) {
      var out = [];
      for (var _i4 = 0, _a14 = keysO(r8); _i4 < _a14.length; _i4++) {
        var key = _a14[_i4];
        out.push(f16(key, r8[key]));
      }
      return out;
    };
  };
}
var toReadonlyArray = collect(Ord4)(function(k11, a6) {
  return [k11, a6];
});
var empty4 = {};
function mapWithIndex3(f16) {
  return function(r8) {
    var out = {};
    for (var k11 in r8) {
      if (has.call(r8, k11)) {
        out[k11] = f16(k11, r8[k11]);
      }
    }
    return out;
  };
}
function map25(f16) {
  return mapWithIndex3(function(_6, a6) {
    return f16(a6);
  });
}
function reduceWithIndex5() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 2) {
    return reduceWithIndex5(Ord4).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b6, f16) {
    return function(fa3) {
      var out = b6;
      var ks4 = keysO(fa3);
      var len = ks4.length;
      for (var i9 = 0; i9 < len; i9++) {
        var k11 = ks4[i9];
        out = f16(k11, out, fa3[k11]);
      }
      return out;
    };
  };
}
function foldMapWithIndex4(O8) {
  if ("compare" in O8) {
    var keysO_1 = keys_(O8);
    return function(M8) {
      return function(f16) {
        return function(fa3) {
          var out = M8.empty;
          var ks4 = keysO_1(fa3);
          var len = ks4.length;
          for (var i9 = 0; i9 < len; i9++) {
            var k11 = ks4[i9];
            out = M8.concat(out, f16(k11, fa3[k11]));
          }
          return out;
        };
      };
    };
  }
  return foldMapWithIndex4(Ord4)(O8);
}
function reduceRightWithIndex4() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 2) {
    return reduceRightWithIndex4(Ord4).apply(void 0, args);
  }
  var keysO = keys_(args[0]);
  return function(b6, f16) {
    return function(fa3) {
      var out = b6;
      var ks4 = keysO(fa3);
      var len = ks4.length;
      for (var i9 = len - 1; i9 >= 0; i9--) {
        var k11 = ks4[i9];
        out = f16(k11, fa3[k11], out);
      }
      return out;
    };
  };
}
function sequence5(F8) {
  return _sequence(Ord4)(F8);
}
function partitionMapWithIndex3(f16) {
  return function(r8) {
    var left13 = {};
    var right13 = {};
    for (var k11 in r8) {
      if (has.call(r8, k11)) {
        var e11 = f16(k11, r8[k11]);
        switch (e11._tag) {
          case "Left":
            left13[k11] = e11.left;
            break;
          case "Right":
            right13[k11] = e11.right;
            break;
        }
      }
    }
    return separated(left13, right13);
  };
}
function partitionWithIndex3(predicateWithIndex) {
  return function(r8) {
    var left13 = {};
    var right13 = {};
    for (var k11 in r8) {
      if (has.call(r8, k11)) {
        var a6 = r8[k11];
        if (predicateWithIndex(k11, a6)) {
          right13[k11] = a6;
        } else {
          left13[k11] = a6;
        }
      }
    }
    return separated(left13, right13);
  };
}
function filterMapWithIndex3(f16) {
  return function(r8) {
    var out = {};
    for (var k11 in r8) {
      if (has.call(r8, k11)) {
        var ob = f16(k11, r8[k11]);
        if (isSome(ob)) {
          out[k11] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex(predicateWithIndex) {
  return function(fa3) {
    var out = {};
    var changed = false;
    for (var key in fa3) {
      if (has.call(fa3, key)) {
        var a6 = fa3[key];
        if (predicateWithIndex(key, a6)) {
          out[key] = a6;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa3;
  };
}
var _map23 = function(fa3, f16) {
  return pipe(fa3, map25(f16));
};
var _mapWithIndex3 = function(fa3, f16) {
  return pipe(fa3, mapWithIndex3(f16));
};
var _reduce5 = function(O8) {
  var reduceO = reduce7(O8);
  return function(fa3, b6, f16) {
    return pipe(fa3, reduceO(b6, f16));
  };
};
var _foldMap5 = function(O8) {
  return function(M8) {
    var foldMapM = foldMap7(O8)(M8);
    return function(fa3, f16) {
      return pipe(fa3, foldMapM(f16));
    };
  };
};
var _reduceRight5 = function(O8) {
  var reduceRightO = reduceRight7(O8);
  return function(fa3, b6, f16) {
    return pipe(fa3, reduceRightO(b6, f16));
  };
};
var _filter4 = function(fa3, predicate) {
  return pipe(fa3, filter7(predicate));
};
var _filterMap4 = function(fa3, f16) {
  return pipe(fa3, filterMap6(f16));
};
var _partition4 = function(fa3, predicate) {
  return pipe(fa3, partition6(predicate));
};
var _partitionMap4 = function(fa3, f16) {
  return pipe(fa3, partitionMap6(f16));
};
var _reduceWithIndex = function(O8) {
  var reduceWithIndexO = reduceWithIndex5(O8);
  return function(fa3, b6, f16) {
    return pipe(fa3, reduceWithIndexO(b6, f16));
  };
};
var _foldMapWithIndex = function(O8) {
  var foldMapWithIndexO = foldMapWithIndex4(O8);
  return function(M8) {
    var foldMapWithIndexM = foldMapWithIndexO(M8);
    return function(fa3, f16) {
      return pipe(fa3, foldMapWithIndexM(f16));
    };
  };
};
var _reduceRightWithIndex = function(O8) {
  var reduceRightWithIndexO = reduceRightWithIndex4(O8);
  return function(fa3, b6, f16) {
    return pipe(fa3, reduceRightWithIndexO(b6, f16));
  };
};
var _partitionMapWithIndex = function(fa3, f16) {
  return pipe(fa3, partitionMapWithIndex3(f16));
};
var _partitionWithIndex = function(fa3, predicateWithIndex) {
  return pipe(fa3, partitionWithIndex3(predicateWithIndex));
};
var _filterMapWithIndex = function(fa3, f16) {
  return pipe(fa3, filterMapWithIndex3(f16));
};
var _filterWithIndex = function(fa3, predicateWithIndex) {
  return pipe(fa3, filterWithIndex(predicateWithIndex));
};
var _traverse5 = function(O8) {
  var traverseWithIndexO = _traverseWithIndex(O8);
  return function(F8) {
    var traverseWithIndexOF = traverseWithIndexO(F8);
    return function(ta3, f16) {
      return traverseWithIndexOF(ta3, flow(SK, f16));
    };
  };
};
var _sequence = function(O8) {
  var traverseO = _traverse5(O8);
  return function(F8) {
    var traverseOF = traverseO(F8);
    return function(ta3) {
      return traverseOF(ta3, identity);
    };
  };
};
var _traverseWithIndex = function(O8) {
  return function(F8) {
    var keysO = keys_(O8);
    return function(ta3, f16) {
      var ks4 = keysO(ta3);
      if (ks4.length === 0) {
        return F8.of(empty4);
      }
      var fr4 = F8.of({});
      var _loop_1 = function(key2) {
        fr4 = F8.ap(F8.map(fr4, function(r8) {
          return function(b6) {
            var _a14;
            return Object.assign({}, r8, (_a14 = {}, _a14[key2] = b6, _a14));
          };
        }), f16(key2, ta3[key2]));
      };
      for (var _i4 = 0, ks_1 = ks4; _i4 < ks_1.length; _i4++) {
        var key = ks_1[_i4];
        _loop_1(key);
      }
      return fr4;
    };
  };
};
var filter7 = function(predicate) {
  return filterWithIndex(function(_6, a6) {
    return predicate(a6);
  });
};
var filterMap6 = function(f16) {
  return filterMapWithIndex3(function(_6, a6) {
    return f16(a6);
  });
};
var partition6 = function(predicate) {
  return partitionWithIndex3(function(_6, a6) {
    return predicate(a6);
  });
};
var partitionMap6 = function(f16) {
  return partitionMapWithIndex3(function(_6, a6) {
    return f16(a6);
  });
};
function reduce7() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 1) {
    var reduceWithIndexO_1 = reduceWithIndex5(args[0]);
    return function(b6, f16) {
      return reduceWithIndexO_1(b6, function(_6, b7, a6) {
        return f16(b7, a6);
      });
    };
  }
  return reduce7(Ord4).apply(void 0, args);
}
function foldMap7(O8) {
  if ("compare" in O8) {
    var foldMapWithIndexO_1 = foldMapWithIndex4(O8);
    return function(M8) {
      var foldMapWithIndexM = foldMapWithIndexO_1(M8);
      return function(f16) {
        return foldMapWithIndexM(function(_6, a6) {
          return f16(a6);
        });
      };
    };
  }
  return foldMap7(Ord4)(O8);
}
function reduceRight7() {
  var args = [];
  for (var _i4 = 0; _i4 < arguments.length; _i4++) {
    args[_i4] = arguments[_i4];
  }
  if (args.length === 1) {
    var reduceRightWithIndexO_1 = reduceRightWithIndex4(args[0]);
    return function(b6, f16) {
      return reduceRightWithIndexO_1(b6, function(_6, b7, a6) {
        return f16(b7, a6);
      });
    };
  }
  return reduceRight7(Ord4).apply(void 0, args);
}
var compact6 = function(r8) {
  var out = {};
  for (var k11 in r8) {
    if (has.call(r8, k11)) {
      var oa3 = r8[k11];
      if (isSome(oa3)) {
        out[k11] = oa3.value;
      }
    }
  }
  return out;
};
var separate6 = function(r8) {
  var left13 = {};
  var right13 = {};
  for (var k11 in r8) {
    if (has.call(r8, k11)) {
      var e11 = r8[k11];
      if (isLeft(e11)) {
        left13[k11] = e11.left;
      } else {
        right13[k11] = e11.right;
      }
    }
  }
  return separated(left13, right13);
};
var URI23 = "ReadonlyRecord";
var Functor23 = {
  URI: URI23,
  map: _map23
};
var flap24 = flap(Functor23);
var Compactable4 = {
  URI: URI23,
  compact: compact6,
  separate: separate6
};
var Foldable2 = {
  URI: URI23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4)
};
var FoldableWithIndex = {
  URI: URI23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  reduceWithIndex: _reduceWithIndex(Ord4),
  foldMapWithIndex: _foldMapWithIndex(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex(Ord4)
};
var Traversable5 = {
  URI: URI23,
  map: _map23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5
};
var TraversableWithIndex = {
  URI: URI23,
  map: _map23,
  mapWithIndex: _mapWithIndex3,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  reduceWithIndex: _reduceWithIndex(Ord4),
  foldMapWithIndex: _foldMapWithIndex(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5,
  traverseWithIndex: _traverseWithIndex(Ord4)
};
var _wither4 = witherDefault(Traversable5, Compactable4);
var _wilt4 = wiltDefault(Traversable5, Compactable4);
var Witherable3 = {
  URI: URI23,
  map: _map23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5,
  compact: compact6,
  separate: separate6,
  filter: _filter4,
  filterMap: _filterMap4,
  partition: _partition4,
  partitionMap: _partitionMap4,
  wither: _wither4,
  wilt: _wilt4
};
var readonlyRecord = {
  URI: URI23,
  map: _map23,
  reduce: _reduce5(Ord4),
  foldMap: _foldMap5(Ord4),
  reduceRight: _reduceRight5(Ord4),
  traverse: _traverse5(Ord4),
  sequence: sequence5,
  compact: compact6,
  separate: separate6,
  filter: _filter4,
  filterMap: _filterMap4,
  partition: _partition4,
  partitionMap: _partitionMap4,
  mapWithIndex: _mapWithIndex3,
  reduceWithIndex: _reduceWithIndex(Ord4),
  foldMapWithIndex: _foldMapWithIndex(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex(Ord4),
  filterMapWithIndex: _filterMapWithIndex,
  filterWithIndex: _filterWithIndex,
  partitionMapWithIndex: _partitionMapWithIndex,
  partitionWithIndex: _partitionWithIndex,
  traverseWithIndex: _traverseWithIndex(Ord4),
  wither: _wither4,
  wilt: _wilt4
};

// node_modules/fp-ts/es6/ReadonlyTuple.js
function fst(ea3) {
  return ea3[0];
}
function snd(ea3) {
  return ea3[1];
}
var _map24 = function(fa3, f16) {
  return pipe(fa3, mapFst(f16));
};
var mapFst = function(f16) {
  return function(fa3) {
    return [f16(fst(fa3)), snd(fa3)];
  };
};
var extend9 = function(f16) {
  return function(wa3) {
    return [f16(wa3), snd(wa3)];
  };
};
var duplicate8 = extend9(identity);
var URI24 = "ReadonlyTuple";
var Functor24 = {
  URI: URI24,
  map: _map24
};
var flap25 = flap(Functor24);

// node_modules/fp-ts/es6/Record.js
var keys_2 = function(O8) {
  return function(r8) {
    return Object.keys(r8).sort(O8.compare);
  };
};
var keys4 = keys_2(Ord4);
function collect2(O8) {
  if (typeof O8 === "function") {
    return collect2(Ord4)(O8);
  }
  var keysO = keys_2(O8);
  return function(f16) {
    return function(r8) {
      var out = [];
      for (var _i4 = 0, _a14 = keysO(r8); _i4 < _a14.length; _i4++) {
        var key = _a14[_i4];
        out.push(f16(key, r8[key]));
      }
      return out;
    };
  };
}
var toArray2 = collect2(Ord4)(function(k11, a6) {
  return [
    k11,
    a6
  ];
});
function sequence6(F8) {
  return sequence5(F8);
}
var _map25 = _map23;
var _mapWithIndex4 = _mapWithIndex3;
var _reduce6 = _reduce5;
var _foldMap6 = _foldMap5;
var _reduceRight6 = _reduceRight5;
var _filter5 = _filter4;
var _filterMap5 = _filterMap4;
var _partition5 = _partition4;
var _partitionMap5 = _partitionMap4;
var _reduceWithIndex2 = _reduceWithIndex;
var _foldMapWithIndex2 = _foldMapWithIndex;
var _reduceRightWithIndex2 = _reduceRightWithIndex;
var _partitionMapWithIndex2 = _partitionMapWithIndex;
var _partitionWithIndex2 = _partitionWithIndex;
var _filterMapWithIndex2 = _filterMapWithIndex;
var _filterWithIndex2 = _filterWithIndex;
var _traverse6 = _traverse5;
var _traverseWithIndex2 = function(O8) {
  return function(F8) {
    var keysO = keys_2(O8);
    return function(ta3, f16) {
      var ks4 = keysO(ta3);
      if (ks4.length === 0) {
        return F8.of({});
      }
      var fr4 = F8.of({});
      var _loop_1 = function(key2) {
        fr4 = F8.ap(F8.map(fr4, function(r8) {
          return function(b6) {
            r8[key2] = b6;
            return r8;
          };
        }), f16(key2, ta3[key2]));
      };
      for (var _i4 = 0, ks_1 = ks4; _i4 < ks_1.length; _i4++) {
        var key = ks_1[_i4];
        _loop_1(key);
      }
      return fr4;
    };
  };
};
var compact7 = compact6;
var separate7 = separate6;
var URI25 = "Record";
var Functor25 = {
  URI: URI25,
  map: _map25
};
var flap26 = flap(Functor25);
var Compactable5 = {
  URI: URI25,
  compact: compact7,
  separate: separate7
};
var Foldable4 = {
  URI: URI25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4)
};
var FoldableWithIndex2 = {
  URI: URI25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  reduceWithIndex: _reduceWithIndex2(Ord4),
  foldMapWithIndex: _foldMapWithIndex2(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex2(Ord4)
};
var Traversable6 = {
  URI: URI25,
  map: _map25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6
};
var TraversableWithIndex2 = {
  URI: URI25,
  map: _map25,
  mapWithIndex: _mapWithIndex4,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  reduceWithIndex: _reduceWithIndex2(Ord4),
  foldMapWithIndex: _foldMapWithIndex2(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex2(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6,
  traverseWithIndex: _traverseWithIndex2(Ord4)
};
var _wither5 = witherDefault(Traversable6, Compactable5);
var _wilt5 = wiltDefault(Traversable6, Compactable5);
var Witherable4 = {
  URI: URI25,
  map: _map25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6,
  compact: compact7,
  separate: separate7,
  filter: _filter5,
  filterMap: _filterMap5,
  partition: _partition5,
  partitionMap: _partitionMap5,
  wither: _wither5,
  wilt: _wilt5
};
var record = {
  URI: URI25,
  map: _map25,
  reduce: _reduce6(Ord4),
  foldMap: _foldMap6(Ord4),
  reduceRight: _reduceRight6(Ord4),
  traverse: _traverse6(Ord4),
  sequence: sequence6,
  compact: compact7,
  separate: separate7,
  filter: _filter5,
  filterMap: _filterMap5,
  partition: _partition5,
  partitionMap: _partitionMap5,
  mapWithIndex: _mapWithIndex4,
  reduceWithIndex: _reduceWithIndex2(Ord4),
  foldMapWithIndex: _foldMapWithIndex2(Ord4),
  reduceRightWithIndex: _reduceRightWithIndex2(Ord4),
  filterMapWithIndex: _filterMapWithIndex2,
  filterWithIndex: _filterWithIndex2,
  partitionMapWithIndex: _partitionMapWithIndex2,
  partitionWithIndex: _partitionWithIndex2,
  traverseWithIndex: _traverseWithIndex2(Ord4),
  wither: _wither5,
  wilt: _wilt5
};

// node_modules/fp-ts/es6/StateT.js
function of21(F8) {
  return function(a6) {
    return function(s5) {
      return F8.of([a6, s5]);
    };
  };
}
function map26(F8) {
  return function(f16) {
    return function(fa3) {
      return function(s5) {
        return F8.map(fa3(s5), function(_a14) {
          var a6 = _a14[0], s1 = _a14[1];
          return [f16(a6), s1];
        });
      };
    };
  };
}
function ap22(M8) {
  return function(fa3) {
    return function(fab) {
      return function(s5) {
        return M8.chain(fab(s5), function(_a14) {
          var f16 = _a14[0], s6 = _a14[1];
          return M8.map(fa3(s6), function(_a15) {
            var a6 = _a15[0], s7 = _a15[1];
            return [f16(a6), s7];
          });
        });
      };
    };
  };
}
function flatMap22(M8) {
  return function(ma3, f16) {
    return function(s5) {
      return M8.chain(ma3(s5), function(_a14) {
        var a6 = _a14[0], s1 = _a14[1];
        return f16(a6)(s1);
      });
    };
  };
}
function fromState(F8) {
  return function(sa3) {
    return function(s5) {
      return F8.of(sa3(s5));
    };
  };
}
function fromF2(F8) {
  return function(ma3) {
    return function(s5) {
      return F8.map(ma3, function(a6) {
        return [a6, s5];
      });
    };
  };
}
function evaluate(F8) {
  return function(s5) {
    return function(ma3) {
      return F8.map(ma3(s5), function(_a14) {
        var a6 = _a14[0];
        return a6;
      });
    };
  };
}
function execute2(F8) {
  return function(s5) {
    return function(ma3) {
      return F8.map(ma3(s5), snd);
    };
  };
}

// node_modules/fp-ts/es6/StateReaderTaskEither.js
var left9 = function(e11) {
  return function() {
    return left8(e11);
  };
};
var right9 = of21(Pointed10);
function rightTask3(ma3) {
  return fromReaderTaskEither(rightTask2(ma3));
}
function rightReader3(ma3) {
  return fromReaderTaskEither(rightReader2(ma3));
}
function rightIO4(ma3) {
  return fromReaderTaskEither(rightIO3(ma3));
}
var fromEither10 = match2(function(e11) {
  return left9(e11);
}, right9);
var fromReader6 = rightReader3;
var fromIO8 = rightIO4;
var fromTask4 = rightTask3;
var fromState2 = fromState(Pointed10);
var fromTaskEither2 = function(ma3) {
  return fromReaderTaskEither(fromTaskEither(ma3));
};
var fromIOEither4 = function(ma3) {
  return fromReaderTaskEither(fromIOEither3(ma3));
};
var fromReaderTaskEither = fromF2(Functor22);
var fromIOEitherK3 = function(f16) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return fromIOEither4(f16.apply(void 0, a6));
  };
};
var fromTaskEitherK2 = function(f16) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return fromTaskEither2(f16.apply(void 0, a6));
  };
};
var fromReaderTaskEitherK = function(f16) {
  return function() {
    var a6 = [];
    for (var _i4 = 0; _i4 < arguments.length; _i4++) {
      a6[_i4] = arguments[_i4];
    }
    return fromReaderTaskEither(f16.apply(void 0, a6));
  };
};
var _map26 = function(fa3, f16) {
  return pipe(fa3, map27(f16));
};
var _ap15 = function(fab, fa3) {
  return pipe(fab, ap23(fa3));
};
var map27 = map26(Functor22);
var ap23 = ap22(Chain18);
var of22 = right9;
var _FromIO8 = {
  fromIO: fromIO8
};
var _FromTask4 = {
  fromTask: fromTask4
};
var _FromReader5 = {
  fromReader: fromReader6
};
var _FromEither7 = {
  fromEither: fromEither10
};
var flatMap23 = dual(2, flatMap22(Monad6));
var _FlatMap10 = {
  flatMap: flatMap23
};
var flatMapTaskEither2 = dual(2, function(self2, f16) {
  return flatMap23(self2, function(a6) {
    return fromTaskEitherK2(f16)(a6);
  });
});
var flatMapIO9 = flatMapIO(_FromIO8, _FlatMap10);
var flatMapTask5 = flatMapTask(_FromTask4, _FlatMap10);
var flatMapReader6 = flatMapReader(_FromReader5, _FlatMap10);
var flatMapIOEither3 = dual(2, function(self2, f16) {
  return flatMap23(self2, function(a6) {
    return fromIOEitherK3(f16)(a6);
  });
});
var flatMapEither7 = dual(2, flatMapEither(_FromEither7, _FlatMap10));
var flatMapOption8 = flatMapOption(_FromEither7, _FlatMap10);
var flatMapReaderTaskEither = dual(2, function(self2, f16) {
  return flatMap23(self2, function(a6) {
    return fromReaderTaskEitherK(f16)(a6);
  });
});
var flatMapState = dual(2, function(self2, f16) {
  return flatMap23(self2, fromStateK2(f16));
});
var flattenW9 = flatMap23(identity);
var URI26 = "StateReaderTaskEither";
var Functor26 = {
  URI: URI26,
  map: _map26
};
var as14 = dual(2, as2(Functor26));
var asUnit13 = asUnit(Functor26);
var flap27 = flap(Functor26);
var Apply14 = {
  URI: URI26,
  map: _map26,
  ap: _ap15
};
var apFirst20 = apFirst(Apply14);
var apSecond20 = apSecond(Apply14);
var Chain19 = {
  URI: URI26,
  map: _map26,
  ap: _ap15,
  chain: flatMap23
};
var FromState = {
  URI: URI26,
  fromState: fromState2
};
var get7 = get6(FromState);
var put3 = put2(FromState);
var modify3 = modify2(FromState);
var gets3 = gets2(FromState);
var fromStateK2 = fromStateK(FromState);
var chainStateK2 = chainStateK(FromState, Chain19);
var FromEither10 = {
  URI: URI26,
  fromEither: fromEither10
};
var FromIO8 = {
  URI: URI26,
  fromIO: fromIO8
};
var FromTask4 = {
  URI: URI26,
  fromIO: fromIO8,
  fromTask: fromTask4
};
var FromReader5 = {
  URI: URI26,
  fromReader: fromReader6
};
var tap16 = dual(2, tap(Chain19));
var tapEither8 = dual(2, tapEither(FromEither10, Chain19));
var tapIO9 = dual(2, tapIO(FromIO8, Chain19));
var tapTask5 = dual(2, tapTask(FromTask4, Chain19));
var tapReader6 = dual(2, tapReader(FromReader5, Chain19));
var ask7 = ask2(FromReader5);
var asks6 = asks(FromReader5);
var fromReaderK6 = fromReaderK(FromReader5);
var fromOption7 = fromOption(FromEither10);
var fromOptionK9 = fromOptionK(FromEither10);
var chainOptionK8 = chainOptionK(FromEither10, Chain19);
var fromPredicate10 = fromPredicate(FromEither10);
var filterOrElse7 = filterOrElse(FromEither10, Chain19);
var fromEitherK10 = fromEitherK(FromEither10);
var fromIOK9 = fromIOK(FromIO8);
var fromTaskK5 = fromTaskK(FromTask4);
var evaluate2 = evaluate(Functor22);
var execute3 = execute2(Functor22);
var bindTo20 = bindTo(Functor26);
var let_19 = let_(Functor26);
var bind21 = bind2(Chain19);
var apS20 = apS(Apply14);
var traverseReadonlyNonEmptyArrayWithIndex13 = function(f16) {
  return function(as17) {
    return function(s5) {
      return function(r8) {
        return function() {
          return tail(as17).reduce(function(acc, a6, i9) {
            return acc.then(function(ebs) {
              return isLeft(ebs) ? acc : f16(i9 + 1, a6)(ebs.right[1])(r8)().then(function(eb) {
                if (isLeft(eb)) {
                  return eb;
                }
                var _a14 = eb.right, b6 = _a14[0], s6 = _a14[1];
                ebs.right[0].push(b6);
                ebs.right[1] = s6;
                return ebs;
              });
            });
          }, f16(0, head(as17))(s5)(r8)().then(map9(function(_a14) {
            var b6 = _a14[0], s6 = _a14[1];
            return [[b6], s6];
          })));
        };
      };
    };
  };
};
var traverseReadonlyArrayWithIndex13 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex13(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : of22(emptyReadonlyArray);
  };
};
var traverseArray13 = function(f16) {
  return traverseReadonlyArrayWithIndex13(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray13 = traverseArray13(identity);

// node_modules/fp-ts/es6/Store.js
var _map27 = function(fa3, f16) {
  return pipe(fa3, map28(f16));
};
var extend10 = function(f16) {
  return function(wa3) {
    return {
      peek: function(s5) {
        return f16({ peek: wa3.peek, pos: s5 });
      },
      pos: wa3.pos
    };
  };
};
var duplicate9 = extend10(identity);
var map28 = function(f16) {
  return function(fa3) {
    return {
      peek: function(s5) {
        return f16(fa3.peek(s5));
      },
      pos: fa3.pos
    };
  };
};
var URI27 = "Store";
var Functor27 = {
  URI: URI27,
  map: _map27
};
var flap28 = flap(Functor27);

// node_modules/fp-ts/es6/TaskOption.js
var some7 = some3(Pointed8);
var fromPredicate11 = fromPredicate5(Pointed8);
var fromEither11 = fromEither5(Pointed8);
var fromIO9 = function(ma3) {
  return fromTask5(fromIO4(ma3));
};
var fromTask5 = fromF(Functor19);
var fromTaskEither3 = map21(fromEither3);
var match10 = match5(Functor19);
var matchE8 = matchE3(Chain15);
var getOrElse9 = getOrElse4(Monad4);
var fromNullable8 = fromNullable4(Pointed8);
var fromNullableK7 = fromNullableK3(Pointed8);
var chainNullableK7 = chainNullableK3(Monad4);
var fromOptionK10 = fromOptionK4(Pointed8);
var chainOptionK9 = chainOptionK4(Monad4);
var map29 = map16(Functor19);
var ap24 = ap13(ApplyPar2);
var of23 = some7;
var _FromIO9 = {
  fromIO: fromIO9
};
var _FromTask5 = {
  fromTask: fromTask5
};
var flatMap24 = dual(2, flatMap13(Monad4));
var _FlatMap11 = {
  flatMap: flatMap24
};
var flatMapIO10 = flatMapIO(_FromIO9, _FlatMap11);
var flatMapTask6 = flatMapTask(_FromTask5, _FlatMap11);
var flatten11 = flatMap24(identity);
var alt9 = alt4(Monad4);
var zero6 = zero4(Pointed8);
var none4 = zero6();
var compact8 = compact4(Functor19, Compactable3);
var separate8 = separate4(Functor19, Compactable3, Functor6);
var filter8 = filter5(Functor19, Filterable);
var filterMap7 = filterMap4(Functor19, Filterable);
var partition7 = partition4(Functor19, Filterable);
var partitionMap7 = partitionMap4(Functor19, Filterable);
var _map28 = function(fa3, f16) {
  return pipe(fa3, map29(f16));
};
var _ap16 = function(fab, fa3) {
  return pipe(fab, ap24(fa3));
};
var URI28 = "TaskOption";
var Functor28 = {
  URI: URI28,
  map: _map28
};
var as15 = dual(2, as2(Functor28));
var asUnit14 = asUnit(Functor28);
var flap29 = flap(Functor28);
var Pointed11 = {
  URI: URI28,
  of: of23
};
var ApplyPar6 = {
  URI: URI28,
  map: _map28,
  ap: _ap16
};
var apFirst21 = apFirst(ApplyPar6);
var apSecond21 = apSecond(ApplyPar6);
var Chain20 = {
  URI: URI28,
  map: _map28,
  ap: _ap16,
  chain: flatMap24
};
var FromEither11 = {
  URI: URI28,
  fromEither: fromEither11
};
var FromIO9 = {
  URI: URI28,
  fromIO: fromIO9
};
var FromTask5 = {
  URI: URI28,
  fromIO: fromIO9,
  fromTask: fromTask5
};
var tap17 = dual(2, tap(Chain20));
var tapEither9 = dual(2, tapEither(FromEither11, Chain20));
var tapIO10 = dual(2, tapIO(FromIO9, Chain20));
var tapTask6 = dual(2, tapTask(FromTask5, Chain20));
var Zero5 = {
  URI: URI28,
  zero: zero6
};
var guard6 = guard(Zero5, Pointed11);
var fromIOK10 = fromIOK(FromIO9);
var fromEitherK11 = fromEitherK(FromEither11);
var chainEitherK3 = chainEitherK(FromEither11, Chain20);
var fromTaskK6 = fromTaskK(FromTask5);
var Do20 = of23(emptyRecord);
var bindTo21 = bindTo(Functor28);
var let_20 = let_(Functor28);
var bind22 = bind2(Chain20);
var apS21 = apS(ApplyPar6);
var ApT13 = of23(emptyReadonlyArray);
var traverseReadonlyNonEmptyArrayWithIndex14 = function(f16) {
  return flow(traverseReadonlyNonEmptyArrayWithIndex9(f16), map21(traverseReadonlyNonEmptyArrayWithIndex(SK)));
};
var traverseReadonlyArrayWithIndex14 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndex14(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT13;
  };
};
var traverseReadonlyNonEmptyArrayWithIndexSeq6 = function(f16) {
  return function(as17) {
    return function() {
      return tail(as17).reduce(function(acc, a6, i9) {
        return acc.then(function(obs) {
          return isNone(obs) ? acc : f16(i9 + 1, a6)().then(function(ob) {
            if (isNone(ob)) {
              return ob;
            }
            obs.value.push(ob.value);
            return obs;
          });
        });
      }, f16(0, head(as17))().then(map7(singleton)));
    };
  };
};
var traverseReadonlyArrayWithIndexSeq6 = function(f16) {
  var g4 = traverseReadonlyNonEmptyArrayWithIndexSeq6(f16);
  return function(as17) {
    return isNonEmpty(as17) ? g4(as17) : ApT13;
  };
};
var traverseArray14 = function(f16) {
  return traverseReadonlyArrayWithIndex14(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceArray14 = traverseArray14(identity);
var traverseSeqArray6 = function(f16) {
  return traverseReadonlyArrayWithIndexSeq6(function(_6, a6) {
    return f16(a6);
  });
};
var sequenceSeqArray6 = traverseSeqArray6(identity);

// node_modules/fp-ts/es6/These.js
var isLeft3 = function(fa3) {
  return fa3._tag === "Left";
};
var isRight3 = function(fa3) {
  return fa3._tag === "Right";
};
function isBoth(fa3) {
  return fa3._tag === "Both";
}
function left10(left13) {
  return { _tag: "Left", left: left13 };
}
function right10(right13) {
  return { _tag: "Right", right: right13 };
}
function both(left13, right13) {
  return { _tag: "Both", left: left13, right: right13 };
}
var matchW3 = function(onLeft, onRight, onBoth) {
  return function(fa3) {
    switch (fa3._tag) {
      case "Left":
        return onLeft(fa3.left);
      case "Right":
        return onRight(fa3.right);
      case "Both":
        return onBoth(fa3.left, fa3.right);
    }
  };
};
var match11 = matchW3;
var swap7 = match11(right10, left10, function(e11, a6) {
  return both(a6, e11);
});
var _map29 = function(fa3, f16) {
  return pipe(fa3, map30(f16));
};
var bimap3 = function(f16, g4) {
  return function(fa3) {
    return isLeft3(fa3) ? left10(f16(fa3.left)) : isRight3(fa3) ? right10(g4(fa3.right)) : both(f16(fa3.left), g4(fa3.right));
  };
};
var mapLeft3 = function(f16) {
  return function(fa3) {
    return isLeft3(fa3) ? left10(f16(fa3.left)) : isBoth(fa3) ? both(f16(fa3.left), fa3.right) : fa3;
  };
};
var map30 = function(f16) {
  return function(fa3) {
    return isLeft3(fa3) ? fa3 : isRight3(fa3) ? right10(f16(fa3.right)) : both(fa3.left, f16(fa3.right));
  };
};
var of24 = right10;
var URI29 = "These";
var Functor29 = {
  URI: URI29,
  map: _map29
};
var flap30 = flap(Functor29);
var FromEither12 = {
  URI: URI29,
  fromEither: identity
};
var fromPredicate12 = fromPredicate(FromEither12);
var fromOption8 = fromOption(FromEither12);
var fromOptionK11 = fromOptionK(FromEither12);
var toTuple22 = function(e11, a6) {
  return function(fa3) {
    return isLeft3(fa3) ? [fa3.left, a6()] : isRight3(fa3) ? [e11(), fa3.right] : [fa3.left, fa3.right];
  };
};
var ApT14 = of24(emptyReadonlyArray);

// node_modules/fp-ts/es6/TheseT.js
function right11(F8) {
  return flow(right10, F8.of);
}
function left11(F8) {
  return flow(left10, F8.of);
}
function both2(F8) {
  return flow(both, F8.of);
}
function rightF2(F8) {
  return function(fa3) {
    return F8.map(fa3, right10);
  };
}
function leftF2(F8) {
  return function(fe5) {
    return F8.map(fe5, left10);
  };
}
function map31(F8) {
  return map(F8, Functor29);
}
function bimap4(F8) {
  return function(f16, g4) {
    return function(fea) {
      return F8.map(fea, bimap3(f16, g4));
    };
  };
}
function mapLeft4(F8) {
  return function(f16) {
    return function(fea) {
      return F8.map(fea, mapLeft3(f16));
    };
  };
}
function match12(F8) {
  return function(onLeft, onRight, onBoth) {
    return function(ma3) {
      return F8.map(ma3, match11(onLeft, onRight, onBoth));
    };
  };
}
function matchE9(M8) {
  return function(onLeft, onRight, onBoth) {
    return function(ma3) {
      return M8.chain(ma3, match11(onLeft, onRight, onBoth));
    };
  };
}
function swap8(F8) {
  return function(ma3) {
    return F8.map(ma3, swap7);
  };
}
function toTuple23(F8) {
  return function(e11, a6) {
    return function(fa3) {
      return F8.map(fa3, toTuple22(e11, a6));
    };
  };
}

// node_modules/fp-ts/es6/TaskThese.js
var left12 = left11(Pointed8);
var right12 = right11(Pointed8);
var both3 = both2(Pointed8);
var rightTask4 = rightF2(Functor19);
var leftTask3 = leftF2(Functor19);
var rightIO5 = flow(fromIO4, rightTask4);
var leftIO4 = flow(fromIO4, leftTask3);
var fromEither12 = of17;
var fromThese = of17;
var fromIO10 = rightIO5;
var fromTask6 = rightTask4;
var match13 = match12(Functor19);
var matchE10 = matchE9(Monad4);
var swap9 = swap8(Functor19);
var _map30 = function(fa3, f16) {
  return pipe(fa3, map32(f16));
};
var map32 = map31(Functor19);
var bimap5 = bimap4(Functor19);
var mapLeft5 = mapLeft4(Functor19);
var of25 = right12;
var URI30 = "TaskThese";
var Functor30 = {
  URI: URI30,
  map: _map30
};
var flap31 = flap(Functor30);
var FromEither13 = {
  URI: URI30,
  fromEither: fromEither12
};
var fromOption9 = fromOption(FromEither13);
var fromOptionK12 = fromOptionK(FromEither13);
var fromPredicate13 = fromPredicate(FromEither13);
var FromThese = {
  URI: URI30,
  fromThese
};
var fromTheseK2 = fromTheseK(FromThese);
var FromIO10 = {
  URI: URI30,
  fromIO: fromIO10
};
var fromIOK11 = fromIOK(FromIO10);
var FromTask6 = {
  URI: URI30,
  fromIO: fromIO10,
  fromTask: fromTask6
};
var fromTaskK7 = fromTaskK(FromTask6);
var toTuple24 = toTuple23(Functor19);
var ApT15 = of25(emptyReadonlyArray);

// node_modules/fp-ts/es6/Traced.js
var _map31 = function(fa3, f16) {
  return pipe(fa3, map33(f16));
};
var map33 = function(f16) {
  return function(fa3) {
    return function(p9) {
      return f16(fa3(p9));
    };
  };
};
var URI31 = "Traced";
var Functor31 = {
  URI: URI31,
  map: _map31
};
var flap32 = flap(Functor31);

// node_modules/fp-ts/es6/Tree.js
function make(value2, forest) {
  if (forest === void 0) {
    forest = [];
  }
  return {
    value: value2,
    forest
  };
}
var _map32 = function(fa3, f16) {
  return pipe(fa3, map34(f16));
};
var _ap17 = function(fab, fa3) {
  return flatMap25(fab, function(f16) {
    return pipe(fa3, map34(f16));
  });
};
var flatMap25 = dual(2, function(ma3, f16) {
  var _a14 = f16(ma3.value), value2 = _a14.value, forest = _a14.forest;
  var concat9 = getMonoid2().concat;
  return {
    value: value2,
    forest: concat9(forest, ma3.forest.map(flatMap25(f16)))
  };
});
var extend11 = function(f16) {
  return function(wa3) {
    return {
      value: f16(wa3),
      forest: wa3.forest.map(extend11(f16))
    };
  };
};
var duplicate10 = extend11(identity);
var flatten12 = flatMap25(identity);
var map34 = function(f16) {
  return function(fa3) {
    return {
      value: f16(fa3.value),
      forest: fa3.forest.map(map34(f16))
    };
  };
};
var of26 = function(a6) {
  return make(a6);
};
var URI32 = "Tree";
var Functor32 = {
  URI: URI32,
  map: _map32
};
var flap33 = flap(Functor32);
var Apply15 = {
  URI: URI32,
  map: _map32,
  ap: _ap17
};
var apFirst22 = apFirst(Apply15);
var apSecond22 = apSecond(Apply15);
var Chain21 = {
  URI: URI32,
  map: _map32,
  ap: _ap17,
  chain: flatMap25
};
var chainFirst7 = chainFirst(Chain21);
var Do21 = of26(emptyRecord);
var bindTo22 = bindTo(Functor32);
var let_21 = let_(Functor32);
var bind23 = bind2(Chain21);
var apS22 = apS(Apply15);

// node_modules/fp-ts/es6/Tuple.js
var fst2 = fst;
var snd2 = snd;
var _map33 = function(fa3, f16) {
  return pipe(fa3, mapFst2(f16));
};
var mapFst2 = function(f16) {
  return function(fa3) {
    return [f16(fst2(fa3)), snd2(fa3)];
  };
};
var extend12 = function(f16) {
  return function(wa3) {
    return [f16(wa3), snd2(wa3)];
  };
};
var duplicate11 = extend12(identity);
var URI33 = "Tuple";
var Functor33 = {
  URI: URI33,
  map: _map33
};
var flap34 = flap(Functor33);

// node_modules/fp-ts/es6/void.js
var Semigroup3 = constant2(void 0);
var Monoid3 = {
  concat: Semigroup3.concat,
  empty: void 0
};

// node_modules/fp-ts/es6/Writer.js
var _map34 = function(fa3, f16) {
  return pipe(fa3, map35(f16));
};
var map35 = function(f16) {
  return function(fa3) {
    return function() {
      var _a14 = fa3(), a6 = _a14[0], w8 = _a14[1];
      return [f16(a6), w8];
    };
  };
};
var URI34 = "Writer";
var Functor34 = {
  URI: URI34,
  map: _map34
};
var flap35 = flap(Functor34);

// node_modules/io-ts/es6/index.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d7, b6) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d8, b7) {
      d8.__proto__ = b7;
    } || function(d8, b7) {
      for (var p9 in b7) if (Object.prototype.hasOwnProperty.call(b7, p9)) d8[p9] = b7[p9];
    };
    return extendStatics(d7, b6);
  };
  return function(d7, b6) {
    if (typeof b6 !== "function" && b6 !== null)
      throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
    extendStatics(d7, b6);
    function __() {
      this.constructor = d7;
    }
    d7.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t6) {
    for (var s5, i9 = 1, n5 = arguments.length; i9 < n5; i9++) {
      s5 = arguments[i9];
      for (var p9 in s5) if (Object.prototype.hasOwnProperty.call(s5, p9))
        t6[p9] = s5[p9];
    }
    return t6;
  };
  return __assign.apply(this, arguments);
};
var failures = left3;
var failure = function(value2, context, message) {
  return failures([{ value: value2, context, message }]);
};
var success = right3;
var Type = (
  /** @class */
  function() {
    function Type2(name, is3, validate22, encode20) {
      this.name = name;
      this.is = is3;
      this.validate = validate22;
      this.encode = encode20;
      this.decode = this.decode.bind(this);
    }
    Type2.prototype.pipe = function(ab, name) {
      var _this = this;
      if (name === void 0) {
        name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
      }
      return new Type2(name, ab.is, function(i9, c9) {
        var e11 = _this.validate(i9, c9);
        if (isLeft2(e11)) {
          return e11;
        }
        return ab.validate(e11.right, c9);
      }, this.encode === identity2 && ab.encode === identity2 ? identity2 : function(b6) {
        return _this.encode(ab.encode(b6));
      });
    };
    Type2.prototype.asDecoder = function() {
      return this;
    };
    Type2.prototype.asEncoder = function() {
      return this;
    };
    Type2.prototype.decode = function(i9) {
      return this.validate(i9, [{ key: "", type: this, actual: i9 }]);
    };
    return Type2;
  }()
);
var identity2 = function(a6) {
  return a6;
};
function getFunctionName(f16) {
  return f16.displayName || f16.name || "<function".concat(f16.length, ">");
}
function appendContext(c9, key, decoder4, actual) {
  var len = c9.length;
  var r8 = Array(len + 1);
  for (var i9 = 0; i9 < len; i9++) {
    r8[i9] = c9[i9];
  }
  r8[len] = { key, type: decoder4, actual };
  return r8;
}
function pushAll(xs4, ys4) {
  var l9 = ys4.length;
  for (var i9 = 0; i9 < l9; i9++) {
    xs4.push(ys4[i9]);
  }
}
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
function getNameFromProps(props) {
  return Object.keys(props).map(function(k11) {
    return "".concat(k11, ": ").concat(props[k11].name);
  }).join(", ");
}
function useIdentity(codecs) {
  for (var i9 = 0; i9 < codecs.length; i9++) {
    if (codecs[i9].encode !== identity2) {
      return false;
    }
  }
  return true;
}
function getInterfaceTypeName(props) {
  return "{ ".concat(getNameFromProps(props), " }");
}
function getPartialTypeName(inner) {
  return "Partial<".concat(inner, ">");
}
function getUnionName(codecs) {
  return "(" + codecs.map(function(type7) {
    return type7.name;
  }).join(" | ") + ")";
}
function mergeAll(base4, us3) {
  var equal = true;
  var primitive = true;
  var baseIsNotADictionary = !UnknownRecord.is(base4);
  for (var _i4 = 0, us_1 = us3; _i4 < us_1.length; _i4++) {
    var u10 = us_1[_i4];
    if (u10 !== base4) {
      equal = false;
    }
    if (UnknownRecord.is(u10)) {
      primitive = false;
    }
  }
  if (equal) {
    return base4;
  } else if (primitive) {
    return us3[us3.length - 1];
  }
  var r8 = {};
  for (var _a14 = 0, us_2 = us3; _a14 < us_2.length; _a14++) {
    var u10 = us_2[_a14];
    for (var k11 in u10) {
      if (!hasOwnProperty3.call(r8, k11) || baseIsNotADictionary || u10[k11] !== base4[k11]) {
        r8[k11] = u10[k11];
      }
    }
  }
  return r8;
}
function isNonEmpty4(as17) {
  return as17.length > 0;
}
var emptyTags = {};
function intersect(a6, b6) {
  var r8 = [];
  for (var _i4 = 0, a_1 = a6; _i4 < a_1.length; _i4++) {
    var v9 = a_1[_i4];
    if (b6.indexOf(v9) !== -1) {
      r8.push(v9);
    }
  }
  return r8;
}
function mergeTags(a6, b6) {
  if (a6 === emptyTags) {
    return b6;
  }
  if (b6 === emptyTags) {
    return a6;
  }
  var r8 = Object.assign({}, a6);
  for (var k11 in b6) {
    if (hasOwnProperty3.call(a6, k11)) {
      var intersection_1 = intersect(a6[k11], b6[k11]);
      if (isNonEmpty4(intersection_1)) {
        r8[k11] = intersection_1;
      } else {
        r8 = emptyTags;
        break;
      }
    } else {
      r8[k11] = b6[k11];
    }
  }
  return r8;
}
function intersectTags(a6, b6) {
  if (a6 === emptyTags || b6 === emptyTags) {
    return emptyTags;
  }
  var r8 = emptyTags;
  for (var k11 in a6) {
    if (hasOwnProperty3.call(b6, k11)) {
      var intersection_2 = intersect(a6[k11], b6[k11]);
      if (intersection_2.length === 0) {
        if (r8 === emptyTags) {
          r8 = {};
        }
        r8[k11] = a6[k11].concat(b6[k11]);
      }
    }
  }
  return r8;
}
function isLiteralC(codec) {
  return codec._tag === "LiteralType";
}
function isTypeC(codec) {
  return codec._tag === "InterfaceType";
}
function isStrictC(codec) {
  return codec._tag === "StrictType";
}
function isExactC(codec) {
  return codec._tag === "ExactType";
}
function isRefinementC(codec) {
  return codec._tag === "RefinementType";
}
function isIntersectionC(codec) {
  return codec._tag === "IntersectionType";
}
function isUnionC(codec) {
  return codec._tag === "UnionType";
}
function isRecursiveC(codec) {
  return codec._tag === "RecursiveType";
}
function isReadonlyC(codec) {
  return codec._tag === "ReadonlyType";
}
var lazyCodecs = [];
function getTags(codec) {
  if (lazyCodecs.indexOf(codec) !== -1) {
    return emptyTags;
  }
  if (isTypeC(codec) || isStrictC(codec)) {
    var index2 = emptyTags;
    for (var k11 in codec.props) {
      var prop = codec.props[k11];
      if (isLiteralC(prop)) {
        if (index2 === emptyTags) {
          index2 = {};
        }
        index2[k11] = [prop.value];
      }
    }
    return index2;
  } else if (isExactC(codec) || isRefinementC(codec) || isReadonlyC(codec)) {
    return getTags(codec.type);
  } else if (isIntersectionC(codec)) {
    return codec.types.reduce(function(tags2, codec2) {
      return mergeTags(tags2, getTags(codec2));
    }, emptyTags);
  } else if (isUnionC(codec)) {
    return codec.types.slice(1).reduce(function(tags2, codec2) {
      return intersectTags(tags2, getTags(codec2));
    }, getTags(codec.types[0]));
  } else if (isRecursiveC(codec)) {
    lazyCodecs.push(codec);
    var tags = getTags(codec.type);
    lazyCodecs.pop();
    return tags;
  }
  return emptyTags;
}
function getIndex(codecs) {
  var tags = getTags(codecs[0]);
  var keys5 = Object.keys(tags);
  var len = codecs.length;
  var _loop_1 = function(k12) {
    var all5 = tags[k12].slice();
    var index2 = [tags[k12]];
    for (var i9 = 1; i9 < len; i9++) {
      var codec = codecs[i9];
      var ctags = getTags(codec);
      var values = ctags[k12];
      if (values === void 0) {
        return "continue-keys";
      } else {
        if (values.some(function(v9) {
          return all5.indexOf(v9) !== -1;
        })) {
          return "continue-keys";
        } else {
          all5.push.apply(all5, values);
          index2.push(values);
        }
      }
    }
    return { value: [k12, index2] };
  };
  keys: for (var _i4 = 0, keys_1 = keys5; _i4 < keys_1.length; _i4++) {
    var k11 = keys_1[_i4];
    var state_1 = _loop_1(k11);
    if (typeof state_1 === "object")
      return state_1.value;
    switch (state_1) {
      case "continue-keys":
        continue keys;
    }
  }
  return void 0;
}
var NullType = (
  /** @class */
  function(_super) {
    __extends(NullType2, _super);
    function NullType2() {
      var _this = _super.call(this, "null", function(u10) {
        return u10 === null;
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "NullType";
      return _this;
    }
    return NullType2;
  }(Type)
);
var nullType = new NullType();
var UndefinedType = (
  /** @class */
  function(_super) {
    __extends(UndefinedType2, _super);
    function UndefinedType2() {
      var _this = _super.call(this, "undefined", function(u10) {
        return u10 === void 0;
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "UndefinedType";
      return _this;
    }
    return UndefinedType2;
  }(Type)
);
var undefinedType = new UndefinedType();
var VoidType = (
  /** @class */
  function(_super) {
    __extends(VoidType2, _super);
    function VoidType2() {
      var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, identity2) || this;
      _this._tag = "VoidType";
      return _this;
    }
    return VoidType2;
  }(Type)
);
var voidType = new VoidType();
var UnknownType = (
  /** @class */
  function(_super) {
    __extends(UnknownType2, _super);
    function UnknownType2() {
      var _this = _super.call(this, "unknown", function(_6) {
        return true;
      }, success, identity2) || this;
      _this._tag = "UnknownType";
      return _this;
    }
    return UnknownType2;
  }(Type)
);
var unknown = new UnknownType();
var StringType = (
  /** @class */
  function(_super) {
    __extends(StringType2, _super);
    function StringType2() {
      var _this = _super.call(this, "string", function(u10) {
        return typeof u10 === "string";
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "StringType";
      return _this;
    }
    return StringType2;
  }(Type)
);
var string2 = new StringType();
var NumberType = (
  /** @class */
  function(_super) {
    __extends(NumberType2, _super);
    function NumberType2() {
      var _this = _super.call(this, "number", function(u10) {
        return typeof u10 === "number";
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "NumberType";
      return _this;
    }
    return NumberType2;
  }(Type)
);
var number = new NumberType();
var BigIntType = (
  /** @class */
  function(_super) {
    __extends(BigIntType2, _super);
    function BigIntType2() {
      var _this = _super.call(
        this,
        "bigint",
        // tslint:disable-next-line: valid-typeof
        function(u10) {
          return typeof u10 === "bigint";
        },
        function(u10, c9) {
          return _this.is(u10) ? success(u10) : failure(u10, c9);
        },
        identity2
      ) || this;
      _this._tag = "BigIntType";
      return _this;
    }
    return BigIntType2;
  }(Type)
);
var bigint = new BigIntType();
var BooleanType = (
  /** @class */
  function(_super) {
    __extends(BooleanType2, _super);
    function BooleanType2() {
      var _this = _super.call(this, "boolean", function(u10) {
        return typeof u10 === "boolean";
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "BooleanType";
      return _this;
    }
    return BooleanType2;
  }(Type)
);
var boolean = new BooleanType();
var AnyArrayType = (
  /** @class */
  function(_super) {
    __extends(AnyArrayType2, _super);
    function AnyArrayType2() {
      var _this = _super.call(this, "UnknownArray", Array.isArray, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "AnyArrayType";
      return _this;
    }
    return AnyArrayType2;
  }(Type)
);
var UnknownArray = new AnyArrayType();
var AnyDictionaryType = (
  /** @class */
  function(_super) {
    __extends(AnyDictionaryType2, _super);
    function AnyDictionaryType2() {
      var _this = _super.call(this, "UnknownRecord", function(u10) {
        return u10 !== null && typeof u10 === "object" && !Array.isArray(u10);
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "AnyDictionaryType";
      return _this;
    }
    return AnyDictionaryType2;
  }(Type)
);
var UnknownRecord = new AnyDictionaryType();
var LiteralType = (
  /** @class */
  function(_super) {
    __extends(LiteralType2, _super);
    function LiteralType2(name, is3, validate22, encode20, value2) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.value = value2;
      _this._tag = "LiteralType";
      return _this;
    }
    return LiteralType2;
  }(Type)
);
function literal(value2, name) {
  if (name === void 0) {
    name = JSON.stringify(value2);
  }
  var is3 = function(u10) {
    return u10 === value2;
  };
  return new LiteralType(name, is3, function(u10, c9) {
    return is3(u10) ? success(value2) : failure(u10, c9);
  }, identity2, value2);
}
var KeyofType = (
  /** @class */
  function(_super) {
    __extends(KeyofType2, _super);
    function KeyofType2(name, is3, validate22, encode20, keys5) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.keys = keys5;
      _this._tag = "KeyofType";
      return _this;
    }
    return KeyofType2;
  }(Type)
);
var RefinementType = (
  /** @class */
  function(_super) {
    __extends(RefinementType2, _super);
    function RefinementType2(name, is3, validate22, encode20, type7, predicate) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.type = type7;
      _this.predicate = predicate;
      _this._tag = "RefinementType";
      return _this;
    }
    return RefinementType2;
  }(Type)
);
function brand(codec, predicate, name) {
  return refinement(codec, predicate, name);
}
var Int = brand(number, function(n5) {
  return Number.isInteger(n5);
}, "Int");
var RecursiveType = (
  /** @class */
  function(_super) {
    __extends(RecursiveType2, _super);
    function RecursiveType2(name, is3, validate22, encode20, runDefinition) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.runDefinition = runDefinition;
      _this._tag = "RecursiveType";
      return _this;
    }
    return RecursiveType2;
  }(Type)
);
Object.defineProperty(RecursiveType.prototype, "type", {
  get: function() {
    return this.runDefinition();
  },
  enumerable: true,
  configurable: true
});
var ArrayType = (
  /** @class */
  function(_super) {
    __extends(ArrayType2, _super);
    function ArrayType2(name, is3, validate22, encode20, type7) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.type = type7;
      _this._tag = "ArrayType";
      return _this;
    }
    return ArrayType2;
  }(Type)
);
var InterfaceType = (
  /** @class */
  function(_super) {
    __extends(InterfaceType2, _super);
    function InterfaceType2(name, is3, validate22, encode20, props) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.props = props;
      _this._tag = "InterfaceType";
      return _this;
    }
    return InterfaceType2;
  }(Type)
);
function type6(props, name) {
  if (name === void 0) {
    name = getInterfaceTypeName(props);
  }
  var keys5 = Object.keys(props);
  var types2 = keys5.map(function(key) {
    return props[key];
  });
  var len = keys5.length;
  return new InterfaceType(name, function(u10) {
    if (UnknownRecord.is(u10)) {
      for (var i9 = 0; i9 < len; i9++) {
        var k11 = keys5[i9];
        var uk = u10[k11];
        if (uk === void 0 && !hasOwnProperty3.call(u10, k11) || !types2[i9].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u10, c9) {
    var e11 = UnknownRecord.validate(u10, c9);
    if (isLeft2(e11)) {
      return e11;
    }
    var o6 = e11.right;
    var a6 = o6;
    var errors = [];
    for (var i9 = 0; i9 < len; i9++) {
      var k11 = keys5[i9];
      var ak = a6[k11];
      var type_1 = types2[i9];
      var result = type_1.validate(ak, appendContext(c9, k11, type_1, ak));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        var vak = result.right;
        if (vak !== ak || vak === void 0 && !hasOwnProperty3.call(a6, k11)) {
          if (a6 === o6) {
            a6 = __assign({}, o6);
          }
          a6[k11] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a6);
  }, useIdentity(types2) ? identity2 : function(a6) {
    var s5 = __assign({}, a6);
    for (var i9 = 0; i9 < len; i9++) {
      var k11 = keys5[i9];
      var encode20 = types2[i9].encode;
      if (encode20 !== identity2) {
        s5[k11] = encode20(a6[k11]);
      }
    }
    return s5;
  }, props);
}
var PartialType = (
  /** @class */
  function(_super) {
    __extends(PartialType2, _super);
    function PartialType2(name, is3, validate22, encode20, props) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.props = props;
      _this._tag = "PartialType";
      return _this;
    }
    return PartialType2;
  }(Type)
);
function partial(props, name) {
  if (name === void 0) {
    name = getPartialTypeName(getInterfaceTypeName(props));
  }
  var keys5 = Object.keys(props);
  var types2 = keys5.map(function(key) {
    return props[key];
  });
  var len = keys5.length;
  return new PartialType(name, function(u10) {
    if (UnknownRecord.is(u10)) {
      for (var i9 = 0; i9 < len; i9++) {
        var k11 = keys5[i9];
        var uk = u10[k11];
        if (uk !== void 0 && !props[k11].is(uk)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }, function(u10, c9) {
    var e11 = UnknownRecord.validate(u10, c9);
    if (isLeft2(e11)) {
      return e11;
    }
    var o6 = e11.right;
    var a6 = o6;
    var errors = [];
    for (var i9 = 0; i9 < len; i9++) {
      var k11 = keys5[i9];
      var ak = a6[k11];
      var type_2 = props[k11];
      var result = type_2.validate(ak, appendContext(c9, k11, type_2, ak));
      if (isLeft2(result)) {
        if (ak !== void 0) {
          pushAll(errors, result.left);
        }
      } else {
        var vak = result.right;
        if (vak !== ak) {
          if (a6 === o6) {
            a6 = __assign({}, o6);
          }
          a6[k11] = vak;
        }
      }
    }
    return errors.length > 0 ? failures(errors) : success(a6);
  }, useIdentity(types2) ? identity2 : function(a6) {
    var s5 = __assign({}, a6);
    for (var i9 = 0; i9 < len; i9++) {
      var k11 = keys5[i9];
      var ak = a6[k11];
      if (ak !== void 0) {
        s5[k11] = types2[i9].encode(ak);
      }
    }
    return s5;
  }, props);
}
var DictionaryType = (
  /** @class */
  function(_super) {
    __extends(DictionaryType2, _super);
    function DictionaryType2(name, is3, validate22, encode20, domain, codomain) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.domain = domain;
      _this.codomain = codomain;
      _this._tag = "DictionaryType";
      return _this;
    }
    return DictionaryType2;
  }(Type)
);
var UnionType = (
  /** @class */
  function(_super) {
    __extends(UnionType2, _super);
    function UnionType2(name, is3, validate22, encode20, types2) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.types = types2;
      _this._tag = "UnionType";
      return _this;
    }
    return UnionType2;
  }(Type)
);
function union5(codecs, name) {
  if (name === void 0) {
    name = getUnionName(codecs);
  }
  var index2 = getIndex(codecs);
  if (index2 !== void 0 && codecs.length > 0) {
    var tag_1 = index2[0], groups_1 = index2[1];
    var len_1 = groups_1.length;
    var find_1 = function(value2) {
      for (var i9 = 0; i9 < len_1; i9++) {
        if (groups_1[i9].indexOf(value2) !== -1) {
          return i9;
        }
      }
      return void 0;
    };
    return new TaggedUnionType(name, function(u10) {
      if (UnknownRecord.is(u10)) {
        var i9 = find_1(u10[tag_1]);
        return i9 !== void 0 ? codecs[i9].is(u10) : false;
      }
      return false;
    }, function(u10, c9) {
      var e11 = UnknownRecord.validate(u10, c9);
      if (isLeft2(e11)) {
        return e11;
      }
      var r8 = e11.right;
      var i9 = find_1(r8[tag_1]);
      if (i9 === void 0) {
        return failure(u10, c9);
      }
      var codec = codecs[i9];
      return codec.validate(r8, appendContext(c9, String(i9), codec, r8));
    }, useIdentity(codecs) ? identity2 : function(a6) {
      var i9 = find_1(a6[tag_1]);
      if (i9 === void 0) {
        throw new Error("no codec found to encode value in union codec ".concat(name));
      } else {
        return codecs[i9].encode(a6);
      }
    }, codecs, tag_1);
  } else {
    return new UnionType(name, function(u10) {
      return codecs.some(function(type7) {
        return type7.is(u10);
      });
    }, function(u10, c9) {
      var errors = [];
      for (var i9 = 0; i9 < codecs.length; i9++) {
        var codec = codecs[i9];
        var result = codec.validate(u10, appendContext(c9, String(i9), codec, u10));
        if (isLeft2(result)) {
          pushAll(errors, result.left);
        } else {
          return success(result.right);
        }
      }
      return failures(errors);
    }, useIdentity(codecs) ? identity2 : function(a6) {
      for (var _i4 = 0, codecs_1 = codecs; _i4 < codecs_1.length; _i4++) {
        var codec = codecs_1[_i4];
        if (codec.is(a6)) {
          return codec.encode(a6);
        }
      }
      throw new Error("no codec found to encode value in union type ".concat(name));
    }, codecs);
  }
}
var IntersectionType = (
  /** @class */
  function(_super) {
    __extends(IntersectionType2, _super);
    function IntersectionType2(name, is3, validate22, encode20, types2) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.types = types2;
      _this._tag = "IntersectionType";
      return _this;
    }
    return IntersectionType2;
  }(Type)
);
function intersection3(codecs, name) {
  if (name === void 0) {
    name = "(".concat(codecs.map(function(type7) {
      return type7.name;
    }).join(" & "), ")");
  }
  var len = codecs.length;
  return new IntersectionType(name, function(u10) {
    return codecs.every(function(type7) {
      return type7.is(u10);
    });
  }, codecs.length === 0 ? success : function(u10, c9) {
    var us3 = [];
    var errors = [];
    for (var i9 = 0; i9 < len; i9++) {
      var codec = codecs[i9];
      var result = codec.validate(u10, appendContext(c9, String(i9), codec, u10));
      if (isLeft2(result)) {
        pushAll(errors, result.left);
      } else {
        us3.push(result.right);
      }
    }
    return errors.length > 0 ? failures(errors) : success(mergeAll(u10, us3));
  }, codecs.length === 0 ? identity2 : function(a6) {
    return mergeAll(a6, codecs.map(function(codec) {
      return codec.encode(a6);
    }));
  }, codecs);
}
var TupleType = (
  /** @class */
  function(_super) {
    __extends(TupleType2, _super);
    function TupleType2(name, is3, validate22, encode20, types2) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.types = types2;
      _this._tag = "TupleType";
      return _this;
    }
    return TupleType2;
  }(Type)
);
var ReadonlyType = (
  /** @class */
  function(_super) {
    __extends(ReadonlyType2, _super);
    function ReadonlyType2(name, is3, validate22, encode20, type7) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.type = type7;
      _this._tag = "ReadonlyType";
      return _this;
    }
    return ReadonlyType2;
  }(Type)
);
var ReadonlyArrayType = (
  /** @class */
  function(_super) {
    __extends(ReadonlyArrayType2, _super);
    function ReadonlyArrayType2(name, is3, validate22, encode20, type7) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.type = type7;
      _this._tag = "ReadonlyArrayType";
      return _this;
    }
    return ReadonlyArrayType2;
  }(Type)
);
var ExactType = (
  /** @class */
  function(_super) {
    __extends(ExactType2, _super);
    function ExactType2(name, is3, validate22, encode20, type7) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.type = type7;
      _this._tag = "ExactType";
      return _this;
    }
    return ExactType2;
  }(Type)
);
var FunctionType = (
  /** @class */
  function(_super) {
    __extends(FunctionType2, _super);
    function FunctionType2() {
      var _this = _super.call(
        this,
        "Function",
        // tslint:disable-next-line:strict-type-predicates
        function(u10) {
          return typeof u10 === "function";
        },
        function(u10, c9) {
          return _this.is(u10) ? success(u10) : failure(u10, c9);
        },
        identity2
      ) || this;
      _this._tag = "FunctionType";
      return _this;
    }
    return FunctionType2;
  }(Type)
);
var Function2 = new FunctionType();
var NeverType = (
  /** @class */
  function(_super) {
    __extends(NeverType2, _super);
    function NeverType2() {
      var _this = _super.call(
        this,
        "never",
        function(_6) {
          return false;
        },
        function(u10, c9) {
          return failure(u10, c9);
        },
        /* istanbul ignore next */
        function() {
          throw new Error("cannot encode never");
        }
      ) || this;
      _this._tag = "NeverType";
      return _this;
    }
    return NeverType2;
  }(Type)
);
var never = new NeverType();
var AnyType = (
  /** @class */
  function(_super) {
    __extends(AnyType2, _super);
    function AnyType2() {
      var _this = _super.call(this, "any", function(_6) {
        return true;
      }, success, identity2) || this;
      _this._tag = "AnyType";
      return _this;
    }
    return AnyType2;
  }(Type)
);
var any = new AnyType();
function refinement(codec, predicate, name) {
  if (name === void 0) {
    name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
  }
  return new RefinementType(name, function(u10) {
    return codec.is(u10) && predicate(u10);
  }, function(i9, c9) {
    var e11 = codec.validate(i9, c9);
    if (isLeft2(e11)) {
      return e11;
    }
    var a6 = e11.right;
    return predicate(a6) ? success(a6) : failure(a6, c9);
  }, codec.encode, codec, predicate);
}
var Integer = refinement(number, Number.isInteger, "Integer");
var TaggedUnionType = (
  /** @class */
  function(_super) {
    __extends(TaggedUnionType2, _super);
    function TaggedUnionType2(name, is3, validate22, encode20, codecs, tag) {
      var _this = _super.call(this, name, is3, validate22, encode20, codecs) || this;
      _this.tag = tag;
      return _this;
    }
    return TaggedUnionType2;
  }(UnionType)
);
var ObjectType = (
  /** @class */
  function(_super) {
    __extends(ObjectType2, _super);
    function ObjectType2() {
      var _this = _super.call(this, "object", function(u10) {
        return u10 !== null && typeof u10 === "object";
      }, function(u10, c9) {
        return _this.is(u10) ? success(u10) : failure(u10, c9);
      }, identity2) || this;
      _this._tag = "ObjectType";
      return _this;
    }
    return ObjectType2;
  }(Type)
);
var object = new ObjectType();
var StrictType = (
  /** @class */
  function(_super) {
    __extends(StrictType2, _super);
    function StrictType2(name, is3, validate22, encode20, props) {
      var _this = _super.call(this, name, is3, validate22, encode20) || this;
      _this.props = props;
      _this._tag = "StrictType";
      return _this;
    }
    return StrictType2;
  }(Type)
);

// node_modules/@dynamic-labs/waas/node_modules/@noble/hashes/utils.js
function isBytes6(a6) {
  return a6 instanceof Uint8Array || ArrayBuffer.isView(a6) && a6.constructor.name === "Uint8Array";
}
function anumber4(n5, title = "") {
  if (!Number.isSafeInteger(n5) || n5 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n5}`);
  }
}
function abytes5(value2, length, title = "") {
  const bytes2 = isBytes6(value2);
  const len = value2 == null ? void 0 : value2.length;
  const needsLen = length !== void 0;
  if (!bytes2 || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function ahash3(h9) {
  if (typeof h9 !== "function" || typeof h9.create !== "function")
    throw new Error("Hash must wrapped by utils.createHasher");
  anumber4(h9.outputLen);
  anumber4(h9.blockLen);
}
function aexists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput3(out, instance) {
  abytes5(out, void 0, "digestInto() output");
  const min4 = instance.outputLen;
  if (out.length < min4) {
    throw new Error('"digestInto() output" expected to be of length >=' + min4);
  }
}
function clean2(...arrays) {
  for (let i9 = 0; i9 < arrays.length; i9++) {
    arrays[i9].fill(0);
  }
}
function createView3(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE2 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin2 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes4 = Array.from({ length: 256 }, (_6, i9) => i9.toString(16).padStart(2, "0"));
function bytesToHex5(bytes2) {
  abytes5(bytes2);
  if (hasHexBuiltin2)
    return bytes2.toHex();
  let hex2 = "";
  for (let i9 = 0; i9 < bytes2.length; i9++) {
    hex2 += hexes4[bytes2[i9]];
  }
  return hex2;
}
var asciis2 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase162(ch2) {
  if (ch2 >= asciis2._0 && ch2 <= asciis2._9)
    return ch2 - asciis2._0;
  if (ch2 >= asciis2.A && ch2 <= asciis2.F)
    return ch2 - (asciis2.A - 10);
  if (ch2 >= asciis2.a && ch2 <= asciis2.f)
    return ch2 - (asciis2.a - 10);
  return;
}
function hexToBytes5(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex2);
  const hl2 = hex2.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl2);
  const array = new Uint8Array(al2);
  for (let ai5 = 0, hi5 = 0; ai5 < al2; ai5++, hi5 += 2) {
    const n1 = asciiToBase162(hex2.charCodeAt(hi5));
    const n22 = asciiToBase162(hex2.charCodeAt(hi5 + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi5] + hex2[hi5 + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi5);
    }
    array[ai5] = n1 * 16 + n22;
  }
  return array;
}
function createHasher4(hashCons, info = {}) {
  const hashC = (msg, opts2) => hashCons(opts2).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts2) => hashCons(opts2);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes3(bytesLength = 32) {
  const cr4 = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr4 == null ? void 0 : cr4.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr4.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/bind.js
function bind24(fn4, thisArg) {
  return function wrap() {
    return fn4.apply(thisArg, arguments);
  };
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/utils.js
var { toString: toString10 } = Object.prototype;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var { iterator: iterator2, toStringTag: toStringTag2 } = Symbol;
var kindOf2 = /* @__PURE__ */ ((cache2) => (thing) => {
  const str = toString10.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest2 = (type7) => {
  type7 = type7.toLowerCase();
  return (thing) => kindOf2(thing) === type7;
};
var typeOfTest2 = (type7) => (thing) => typeof thing === type7;
var { isArray: isArray2 } = Array;
var isUndefined2 = typeOfTest2("undefined");
function isBuffer2(val) {
  return val !== null && !isUndefined2(val) && val.constructor !== null && !isUndefined2(val.constructor) && isFunction3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer2 = kindOfTest2("ArrayBuffer");
function isArrayBufferView2(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer2(val.buffer);
  }
  return result;
}
var isString2 = typeOfTest2("string");
var isFunction3 = typeOfTest2("function");
var isNumber2 = typeOfTest2("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean2 = (thing) => thing === true || thing === false;
var isPlainObject2 = (val) => {
  if (kindOf2(val) !== "object") {
    return false;
  }
  const prototype5 = getPrototypeOf2(val);
  return (prototype5 === null || prototype5 === Object.prototype || Object.getPrototypeOf(prototype5) === null) && !(toStringTag2 in val) && !(iterator2 in val);
};
var isDate2 = kindOfTest2("Date");
var isFile2 = kindOfTest2("File");
var isBlob2 = kindOfTest2("Blob");
var isFileList2 = kindOfTest2("FileList");
var isStream2 = (val) => isObject2(val) && isFunction3(val.pipe);
var isFormData2 = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction3(thing.append) && ((kind = kindOf2(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction3(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams2 = kindOfTest2("URLSearchParams");
var [isReadableStream2, isRequest2, isResponse2, isHeaders2] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest2);
var trim6 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach2(obj, fn4, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i9;
  let l9;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray2(obj)) {
    for (i9 = 0, l9 = obj.length; i9 < l9; i9++) {
      fn4.call(null, obj[i9], i9, obj);
    }
  } else {
    const keys5 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys5.length;
    let key;
    for (i9 = 0; i9 < len; i9++) {
      key = keys5[i9];
      fn4.call(null, obj[key], key, obj);
    }
  }
}
function findKey2(obj, key) {
  key = key.toLowerCase();
  const keys5 = Object.keys(obj);
  let i9 = keys5.length;
  let _key;
  while (i9-- > 0) {
    _key = keys5[i9];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global2 = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined2 = (context) => !isUndefined2(context) && context !== _global2;
function merge2() {
  const { caseless } = isContextDefined2(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey2(result, key) || key;
    if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
      result[targetKey] = merge2(result[targetKey], val);
    } else if (isPlainObject2(val)) {
      result[targetKey] = merge2({}, val);
    } else if (isArray2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i9 = 0, l9 = arguments.length; i9 < l9; i9++) {
    arguments[i9] && forEach2(arguments[i9], assignValue);
  }
  return result;
}
var extend13 = (a6, b6, thisArg, { allOwnKeys } = {}) => {
  forEach2(b6, (val, key) => {
    if (thisArg && isFunction3(val)) {
      a6[key] = bind24(val, thisArg);
    } else {
      a6[key] = val;
    }
  }, { allOwnKeys });
  return a6;
};
var stripBOM2 = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits2 = (constructor, superConstructor, props, descriptors3) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors3);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject2 = (sourceObj, destObj, filter10, propFilter) => {
  let props;
  let i9;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i9 = props.length;
    while (i9-- > 0) {
      prop = props[i9];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter10 !== false && getPrototypeOf2(sourceObj);
  } while (sourceObj && (!filter10 || filter10(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith2 = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray3 = (thing) => {
  if (!thing) return null;
  if (isArray2(thing)) return thing;
  let i9 = thing.length;
  if (!isNumber2(i9)) return null;
  const arr = new Array(i9);
  while (i9-- > 0) {
    arr[i9] = thing[i9];
  }
  return arr;
};
var isTypedArray2 = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf2(Uint8Array));
var forEachEntry2 = (obj, fn4) => {
  const generator = obj && obj[iterator2];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn4.call(obj, pair[0], pair[1]);
  }
};
var matchAll2 = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm2 = kindOfTest2("HTMLFormElement");
var toCamelCase2 = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m6, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty4 = (({ hasOwnProperty: hasOwnProperty7 }) => (obj, prop) => hasOwnProperty7.call(obj, prop))(Object.prototype);
var isRegExp2 = kindOfTest2("RegExp");
var reduceDescriptors2 = (obj, reducer) => {
  const descriptors3 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach2(descriptors3, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods2 = (obj) => {
  reduceDescriptors2(obj, (descriptor, name) => {
    if (isFunction3(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value2 = obj[name];
    if (!isFunction3(value2)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet2 = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray2(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber2 = (value2, defaultValue) => {
  return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
};
function isSpecCompliantForm2(thing) {
  return !!(thing && isFunction3(thing.append) && thing[toStringTag2] === "FormData" && thing[iterator2]);
}
var toJSONObject2 = (obj) => {
  const stack = new Array(10);
  const visit = (source, i9) => {
    if (isObject2(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i9] = source;
        const target = isArray2(source) ? [] : {};
        forEach2(source, (value2, key) => {
          const reducedValue = visit(value2, i9 + 1);
          !isUndefined2(reducedValue) && (target[key] = reducedValue);
        });
        stack[i9] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn2 = kindOfTest2("AsyncFunction");
var isThenable2 = (thing) => thing && (isObject2(thing) || isFunction3(thing)) && isFunction3(thing.then) && isFunction3(thing.catch);
var _setImmediate2 = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global2.addEventListener("message", ({ source, data }) => {
      if (source === _global2 && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global2.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction3(_global2.postMessage)
);
var asap2 = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global2) : typeof process !== "undefined" && process.nextTick || _setImmediate2;
var isIterable2 = (thing) => thing != null && isFunction3(thing[iterator2]);
var utils_default2 = {
  isArray: isArray2,
  isArrayBuffer: isArrayBuffer2,
  isBuffer: isBuffer2,
  isFormData: isFormData2,
  isArrayBufferView: isArrayBufferView2,
  isString: isString2,
  isNumber: isNumber2,
  isBoolean: isBoolean2,
  isObject: isObject2,
  isPlainObject: isPlainObject2,
  isReadableStream: isReadableStream2,
  isRequest: isRequest2,
  isResponse: isResponse2,
  isHeaders: isHeaders2,
  isUndefined: isUndefined2,
  isDate: isDate2,
  isFile: isFile2,
  isBlob: isBlob2,
  isRegExp: isRegExp2,
  isFunction: isFunction3,
  isStream: isStream2,
  isURLSearchParams: isURLSearchParams2,
  isTypedArray: isTypedArray2,
  isFileList: isFileList2,
  forEach: forEach2,
  merge: merge2,
  extend: extend13,
  trim: trim6,
  stripBOM: stripBOM2,
  inherits: inherits2,
  toFlatObject: toFlatObject2,
  kindOf: kindOf2,
  kindOfTest: kindOfTest2,
  endsWith: endsWith2,
  toArray: toArray3,
  forEachEntry: forEachEntry2,
  matchAll: matchAll2,
  isHTMLForm: isHTMLForm2,
  hasOwnProperty: hasOwnProperty4,
  hasOwnProp: hasOwnProperty4,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: reduceDescriptors2,
  freezeMethods: freezeMethods2,
  toObjectSet: toObjectSet2,
  toCamelCase: toCamelCase2,
  noop: noop2,
  toFiniteNumber: toFiniteNumber2,
  findKey: findKey2,
  global: _global2,
  isContextDefined: isContextDefined2,
  isSpecCompliantForm: isSpecCompliantForm2,
  toJSONObject: toJSONObject2,
  isAsyncFn: isAsyncFn2,
  isThenable: isThenable2,
  setImmediate: _setImmediate2,
  asap: asap2,
  isIterable: isIterable2
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/AxiosError.js
function AxiosError3(message, code, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default2.inherits(AxiosError3, Error, {
  toJSON: function toJSON2() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype3 = AxiosError3.prototype;
var descriptors2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors2[code] = { value: code };
});
Object.defineProperties(AxiosError3, descriptors2);
Object.defineProperty(prototype3, "isAxiosError", { value: true });
AxiosError3.from = (error, code, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype3);
  utils_default2.toFlatObject(error, axiosError, function filter10(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError3.call(axiosError, error.message, code, config2, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default2 = AxiosError3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/null.js
var null_default2 = null;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/toFormData.js
function isVisitable2(thing) {
  return utils_default2.isPlainObject(thing) || utils_default2.isArray(thing);
}
function removeBrackets2(key) {
  return utils_default2.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey2(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i9) {
    token = removeBrackets2(token);
    return !dots && i9 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray2(arr) {
  return utils_default2.isArray(arr) && !arr.some(isVisitable2);
}
var predicates2 = utils_default2.toFlatObject(utils_default2, {}, null, function filter9(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData3(obj, formData, options) {
  if (!utils_default2.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default2 || FormData)();
  options = utils_default2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default2.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default2.isSpecCompliantForm(formData);
  if (!utils_default2.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue3(value2) {
    if (value2 === null) return "";
    if (utils_default2.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils_default2.isBlob(value2)) {
      throw new AxiosError_default2("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default2.isArrayBuffer(value2) || utils_default2.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path2) {
    let arr = value2;
    if (value2 && !path2 && typeof value2 === "object") {
      if (utils_default2.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils_default2.isArray(value2) && isFlatArray2(value2) || (utils_default2.isFileList(value2) || utils_default2.endsWith(key, "[]")) && (arr = utils_default2.toArray(value2))) {
        key = removeBrackets2(key);
        arr.forEach(function each(el2, index2) {
          !(utils_default2.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey2([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue3(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable2(value2)) {
      return true;
    }
    formData.append(renderKey2(path2, key, dots), convertValue3(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates2, {
    defaultVisitor,
    convertValue: convertValue3,
    isVisitable: isVisitable2
  });
  function build(value2, path2) {
    if (utils_default2.isUndefined(value2)) return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value2);
    utils_default2.forEach(value2, function each(el2, key) {
      const result = !(utils_default2.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils_default2.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default2.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default2 = toFormData3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode17(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match14) {
    return charMap[match14];
  });
}
function AxiosURLSearchParams2(params, options) {
  this._pairs = [];
  params && toFormData_default2(params, this, options);
}
var prototype4 = AxiosURLSearchParams2.prototype;
prototype4.append = function append6(name, value2) {
  this._pairs.push([name, value2]);
};
prototype4.toString = function toString11(encoder5) {
  const _encode = encoder5 ? function(value2) {
    return encoder5.call(this, value2, encode17);
  } : encode17;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default2 = AxiosURLSearchParams2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/buildURL.js
function encode18(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL2(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode18;
  if (utils_default2.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default2(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager2 = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn4) {
    utils_default2.forEach(this.handlers, function forEachHandler(h9) {
      if (h9 !== null) {
        fn4(h9);
      }
    });
  }
};
var InterceptorManager_default2 = InterceptorManager2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/defaults/transitional.js
var transitional_default2 = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default2 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default2 = typeof FormData !== "undefined" ? FormData : null;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default2 = typeof Blob !== "undefined" ? Blob : null;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/browser/index.js
var browser_default2 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default2,
    FormData: FormData_default2,
    Blob: Blob_default2
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/common/utils.js
var utils_exports4 = {};
__export(utils_exports4, {
  hasBrowserEnv: () => hasBrowserEnv2,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv2,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv2,
  navigator: () => _navigator2,
  origin: () => origin2
});
var hasBrowserEnv2 = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator2 = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv2 = hasBrowserEnv2 && (!_navigator2 || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator2.product) < 0);
var hasStandardBrowserWebWorkerEnv2 = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin2 = hasBrowserEnv2 && window.location.href || "http://localhost";

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/platform/index.js
var platform_default2 = {
  ...utils_exports4,
  ...browser_default2
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm2(data, options) {
  return toFormData_default2(data, new platform_default2.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key, path2, helpers) {
      if (platform_default2.isNode && utils_default2.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath2(name) {
  return utils_default2.matchAll(/\w+|\[(\w*)]/g, name).map((match14) => {
    return match14[0] === "[]" ? "" : match14[1] || match14[0];
  });
}
function arrayToObject2(arr) {
  const obj = {};
  const keys5 = Object.keys(arr);
  let i9;
  const len = keys5.length;
  let key;
  for (i9 = 0; i9 < len; i9++) {
    key = keys5[i9];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON2(formData) {
  function buildPath(path2, value2, target, index2) {
    let name = path2[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils_default2.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default2.hasOwnProp(target, name)) {
        target[name] = [target[name], value2];
      } else {
        target[name] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default2.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value2, target[name], index2);
    if (result && utils_default2.isArray(target[name])) {
      target[name] = arrayToObject2(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default2.isFormData(formData) && utils_default2.isFunction(formData.entries)) {
    const obj = {};
    utils_default2.forEachEntry(formData, (name, value2) => {
      buildPath(parsePropPath2(name), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default2 = formDataToJSON2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/defaults/index.js
function stringifySafely2(rawValue, parser, encoder5) {
  if (utils_default2.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default2.trim(rawValue);
    } catch (e11) {
      if (e11.name !== "SyntaxError") {
        throw e11;
      }
    }
  }
  return (encoder5 || JSON.stringify)(rawValue);
}
var defaults2 = {
  transitional: transitional_default2,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest2(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default2.isObject(data);
    if (isObjectPayload && utils_default2.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData3 = utils_default2.isFormData(data);
    if (isFormData3) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default2(data)) : data;
    }
    if (utils_default2.isArrayBuffer(data) || utils_default2.isBuffer(data) || utils_default2.isStream(data) || utils_default2.isFile(data) || utils_default2.isBlob(data) || utils_default2.isReadableStream(data)) {
      return data;
    }
    if (utils_default2.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default2.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList3;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm2(data, this.formSerializer).toString();
      }
      if ((isFileList3 = utils_default2.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default2(
          isFileList3 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely2(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse2(data) {
    const transitional3 = this.transitional || defaults2.transitional;
    const forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default2.isResponse(data) || utils_default2.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e11) {
        if (strictJSONParsing) {
          if (e11.name === "SyntaxError") {
            throw AxiosError_default2.from(e11, AxiosError_default2.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e11;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default2.classes.FormData,
    Blob: platform_default2.classes.Blob
  },
  validateStatus: function validateStatus2(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults2.headers[method] = {};
});
var defaults_default2 = defaults2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf2 = utils_default2.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default2 = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i9;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i9 = line.indexOf(":");
    key = line.substring(0, i9).trim().toLowerCase();
    val = line.substring(i9 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf2[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/AxiosHeaders.js
var $internals2 = Symbol("internals");
function normalizeHeader2(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue2(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils_default2.isArray(value2) ? value2.map(normalizeValue2) : String(value2);
}
function parseTokens2(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match14;
  while (match14 = tokensRE.exec(str)) {
    tokens[match14[1]] = match14[2];
  }
  return tokens;
}
var isValidHeaderName2 = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue2(context, value2, header, filter10, isHeaderNameFilter) {
  if (utils_default2.isFunction(filter10)) {
    return filter10.call(this, value2, header);
  }
  if (isHeaderNameFilter) {
    value2 = header;
  }
  if (!utils_default2.isString(value2)) return;
  if (utils_default2.isString(filter10)) {
    return value2.indexOf(filter10) !== -1;
  }
  if (utils_default2.isRegExp(filter10)) {
    return filter10.test(value2);
  }
}
function formatHeader2(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w8, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors2(obj, header) {
  const accessorName = utils_default2.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders3 = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader2(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default2.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue2(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default2.isString(header) && (header = header.trim()) && !isValidHeaderName2(header)) {
      setHeaders(parseHeaders_default2(header), valueOrRewrite);
    } else if (utils_default2.isObject(header) && utils_default2.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default2.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default2.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader2(header);
    if (header) {
      const key = utils_default2.findKey(this, header);
      if (key) {
        const value2 = this[key];
        if (!parser) {
          return value2;
        }
        if (parser === true) {
          return parseTokens2(value2);
        }
        if (utils_default2.isFunction(parser)) {
          return parser.call(this, value2, key);
        }
        if (utils_default2.isRegExp(parser)) {
          return parser.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader2(header);
    if (header) {
      const key = utils_default2.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue2(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader2(_header);
      if (_header) {
        const key = utils_default2.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue2(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys5 = Object.keys(this);
    let i9 = keys5.length;
    let deleted = false;
    while (i9--) {
      const key = keys5[i9];
      if (!matcher || matchHeaderValue2(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format9) {
    const self2 = this;
    const headers = {};
    utils_default2.forEach(this, (value2, header) => {
      const key = utils_default2.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue2(value2);
        delete self2[header];
        return;
      }
      const normalized = format9 ? formatHeader2(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue2(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default2.forEach(this, (value2, header) => {
      value2 != null && value2 !== false && (obj[header] = asStrings && utils_default2.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value2]) => header + ": " + value2).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals2] = this[$internals2] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype5 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader2(_header);
      if (!accessors[lHeader]) {
        buildAccessors2(prototype5, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders3.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default2.reduceDescriptors(AxiosHeaders3.prototype, ({ value: value2 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value2,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default2.freezeMethods(AxiosHeaders3);
var AxiosHeaders_default2 = AxiosHeaders3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/transformData.js
function transformData2(fns, response) {
  const config2 = this || defaults_default2;
  const context = response || config2;
  const headers = AxiosHeaders_default2.from(context.headers);
  let data = context.data;
  utils_default2.forEach(fns, function transform(fn4) {
    data = fn4.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/cancel/isCancel.js
function isCancel3(value2) {
  return !!(value2 && value2.__CANCEL__);
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError3(message, config2, request2) {
  AxiosError_default2.call(this, message == null ? "canceled" : message, AxiosError_default2.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils_default2.inherits(CanceledError3, AxiosError_default2, {
  __CANCEL__: true
});
var CanceledError_default2 = CanceledError3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/settle.js
function settle2(resolve, reject, response) {
  const validateStatus3 = response.config.validateStatus;
  if (!response.status || !validateStatus3 || validateStatus3(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default2(
      "Request failed with status code " + response.status,
      [AxiosError_default2.ERR_BAD_REQUEST, AxiosError_default2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol2(url2) {
  const match14 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match14 && match14[1] || "";
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/speedometer.js
function speedometer2(samplesCount, min4) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head5 = 0;
  let tail4 = 0;
  let firstSampleTS;
  min4 = min4 !== void 0 ? min4 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail4];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head5] = chunkLength;
    timestamps[head5] = now;
    let i9 = tail4;
    let bytesCount = 0;
    while (i9 !== head5) {
      bytesCount += bytes2[i9++];
      i9 = i9 % samplesCount;
    }
    head5 = (head5 + 1) % samplesCount;
    if (head5 === tail4) {
      tail4 = (tail4 + 1) % samplesCount;
    }
    if (now - firstSampleTS < min4) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default2 = speedometer2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/throttle.js
function throttle2(fn4, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn4.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default2 = throttle2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer2 = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default2(50, 250);
  return throttle_default2((e11) => {
    const loaded = e11.loaded;
    const total = e11.lengthComputable ? e11.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange3 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange3 ? (total - loaded) / rate : void 0,
      event: e11,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator2 = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator2 = (fn4) => (...args) => utils_default2.asap(() => fn4(...args));

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default2 = platform_default2.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin3, isMSIE) => (url2) => {
  url2 = new URL(url2, platform_default2.origin);
  return origin3.protocol === url2.protocol && origin3.host === url2.host && (isMSIE || origin3.port === url2.port);
})(
  new URL(platform_default2.origin),
  platform_default2.navigator && /(msie|trident)/i.test(platform_default2.navigator.userAgent)
) : () => true;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/cookies.js
var cookies_default2 = platform_default2.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value2, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value2)];
      utils_default2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default2.isString(path2) && cookie.push("path=" + path2);
      utils_default2.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match14 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match14 ? decodeURIComponent(match14[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL2(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs2(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath2(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL2(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/mergeConfig.js
var headersToObject2 = (thing) => thing instanceof AxiosHeaders_default2 ? { ...thing } : thing;
function mergeConfig3(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default2.isPlainObject(target) && utils_default2.isPlainObject(source)) {
      return utils_default2.merge.call({ caseless }, target, source);
    } else if (utils_default2.isPlainObject(source)) {
      return utils_default2.merge({}, source);
    } else if (utils_default2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a6, b6, prop, caseless) {
    if (!utils_default2.isUndefined(b6)) {
      return getMergedValue(a6, b6, prop, caseless);
    } else if (!utils_default2.isUndefined(a6)) {
      return getMergedValue(void 0, a6, prop, caseless);
    }
  }
  function valueFromConfig2(a6, b6) {
    if (!utils_default2.isUndefined(b6)) {
      return getMergedValue(void 0, b6);
    }
  }
  function defaultToConfig2(a6, b6) {
    if (!utils_default2.isUndefined(b6)) {
      return getMergedValue(void 0, b6);
    } else if (!utils_default2.isUndefined(a6)) {
      return getMergedValue(void 0, a6);
    }
  }
  function mergeDirectKeys(a6, b6, prop) {
    if (prop in config2) {
      return getMergedValue(a6, b6);
    } else if (prop in config1) {
      return getMergedValue(void 0, a6);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a6, b6, prop) => mergeDeepProperties(headersToObject2(a6), headersToObject2(b6), prop, true)
  };
  utils_default2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils_default2.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default2 = (config2) => {
  const newConfig = mergeConfig3({}, config2);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default2.from(headers);
  newConfig.url = buildURL2(buildFullPath2(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default2.isFormData(data)) {
    if (platform_default2.hasStandardBrowserEnv || platform_default2.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type7, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type7 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default2.hasStandardBrowserEnv) {
    withXSRFToken && utils_default2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default2(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default2.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported2 = typeof XMLHttpRequest !== "undefined";
var xhr_default2 = isXHRAdapterSupported2 && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default2(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default2.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders_default2.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle2(function _resolve(value2) {
        resolve(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError_default2("Request aborted", AxiosError_default2.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError_default2("Network Error", AxiosError_default2.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional3 = _config.transitional || transitional_default2;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default2(
        timeoutErrorMessage,
        transitional3.clarifyTimeoutError ? AxiosError_default2.ETIMEDOUT : AxiosError_default2.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils_default2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils_default2.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer2(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer2(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default2(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol4 = parseProtocol2(_config.url);
    if (protocol4 && platform_default2.protocols.indexOf(protocol4) === -1) {
      reject(new AxiosError_default2("Unsupported protocol " + protocol4 + ":", AxiosError_default2.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/composeSignals.js
var composeSignals2 = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default2 ? err : new CanceledError_default2(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default2(`timeout ${timeout} of ms exceeded`, AxiosError_default2.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default2.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default2 = composeSignals2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/trackStream.js
var streamChunk2 = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes2 = async function* (iterable, chunkSize) {
  for await (const chunk of readStream2(iterable)) {
    yield* streamChunk2(chunk, chunkSize);
  }
};
var readStream2 = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value: value2 } = await reader.read();
      if (done) {
        break;
      }
      yield value2;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream2 = (stream, chunkSize, onProgress, onFinish) => {
  const iterator4 = readBytes2(stream, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e11) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e11);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value: value2 } = await iterator4.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value2.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value2));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator4.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder5) => (str) => encoder5.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test2 = (fn4, ...args) => {
  try {
    return !!fn4(...args);
  } catch (e11) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test2(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default2.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE2 = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test2(() => utils_default2.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type7) => {
    !resolvers[type7] && (resolvers[type7] = utils_default2.isFunction(res[type7]) ? (res2) => res2[type7]() : (_6, config2) => {
      throw new AxiosError_default2(`Response type '${type7}' is not supported`, AxiosError_default2.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default2.isBlob(body)) {
    return body.size;
  }
  if (utils_default2.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default2.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default2.isArrayBufferView(body) || utils_default2.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default2.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default2.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default2.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config2) => {
  let {
    url: url2,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default2(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default2([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default2.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator2(
          requestContentLength,
          progressEventReducer2(asyncDecorator2(onUploadProgress))
        );
        data = trackStream2(_request.body, DEFAULT_CHUNK_SIZE2, onProgress, flush);
      }
    }
    if (!utils_default2.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default2.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator2(
        responseContentLength,
        progressEventReducer2(asyncDecorator2(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream2(response.body, DEFAULT_CHUNK_SIZE2, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default2.findKey(resolvers, responseType) || "text"](response, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle2(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default2.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config: config2,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default2("Network Error", AxiosError_default2.ERR_NETWORK, config2, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default2.from(err, err && err.code, config2, request2);
  }
});

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/adapters/adapters.js
var knownAdapters2 = {
  http: null_default2,
  xhr: xhr_default2,
  fetch: fetch_default
};
utils_default2.forEach(knownAdapters2, (fn4, value2) => {
  if (fn4) {
    try {
      Object.defineProperty(fn4, "name", { value: value2 });
    } catch (e11) {
    }
    Object.defineProperty(fn4, "adapterName", { value: value2 });
  }
});
var renderReason2 = (reason) => `- ${reason}`;
var isResolvedHandle2 = (adapter2) => utils_default2.isFunction(adapter2) || adapter2 === null || adapter2 === false;
var adapters_default2 = {
  getAdapter: (adapters) => {
    adapters = utils_default2.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter2;
    const rejectedReasons = {};
    for (let i9 = 0; i9 < length; i9++) {
      nameOrAdapter = adapters[i9];
      let id2;
      adapter2 = nameOrAdapter;
      if (!isResolvedHandle2(nameOrAdapter)) {
        adapter2 = knownAdapters2[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter2 === void 0) {
          throw new AxiosError_default2(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter2) {
        break;
      }
      rejectedReasons[id2 || "#" + i9] = adapter2;
    }
    if (!adapter2) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s5 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason2).join("\n") : " " + renderReason2(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default2(
        `There is no suitable adapter to dispatch the request ` + s5,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter2;
  },
  adapters: knownAdapters2
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested2(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError_default2(null, config2);
  }
}
function dispatchRequest2(config2) {
  throwIfCancellationRequested2(config2);
  config2.headers = AxiosHeaders_default2.from(config2.headers);
  config2.data = transformData2.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default2.getAdapter(config2.adapter || defaults_default2.adapter);
  return adapter2(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested2(config2);
    response.data = transformData2.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default2.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel3(reason)) {
      throwIfCancellationRequested2(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default2.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/env/data.js
var VERSION4 = "1.9.0";

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/validator.js
var validators3 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type7, i9) => {
  validators3[type7] = function validator(thing) {
    return typeof thing === type7 || "a" + (i9 < 1 ? "n " : " ") + type7;
  };
});
var deprecatedWarnings2 = {};
validators3.transitional = function transitional2(validator, version11, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION4 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value2, opt, opts2) => {
    if (validator === false) {
      throw new AxiosError_default2(
        formatMessage(opt, " has been removed" + (version11 ? " in " + version11 : "")),
        AxiosError_default2.ERR_DEPRECATED
      );
    }
    if (version11 && !deprecatedWarnings2[opt]) {
      deprecatedWarnings2[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version11 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value2, opt, opts2) : true;
  };
};
validators3.spelling = function spelling2(correctSpelling) {
  return (value2, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions2(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default2("options must be an object", AxiosError_default2.ERR_BAD_OPTION_VALUE);
  }
  const keys5 = Object.keys(options);
  let i9 = keys5.length;
  while (i9-- > 0) {
    const opt = keys5[i9];
    const validator = schema[opt];
    if (validator) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator(value2, opt, options);
      if (result !== true) {
        throw new AxiosError_default2("option " + opt + " must be " + result, AxiosError_default2.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default2("Unknown option " + opt, AxiosError_default2.ERR_BAD_OPTION);
    }
  }
}
var validator_default2 = {
  assertOptions: assertOptions2,
  validators: validators3
};

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/core/Axios.js
var validators4 = validator_default2.validators;
var Axios3 = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default2(),
      response: new InterceptorManager_default2()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e11) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig3(this.defaults, config2);
    const { transitional: transitional3, paramsSerializer, headers } = config2;
    if (transitional3 !== void 0) {
      validator_default2.assertOptions(transitional3, {
        silentJSONParsing: validators4.transitional(validators4.boolean),
        forcedJSONParsing: validators4.transitional(validators4.boolean),
        clarifyTimeoutError: validators4.transitional(validators4.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default2.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default2.assertOptions(paramsSerializer, {
          encode: validators4.function,
          serialize: validators4.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator_default2.assertOptions(config2, {
      baseUrl: validators4.spelling("baseURL"),
      withXsrfToken: validators4.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default2.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils_default2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders_default2.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i9 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain6 = [dispatchRequest2.bind(this), void 0];
      chain6.unshift.apply(chain6, requestInterceptorChain);
      chain6.push.apply(chain6, responseInterceptorChain);
      len = chain6.length;
      promise = Promise.resolve(config2);
      while (i9 < len) {
        promise = promise.then(chain6[i9++], chain6[i9++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i9 = 0;
    while (i9 < len) {
      const onFulfilled = requestInterceptorChain[i9++];
      const onRejected = requestInterceptorChain[i9++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest2.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i9 = 0;
    len = responseInterceptorChain.length;
    while (i9 < len) {
      promise = promise.then(responseInterceptorChain[i9++], responseInterceptorChain[i9++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig3(this.defaults, config2);
    const fullPath = buildFullPath2(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL2(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils_default2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios3.prototype[method] = function(url2, config2) {
    return this.request(mergeConfig3(config2 || {}, {
      method,
      url: url2,
      data: (config2 || {}).data
    }));
  };
});
utils_default2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config2) {
      return this.request(mergeConfig3(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios3.prototype[method] = generateHTTPMethod();
  Axios3.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default2 = Axios3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken3 = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i9 = token._listeners.length;
      while (i9-- > 0) {
        token._listeners[i9](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default2(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c9) {
      cancel = c9;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default2 = CancelToken3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/spread.js
function spread3(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError3(payload) {
  return utils_default2.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode3 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode3).forEach(([key, value2]) => {
  HttpStatusCode3[value2] = key;
});
var HttpStatusCode_default2 = HttpStatusCode3;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/lib/axios.js
function createInstance2(defaultConfig) {
  const context = new Axios_default2(defaultConfig);
  const instance = bind24(Axios_default2.prototype.request, context);
  utils_default2.extend(instance, Axios_default2.prototype, context, { allOwnKeys: true });
  utils_default2.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create6(instanceConfig) {
    return createInstance2(mergeConfig3(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios2 = createInstance2(defaults_default2);
axios2.Axios = Axios_default2;
axios2.CanceledError = CanceledError_default2;
axios2.CancelToken = CancelToken_default2;
axios2.isCancel = isCancel3;
axios2.VERSION = VERSION4;
axios2.toFormData = toFormData_default2;
axios2.AxiosError = AxiosError_default2;
axios2.Cancel = axios2.CanceledError;
axios2.all = function all3(promises) {
  return Promise.all(promises);
};
axios2.spread = spread3;
axios2.isAxiosError = isAxiosError3;
axios2.mergeConfig = mergeConfig3;
axios2.AxiosHeaders = AxiosHeaders_default2;
axios2.formToJSON = (thing) => formDataToJSON_default2(utils_default2.isHTMLForm(thing) ? new FormData(thing) : thing);
axios2.getAdapter = adapters_default2.getAdapter;
axios2.HttpStatusCode = HttpStatusCode_default2;
axios2.default = axios2;
var axios_default2 = axios2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/axios/index.js
var {
  Axios: Axios4,
  AxiosError: AxiosError4,
  CanceledError: CanceledError4,
  isCancel: isCancel4,
  CancelToken: CancelToken4,
  VERSION: VERSION5,
  all: all4,
  Cancel: Cancel2,
  isAxiosError: isAxiosError4,
  spread: spread4,
  toFormData: toFormData4,
  AxiosHeaders: AxiosHeaders4,
  HttpStatusCode: HttpStatusCode4,
  formToJSON: formToJSON2,
  getAdapter: getAdapter2,
  mergeConfig: mergeConfig4
} = axios_default2;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/node_modules/@dynamic-labs-wallet/core/index.esm.js
var ENVIRONMENT_ENUM = function(ENVIRONMENT_ENUM3) {
  ENVIRONMENT_ENUM3["development"] = "development";
  ENVIRONMENT_ENUM3["preprod"] = "preprod";
  ENVIRONMENT_ENUM3["production"] = "production";
  return ENVIRONMENT_ENUM3;
}({});
var WalletOperation = function(WalletOperation3) {
  WalletOperation3["REACH_THRESHOLD"] = "REACH_THRESHOLD";
  WalletOperation3["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
  WalletOperation3["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  WalletOperation3["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  WalletOperation3["REFRESH"] = "REFRESH";
  WalletOperation3["RESHARE"] = "RESHARE";
  WalletOperation3["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
  WalletOperation3["NO_OPERATION"] = "NO_OPERATION";
  return WalletOperation3;
}({});
var BackupLocation = function(BackupLocation3) {
  BackupLocation3["DYNAMIC"] = "dynamic";
  BackupLocation3["GOOGLE_DRIVE"] = "googleDrive";
  BackupLocation3["ICLOUD"] = "iCloud";
  BackupLocation3["USER"] = "user";
  BackupLocation3["EXTERNAL"] = "external";
  BackupLocation3["DELEGATED"] = "delegated";
  return BackupLocation3;
}({});
var SigningAlgorithm = function(SigningAlgorithm3) {
  SigningAlgorithm3["ECDSA"] = "ECDSA";
  SigningAlgorithm3["ED25519"] = "ED25519";
  SigningAlgorithm3["BIP340"] = "BIP340";
  return SigningAlgorithm3;
}({});
var BITCOIN_DERIVATION_PATHS = {
  LEGACY: [
    44,
    0,
    0,
    0,
    0
  ],
  // m/49'/0'/0'/0/0  - SegWit (P2SH-P2WPKH)
  NATIVE_SEGWIT: [
    84,
    0,
    0,
    0,
    0
  ],
  // m/44'/0'/0'/0/0  - Legacy (P2PKH)
  SEGWIT: [
    49,
    0,
    0,
    0,
    0
  ]
};
var MPC_CHAIN_CONFIG = {
  EVM: {
    // Uses secp256k1 ECDSA
    derivationPath: [
      44,
      60,
      0,
      0,
      0
    ],
    signingAlgorithm: "ECDSA"
  },
  SVM: {
    // Uses Ed25519
    derivationPath: [
      44,
      501,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  BTC: {
    // Uses secp256k1 BIP340
    derivationPath: BITCOIN_DERIVATION_PATHS.NATIVE_SEGWIT,
    signingAlgorithm: "BIP340"
  },
  COSMOS: {
    // Uses Ed25519
    derivationPath: [
      44,
      118,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  FLOW: {
    // Uses Ed25519
    derivationPath: [
      44,
      539,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  SUI: {
    // Uses Ed25519
    derivationPath: [
      44,
      784,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  }
};
var ThresholdSignatureScheme = function(ThresholdSignatureScheme3) {
  ThresholdSignatureScheme3["TWO_OF_TWO"] = "TWO_OF_TWO";
  ThresholdSignatureScheme3["TWO_OF_THREE"] = "TWO_OF_THREE";
  ThresholdSignatureScheme3["THREE_OF_FIVE"] = "THREE_OF_FIVE";
  return ThresholdSignatureScheme3;
}({});
var CreateRoomPartiesOptions = function(CreateRoomPartiesOptions3) {
  CreateRoomPartiesOptions3["THRESHOLD"] = "threshold";
  CreateRoomPartiesOptions3["FULL"] = "full";
  return CreateRoomPartiesOptions3;
}({});
var URL_PATTERNS = {
  [ENVIRONMENT_ENUM.development]: /^http:\/\/localhost:\d+$/,
  [ENVIRONMENT_ENUM.preprod]: /dynamic-preprod/,
  [ENVIRONMENT_ENUM.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
var AuthMode = function(AuthMode3) {
  AuthMode3["HEADER"] = "header";
  AuthMode3["COOKIE"] = "cookie";
  return AuthMode3;
}({});
var SuccessEventType = function(SuccessEventType3) {
  SuccessEventType3["KeygenComplete"] = "keygen_complete";
  SuccessEventType3["RoomCreated"] = "room_created";
  SuccessEventType3["CeremonyComplete"] = "ceremony_complete";
  return SuccessEventType3;
}({});

// node_modules/@noble/post-quantum/node_modules/@noble/hashes/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig2(n5, le5 = false) {
  if (le5)
    return { h: Number(n5 & U32_MASK64), l: Number(n5 >> _32n & U32_MASK64) };
  return { h: Number(n5 >> _32n & U32_MASK64) | 0, l: Number(n5 & U32_MASK64) | 0 };
}
function split(lst, le5 = false) {
  const len = lst.length;
  let Ah2 = new Uint32Array(len);
  let Al2 = new Uint32Array(len);
  for (let i9 = 0; i9 < len; i9++) {
    const { h: h9, l: l9 } = fromBig2(lst[i9], le5);
    [Ah2[i9], Al2[i9]] = [h9, l9];
  }
  return [Ah2, Al2];
}
var rotlSH = (h9, l9, s5) => h9 << s5 | l9 >>> 32 - s5;
var rotlSL = (h9, l9, s5) => l9 << s5 | h9 >>> 32 - s5;
var rotlBH = (h9, l9, s5) => l9 << s5 - 32 | h9 >>> 64 - s5;
var rotlBL = (h9, l9, s5) => h9 << s5 - 32 | l9 >>> 64 - s5;

// node_modules/@noble/post-quantum/node_modules/@noble/hashes/utils.js
function isBytes7(a6) {
  return a6 instanceof Uint8Array || ArrayBuffer.isView(a6) && a6.constructor.name === "Uint8Array";
}
function anumber5(n5, title = "") {
  if (!Number.isSafeInteger(n5) || n5 < 0) {
    const prefix = title && `"${title}" `;
    throw new Error(`${prefix}expected integer >= 0, got ${n5}`);
  }
}
function abytes6(value2, length, title = "") {
  const bytes2 = isBytes7(value2);
  const len = value2 == null ? void 0 : value2.length;
  const needsLen = length !== void 0;
  if (!bytes2 || needsLen && len !== length) {
    const prefix = title && `"${title}" `;
    const ofLen = needsLen ? ` of length ${length}` : "";
    const got = bytes2 ? `length=${len}` : `type=${typeof value2}`;
    throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
  }
  return value2;
}
function aexists4(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput4(out, instance) {
  abytes6(out, void 0, "digestInto() output");
  const min4 = instance.outputLen;
  if (out.length < min4) {
    throw new Error('"digestInto() output" expected to be of length >=' + min4);
  }
}
function u322(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean3(...arrays) {
  for (let i9 = 0; i9 < arrays.length; i9++) {
    arrays[i9].fill(0);
  }
}
var isLE3 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i9 = 0; i9 < arr.length; i9++) {
    arr[i9] = byteSwap(arr[i9]);
  }
  return arr;
}
var swap32IfBE2 = isLE3 ? (u10) => u10 : byteSwap32;
var hasHexBuiltin3 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes5 = Array.from({ length: 256 }, (_6, i9) => i9.toString(16).padStart(2, "0"));
function createHasher5(hashCons, info = {}) {
  const hashC = (msg, opts2) => hashCons(opts2).update(msg).digest();
  const tmp = hashCons(void 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts2) => hashCons(opts2);
  Object.assign(hashC, info);
  return Object.freeze(hashC);
}
function randomBytes4(bytesLength = 32) {
  const cr4 = typeof globalThis === "object" ? globalThis.crypto : null;
  if (typeof (cr4 == null ? void 0 : cr4.getRandomValues) !== "function")
    throw new Error("crypto.getRandomValues must be defined");
  return cr4.getRandomValues(new Uint8Array(bytesLength));
}
var oidNist2 = (suffix) => ({
  oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
});

// node_modules/@noble/post-quantum/node_modules/@noble/hashes/sha3.js
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n9 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R6 = _1n10, x7 = 1, y11 = 0; round < 24; round++) {
  [x7, y11] = [y11, (2 * x7 + 3 * y11) % 5];
  SHA3_PI.push(2 * (5 * y11 + x7));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t6 = _0n10;
  for (let j9 = 0; j9 < 7; j9++) {
    R6 = (R6 << _1n10 ^ (R6 >> _7n) * _0x71n) % _256n;
    if (R6 & _2n9)
      t6 ^= _1n10 << (_1n10 << BigInt(j9)) - _1n10;
  }
  _SHA3_IOTA.push(t6);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h9, l9, s5) => s5 > 32 ? rotlBH(h9, l9, s5) : rotlSH(h9, l9, s5);
var rotlL = (h9, l9, s5) => s5 > 32 ? rotlBL(h9, l9, s5) : rotlSL(h9, l9, s5);
function keccakP(s5, rounds = 24) {
  const B9 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x7 = 0; x7 < 10; x7++)
      B9[x7] = s5[x7] ^ s5[x7 + 10] ^ s5[x7 + 20] ^ s5[x7 + 30] ^ s5[x7 + 40];
    for (let x7 = 0; x7 < 10; x7 += 2) {
      const idx1 = (x7 + 8) % 10;
      const idx0 = (x7 + 2) % 10;
      const B0 = B9[idx0];
      const B1 = B9[idx0 + 1];
      const Th2 = rotlH(B0, B1, 1) ^ B9[idx1];
      const Tl2 = rotlL(B0, B1, 1) ^ B9[idx1 + 1];
      for (let y11 = 0; y11 < 50; y11 += 10) {
        s5[x7 + y11] ^= Th2;
        s5[x7 + y11 + 1] ^= Tl2;
      }
    }
    let curH = s5[2];
    let curL = s5[3];
    for (let t6 = 0; t6 < 24; t6++) {
      const shift = SHA3_ROTL[t6];
      const Th2 = rotlH(curH, curL, shift);
      const Tl2 = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t6];
      curH = s5[PI];
      curL = s5[PI + 1];
      s5[PI] = Th2;
      s5[PI + 1] = Tl2;
    }
    for (let y11 = 0; y11 < 50; y11 += 10) {
      for (let x7 = 0; x7 < 10; x7++)
        B9[x7] = s5[y11 + x7];
      for (let x7 = 0; x7 < 10; x7++)
        s5[y11 + x7] ^= ~B9[(x7 + 2) % 10] & B9[(x7 + 4) % 10];
    }
    s5[0] ^= SHA3_IOTA_H[round];
    s5[1] ^= SHA3_IOTA_L[round];
  }
  clean3(B9);
}
var Keccak = class _Keccak {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    __publicField(this, "state");
    __publicField(this, "pos", 0);
    __publicField(this, "posOut", 0);
    __publicField(this, "finished", false);
    __publicField(this, "state32");
    __publicField(this, "destroyed", false);
    __publicField(this, "blockLen");
    __publicField(this, "suffix");
    __publicField(this, "outputLen");
    __publicField(this, "enableXOF", false);
    __publicField(this, "rounds");
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber5(outputLen, "outputLen");
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE2(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE2(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists4(this);
    abytes6(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i9 = 0; i9 < take; i9++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists4(this, false);
    abytes6(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    anumber5(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    aoutput4(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean3(this.state);
  }
  _cloneInto(to6) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to6 || (to6 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to6.state32.set(this.state32);
    to6.pos = this.pos;
    to6.posOut = this.posOut;
    to6.finished = this.finished;
    to6.rounds = rounds;
    to6.suffix = suffix;
    to6.outputLen = outputLen;
    to6.enableXOF = enableXOF;
    to6.destroyed = this.destroyed;
    return to6;
  }
};
var genKeccak = (suffix, blockLen, outputLen, info = {}) => createHasher5(() => new Keccak(blockLen, suffix, outputLen), info);
var sha3_224 = genKeccak(
  6,
  144,
  28,
  oidNist2(7)
);
var sha3_256 = genKeccak(
  6,
  136,
  32,
  oidNist2(8)
);
var sha3_384 = genKeccak(
  6,
  104,
  48,
  oidNist2(9)
);
var sha3_512 = genKeccak(
  6,
  72,
  64,
  oidNist2(10)
);
var keccak_224 = genKeccak(1, 144, 28);
var keccak_2562 = genKeccak(1, 136, 32);
var keccak_384 = genKeccak(1, 104, 48);
var keccak_512 = genKeccak(1, 72, 64);
var genShake = (suffix, blockLen, outputLen, info = {}) => createHasher5((opts2 = {}) => new Keccak(blockLen, suffix, opts2.dkLen === void 0 ? outputLen : opts2.dkLen, true), info);
var shake128 = genShake(31, 168, 16, oidNist2(11));
var shake256 = genShake(31, 136, 32, oidNist2(12));
var shake128_32 = genShake(31, 168, 32, oidNist2(11));
var shake256_64 = genShake(31, 136, 64, oidNist2(12));

// node_modules/@noble/post-quantum/node_modules/@noble/curves/abstract/fft.js
function checkU32(n5) {
  if (!Number.isSafeInteger(n5) || n5 < 0 || n5 > 4294967295)
    throw new Error("wrong u32 integer:" + n5);
  return n5;
}
function isPowerOfTwo(x7) {
  checkU32(x7);
  return (x7 & x7 - 1) === 0 && x7 !== 0;
}
function reverseBits(n5, bits) {
  checkU32(n5);
  let reversed = 0;
  for (let i9 = 0; i9 < bits; i9++, n5 >>>= 1)
    reversed = reversed << 1 | n5 & 1;
  return reversed;
}
function log2(n5) {
  checkU32(n5);
  return 31 - Math.clz32(n5);
}
function bitReversalInplace(values) {
  const n5 = values.length;
  if (n5 < 2 || !isPowerOfTwo(n5))
    throw new Error("n must be a power of 2 and greater than 1. Got " + n5);
  const bits = log2(n5);
  for (let i9 = 0; i9 < n5; i9++) {
    const j9 = reverseBits(i9, bits);
    if (i9 < j9) {
      const tmp = values[i9];
      values[i9] = values[j9];
      values[j9] = tmp;
    }
  }
  return values;
}
var _1n11 = BigInt(1);
var FFTCore = (F8, coreOpts) => {
  const { N: N9, roots, dit, invertButterflies = false, skipStages = 0, brp = true } = coreOpts;
  const bits = log2(N9);
  if (!isPowerOfTwo(N9))
    throw new Error("FFT: Polynomial size should be power of two");
  const isDit = dit !== invertButterflies;
  isDit;
  return (values) => {
    if (values.length !== N9)
      throw new Error("FFT: wrong Polynomial length");
    if (dit && brp)
      bitReversalInplace(values);
    for (let i9 = 0, g4 = 1; i9 < bits - skipStages; i9++) {
      const s5 = dit ? i9 + 1 + skipStages : bits - i9;
      const m6 = 1 << s5;
      const m22 = m6 >> 1;
      const stride = N9 >> s5;
      for (let k11 = 0; k11 < N9; k11 += m6) {
        for (let j9 = 0, grp = g4++; j9 < m22; j9++) {
          const rootPos = invertButterflies ? dit ? N9 - grp : grp : j9 * stride;
          const i0 = k11 + j9;
          const i1 = k11 + j9 + m22;
          const omega = roots[rootPos];
          const b6 = values[i1];
          const a6 = values[i0];
          if (isDit) {
            const t6 = F8.mul(b6, omega);
            values[i0] = F8.add(a6, t6);
            values[i1] = F8.sub(a6, t6);
          } else if (invertButterflies) {
            values[i0] = F8.add(b6, a6);
            values[i1] = F8.mul(F8.sub(b6, a6), omega);
          } else {
            values[i0] = F8.add(a6, b6);
            values[i1] = F8.mul(F8.sub(a6, b6), omega);
          }
        }
      }
    }
    if (!dit && brp)
      bitReversalInplace(values);
    return values;
  };
};

// node_modules/@noble/post-quantum/utils.js
var randomBytes5 = randomBytes4;
function equalBytes4(a6, b6) {
  if (a6.length !== b6.length)
    return false;
  let diff = 0;
  for (let i9 = 0; i9 < a6.length; i9++)
    diff |= a6[i9] ^ b6[i9];
  return diff === 0;
}
function copyBytes2(bytes2) {
  return Uint8Array.from(bytes2);
}
function splitCoder(label, ...lengths) {
  const getLength = (c9) => typeof c9 === "number" ? c9 : c9.bytesLen;
  const bytesLen = lengths.reduce((sum, a6) => sum + getLength(a6), 0);
  return {
    bytesLen,
    encode: (bufs) => {
      const res = new Uint8Array(bytesLen);
      for (let i9 = 0, pos = 0; i9 < lengths.length; i9++) {
        const c9 = lengths[i9];
        const l9 = getLength(c9);
        const b6 = typeof c9 === "number" ? bufs[i9] : c9.encode(bufs[i9]);
        abytes6(b6, l9, label);
        res.set(b6, pos);
        if (typeof c9 !== "number")
          b6.fill(0);
        pos += l9;
      }
      return res;
    },
    decode: (buf) => {
      abytes6(buf, bytesLen, label);
      const res = [];
      for (const c9 of lengths) {
        const l9 = getLength(c9);
        const b6 = buf.subarray(0, l9);
        res.push(typeof c9 === "number" ? b6 : c9.decode(b6));
        buf = buf.subarray(l9);
      }
      return res;
    }
  };
}
function vecCoder(c9, vecLen) {
  const bytesLen = vecLen * c9.bytesLen;
  return {
    bytesLen,
    encode: (u10) => {
      if (u10.length !== vecLen)
        throw new Error(`vecCoder.encode: wrong length=${u10.length}. Expected: ${vecLen}`);
      const res = new Uint8Array(bytesLen);
      for (let i9 = 0, pos = 0; i9 < u10.length; i9++) {
        const b6 = c9.encode(u10[i9]);
        res.set(b6, pos);
        b6.fill(0);
        pos += b6.length;
      }
      return res;
    },
    decode: (a6) => {
      abytes6(a6, bytesLen);
      const r8 = [];
      for (let i9 = 0; i9 < a6.length; i9 += c9.bytesLen)
        r8.push(c9.decode(a6.subarray(i9, i9 + c9.bytesLen)));
      return r8;
    }
  };
}
function cleanBytes(...list) {
  for (const t6 of list) {
    if (Array.isArray(t6))
      for (const b6 of t6)
        b6.fill(0);
    else
      t6.fill(0);
  }
}
function getMask(bits) {
  return (1 << bits) - 1;
}
var EMPTY = Uint8Array.of();
var oidNistP = Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2]);

// node_modules/@noble/post-quantum/_crystals.js
var genCrystals = (opts2) => {
  const { newPoly, N: N9, Q: Q7, F: F8, ROOT_OF_UNITY: ROOT_OF_UNITY2, brvBits, isKyber } = opts2;
  const mod4 = (a6, modulo = Q7) => {
    const result = a6 % modulo | 0;
    return (result >= 0 ? result | 0 : modulo + result | 0) | 0;
  };
  const smod = (a6, modulo = Q7) => {
    const r8 = mod4(a6, modulo) | 0;
    return (r8 > modulo >> 1 ? r8 - modulo | 0 : r8) | 0;
  };
  function getZettas() {
    const out = newPoly(N9);
    for (let i9 = 0; i9 < N9; i9++) {
      const b6 = reverseBits(i9, brvBits);
      const p9 = BigInt(ROOT_OF_UNITY2) ** BigInt(b6) % BigInt(Q7);
      out[i9] = Number(p9) | 0;
    }
    return out;
  }
  const nttZetas2 = getZettas();
  const field = {
    add: (a6, b6) => mod4((a6 | 0) + (b6 | 0)) | 0,
    sub: (a6, b6) => mod4((a6 | 0) - (b6 | 0)) | 0,
    mul: (a6, b6) => mod4((a6 | 0) * (b6 | 0)) | 0,
    inv: (_a14) => {
      throw new Error("not implemented");
    }
  };
  const nttOpts = {
    N: N9,
    roots: nttZetas2,
    invertButterflies: true,
    skipStages: isKyber ? 1 : 0,
    brp: false
  };
  const dif = FFTCore(field, { dit: false, ...nttOpts });
  const dit = FFTCore(field, { dit: true, ...nttOpts });
  const NTT2 = {
    encode: (r8) => {
      return dif(r8);
    },
    decode: (r8) => {
      dit(r8);
      for (let i9 = 0; i9 < r8.length; i9++)
        r8[i9] = mod4(F8 * r8[i9]);
      return r8;
    }
  };
  const bitsCoder2 = (d7, c9) => {
    const mask = getMask(d7);
    const bytesLen = d7 * (N9 / 8);
    return {
      bytesLen,
      encode: (poly) => {
        const r8 = new Uint8Array(bytesLen);
        for (let i9 = 0, buf = 0, bufLen = 0, pos = 0; i9 < poly.length; i9++) {
          buf |= (c9.encode(poly[i9]) & mask) << bufLen;
          bufLen += d7;
          for (; bufLen >= 8; bufLen -= 8, buf >>= 8)
            r8[pos++] = buf & getMask(bufLen);
        }
        return r8;
      },
      decode: (bytes2) => {
        const r8 = newPoly(N9);
        for (let i9 = 0, buf = 0, bufLen = 0, pos = 0; i9 < bytes2.length; i9++) {
          buf |= bytes2[i9] << bufLen;
          bufLen += 8;
          for (; bufLen >= d7; bufLen -= d7, buf >>= d7)
            r8[pos++] = c9.decode(buf & mask);
        }
        return r8;
      }
    };
  };
  return { mod: mod4, smod, nttZetas: nttZetas2, NTT: NTT2, bitsCoder: bitsCoder2 };
};
var createXofShake = (shake) => (seed, blockLen) => {
  if (!blockLen)
    blockLen = shake.blockLen;
  const _seed = new Uint8Array(seed.length + 2);
  _seed.set(seed);
  const seedLen = seed.length;
  const buf = new Uint8Array(blockLen);
  let h9 = shake.create({});
  let calls = 0;
  let xofs = 0;
  return {
    stats: () => ({ calls, xofs }),
    get: (x7, y11) => {
      _seed[seedLen + 0] = x7;
      _seed[seedLen + 1] = y11;
      h9.destroy();
      h9 = shake.create({}).update(_seed);
      calls++;
      return () => {
        xofs++;
        return h9.xofInto(buf);
      };
    },
    clean: () => {
      h9.destroy();
      cleanBytes(buf, _seed);
    }
  };
};
var XOF128 = createXofShake(shake128);
var XOF256 = createXofShake(shake256);

// node_modules/@noble/post-quantum/ml-kem.js
var N6 = 256;
var Q5 = 3329;
var F5 = 3303;
var ROOT_OF_UNITY = 17;
var { mod: mod3, nttZetas, NTT, bitsCoder } = genCrystals({
  N: N6,
  Q: Q5,
  F: F5,
  ROOT_OF_UNITY,
  newPoly: (n5) => new Uint16Array(n5),
  brvBits: 7,
  isKyber: true
});
var PARAMS = {
  512: { N: N6, Q: Q5, K: 2, ETA1: 3, ETA2: 2, du: 10, dv: 4, RBGstrength: 128 },
  768: { N: N6, Q: Q5, K: 3, ETA1: 2, ETA2: 2, du: 10, dv: 4, RBGstrength: 192 },
  1024: { N: N6, Q: Q5, K: 4, ETA1: 2, ETA2: 2, du: 11, dv: 5, RBGstrength: 256 }
};
var compress3 = (d7) => {
  if (d7 >= 12)
    return { encode: (i9) => i9, decode: (i9) => i9 };
  const a6 = 2 ** (d7 - 1);
  return {
    // const compress = (i: number) => round((2 ** d / Q) * i) % 2 ** d;
    encode: (i9) => ((i9 << d7) + Q5 / 2) / Q5,
    // const decompress = (i: number) => round((Q / 2 ** d) * i);
    decode: (i9) => i9 * Q5 + a6 >>> d7
  };
};
var polyCoder = (d7) => bitsCoder(d7, compress3(d7));
function polyAdd(a6, b6) {
  for (let i9 = 0; i9 < N6; i9++)
    a6[i9] = mod3(a6[i9] + b6[i9]);
}
function polySub(a6, b6) {
  for (let i9 = 0; i9 < N6; i9++)
    a6[i9] = mod3(a6[i9] - b6[i9]);
}
function BaseCaseMultiply(a0, a1, b0, b1, zeta) {
  const c0 = mod3(a1 * b1 * zeta + a0 * b0);
  const c1 = mod3(a0 * b1 + a1 * b0);
  return { c0, c1 };
}
function MultiplyNTTs(f16, g4) {
  for (let i9 = 0; i9 < N6 / 2; i9++) {
    let z9 = nttZetas[64 + (i9 >> 1)];
    if (i9 & 1)
      z9 = -z9;
    const { c0, c1 } = BaseCaseMultiply(f16[2 * i9 + 0], f16[2 * i9 + 1], g4[2 * i9 + 0], g4[2 * i9 + 1], z9);
    f16[2 * i9 + 0] = c0;
    f16[2 * i9 + 1] = c1;
  }
  return f16;
}
function SampleNTT(xof) {
  const r8 = new Uint16Array(N6);
  for (let j9 = 0; j9 < N6; ) {
    const b6 = xof();
    if (b6.length % 3)
      throw new Error("SampleNTT: unaligned block");
    for (let i9 = 0; j9 < N6 && i9 + 3 <= b6.length; i9 += 3) {
      const d1 = (b6[i9 + 0] >> 0 | b6[i9 + 1] << 8) & 4095;
      const d22 = (b6[i9 + 1] >> 4 | b6[i9 + 2] << 4) & 4095;
      if (d1 < Q5)
        r8[j9++] = d1;
      if (j9 < N6 && d22 < Q5)
        r8[j9++] = d22;
    }
  }
  return r8;
}
function sampleCBD(PRF, seed, nonce, eta) {
  const buf = PRF(eta * N6 / 4, seed, nonce);
  const r8 = new Uint16Array(N6);
  const b32 = u322(buf);
  let len = 0;
  for (let i9 = 0, p9 = 0, bb = 0, t0 = 0; i9 < b32.length; i9++) {
    let b6 = b32[i9];
    for (let j9 = 0; j9 < 32; j9++) {
      bb += b6 & 1;
      b6 >>= 1;
      len += 1;
      if (len === eta) {
        t0 = bb;
        bb = 0;
      } else if (len === 2 * eta) {
        r8[p9++] = mod3(t0 - bb);
        bb = 0;
        len = 0;
      }
    }
  }
  if (len)
    throw new Error(`sampleCBD: leftover bits: ${len}`);
  return r8;
}
var genKPKE = (opts2) => {
  const { K: K5, PRF, XOF, HASH512, ETA1, ETA2, du: du2, dv } = opts2;
  const poly1 = polyCoder(1);
  const polyV = polyCoder(dv);
  const polyU = polyCoder(du2);
  const publicCoder = splitCoder("publicKey", vecCoder(polyCoder(12), K5), 32);
  const secretCoder = vecCoder(polyCoder(12), K5);
  const cipherCoder = splitCoder("ciphertext", vecCoder(polyU, K5), polyV);
  const seedCoder = splitCoder("seed", 32, 32);
  return {
    secretCoder,
    lengths: {
      secretKey: secretCoder.bytesLen,
      publicKey: publicCoder.bytesLen,
      cipherText: cipherCoder.bytesLen
    },
    keygen: (seed) => {
      abytes6(seed, 32, "seed");
      const seedDst = new Uint8Array(33);
      seedDst.set(seed);
      seedDst[32] = K5;
      const seedHash = HASH512(seedDst);
      const [rho, sigma] = seedCoder.decode(seedHash);
      const sHat = [];
      const tHat = [];
      for (let i9 = 0; i9 < K5; i9++)
        sHat.push(NTT.encode(sampleCBD(PRF, sigma, i9, ETA1)));
      const x7 = XOF(rho);
      for (let i9 = 0; i9 < K5; i9++) {
        const e11 = NTT.encode(sampleCBD(PRF, sigma, K5 + i9, ETA1));
        for (let j9 = 0; j9 < K5; j9++) {
          const aji = SampleNTT(x7.get(j9, i9));
          polyAdd(e11, MultiplyNTTs(aji, sHat[j9]));
        }
        tHat.push(e11);
      }
      x7.clean();
      const res = {
        publicKey: publicCoder.encode([tHat, rho]),
        secretKey: secretCoder.encode(sHat)
      };
      cleanBytes(rho, sigma, sHat, tHat, seedDst, seedHash);
      return res;
    },
    encrypt: (publicKey, msg, seed) => {
      const [tHat, rho] = publicCoder.decode(publicKey);
      const rHat = [];
      for (let i9 = 0; i9 < K5; i9++)
        rHat.push(NTT.encode(sampleCBD(PRF, seed, i9, ETA1)));
      const x7 = XOF(rho);
      const tmp2 = new Uint16Array(N6);
      const u10 = [];
      for (let i9 = 0; i9 < K5; i9++) {
        const e1 = sampleCBD(PRF, seed, K5 + i9, ETA2);
        const tmp = new Uint16Array(N6);
        for (let j9 = 0; j9 < K5; j9++) {
          const aij = SampleNTT(x7.get(i9, j9));
          polyAdd(tmp, MultiplyNTTs(aij, rHat[j9]));
        }
        polyAdd(e1, NTT.decode(tmp));
        u10.push(e1);
        polyAdd(tmp2, MultiplyNTTs(tHat[i9], rHat[i9]));
        cleanBytes(tmp);
      }
      x7.clean();
      const e22 = sampleCBD(PRF, seed, 2 * K5, ETA2);
      polyAdd(e22, NTT.decode(tmp2));
      const v9 = poly1.decode(msg);
      polyAdd(v9, e22);
      cleanBytes(tHat, rHat, tmp2, e22);
      return cipherCoder.encode([u10, v9]);
    },
    decrypt: (cipherText, privateKey) => {
      const [u10, v9] = cipherCoder.decode(cipherText);
      const sk = secretCoder.decode(privateKey);
      const tmp = new Uint16Array(N6);
      for (let i9 = 0; i9 < K5; i9++)
        polyAdd(tmp, MultiplyNTTs(sk[i9], NTT.encode(u10[i9])));
      polySub(v9, NTT.decode(tmp));
      cleanBytes(tmp, sk, u10);
      return poly1.encode(v9);
    }
  };
};
function createKyber(opts2) {
  const KPKE = genKPKE(opts2);
  const { HASH256, HASH512, KDF } = opts2;
  const { secretCoder: KPKESecretCoder, lengths } = KPKE;
  const secretCoder = splitCoder("secretKey", lengths.secretKey, lengths.publicKey, 32, 32);
  const msgLen = 32;
  const seedLen = 64;
  return {
    info: { type: "ml-kem" },
    lengths: {
      ...lengths,
      seed: 64,
      msg: msgLen,
      msgRand: msgLen,
      secretKey: secretCoder.bytesLen
    },
    keygen: (seed = randomBytes5(seedLen)) => {
      abytes6(seed, seedLen, "seed");
      const { publicKey, secretKey: sk } = KPKE.keygen(seed.subarray(0, 32));
      const publicKeyHash = HASH256(publicKey);
      const secretKey = secretCoder.encode([sk, publicKey, publicKeyHash, seed.subarray(32)]);
      cleanBytes(sk, publicKeyHash);
      return { publicKey, secretKey };
    },
    getPublicKey: (secretKey) => {
      const [_sk, publicKey, _publicKeyHash, _z] = secretCoder.decode(secretKey);
      return Uint8Array.from(publicKey);
    },
    encapsulate: (publicKey, msg = randomBytes5(msgLen)) => {
      abytes6(publicKey, lengths.publicKey, "publicKey");
      abytes6(msg, msgLen, "message");
      const eke = publicKey.subarray(0, 384 * opts2.K);
      const ek = KPKESecretCoder.encode(KPKESecretCoder.decode(copyBytes2(eke)));
      if (!equalBytes4(ek, eke)) {
        cleanBytes(ek);
        throw new Error("ML-KEM.encapsulate: wrong publicKey modulus");
      }
      cleanBytes(ek);
      const kr4 = HASH512.create().update(msg).update(HASH256(publicKey)).digest();
      const cipherText = KPKE.encrypt(publicKey, msg, kr4.subarray(32, 64));
      cleanBytes(kr4.subarray(32));
      return { cipherText, sharedSecret: kr4.subarray(0, 32) };
    },
    decapsulate: (cipherText, secretKey) => {
      abytes6(secretKey, secretCoder.bytesLen, "secretKey");
      abytes6(cipherText, lengths.cipherText, "cipherText");
      const k768 = secretCoder.bytesLen - 96;
      const start = k768 + 32;
      const test3 = HASH256(secretKey.subarray(k768 / 2, start));
      if (!equalBytes4(test3, secretKey.subarray(start, start + 32)))
        throw new Error("invalid secretKey: hash check failed");
      const [sk, publicKey, publicKeyHash, z9] = secretCoder.decode(secretKey);
      const msg = KPKE.decrypt(cipherText, sk);
      const kr4 = HASH512.create().update(msg).update(publicKeyHash).digest();
      const Khat = kr4.subarray(0, 32);
      const cipherText2 = KPKE.encrypt(publicKey, msg, kr4.subarray(32, 64));
      const isValid = equalBytes4(cipherText, cipherText2);
      const Kbar = KDF.create({ dkLen: 32 }).update(z9).update(cipherText).digest();
      cleanBytes(msg, cipherText2, !isValid ? Khat : Kbar);
      return isValid ? Khat : Kbar;
    }
  };
}
function shakePRF(dkLen, key, nonce) {
  return shake256.create({ dkLen }).update(key).update(new Uint8Array([nonce])).digest();
}
var opts = {
  HASH256: sha3_256,
  HASH512: sha3_512,
  KDF: shake256,
  XOF: XOF128,
  PRF: shakePRF
};
var ml_kem512 = createKyber({
  ...opts,
  ...PARAMS[512]
});
var ml_kem768 = createKyber({
  ...opts,
  ...PARAMS[768]
});
var ml_kem1024 = createKyber({
  ...opts,
  ...PARAMS[1024]
});

// node_modules/@dynamic-labs/waas/node_modules/@noble/hashes/hmac.js
var _HMAC = class {
  constructor(hash9, key) {
    __publicField(this, "oHash");
    __publicField(this, "iHash");
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "finished", false);
    __publicField(this, "destroyed", false);
    ahash3(hash9);
    abytes5(key, void 0, "key");
    this.iHash = hash9.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad5 = new Uint8Array(blockLen);
    pad5.set(key.length > blockLen ? hash9.create().update(key).digest() : key);
    for (let i9 = 0; i9 < pad5.length; i9++)
      pad5[i9] ^= 54;
    this.iHash.update(pad5);
    this.oHash = hash9.create();
    for (let i9 = 0; i9 < pad5.length; i9++)
      pad5[i9] ^= 54 ^ 92;
    this.oHash.update(pad5);
    clean2(pad5);
  }
  update(buf) {
    aexists3(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists3(this);
    abytes5(out, this.outputLen, "output");
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to6) {
    to6 || (to6 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to6 = to6;
    to6.finished = finished;
    to6.destroyed = destroyed;
    to6.blockLen = blockLen;
    to6.outputLen = outputLen;
    to6.oHash = oHash._cloneInto(to6.oHash);
    to6.iHash = iHash._cloneInto(to6.iHash);
    return to6;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac3 = (hash9, key, message) => new _HMAC(hash9, key).update(message).digest();
hmac3.create = (hash9, key) => new _HMAC(hash9, key);

// node_modules/@dynamic-labs/waas/node_modules/@noble/hashes/hkdf.js
function extract5(hash9, ikm, salt) {
  ahash3(hash9);
  if (salt === void 0)
    salt = new Uint8Array(hash9.outputLen);
  return hmac3(hash9, salt, ikm);
}
var HKDF_COUNTER = Uint8Array.of(0);
var EMPTY_BUFFER = Uint8Array.of();
function expand(hash9, prk, info, length = 32) {
  ahash3(hash9);
  anumber4(length, "length");
  const olen = hash9.outputLen;
  if (length > 255 * olen)
    throw new Error("Length must be <= 255*HashLen");
  const blocks = Math.ceil(length / olen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  else
    abytes5(info, void 0, "info");
  const okm = new Uint8Array(blocks * olen);
  const HMAC2 = hmac3.create(hash9, prk);
  const HMACTmp = HMAC2._cloneInto();
  const T8 = new Uint8Array(HMAC2.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T8).update(info).update(HKDF_COUNTER).digestInto(T8);
    okm.set(T8, olen * counter);
    HMAC2._cloneInto(HMACTmp);
  }
  HMAC2.destroy();
  HMACTmp.destroy();
  clean2(T8, HKDF_COUNTER);
  return okm.slice(0, length);
}
var hkdf = (hash9, ikm, salt, info, length) => expand(hash9, extract5(hash9, ikm, salt), info, length);

// node_modules/@dynamic-labs/waas/node_modules/@noble/hashes/_md.js
function Chi2(a6, b6, c9) {
  return a6 & b6 ^ ~a6 & c9;
}
function Maj2(a6, b6, c9) {
  return a6 & b6 ^ a6 & c9 ^ b6 & c9;
}
var HashMD2 = class {
  constructor(blockLen, outputLen, padOffset, isLE5) {
    __publicField(this, "blockLen");
    __publicField(this, "outputLen");
    __publicField(this, "padOffset");
    __publicField(this, "isLE");
    // For partial updates less than block size
    __publicField(this, "buffer");
    __publicField(this, "view");
    __publicField(this, "finished", false);
    __publicField(this, "length", 0);
    __publicField(this, "pos", 0);
    __publicField(this, "destroyed", false);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE5;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView3(this.buffer);
  }
  update(data) {
    aexists3(this);
    abytes5(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView3(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists3(this);
    aoutput3(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE5 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean2(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i9 = pos; i9 < blockLen; i9++)
      buffer2[i9] = 0;
    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE5);
    this.process(view, 0);
    const oview = createView3(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen must be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i9 = 0; i9 < outLen; i9++)
      oview.setUint32(4 * i9, state[i9], isLE5);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to6) {
    to6 || (to6 = new this.constructor());
    to6.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to6.destroyed = destroyed;
    to6.finished = finished;
    to6.length = length;
    to6.pos = pos;
    if (length % blockLen)
      to6.buffer.set(buffer2);
    return to6;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV3 = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA224_IV = Uint32Array.from([
  3238371032,
  914150663,
  812702999,
  4144912697,
  4290775857,
  1750603025,
  1694076839,
  3204075428
]);
var SHA384_IV = Uint32Array.from([
  3418070365,
  3238371032,
  1654270250,
  914150663,
  2438529370,
  812702999,
  355462360,
  4144912697,
  1731405415,
  4290775857,
  2394180231,
  1750603025,
  3675008525,
  1694076839,
  1203062813,
  3204075428
]);
var SHA512_IV = Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// node_modules/@dynamic-labs/waas/node_modules/@noble/hashes/_u64.js
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
function fromBig3(n5, le5 = false) {
  if (le5)
    return { h: Number(n5 & U32_MASK642), l: Number(n5 >> _32n2 & U32_MASK642) };
  return { h: Number(n5 >> _32n2 & U32_MASK642) | 0, l: Number(n5 & U32_MASK642) | 0 };
}
function split2(lst, le5 = false) {
  const len = lst.length;
  let Ah2 = new Uint32Array(len);
  let Al2 = new Uint32Array(len);
  for (let i9 = 0; i9 < len; i9++) {
    const { h: h9, l: l9 } = fromBig3(lst[i9], le5);
    [Ah2[i9], Al2[i9]] = [h9, l9];
  }
  return [Ah2, Al2];
}
var shrSH = (h9, _l2, s5) => h9 >>> s5;
var shrSL = (h9, l9, s5) => h9 << 32 - s5 | l9 >>> s5;
var rotrSH2 = (h9, l9, s5) => h9 >>> s5 | l9 << 32 - s5;
var rotrSL2 = (h9, l9, s5) => h9 << 32 - s5 | l9 >>> s5;
var rotrBH2 = (h9, l9, s5) => h9 << 64 - s5 | l9 >>> s5 - 32;
var rotrBL2 = (h9, l9, s5) => h9 >>> s5 - 32 | l9 << 64 - s5;
function add2(Ah2, Al2, Bh2, Bl2) {
  const l9 = (Al2 >>> 0) + (Bl2 >>> 0);
  return { h: Ah2 + Bh2 + (l9 / 2 ** 32 | 0) | 0, l: l9 | 0 };
}
var add3L2 = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
var add3H2 = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
var add4L = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
var add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
var add5L = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
var add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;

// node_modules/@dynamic-labs/waas/node_modules/@noble/hashes/sha2.js
var SHA256_K2 = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2_32B = class extends HashMD2 {
  constructor(outputLen) {
    super(64, outputLen, 8, false);
  }
  get() {
    const { A: A9, B: B9, C: C10, D: D9, E: E8, F: F8, G: G7, H: H4 } = this;
    return [A9, B9, C10, D9, E8, F8, G7, H4];
  }
  // prettier-ignore
  set(A9, B9, C10, D9, E8, F8, G7, H4) {
    this.A = A9 | 0;
    this.B = B9 | 0;
    this.C = C10 | 0;
    this.D = D9 | 0;
    this.E = E8 | 0;
    this.F = F8 | 0;
    this.G = G7 | 0;
    this.H = H4 | 0;
  }
  process(view, offset) {
    for (let i9 = 0; i9 < 16; i9++, offset += 4)
      SHA256_W2[i9] = view.getUint32(offset, false);
    for (let i9 = 16; i9 < 64; i9++) {
      const W15 = SHA256_W2[i9 - 15];
      const W22 = SHA256_W2[i9 - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W22, 17) ^ rotr3(W22, 19) ^ W22 >>> 10;
      SHA256_W2[i9] = s1 + SHA256_W2[i9 - 7] + s0 + SHA256_W2[i9 - 16] | 0;
    }
    let { A: A9, B: B9, C: C10, D: D9, E: E8, F: F8, G: G7, H: H4 } = this;
    for (let i9 = 0; i9 < 64; i9++) {
      const sigma1 = rotr3(E8, 6) ^ rotr3(E8, 11) ^ rotr3(E8, 25);
      const T1 = H4 + sigma1 + Chi2(E8, F8, G7) + SHA256_K2[i9] + SHA256_W2[i9] | 0;
      const sigma0 = rotr3(A9, 2) ^ rotr3(A9, 13) ^ rotr3(A9, 22);
      const T22 = sigma0 + Maj2(A9, B9, C10) | 0;
      H4 = G7;
      G7 = F8;
      F8 = E8;
      E8 = D9 + T1 | 0;
      D9 = C10;
      C10 = B9;
      B9 = A9;
      A9 = T1 + T22 | 0;
    }
    A9 = A9 + this.A | 0;
    B9 = B9 + this.B | 0;
    C10 = C10 + this.C | 0;
    D9 = D9 + this.D | 0;
    E8 = E8 + this.E | 0;
    F8 = F8 + this.F | 0;
    G7 = G7 + this.G | 0;
    H4 = H4 + this.H | 0;
    this.set(A9, B9, C10, D9, E8, F8, G7, H4);
  }
  roundClean() {
    clean2(SHA256_W2);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean2(this.buffer);
  }
};
var _SHA256 = class extends SHA2_32B {
  constructor() {
    super(32);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    __publicField(this, "A", SHA256_IV3[0] | 0);
    __publicField(this, "B", SHA256_IV3[1] | 0);
    __publicField(this, "C", SHA256_IV3[2] | 0);
    __publicField(this, "D", SHA256_IV3[3] | 0);
    __publicField(this, "E", SHA256_IV3[4] | 0);
    __publicField(this, "F", SHA256_IV3[5] | 0);
    __publicField(this, "G", SHA256_IV3[6] | 0);
    __publicField(this, "H", SHA256_IV3[7] | 0);
  }
};
var _SHA224 = class extends SHA2_32B {
  constructor() {
    super(28);
    __publicField(this, "A", SHA224_IV[0] | 0);
    __publicField(this, "B", SHA224_IV[1] | 0);
    __publicField(this, "C", SHA224_IV[2] | 0);
    __publicField(this, "D", SHA224_IV[3] | 0);
    __publicField(this, "E", SHA224_IV[4] | 0);
    __publicField(this, "F", SHA224_IV[5] | 0);
    __publicField(this, "G", SHA224_IV[6] | 0);
    __publicField(this, "H", SHA224_IV[7] | 0);
  }
};
var K512 = (() => split2([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n5) => BigInt(n5))))();
var SHA512_Kh = (() => K512[0])();
var SHA512_Kl = (() => K512[1])();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA2_64B = class extends HashMD2 {
  constructor(outputLen) {
    super(128, outputLen, 16, false);
  }
  // prettier-ignore
  get() {
    const { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
    return [Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2];
  }
  // prettier-ignore
  set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2) {
    this.Ah = Ah2 | 0;
    this.Al = Al2 | 0;
    this.Bh = Bh2 | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch2 | 0;
    this.Cl = Cl2 | 0;
    this.Dh = Dh2 | 0;
    this.Dl = Dl2 | 0;
    this.Eh = Eh2 | 0;
    this.El = El2 | 0;
    this.Fh = Fh2 | 0;
    this.Fl = Fl2 | 0;
    this.Gh = Gh2 | 0;
    this.Gl = Gl2 | 0;
    this.Hh = Hh2 | 0;
    this.Hl = Hl2 | 0;
  }
  process(view, offset) {
    for (let i9 = 0; i9 < 16; i9++, offset += 4) {
      SHA512_W_H[i9] = view.getUint32(offset);
      SHA512_W_L[i9] = view.getUint32(offset += 4);
    }
    for (let i9 = 16; i9 < 80; i9++) {
      const W15h = SHA512_W_H[i9 - 15] | 0;
      const W15l = SHA512_W_L[i9 - 15] | 0;
      const s0h = rotrSH2(W15h, W15l, 1) ^ rotrSH2(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL2(W15h, W15l, 1) ^ rotrSL2(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i9 - 2] | 0;
      const W2l = SHA512_W_L[i9 - 2] | 0;
      const s1h = rotrSH2(W2h, W2l, 19) ^ rotrBH2(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL2(W2h, W2l, 19) ^ rotrBL2(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i9 - 7], SHA512_W_L[i9 - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i9 - 7], SHA512_W_H[i9 - 16]);
      SHA512_W_H[i9] = SUMh | 0;
      SHA512_W_L[i9] = SUMl | 0;
    }
    let { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
    for (let i9 = 0; i9 < 80; i9++) {
      const sigma1h = rotrSH2(Eh2, El2, 14) ^ rotrSH2(Eh2, El2, 18) ^ rotrBH2(Eh2, El2, 41);
      const sigma1l = rotrSL2(Eh2, El2, 14) ^ rotrSL2(Eh2, El2, 18) ^ rotrBL2(Eh2, El2, 41);
      const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
      const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
      const T1ll = add5L(Hl2, sigma1l, CHIl, SHA512_Kl[i9], SHA512_W_L[i9]);
      const T1h = add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i9], SHA512_W_H[i9]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH2(Ah2, Al2, 28) ^ rotrBH2(Ah2, Al2, 34) ^ rotrBH2(Ah2, Al2, 39);
      const sigma0l = rotrSL2(Ah2, Al2, 28) ^ rotrBL2(Ah2, Al2, 34) ^ rotrBL2(Ah2, Al2, 39);
      const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
      const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
      Hh2 = Gh2 | 0;
      Hl2 = Gl2 | 0;
      Gh2 = Fh2 | 0;
      Gl2 = Fl2 | 0;
      Fh2 = Eh2 | 0;
      Fl2 = El2 | 0;
      ({ h: Eh2, l: El2 } = add2(Dh2 | 0, Dl2 | 0, T1h | 0, T1l | 0));
      Dh2 = Ch2 | 0;
      Dl2 = Cl2 | 0;
      Ch2 = Bh2 | 0;
      Cl2 = Bl2 | 0;
      Bh2 = Ah2 | 0;
      Bl2 = Al2 | 0;
      const All = add3L2(T1l, sigma0l, MAJl);
      Ah2 = add3H2(All, T1h, sigma0h, MAJh);
      Al2 = All | 0;
    }
    ({ h: Ah2, l: Al2 } = add2(this.Ah | 0, this.Al | 0, Ah2 | 0, Al2 | 0));
    ({ h: Bh2, l: Bl2 } = add2(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl2 | 0));
    ({ h: Ch2, l: Cl2 } = add2(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl2 | 0));
    ({ h: Dh2, l: Dl2 } = add2(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl2 | 0));
    ({ h: Eh2, l: El2 } = add2(this.Eh | 0, this.El | 0, Eh2 | 0, El2 | 0));
    ({ h: Fh2, l: Fl2 } = add2(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl2 | 0));
    ({ h: Gh2, l: Gl2 } = add2(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl2 | 0));
    ({ h: Hh2, l: Hl2 } = add2(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl2 | 0));
    this.set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2);
  }
  roundClean() {
    clean2(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean2(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _SHA512 = class extends SHA2_64B {
  constructor() {
    super(64);
    __publicField(this, "Ah", SHA512_IV[0] | 0);
    __publicField(this, "Al", SHA512_IV[1] | 0);
    __publicField(this, "Bh", SHA512_IV[2] | 0);
    __publicField(this, "Bl", SHA512_IV[3] | 0);
    __publicField(this, "Ch", SHA512_IV[4] | 0);
    __publicField(this, "Cl", SHA512_IV[5] | 0);
    __publicField(this, "Dh", SHA512_IV[6] | 0);
    __publicField(this, "Dl", SHA512_IV[7] | 0);
    __publicField(this, "Eh", SHA512_IV[8] | 0);
    __publicField(this, "El", SHA512_IV[9] | 0);
    __publicField(this, "Fh", SHA512_IV[10] | 0);
    __publicField(this, "Fl", SHA512_IV[11] | 0);
    __publicField(this, "Gh", SHA512_IV[12] | 0);
    __publicField(this, "Gl", SHA512_IV[13] | 0);
    __publicField(this, "Hh", SHA512_IV[14] | 0);
    __publicField(this, "Hl", SHA512_IV[15] | 0);
  }
};
var _SHA384 = class extends SHA2_64B {
  constructor() {
    super(48);
    __publicField(this, "Ah", SHA384_IV[0] | 0);
    __publicField(this, "Al", SHA384_IV[1] | 0);
    __publicField(this, "Bh", SHA384_IV[2] | 0);
    __publicField(this, "Bl", SHA384_IV[3] | 0);
    __publicField(this, "Ch", SHA384_IV[4] | 0);
    __publicField(this, "Cl", SHA384_IV[5] | 0);
    __publicField(this, "Dh", SHA384_IV[6] | 0);
    __publicField(this, "Dl", SHA384_IV[7] | 0);
    __publicField(this, "Eh", SHA384_IV[8] | 0);
    __publicField(this, "El", SHA384_IV[9] | 0);
    __publicField(this, "Fh", SHA384_IV[10] | 0);
    __publicField(this, "Fl", SHA384_IV[11] | 0);
    __publicField(this, "Gh", SHA384_IV[12] | 0);
    __publicField(this, "Gl", SHA384_IV[13] | 0);
    __publicField(this, "Hh", SHA384_IV[14] | 0);
    __publicField(this, "Hl", SHA384_IV[15] | 0);
  }
};
var T224_IV = Uint32Array.from([
  2352822216,
  424955298,
  1944164710,
  2312950998,
  502970286,
  855612546,
  1738396948,
  1479516111,
  258812777,
  2077511080,
  2011393907,
  79989058,
  1067287976,
  1780299464,
  286451373,
  2446758561
]);
var T256_IV = Uint32Array.from([
  573645204,
  4230739756,
  2673172387,
  3360449730,
  596883563,
  1867755857,
  2520282905,
  1497426621,
  2519219938,
  2827943907,
  3193839141,
  1401305490,
  721525244,
  746961066,
  246885852,
  2177182882
]);
var _SHA512_224 = class extends SHA2_64B {
  constructor() {
    super(28);
    __publicField(this, "Ah", T224_IV[0] | 0);
    __publicField(this, "Al", T224_IV[1] | 0);
    __publicField(this, "Bh", T224_IV[2] | 0);
    __publicField(this, "Bl", T224_IV[3] | 0);
    __publicField(this, "Ch", T224_IV[4] | 0);
    __publicField(this, "Cl", T224_IV[5] | 0);
    __publicField(this, "Dh", T224_IV[6] | 0);
    __publicField(this, "Dl", T224_IV[7] | 0);
    __publicField(this, "Eh", T224_IV[8] | 0);
    __publicField(this, "El", T224_IV[9] | 0);
    __publicField(this, "Fh", T224_IV[10] | 0);
    __publicField(this, "Fl", T224_IV[11] | 0);
    __publicField(this, "Gh", T224_IV[12] | 0);
    __publicField(this, "Gl", T224_IV[13] | 0);
    __publicField(this, "Hh", T224_IV[14] | 0);
    __publicField(this, "Hl", T224_IV[15] | 0);
  }
};
var _SHA512_256 = class extends SHA2_64B {
  constructor() {
    super(32);
    __publicField(this, "Ah", T256_IV[0] | 0);
    __publicField(this, "Al", T256_IV[1] | 0);
    __publicField(this, "Bh", T256_IV[2] | 0);
    __publicField(this, "Bl", T256_IV[3] | 0);
    __publicField(this, "Ch", T256_IV[4] | 0);
    __publicField(this, "Cl", T256_IV[5] | 0);
    __publicField(this, "Dh", T256_IV[6] | 0);
    __publicField(this, "Dl", T256_IV[7] | 0);
    __publicField(this, "Eh", T256_IV[8] | 0);
    __publicField(this, "El", T256_IV[9] | 0);
    __publicField(this, "Fh", T256_IV[10] | 0);
    __publicField(this, "Fl", T256_IV[11] | 0);
    __publicField(this, "Gh", T256_IV[12] | 0);
    __publicField(this, "Gl", T256_IV[13] | 0);
    __publicField(this, "Hh", T256_IV[14] | 0);
    __publicField(this, "Hl", T256_IV[15] | 0);
  }
};
var sha2567 = createHasher4(
  () => new _SHA256(),
  oidNist(1)
);
var sha2242 = createHasher4(
  () => new _SHA224(),
  oidNist(4)
);
var sha5122 = createHasher4(
  () => new _SHA512(),
  oidNist(3)
);
var sha3842 = createHasher4(
  () => new _SHA384(),
  oidNist(2)
);
var sha512_256 = createHasher4(
  () => new _SHA512_256(),
  oidNist(6)
);
var sha512_224 = createHasher4(
  () => new _SHA512_224(),
  oidNist(5)
);

// node_modules/@noble/ciphers/esm/utils.js
var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
var u323 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes8(a6) {
  return a6 instanceof Uint8Array || a6 != null && typeof a6 === "object" && a6.constructor.name === "Uint8Array";
}
var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE4 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE4)
  throw new Error("Non little-endian hardware is not supported");
var hexes6 = Array.from({ length: 256 }, (_6, i9) => i9.toString(16).padStart(2, "0"));
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes14(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  else if (isBytes8(data))
    data = data.slice();
  else
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function ensureBytes3(b6, len) {
  if (!isBytes8(b6))
    throw new Error("Uint8Array expected");
  if (typeof len === "number") {
    if (b6.length !== len)
      throw new Error(`Uint8Array length ${len} expected`);
  }
}
function equalBytes5(a6, b6) {
  if (a6.length !== b6.length)
    return false;
  let diff = 0;
  for (let i9 = 0; i9 < a6.length; i9++)
    diff |= a6[i9] ^ b6[i9];
  return diff === 0;
}
var wrapCipher = (params, c9) => {
  Object.assign(c9, params);
  return c9;
};
function setBigUint642(view, byteOffset, value2, isLE5) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value2, isLE5);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh2 = Number(value2 >> _32n3 & _u32_max);
  const wl2 = Number(value2 & _u32_max);
  const h9 = isLE5 ? 4 : 0;
  const l9 = isLE5 ? 0 : 4;
  view.setUint32(byteOffset + h9, wh2, isLE5);
  view.setUint32(byteOffset + l9, wl2, isLE5);
}

// node_modules/@noble/ciphers/esm/_assert.js
function isBytes9(a6) {
  return a6 != null && typeof a6 === "object" && (a6 instanceof Uint8Array || a6.constructor.name === "Uint8Array");
}
function bytes(b6, ...lengths) {
  if (!isBytes9(b6))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b6.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b6.length}`);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min4 = instance.outputLen;
  if (out.length < min4) {
    throw new Error(`digestInto() expects output buffer of length at least ${min4}`);
  }
}

// node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = new Uint8Array(16);
var ZEROS32 = u323(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s22, s32) => {
  const hiBit = s32 & 1;
  return {
    s3: s22 << 31 | s32 >>> 1,
    s2: s1 << 31 | s22 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n5) => (n5 >>> 0 & 255) << 24 | (n5 >>> 8 & 255) << 16 | (n5 >>> 16 & 255) << 8 | n5 >>> 24 & 255 | 0;
function _toGHASHKey(k11) {
  k11.reverse();
  const hiBit = k11[15] & 1;
  let carry = 0;
  for (let i9 = 0; i9 < k11.length; i9++) {
    const t6 = k11[i9];
    k11[i9] = t6 >>> 1 | carry;
    carry = (t6 & 1) << 7;
  }
  k11[0] ^= -hiBit & 225;
  return k11;
}
var estimateWindow = (bytes2) => {
  if (bytes2 > 64 * 1024)
    return 8;
  if (bytes2 > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes14(key);
    ensureBytes3(key, 16);
    const kView = createView4(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k22 = kView.getUint32(8, false);
    let k32 = kView.getUint32(12, false);
    const doubles = [];
    for (let i9 = 0; i9 < 128; i9++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k22), s3: swapLE(k32) });
      ({ s0: k0, s1: k1, s2: k22, s3: k32 } = mul2(k0, k1, k22, k32));
    }
    const W6 = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W6))
      throw new Error(`ghash: wrong window size=${W6}, should be 2, 4 or 8`);
    this.W = W6;
    const bits = 128;
    const windows = bits / W6;
    const windowSize = this.windowSize = 2 ** W6;
    const items = [];
    for (let w8 = 0; w8 < windows; w8++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s22 = 0, s32 = 0;
        for (let j9 = 0; j9 < W6; j9++) {
          const bit = byte >>> W6 - j9 - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d22, s3: d32 } = doubles[W6 * w8 + j9];
          s0 ^= d0, s1 ^= d1, s22 ^= d22, s32 ^= d32;
        }
        items.push({ s0, s1, s2: s22, s3: s32 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s22, s32) {
    s0 ^= this.s0, s1 ^= this.s1, s22 ^= this.s2, s32 ^= this.s3;
    const { W: W6, t: t6, windowSize } = this;
    let o0 = 0, o1 = 0, o22 = 0, o32 = 0;
    const mask = (1 << W6) - 1;
    let w8 = 0;
    for (const num3 of [s0, s1, s22, s32]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num3 >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W6 - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W6 * bitPos & mask;
          const { s0: e0, s1: e1, s2: e22, s3: e32 } = t6[w8 * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o22 ^= e22, o32 ^= e32;
          w8 += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o22;
    this.s3 = o32;
  }
  update(data) {
    data = toBytes14(data);
    exists2(this);
    const b32 = u323(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left13 = data.length % BLOCK_SIZE;
    for (let i9 = 0; i9 < blocks; i9++) {
      this._updateBlock(b32[i9 * 4 + 0], b32[i9 * 4 + 1], b32[i9 * 4 + 2], b32[i9 * 4 + 3]);
    }
    if (left13) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      ZEROS32.fill(0);
    }
    return this;
  }
  destroy() {
    const { t: t6 } = this;
    for (const elm of t6) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    exists2(this);
    output(out, this);
    this.finished = true;
    const { s0, s1, s2: s22, s3: s32 } = this;
    const o32 = u323(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s22;
    o32[3] = s32;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes14(key);
    const ghKey = _toGHASHKey(key.slice());
    super(ghKey, expectedLength);
    ghKey.fill(0);
  }
  update(data) {
    data = toBytes14(data);
    exists2(this);
    const b32 = u323(data);
    const left13 = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i9 = 0; i9 < blocks; i9++) {
      this._updateBlock(swapLE(b32[i9 * 4 + 3]), swapLE(b32[i9 * 4 + 2]), swapLE(b32[i9 * 4 + 1]), swapLE(b32[i9 * 4 + 0]));
    }
    if (left13) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      ZEROS32.fill(0);
    }
    return this;
  }
  digestInto(out) {
    exists2(this);
    output(out, this);
    this.finished = true;
    const { s0, s1, s2: s22, s3: s32 } = this;
    const o32 = u323(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s22;
    o32[3] = s32;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes14(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n5) {
  return n5 << 1 ^ POLY2 & -(n5 >> 7);
}
function mul(a6, b6) {
  let res = 0;
  for (; b6 > 0; b6 >>= 1) {
    res ^= a6 & -(b6 & 1);
    a6 = mul22(a6);
  }
  return res;
}
var _sbox = (() => {
  let t6 = new Uint8Array(256);
  for (let i9 = 0, x7 = 1; i9 < 256; i9++, x7 ^= mul22(x7))
    t6[i9] = x7;
  const sbox = new Uint8Array(256);
  sbox[0] = 99;
  for (let i9 = 0; i9 < 255; i9++) {
    let x7 = t6[255 - i9];
    x7 |= x7 << 8;
    sbox[t6[i9]] = (x7 ^ x7 >> 4 ^ x7 >> 5 ^ x7 >> 6 ^ x7 >> 7 ^ 99) & 255;
  }
  return sbox;
})();
var _inv_sbox = _sbox.map((_6, j9) => _sbox.indexOf(j9));
var rotr32_8 = (n5) => n5 << 24 | n5 >>> 8;
var rotl32_8 = (n5) => n5 << 8 | n5 >>> 24;
function genTtable(sbox, fn4) {
  if (sbox.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_6, j9) => fn4(sbox[j9]));
  const T1 = T0.map(rotl32_8);
  const T22 = T1.map(rotl32_8);
  const T32 = T22.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox2 = new Uint16Array(256 * 256);
  for (let i9 = 0; i9 < 256; i9++) {
    for (let j9 = 0; j9 < 256; j9++) {
      const idx = i9 * 256 + j9;
      T01[idx] = T0[i9] ^ T1[j9];
      T23[idx] = T22[i9] ^ T32[j9];
      sbox2[idx] = sbox[i9] << 8 | sbox[j9];
    }
  }
  return { sbox, sbox2, T0, T1, T2: T22, T3: T32, T01, T23 };
}
var TABLE_ENC = genTtable(_sbox, (s5) => mul(s5, 3) << 24 | s5 << 16 | s5 << 8 | mul(s5, 2));
var TABLE_DEC = genTtable(_inv_sbox, (s5) => mul(s5, 11) << 24 | mul(s5, 13) << 16 | mul(s5, 9) << 8 | mul(s5, 14));
var POWX = (() => {
  const p9 = new Uint8Array(16);
  for (let i9 = 0, x7 = 1; i9 < 16; i9++, x7 = mul22(x7))
    p9[i9] = x7;
  return p9;
})();
function expandKeyLE(key) {
  ensureBytes3(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
  const { sbox2 } = TABLE_ENC;
  const k32 = u323(key);
  const Nk = k32.length;
  const subByte = (n5) => applySbox(sbox2, n5, n5, n5, n5);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i9 = Nk; i9 < xk.length; i9++) {
    let t6 = xk[i9 - 1];
    if (i9 % Nk === 0)
      t6 = subByte(rotr32_8(t6)) ^ POWX[i9 / Nk - 1];
    else if (Nk > 6 && i9 % Nk === 4)
      t6 = subByte(t6);
    xk[i9] = xk[i9 - Nk] ^ t6;
  }
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = TABLE_ENC;
  const { T0, T1, T2: T22, T3: T32 } = TABLE_DEC;
  for (let i9 = 0; i9 < Nk; i9 += 4) {
    for (let j9 = 0; j9 < 4; j9++)
      xk[i9 + j9] = encKey[Nk - i9 - 4 + j9];
  }
  encKey.fill(0);
  for (let i9 = 4; i9 < Nk - 4; i9++) {
    const x7 = xk[i9];
    const w8 = applySbox(sbox2, x7, x7, x7, x7);
    xk[i9] = T0[w8 & 255] ^ T1[w8 >>> 8 & 255] ^ T22[w8 >>> 16 & 255] ^ T32[w8 >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s22, s32) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s22 >>> 8 & 65280 | s32 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s22, s32) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s22 >>> 16 & 255 | s32 >>> 16 & 65280] << 16;
}
function encrypt3(xk, s0, s1, s22, s32) {
  const { sbox2, T01, T23 } = TABLE_ENC;
  let k11 = 0;
  s0 ^= xk[k11++], s1 ^= xk[k11++], s22 ^= xk[k11++], s32 ^= xk[k11++];
  const rounds = xk.length / 4 - 2;
  for (let i9 = 0; i9 < rounds; i9++) {
    const t02 = xk[k11++] ^ apply0123(T01, T23, s0, s1, s22, s32);
    const t12 = xk[k11++] ^ apply0123(T01, T23, s1, s22, s32, s0);
    const t23 = xk[k11++] ^ apply0123(T01, T23, s22, s32, s0, s1);
    const t33 = xk[k11++] ^ apply0123(T01, T23, s32, s0, s1, s22);
    s0 = t02, s1 = t12, s22 = t23, s32 = t33;
  }
  const t0 = xk[k11++] ^ applySbox(sbox2, s0, s1, s22, s32);
  const t1 = xk[k11++] ^ applySbox(sbox2, s1, s22, s32, s0);
  const t22 = xk[k11++] ^ applySbox(sbox2, s22, s32, s0, s1);
  const t32 = xk[k11++] ^ applySbox(sbox2, s32, s0, s1, s22);
  return { s0: t0, s1: t1, s2: t22, s3: t32 };
}
function decrypt3(xk, s0, s1, s22, s32) {
  const { sbox2, T01, T23 } = TABLE_DEC;
  let k11 = 0;
  s0 ^= xk[k11++], s1 ^= xk[k11++], s22 ^= xk[k11++], s32 ^= xk[k11++];
  const rounds = xk.length / 4 - 2;
  for (let i9 = 0; i9 < rounds; i9++) {
    const t02 = xk[k11++] ^ apply0123(T01, T23, s0, s32, s22, s1);
    const t12 = xk[k11++] ^ apply0123(T01, T23, s1, s0, s32, s22);
    const t23 = xk[k11++] ^ apply0123(T01, T23, s22, s1, s0, s32);
    const t33 = xk[k11++] ^ apply0123(T01, T23, s32, s22, s1, s0);
    s0 = t02, s1 = t12, s22 = t23, s32 = t33;
  }
  const t0 = xk[k11++] ^ applySbox(sbox2, s0, s32, s22, s1);
  const t1 = xk[k11++] ^ applySbox(sbox2, s1, s0, s32, s22);
  const t22 = xk[k11++] ^ applySbox(sbox2, s22, s1, s0, s32);
  const t32 = xk[k11++] ^ applySbox(sbox2, s32, s22, s1, s0);
  return { s0: t0, s1: t1, s2: t22, s3: t32 };
}
function getDst(len, dst) {
  if (!dst)
    return new Uint8Array(len);
  ensureBytes3(dst);
  if (dst.length < len)
    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
  return dst;
}
function ctrCounter(xk, nonce, src, dst) {
  ensureBytes3(nonce, BLOCK_SIZE2);
  ensureBytes3(src);
  const srcLen = src.length;
  dst = getDst(srcLen, dst);
  const ctr3 = nonce;
  const c32 = u323(ctr3);
  let { s0, s1, s2: s22, s3: s32 } = encrypt3(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u323(src);
  const dst32 = u323(dst);
  for (let i9 = 0; i9 + 4 <= src32.length; i9 += 4) {
    dst32[i9 + 0] = src32[i9 + 0] ^ s0;
    dst32[i9 + 1] = src32[i9 + 1] ^ s1;
    dst32[i9 + 2] = src32[i9 + 2] ^ s22;
    dst32[i9 + 3] = src32[i9 + 3] ^ s32;
    let carry = 1;
    for (let i10 = ctr3.length - 1; i10 >= 0; i10--) {
      carry = carry + (ctr3[i10] & 255) | 0;
      ctr3[i10] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2: s22, s3: s32 } = encrypt3(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s22, s32]);
    const buf = u82(b32);
    for (let i9 = start, pos = 0; i9 < srcLen; i9++, pos++)
      dst[i9] = src[i9] ^ buf[pos];
  }
  return dst;
}
function ctr32(xk, isLE5, nonce, src, dst) {
  ensureBytes3(nonce, BLOCK_SIZE2);
  ensureBytes3(src);
  dst = getDst(src.length, dst);
  const ctr3 = nonce;
  const c32 = u323(ctr3);
  const view = createView4(ctr3);
  const src32 = u323(src);
  const dst32 = u323(dst);
  const ctrPos = isLE5 ? 0 : 12;
  const srcLen = src.length;
  let ctrNum = view.getUint32(ctrPos, isLE5);
  let { s0, s1, s2: s22, s3: s32 } = encrypt3(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i9 = 0; i9 + 4 <= src32.length; i9 += 4) {
    dst32[i9 + 0] = src32[i9 + 0] ^ s0;
    dst32[i9 + 1] = src32[i9 + 1] ^ s1;
    dst32[i9 + 2] = src32[i9 + 2] ^ s22;
    dst32[i9 + 3] = src32[i9 + 3] ^ s32;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE5);
    ({ s0, s1, s2: s22, s3: s32 } = encrypt3(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s22, s32]);
    const buf = u82(b32);
    for (let i9 = start, pos = 0; i9 < srcLen; i9++, pos++)
      dst[i9] = src[i9] ^ buf[pos];
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce) {
  ensureBytes3(key);
  ensureBytes3(nonce, BLOCK_SIZE2);
  function processCtr(buf, dst) {
    const xk = expandKeyLE(key);
    const n5 = nonce.slice();
    const out = ctrCounter(xk, n5, buf, dst);
    xk.fill(0);
    n5.fill(0);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  ensureBytes3(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  const b6 = u323(plaintext);
  if (pcks5) {
    let left13 = BLOCK_SIZE2 - remaining;
    if (!left13)
      left13 = BLOCK_SIZE2;
    outLen = outLen + left13;
  }
  const out = getDst(outLen, dst);
  const o6 = u323(out);
  return { b: b6, o: o6, out };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
  const out = data.subarray(0, -lastByte);
  for (let i9 = 0; i9 < lastByte; i9++)
    if (data[len - i9 - 1] !== lastByte)
      throw new Error(`aes/pcks5: wrong padding`);
  return out;
}
function padPCKS(left13) {
  const tmp = new Uint8Array(16);
  const tmp32 = u323(tmp);
  tmp.set(left13);
  const paddingByte = BLOCK_SIZE2 - left13.length;
  for (let i9 = BLOCK_SIZE2 - paddingByte; i9 < BLOCK_SIZE2; i9++)
    tmp[i9] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function ecb2(key, opts2 = {}) {
  ensureBytes3(key);
  const pcks5 = !opts2.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      ensureBytes3(plaintext);
      const { b: b6, o: o6, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i9 = 0;
      for (; i9 + 4 <= b6.length; ) {
        const { s0, s1, s2: s22, s3: s32 } = encrypt3(xk, b6[i9 + 0], b6[i9 + 1], b6[i9 + 2], b6[i9 + 3]);
        o6[i9++] = s0, o6[i9++] = s1, o6[i9++] = s22, o6[i9++] = s32;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i9 * 4));
        const { s0, s1, s2: s22, s3: s32 } = encrypt3(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o6[i9++] = s0, o6[i9++] = s1, o6[i9++] = s22, o6[i9++] = s32;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const out = getDst(ciphertext.length, dst);
      const b6 = u323(ciphertext);
      const o6 = u323(out);
      for (let i9 = 0; i9 + 4 <= b6.length; ) {
        const { s0, s1, s2: s22, s3: s32 } = decrypt3(xk, b6[i9 + 0], b6[i9 + 1], b6[i9 + 2], b6[i9 + 3]);
        o6[i9++] = s0, o6[i9++] = s1, o6[i9++] = s22, o6[i9++] = s32;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts2 = {}) {
  ensureBytes3(key);
  ensureBytes3(iv, 16);
  const pcks5 = !opts2.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      const xk = expandKeyLE(key);
      const { b: b6, o: o6, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const n32 = u323(iv);
      let s0 = n32[0], s1 = n32[1], s22 = n32[2], s32 = n32[3];
      let i9 = 0;
      for (; i9 + 4 <= b6.length; ) {
        s0 ^= b6[i9 + 0], s1 ^= b6[i9 + 1], s22 ^= b6[i9 + 2], s32 ^= b6[i9 + 3];
        ({ s0, s1, s2: s22, s3: s32 } = encrypt3(xk, s0, s1, s22, s32));
        o6[i9++] = s0, o6[i9++] = s1, o6[i9++] = s22, o6[i9++] = s32;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i9 * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s22 ^= tmp32[2], s32 ^= tmp32[3];
        ({ s0, s1, s2: s22, s3: s32 } = encrypt3(xk, s0, s1, s22, s32));
        o6[i9++] = s0, o6[i9++] = s1, o6[i9++] = s22, o6[i9++] = s32;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const n32 = u323(iv);
      const out = getDst(ciphertext.length, dst);
      const b6 = u323(ciphertext);
      const o6 = u323(out);
      let s0 = n32[0], s1 = n32[1], s22 = n32[2], s32 = n32[3];
      for (let i9 = 0; i9 + 4 <= b6.length; ) {
        const ps0 = s0, ps1 = s1, ps22 = s22, ps3 = s32;
        s0 = b6[i9 + 0], s1 = b6[i9 + 1], s22 = b6[i9 + 2], s32 = b6[i9 + 3];
        const { s0: o0, s1: o1, s2: o22, s3: o32 } = decrypt3(xk, s0, s1, s22, s32);
        o6[i9++] = o0 ^ ps0, o6[i9++] = o1 ^ ps1, o6[i9++] = o22 ^ ps22, o6[i9++] = o32 ^ ps3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
function computeTag(fn4, isLE5, key, data, AAD) {
  const h9 = fn4.create(key, data.length + ((AAD == null ? void 0 : AAD.length) || 0));
  if (AAD)
    h9.update(AAD);
  h9.update(data);
  const num3 = new Uint8Array(16);
  const view = createView4(num3);
  if (AAD)
    setBigUint642(view, 0, BigInt(AAD.length * 8), isLE5);
  setBigUint642(view, 8, BigInt(data.length * 8), isLE5);
  h9.update(num3);
  return h9.digest();
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce, AAD) {
  ensureBytes3(nonce);
  if (nonce.length === 0)
    throw new Error("aes/gcm: empty nonce");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag = computeTag(ghash, false, authKey, data, AAD);
    for (let i9 = 0; i9 < tagMask.length; i9++)
      tag[i9] ^= tagMask[i9];
    return tag;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter, counter, authKey);
    if (nonce.length === 12) {
      counter.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView4(nonceLen);
      setBigUint642(view, 8, BigInt(nonce.length * 8), false);
      ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);
    }
    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
    return { xk, authKey, counter, tagMask };
  }
  return {
    encrypt: (plaintext) => {
      ensureBytes3(plaintext);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      ctr32(xk, false, counter, plaintext, out);
      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      out.set(tag, plaintext.length);
      xk.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      ensureBytes3(ciphertext);
      if (ciphertext.length < tagLength)
        throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = _computeTag(authKey, tagMask, data);
      if (!equalBytes5(tag, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter, data);
      authKey.fill(0);
      tagMask.fill(0);
      xk.fill(0);
      return out;
    }
  };
});
var limit = (name, min4, max4) => (value2) => {
  if (!Number.isSafeInteger(value2) || min4 > value2 || value2 > max4)
    throw new Error(`${name}: invalid value=${value2}, must be [${min4}..${max4}]`);
};
var siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  ensureBytes3(nonce);
  NONCE_LIMIT(nonce.length);
  if (AAD) {
    ensureBytes3(AAD);
    AAD_LIMIT(AAD.length);
  }
  function deriveKeys() {
    const len = key.length;
    if (len !== 16 && len !== 24 && len !== 32)
      throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(len);
    const authKey = new Uint8Array(16);
    const n32 = u323(nonce);
    let s0 = 0, s1 = n32[0], s22 = n32[1], s32 = n32[2];
    let counter = 0;
    for (const derivedKey of [authKey, encKey].map(u323)) {
      const d32 = u323(derivedKey);
      for (let i9 = 0; i9 < d32.length; i9 += 2) {
        const { s0: o0, s1: o1 } = encrypt3(xk, s0, s1, s22, s32);
        d32[i9 + 0] = o0;
        d32[i9 + 1] = o1;
        s0 = ++counter;
      }
    }
    xk.fill(0);
    return { authKey, encKey: expandKeyLE(encKey) };
  }
  function _computeTag(encKey, authKey, data) {
    const tag = computeTag(polyval, true, authKey, data, AAD);
    for (let i9 = 0; i9 < 12; i9++)
      tag[i9] ^= nonce[i9];
    tag[15] &= 127;
    const t32 = u323(tag);
    let s0 = t32[0], s1 = t32[1], s22 = t32[2], s32 = t32[3];
    ({ s0, s1, s2: s22, s3: s32 } = encrypt3(encKey, s0, s1, s22, s32));
    t32[0] = s0, t32[1] = s1, t32[2] = s22, t32[3] = s32;
    return tag;
  }
  function processSiv(encKey, tag, input) {
    let block = tag.slice();
    block[15] |= 128;
    return ctr32(encKey, true, block, input);
  }
  return {
    encrypt: (plaintext) => {
      ensureBytes3(plaintext);
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag = _computeTag(encKey, authKey, plaintext);
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag, plaintext.length);
      out.set(processSiv(encKey, tag, plaintext));
      encKey.fill(0);
      authKey.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      ensureBytes3(ciphertext);
      CIPHER_LIMIT(ciphertext.length);
      const tag = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      encKey.fill(0);
      authKey.fill(0);
      if (!equalBytes5(tag, expectedTag))
        throw new Error("invalid polyval tag");
      return plaintext;
    }
  };
});

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-shared/dist/index.js
var __defProp = Object.defineProperty;
var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
var WebSocketErrorType = function(WebSocketErrorType2) {
  WebSocketErrorType2["INVALID_MESSAGE"] = "INVALID_MESSAGE";
  WebSocketErrorType2["HANDLER_NOT_FOUND"] = "HANDLER_NOT_FOUND";
  WebSocketErrorType2["HANDLER_ERROR"] = "HANDLER_ERROR";
  WebSocketErrorType2["CONNECTION_ERROR"] = "CONNECTION_ERROR";
  WebSocketErrorType2["VALIDATION_ERROR"] = "VALIDATION_ERROR";
  return WebSocketErrorType2;
}({});
var _a4;
var BaseMessage = (_a4 = class {
  constructor(data) {
    __publicField(this, "data");
    this.data = data;
  }
  getData() {
    return this.data;
  }
}, __name(_a4, "BaseMessage"), _a4);
var Uint8ArrayCodec = new Type(
  "Uint8Array",
  (u10) => u10 instanceof Uint8Array,
  (u10, c9) => {
    if (typeof u10 !== "string") {
      return failure(u10, c9, "Expected a hex string for Uint8Array");
    }
    try {
      const cleanHex = u10.startsWith("0x") ? u10.slice(2) : u10;
      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {
        return failure(u10, c9, "Invalid hex string format");
      }
      const decoded = hexToBytes5(cleanHex);
      return success(decoded);
    } catch (e11) {
      return failure(u10, c9, `Invalid hex string: ${e11}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a6) => bytesToHex5(a6)
);
var Uint32ArrayCodec = new Type(
  "Uint32Array",
  (u10) => u10 instanceof Uint32Array,
  (u10, c9) => {
    if (typeof u10 !== "string") {
      return failure(u10, c9, "Expected a hex string for Uint32Array");
    }
    try {
      const cleanHex = u10.startsWith("0x") ? u10.slice(2) : u10;
      if (cleanHex.length === 0) {
        return failure(u10, c9, "Empty hex string not allowed for Uint32Array");
      }
      if (cleanHex.length % 8 !== 0) {
        return failure(u10, c9, "Invalid hex string format for Uint32Array (must be multiple of 8 hex characters)");
      }
      const uint8Array = hexToBytes5(cleanHex);
      const uint32Array = new Uint32Array(uint8Array.buffer);
      return success(uint32Array);
    } catch (e11) {
      return failure(u10, c9, `Invalid hex string: ${e11}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a6) => {
    const uint8Array = new Uint8Array(a6.buffer);
    return bytesToHex5(uint8Array);
  }
);
var EncryptedKeyshareCodec = type6({
  salt: Uint8ArrayCodec,
  encryptedPayload: Uint8ArrayCodec
});
function buildMessageSchema(messageType, version11, additionalFields = {}, ...additionalSchemas) {
  const schema = type6({
    type: literal(messageType),
    version: literal(version11),
    ...additionalFields
  });
  if (additionalSchemas.length === 0) {
    return schema;
  }
  if (additionalSchemas.length === 1) {
    return intersection3([
      schema,
      additionalSchemas[0]
    ]);
  }
  let result = intersection3([
    schema,
    additionalSchemas[0]
  ]);
  for (let i9 = 1; i9 < additionalSchemas.length; i9++) {
    result = intersection3([
      result,
      additionalSchemas[i9]
    ]);
  }
  return result;
}
__name(buildMessageSchema, "buildMessageSchema");
function createComplexEncoder(messageType, version11, fieldTransforms = {}) {
  return (data) => {
    const encoded = {
      type: messageType,
      version: version11
    };
    for (const [key, value2] of Object.entries(data)) {
      if (value2 !== void 0) {
        encoded[key] = fieldTransforms[key] ? fieldTransforms[key](value2) : value2;
      }
    }
    return encoded;
  };
}
__name(createComplexEncoder, "createComplexEncoder");
function createStandardDecoder(fieldExtractor) {
  return (decoded) => fieldExtractor(decoded);
}
__name(createStandardDecoder, "createStandardDecoder");
function createStandardMessage(config2) {
  var _a14;
  let StandardMessageClass = (_a14 = class extends BaseMessage {
    constructor(data) {
      super(data);
      __publicField(this, "type", config2.messageType);
      __publicField(this, "version", config2.version);
    }
    encode() {
      return config2.encodeData(this.data, this.type, this.version);
    }
    static decode(wireData) {
      const result = config2.schema.decode(wireData);
      if (Either_exports.isLeft(result)) {
        return result;
      }
      const decoded = result.right;
      return {
        _tag: "Right",
        right: new _a14(config2.decodeData(decoded))
      };
    }
  }, __name(_a14, "StandardMessageClass"), __publicField(_a14, "MESSAGE_TYPE", config2.messageType), __publicField(_a14, "MESSAGE_VERSION", config2.version), __publicField(_a14, "schema", config2.schema), _a14);
  return StandardMessageClass;
}
__name(createStandardMessage, "createStandardMessage");
function createSimpleMessage(config2) {
  return createStandardMessage({
    messageType: config2.messageType,
    version: config2.version,
    schema: config2.schema,
    encodeData: __name((data) => ({
      type: config2.messageType,
      version: config2.version,
      ...data
    }), "encodeData"),
    decodeData: __name((decoded) => {
      const { type: type7, version: version11, ...data } = decoded;
      return data;
    }, "decodeData")
  });
}
__name(createSimpleMessage, "createSimpleMessage");
var HandshakeRequestSchema = buildMessageSchema("handshake", 1, {
  challenge: Uint8ArrayCodec,
  nonce: Uint8ArrayCodec
});
var HandshakeV1RequestMessage = createStandardMessage({
  messageType: "handshake",
  version: 1,
  schema: HandshakeRequestSchema,
  encodeData: __name((data) => HandshakeRequestSchema.encode({
    type: "handshake",
    version: 1,
    challenge: data.challenge,
    nonce: data.nonce
  }), "encodeData"),
  decodeData: createStandardDecoder((decoded) => ({
    challenge: decoded.challenge,
    nonce: decoded.nonce
  }))
});
var HandshakeResponseSchema = buildMessageSchema("handshake_response", 1, {
  encapsulatedSharedSecret: string2,
  attestationDoc: string2,
  connectionId: string2
});
var HandshakeV1ResponseMessage = createSimpleMessage({
  messageType: "handshake_response",
  version: 1,
  schema: HandshakeResponseSchema
});
var _a5;
var BaseSigningAlgorithm = (_a5 = class {
}, __name(_a5, "BaseSigningAlgorithm"), _a5);
var _a6;
var Ed25519SigningAlgorithm = (_a6 = class extends BaseSigningAlgorithm {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "ed25519");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type6({
        signingAlgo: literal("ed25519")
      }),
      partial({
        derivationPath: Uint32ArrayCodec
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: new Uint8Array(32)
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name(_a6, "Ed25519SigningAlgorithm"), _a6);
var _a7;
var BIP340SigningAlgorithm = (_a7 = class extends BaseSigningAlgorithm {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "bip340");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type6({
        signingAlgo: literal("bip340")
      }),
      partial({
        derivationPath: Uint32ArrayCodec,
        tweak: Uint8ArrayCodec
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: new Uint8Array(32)
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name(_a7, "BIP340SigningAlgorithm"), _a7);
var _a8;
var EcdsaSigningAlgorithm = (_a8 = class extends BaseSigningAlgorithm {
  constructor() {
    super(...arguments);
    __publicField(this, "algorithmName", "ecdsa");
    __publicField(this, "version", 1);
    __publicField(this, "schema", intersection3([
      type6({
        signingAlgo: literal("ecdsa")
      }),
      partial({
        hashAlgo: union5([
          literal("sha256"),
          literal("sha256d"),
          literal("keccak256")
        ]),
        derivationPath: Uint32ArrayCodec
      })
    ]));
  }
  createKeygenResultFromSecretShare(secretShare) {
    return {
      secretShare,
      pubkey: {
        pubKeyAsHex: __name(() => "0x" + "00".repeat(33), "pubKeyAsHex"),
        serializeCompressed: __name(() => new Uint8Array(33), "serializeCompressed"),
        serializeUncompressed: __name(() => new Uint8Array(65), "serializeUncompressed")
      }
    };
  }
  createSignRequest(keygenResult, params) {
    return {
      secretShare: keygenResult.secretShare,
      ...params
    };
  }
  processSignResult(_result) {
    return new Uint8Array(64);
  }
}, __name(_a8, "EcdsaSigningAlgorithm"), _a8);
var SIGNING_ALGORITHM_CLASSES = {
  ed25519: Ed25519SigningAlgorithm,
  bip340: BIP340SigningAlgorithm,
  ecdsa: EcdsaSigningAlgorithm
};
var ALL_SIGNING_ALGORITHM_NAMES = Object.keys(SIGNING_ALGORITHM_CLASSES);
var SIGNING_ALGORITHM_INSTANCES = {
  ed25519: new SIGNING_ALGORITHM_CLASSES.ed25519(),
  bip340: new SIGNING_ALGORITHM_CLASSES.bip340(),
  ecdsa: new SIGNING_ALGORITHM_CLASSES.ecdsa()
};
var ALL_SIGNING_ALGORITHM_SCHEMA = (() => {
  const schemas = Object.values(SIGNING_ALGORITHM_INSTANCES).map((instance) => instance.schema);
  if (schemas.length === 0) {
    throw new Error("No signing algorithms defined");
  }
  if (schemas.length === 1) {
    return schemas[0];
  }
  return union5([
    schemas[0],
    schemas[1],
    ...schemas.slice(2)
  ]);
})();
function isValidSigningAlgorithm(name) {
  return name in SIGNING_ALGORITHM_CLASSES;
}
__name(isValidSigningAlgorithm, "isValidSigningAlgorithm");
function createKeygenResultFromSecretShare(algorithmName, secretShare) {
  const algorithm = SIGNING_ALGORITHM_INSTANCES[algorithmName];
  if (!algorithm) {
    throw new Error(`Unknown signing algorithm: ${algorithmName}`);
  }
  return algorithm.createKeygenResultFromSecretShare(secretShare);
}
__name(createKeygenResultFromSecretShare, "createKeygenResultFromSecretShare");
var ALGORITHMS = {
  [SigningAlgorithm.ECDSA]: {
    name: "ecdsa",
    dynamicEnum: SigningAlgorithm.ECDSA,
    className: "Ecdsa",
    requiresHashAlgo: true,
    supportsDerivationPath: true,
    supportsTweak: false,
    supportedHashAlgos: [
      "sha256",
      "sha256d",
      "keccak256"
    ]
  },
  [SigningAlgorithm.ED25519]: {
    name: "ed25519",
    dynamicEnum: SigningAlgorithm.ED25519,
    className: "Ed25519",
    requiresHashAlgo: false,
    supportsDerivationPath: true,
    supportsTweak: false,
    supportedHashAlgos: []
  },
  [SigningAlgorithm.BIP340]: {
    name: "bip340",
    dynamicEnum: SigningAlgorithm.BIP340,
    className: "BIP340",
    requiresHashAlgo: false,
    supportsDerivationPath: true,
    supportsTweak: true,
    supportedHashAlgos: []
  }
};
function toDynamicSigningAlgorithm(algorithmName) {
  const algorithmConfig = Object.values(ALGORITHMS).find((config2) => config2.name === algorithmName);
  if (!algorithmConfig) {
    throw new Error(`Unknown algorithm: ${algorithmName}`);
  }
  return algorithmConfig.dynamicEnum;
}
__name(toDynamicSigningAlgorithm, "toDynamicSigningAlgorithm");
function fromDynamicSigningAlgorithm(dynamicAlgorithm) {
  const algorithmConfig = ALGORITHMS[dynamicAlgorithm];
  if (!algorithmConfig) {
    throw new Error(`Unknown Dynamic SDK algorithm: ${dynamicAlgorithm}`);
  }
  return algorithmConfig.name;
}
__name(fromDynamicSigningAlgorithm, "fromDynamicSigningAlgorithm");
var SignatureAlgoSchema = ALL_SIGNING_ALGORITHM_SCHEMA;
var DomainCodec = new Type("DomainCodec", (u10) => typeof u10 === "string", (u10, c9) => {
  if (typeof u10 !== "string") {
    return failure(u10, c9, "Value must be a string");
  }
  const domainPattern = /^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(?::\d{1,5})?$/;
  if (!domainPattern.test(u10)) {
    return failure(u10, c9, "Invalid domain format");
  }
  return success(u10);
}, identity2);
var Uint8ArrayOrHexCodec = new Type(
  "Uint8ArrayOrHex",
  (u10) => u10 instanceof Uint8Array,
  (u10, c9) => {
    if (u10 instanceof Uint8Array) {
      return success(u10);
    }
    if (typeof u10 !== "string") {
      return failure(u10, c9, "Expected a hex string or Uint8Array");
    }
    try {
      const cleanHex = u10.startsWith("0x") ? u10.slice(2) : u10;
      if (cleanHex.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(cleanHex)) {
        return failure(u10, c9, "Invalid hex string format");
      }
      const decoded = hexToBytes5(cleanHex);
      return success(decoded);
    } catch (e11) {
      return failure(u10, c9, `Invalid hex string: ${e11}`);
    }
  },
  // The `encode` function for converting back to the output type
  (a6) => {
    if (typeof a6 === "string") {
      return a6;
    }
    return bytesToHex5(a6);
  }
);
var SignMessageRequestSchema = buildMessageSchema("signMessage", 1, {
  relayDomain: DomainCodec,
  keyshare: EncryptedKeyshareCodec,
  message: Uint8ArrayOrHexCodec,
  roomUuid: string2
}, SignatureAlgoSchema);
var SignMessageV1RequestMessage = createStandardMessage({
  messageType: "signMessage",
  version: 1,
  schema: SignMessageRequestSchema,
  encodeData: createComplexEncoder("signMessage", 1, {
    signingAlgo: __name((value2) => fromDynamicSigningAlgorithm(value2), "signingAlgo"),
    derivationPath: __name((value2) => Uint32ArrayCodec.encode(value2), "derivationPath"),
    tweak: __name((value2) => Uint8ArrayCodec.encode(value2), "tweak"),
    keyshare: __name((value2) => EncryptedKeyshareCodec.encode(value2), "keyshare"),
    message: __name((value2) => Uint8ArrayOrHexCodec.encode(value2), "message")
  }),
  decodeData: createStandardDecoder((decoded) => ({
    relayDomain: decoded.relayDomain,
    signingAlgo: decoded.signingAlgo,
    hashAlgo: decoded.hashAlgo,
    derivationPath: decoded.derivationPath,
    tweak: decoded.tweak,
    keyshare: decoded.keyshare,
    message: decoded.message,
    roomUuid: decoded.roomUuid
  }))
});
var WebSocketErrorTypeCodec = string2;
var WebSocketErrorCodec = type6({
  type: WebSocketErrorTypeCodec,
  message: string2,
  details: union5([
    unknown,
    undefinedType
  ])
});
var SignMessageResponseSchema = buildMessageSchema("signMessage_response", 1, {
  signature: union5([
    Uint8ArrayOrHexCodec,
    undefinedType
  ]),
  error: union5([
    WebSocketErrorCodec,
    undefinedType
  ])
});
var SignMessageV1ResponseMessage = createStandardMessage({
  messageType: "signMessage_response",
  version: 1,
  schema: SignMessageResponseSchema,
  encodeData: createComplexEncoder("signMessage_response", 1, {
    signature: __name((value2) => Uint8ArrayOrHexCodec.encode(value2), "signature")
  }),
  decodeData: createStandardDecoder((decoded) => ({
    signature: decoded.signature,
    error: decoded.error
  }))
});
var ConnectionAckRequestSchema = buildMessageSchema("connection_ack", 1, {
  connectionId: union5([
    string2,
    undefinedType
  ])
});
var ConnectionAckV1RequestMessage = createSimpleMessage({
  messageType: "connection_ack",
  version: 1,
  schema: ConnectionAckRequestSchema
});
var ConnectionAckResponseSchema = buildMessageSchema("connection_ack_response", 1, {
  status: literal("acknowledged"),
  timestamp: string2
});
var ConnectionAckV1ResponseMessage = createSimpleMessage({
  messageType: "connection_ack_response",
  version: 1,
  schema: ConnectionAckResponseSchema
});
var ALL_MESSAGE_CLASSES = {
  "handshake@1": HandshakeV1RequestMessage,
  "handshake_response@1": HandshakeV1ResponseMessage,
  "signMessage@1": SignMessageV1RequestMessage,
  "signMessage_response@1": SignMessageV1ResponseMessage,
  "connection_ack@1": ConnectionAckV1RequestMessage,
  "connection_ack_response@1": ConnectionAckV1ResponseMessage
};
var ALL_MESSAGE_KEYS = Object.keys(ALL_MESSAGE_CLASSES);
function getMessageClass(type7, version11) {
  const key = `${type7}@${version11}`;
  const MessageClass = ALL_MESSAGE_CLASSES[key];
  if (!MessageClass) {
    throw new Error(`Unknown message type: ${type7} version ${version11}`);
  }
  return MessageClass;
}
__name(getMessageClass, "getMessageClass");
function isValidMessageType(type7, version11) {
  const key = `${type7}@${version11}`;
  return key in ALL_MESSAGE_CLASSES;
}
__name(isValidMessageType, "isValidMessageType");
function getAllSupportedMessages() {
  return ALL_MESSAGE_KEYS.map((key) => {
    const [type7, versionStr] = key.split("@");
    return {
      type: type7,
      version: parseInt(versionStr, 10)
    };
  });
}
__name(getAllSupportedMessages, "getAllSupportedMessages");
function parseMessageKey(key) {
  const [type7, versionStr] = key.split("@");
  return {
    type: type7,
    version: parseInt(versionStr, 10)
  };
}
__name(parseMessageKey, "parseMessageKey");
var _a9;
var MessageRegistry = (_a9 = class {
  constructor() {
  }
  static getInstance() {
    if (!_a9.instance) {
      _a9.instance = new _a9();
    }
    return _a9.instance;
  }
  /**
  * Get a message class by type and version (derived from single source)
  */
  getMessageClass(type7, version11) {
    try {
      return getMessageClass(type7, version11);
    } catch {
      return void 0;
    }
  }
  /**
  * Create a message instance from wire data (using derived message classes)
  */
  decode(wireData) {
    if (!wireData || typeof wireData !== "object") {
      return {
        _tag: "Left",
        left: "Invalid wire data: must be an object"
      };
    }
    const { type: type7, version: version11 } = wireData;
    if (!type7 || !version11) {
      return {
        _tag: "Left",
        left: "Invalid wire data: missing type or version"
      };
    }
    const MessageClass = this.getMessageClass(type7, version11);
    if (!MessageClass) {
      return {
        _tag: "Left",
        left: `Unknown message type: ${type7}@${version11}`
      };
    }
    const result = MessageClass.decode(wireData);
    if (Either_exports.isLeft(result)) {
      return {
        _tag: "Left",
        left: `Decode error: ${result.left.map((e11) => e11.message).join(", ")}`
      };
    }
    return {
      _tag: "Right",
      right: result.right
    };
  }
  /**
  * Encode a message to wire format
  */
  encode(message) {
    return message.encode();
  }
  /**
  * Get all registered message types (derived from single source)
  */
  getRegisteredTypes() {
    return getAllSupportedMessages().map(({ type: type7, version: version11 }) => `${type7}@${version11}`);
  }
}, __name(_a9, "MessageRegistry"), __publicField(_a9, "instance"), _a9);
var messageRegistry = MessageRegistry.getInstance();
function assertDefined(value2, message) {
  if (value2 === null || value2 === void 0) {
    throw new Error(message ?? "Value must be defined");
  }
}
__name(assertDefined, "assertDefined");
function assertNotNull(value2, message) {
  if (value2 === null) {
    throw new Error(message ?? "Value must not be null");
  }
}
__name(assertNotNull, "assertNotNull");
function getDefined(value2, message) {
  assertDefined(value2, message);
  return value2;
}
__name(getDefined, "getDefined");
var generateMlKem768Keypair = __name(() => {
  try {
    const keys5 = ml_kem768.keygen();
    assertNotNull(keys5.publicKey, "Encapsulation key must be defined");
    assertNotNull(keys5.secretKey, "Decapsulation key must be defined");
    return {
      encapsulationKey: keys5.publicKey,
      decapsulationKey: keys5.secretKey
    };
  } catch (error) {
    throw new Error(`Failed to generate ML-KEM-768 keypair: ${error instanceof Error ? error.message : String(error)}`);
  }
}, "generateMlKem768Keypair");
var encapsulateMlKem768 = __name((encapsulationKey) => {
  return ml_kem768.encapsulate(encapsulationKey);
}, "encapsulateMlKem768");
var decapsulateMlKem768 = __name((decapsulationKey, cipherText) => {
  return ml_kem768.decapsulate(cipherText, decapsulationKey);
}, "decapsulateMlKem768");
var AES_256_GCM_KEY_SIZE = 32;
function deriveAESKey(sharedSecret, salt, info) {
  const infoBytes = new TextEncoder().encode(info);
  return hkdf(sha2567, sharedSecret, salt, infoBytes, AES_256_GCM_KEY_SIZE);
}
__name(deriveAESKey, "deriveAESKey");
function createKeyDerivationInfo(purpose, connectionId, version11 = 1) {
  return `forward-mpc-${purpose}-v${version11}-${connectionId}`;
}
__name(createKeyDerivationInfo, "createKeyDerivationInfo");
async function encryptKeyshare(keyshare, sharedSecret, connectionId, signingAlgorithm) {
  const salt = randomBytes3(32);
  const keyshareInfo = createKeyDerivationInfo("keyshare", connectionId);
  const aesKey = deriveAESKey(sharedSecret, salt, keyshareInfo);
  const keyshareData = {
    keyshare,
    signingAlgorithm,
    timestamp: Date.now(),
    nonce: bytesToHex5(randomBytes3(16))
  };
  const nonce = randomBytes3(12);
  const aes256Gcm = gcm(aesKey, nonce);
  const plaintext = new TextEncoder().encode(JSON.stringify(keyshareData));
  const ciphertext = aes256Gcm.encrypt(plaintext);
  const encryptedPayload = new Uint8Array(nonce.length + ciphertext.length);
  encryptedPayload.set(nonce, 0);
  encryptedPayload.set(ciphertext, nonce.length);
  aesKey.fill(0);
  return {
    salt,
    encryptedPayload
  };
}
__name(encryptKeyshare, "encryptKeyshare");
var _a10;
var SigningAlgorithmRegistry = (_a10 = class {
  /**
  * Get algorithm instance (derived from single source of truth)
  */
  get(name) {
    const algorithm = SIGNING_ALGORITHM_INSTANCES[name];
    if (!algorithm) {
      throw new Error(`Unknown signing algorithm: ${name}`);
    }
    return algorithm;
  }
  /**
  * Type-safe check if algorithm exists
  */
  has(name) {
    return isValidSigningAlgorithm(name);
  }
  /**
  * Get all algorithm names (derived from classes)
  */
  getAllNames() {
    return ALL_SIGNING_ALGORITHM_NAMES;
  }
  /**
  * Get all algorithm instances (derived from classes)
  */
  getAllInstances() {
    return SIGNING_ALGORITHM_INSTANCES;
  }
}, __name(_a10, "SigningAlgorithmRegistry"), _a10);
var signingAlgorithmRegistry = new SigningAlgorithmRegistry();

// node_modules/@evervault/wasm-attestation-bindings/index.js
var wasm;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString2 = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function isLikeNone(x7) {
  return x7 === void 0 || x7 === null;
}
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_3.set(idx, obj);
  return idx;
}
function passArrayJsValueToWasm0(array, malloc) {
  const ptr = malloc(array.length * 4, 4) >>> 0;
  for (let i9 = 0; i9 < array.length; i9++) {
    const add3 = addToExternrefTable0(array[i9]);
    getDataViewMemory0().setUint32(ptr + 4 * i9, add3, true);
  }
  WASM_VECTOR_LEN = array.length;
  return ptr;
}
function validateAttestationDocPcrs(attestation_doc, expected_pcrs_list) {
  const ptr0 = passStringToWasm0(attestation_doc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ptr1 = passArrayJsValueToWasm0(expected_pcrs_list, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  const ret = wasm.validateAttestationDocPcrs(ptr0, len0, ptr1, len1);
  return ret !== 0;
}
function takeFromExternrefTable0(idx) {
  const value2 = wasm.__wbindgen_export_3.get(idx);
  wasm.__externref_table_dealloc(idx);
  return value2;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function getUserData(attestation_doc) {
  const ptr0 = passStringToWasm0(attestation_doc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getUserData(ptr0, len0);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  let v22;
  if (ret[0] !== 0) {
    v22 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  }
  return v22;
}
function getNonce(attestation_doc) {
  const ptr0 = passStringToWasm0(attestation_doc, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getNonce(ptr0, len0);
  if (ret[3]) {
    throw takeFromExternrefTable0(ret[2]);
  }
  let v22;
  if (ret[0] !== 0) {
    v22 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
  }
  return v22;
}
var PCRsFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_pcrs_free(ptr >>> 0, 1));
var PCRs = class _PCRs {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_PCRs.prototype);
    obj.__wbg_ptr = ptr;
    PCRsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  static __unwrap(jsValue) {
    if (!(jsValue instanceof _PCRs)) {
      return 0;
    }
    return jsValue.__destroy_into_raw();
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PCRsFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_pcrs_free(ptr, 0);
  }
  /**
   * @returns {string | undefined}
   */
  get hashAlgorithm() {
    const ret = wasm.__wbg_get_pcrs_hashAlgorithm(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set hashAlgorithm(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_hashAlgorithm(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr0() {
    const ret = wasm.__wbg_get_pcrs_pcr0(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr0(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr0(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr1() {
    const ret = wasm.__wbg_get_pcrs_pcr1(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr1(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr1(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr2() {
    const ret = wasm.__wbg_get_pcrs_pcr2(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr2(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr2(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get pcr8() {
    const ret = wasm.__wbg_get_pcrs_pcr8(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  /**
   * @param {string | null} [arg0]
   */
  set pcr8(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_pcrs_pcr8(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @param {string | null} [pcr_0]
   * @param {string | null} [pcr_1]
   * @param {string | null} [pcr_2]
   * @param {string | null} [pcr_8]
   * @param {string | null} [hash_algorithm]
   */
  constructor(pcr_0, pcr_1, pcr_2, pcr_8, hash_algorithm) {
    var ptr0 = isLikeNone(pcr_0) ? 0 : passStringToWasm0(pcr_0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = isLikeNone(pcr_1) ? 0 : passStringToWasm0(pcr_1, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(pcr_2) ? 0 : passStringToWasm0(pcr_2, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(pcr_8) ? 0 : passStringToWasm0(pcr_8, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    var ptr4 = isLikeNone(hash_algorithm) ? 0 : passStringToWasm0(hash_algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len4 = WASM_VECTOR_LEN;
    const ret = wasm.pcrs_new(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);
    this.__wbg_ptr = ret >>> 0;
    PCRsFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * Helper to create an empty PCR container, to support setting the PCRs explicitly
   * ```js
   * const pcrs = PCRs.empty();
   * pcrs.pcr0 = "...";
   * pcrs.pcr8 = "...";
   * ```
   * @returns {PCRs}
   */
  static empty() {
    const ret = wasm.pcrs_empty();
    return _PCRs.__wrap(ret);
  }
};
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e11) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e11);
        } else {
          throw e11;
        }
      }
    }
    const bytes2 = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes2, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_error_40b1c155aa56d80b = function(arg0, arg1) {
    console.error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
    const ret = new Error();
    return ret;
  };
  imports.wbg.__wbg_now_b8ba7a2a6289a15e = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_pcrs_unwrap = function(arg0) {
    const ret = PCRs.__unwrap(arg0);
    return ret;
  };
  imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
    const ret = arg1.stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_export_3;
    const offset = table.grow(4);
    table.set(0, void 0);
    table.set(offset + 0, void 0);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
    ;
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return ret;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_init_memory(imports, memory2) {
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn("using deprecated parameters for the initialization function; pass a single object instead");
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("index_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  __wbg_init_memory(imports);
  const { instance, module } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module);
}
var wasm_attestation_bindings_default = __wbg_init;

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/forward-mpc-client/dist/index.js
var __defProp2 = Object.defineProperty;
var __name2 = (target, value2) => __defProp2(target, "name", { value: value2, configurable: true });
var ATTESTATION_CONSTANTS = {
  // Maximum age of attestation document in milliseconds
  MAX_ATTESTATION_AGE: 5 * 60 * 1e3
};
var _a11;
var NitroAttestationVerifier = (_a11 = class {
  constructor(config2) {
    __publicField(this, "config");
    __publicField(this, "wasmInitialized", false);
    this.config = {
      strictCertValidation: true,
      maxAge: ATTESTATION_CONSTANTS.MAX_ATTESTATION_AGE,
      ...config2
    };
  }
  /**
  * Initialize WASM module if not already initialized
  */
  async ensureWasmInitialized() {
    if (!this.wasmInitialized) {
      try {
        await wasm_attestation_bindings_default();
        this.wasmInitialized = true;
      } catch (error) {
        throw new Error(`Failed to initialize WASM module: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  /**
  * Verify an attestation document using Evervault WASM bindings
  * Accepts base64-encoded attestation document directly
  *
  * @param attestationDocBase64 - Base64-encoded attestation document
  * @param expectedChallenge - Expected challenge (ciphertext hash)
  * @param expectedNonce - Expected nonce (REQUIRED for security)
  */
  async verify(attestationDocBase64, expectedChallenge, expectedNonce) {
    try {
      await this.ensureWasmInitialized();
      const expectedPcrs = PCRs.empty();
      expectedPcrs.pcr8 = this.config.expectedPcr8;
      const isValid = validateAttestationDocPcrs(attestationDocBase64, [
        expectedPcrs
      ]);
      if (!isValid) {
        return {
          valid: false,
          errors: [
            "Attestation document PCR verification failed"
          ],
          timestamp: Date.now()
        };
      }
      if (expectedChallenge) {
        try {
          const userData = getUserData(attestationDocBase64);
          if (!userData) {
            return {
              valid: false,
              errors: [
                "No user data found in attestation document"
              ],
              timestamp: Date.now()
            };
          }
          const userDataString = new TextDecoder("utf-8").decode(userData);
          if (!userDataString.includes(expectedChallenge)) {
            return {
              valid: false,
              errors: [
                "Ciphertext hash verification failed - challenge not found in attestation user data"
              ],
              timestamp: Date.now()
            };
          }
        } catch (error) {
          return {
            valid: false,
            errors: [
              `Failed to extract or verify ciphertext hash: ${error instanceof Error ? error.message : String(error)}`
            ],
            timestamp: Date.now()
          };
        }
      }
      try {
        const extractedNonceRaw = getNonce(attestationDocBase64);
        if (!extractedNonceRaw) {
          return {
            valid: false,
            errors: [
              "No nonce found in attestation document"
            ],
            timestamp: Date.now()
          };
        }
        let extractedNonce;
        try {
          const nonceString = new TextDecoder().decode(extractedNonceRaw);
          if (typeof atob !== "undefined") {
            const binaryString = atob(nonceString);
            extractedNonce = new Uint8Array(binaryString.length);
            for (let i9 = 0; i9 < binaryString.length; i9++) {
              extractedNonce[i9] = binaryString.charCodeAt(i9);
            }
          } else {
            const decodedBuffer = Buffer.from(nonceString, "base64");
            extractedNonce = new Uint8Array(decodedBuffer);
          }
        } catch (decodeError) {
          return {
            valid: false,
            errors: [
              `Failed to decode nonce from base64: ${decodeError instanceof Error ? decodeError.message : String(decodeError)}`
            ],
            timestamp: Date.now()
          };
        }
        if (extractedNonce.length !== expectedNonce.length) {
          return {
            valid: false,
            errors: [
              `Nonce length mismatch: expected ${expectedNonce.length} bytes, got ${extractedNonce.length} bytes`
            ],
            timestamp: Date.now()
          };
        }
        for (let i9 = 0; i9 < expectedNonce.length; i9++) {
          if (extractedNonce[i9] !== expectedNonce[i9]) {
            return {
              valid: false,
              errors: [
                "Nonce verification failed - nonce mismatch"
              ],
              timestamp: Date.now()
            };
          }
        }
      } catch (error) {
        return {
          valid: false,
          errors: [
            `Failed to extract or verify nonce: ${error instanceof Error ? error.message : String(error)}`
          ],
          timestamp: Date.now()
        };
      }
      return {
        valid: true,
        errors: [],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        valid: false,
        errors: [
          `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`
        ],
        timestamp: Date.now()
      };
    }
  }
}, __name2(_a11, "NitroAttestationVerifier"), _a11);
var isWindow = typeof globalThis !== "undefined" && typeof globalThis.window !== "undefined";
var WebSocketImpl = isWindow ? globalThis.WebSocket : ws3.WebSocket;
var _a12;
var ForwardMPCClient = (_a12 = class extends import_index.default {
  constructor(url2, options = {}) {
    super();
    __publicField(this, "ws", null);
    __publicField(this, "url");
    __publicField(this, "options");
    __publicField(this, "attestationVerifier", null);
    __publicField(this, "isConnected", false);
    __publicField(this, "messageId", 0);
    __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "sharedSecret", null);
    __publicField(this, "decapsulationKey", null);
    __publicField(this, "connectionId");
    __publicField(this, "handshakeNonce", null);
    this.url = url2;
    this.connectionId = "";
    this.options = {
      reconnectAttempts: options.reconnectAttempts ?? 3,
      reconnectInterval: options.reconnectInterval ?? 1e3,
      connectionTimeout: options.connectionTimeout ?? 1e4,
      heartbeatInterval: options.heartbeatInterval ?? 3e4,
      attestationConfig: options.attestationConfig,
      attestationVerifier: options.attestationVerifier
    };
    if (options.attestationVerifier) {
      this.attestationVerifier = options.attestationVerifier;
    } else if (this.options.attestationConfig) {
      this.attestationVerifier = new NitroAttestationVerifier(this.options.attestationConfig);
    }
  }
  async connect() {
    return new Promise((resolve, reject) => {
      if (this.isConnected) {
        resolve();
        return;
      }
      const timeout = setTimeout(() => {
        reject(new Error("Connection timeout"));
      }, this.options.connectionTimeout);
      this.ws = new WebSocketImpl(this.url);
      if (isWindow) {
        this.ws.onopen = () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        };
        this.ws.onerror = (_error) => {
          clearTimeout(timeout);
          this.emit("error", new Error("WebSocket error"));
          reject(new Error("WebSocket error"));
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onclose = () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        };
      } else {
        this.ws.on("open", () => {
          clearTimeout(timeout);
          this.isConnected = true;
          this.emit("connected");
          resolve();
        });
        this.ws.on("error", (error) => {
          clearTimeout(timeout);
          this.emit("error", error);
          reject(error);
        });
        this.ws.on("message", (data) => {
          this.handleMessage(data.toString());
        });
        this.ws.on("close", () => {
          this.isConnected = false;
          this.emit("disconnected");
          this.cleanup();
        });
      }
    });
  }
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.cleanup();
  }
  cleanup() {
    for (const [, request2] of this.pendingRequests) {
      clearTimeout(request2.timeout);
      request2.reject(new Error("Connection closed"));
    }
    this.pendingRequests.clear();
    if (this.sharedSecret) {
      this.sharedSecret.fill(0);
      this.sharedSecret = null;
    }
    if (this.decapsulationKey) {
      this.decapsulationKey.fill(0);
      this.decapsulationKey = null;
    }
    if (this.handshakeNonce) {
      this.handshakeNonce.fill(0);
      this.handshakeNonce = null;
    }
    this.connectionId = "";
  }
  /**
  * Ensures the WebSocket connection is active and handshake is completed.
  * Automatically connects and performs handshake if needed.
  * @returns Object containing the shared secret and connection ID
  * @throws Error if connection or handshake fails
  */
  async ensureWsConnection() {
    if (!this.isConnected || !this.ws) {
      await this.connect();
    }
    if (!this.sharedSecret || !this.connectionId) {
      await this.handshake();
    }
    if (!this.sharedSecret || !this.connectionId) {
      throw new Error("Failed to establish connection and handshake");
    }
    return {
      sharedSecret: this.sharedSecret,
      connectionId: this.connectionId
    };
  }
  handleMessage(data) {
    try {
      const parsed = JSON.parse(data);
      const requestId = parsed.requestId;
      if (requestId) {
        delete parsed.requestId;
      }
      const message = this.deserializeMessage(JSON.stringify(parsed));
      if (requestId && this.pendingRequests.has(requestId)) {
        const request2 = this.pendingRequests.get(requestId);
        this.pendingRequests.delete(requestId);
        clearTimeout(request2.timeout);
        if (message.type === "error") {
          const errorMsg = message;
          request2.reject(new Error(errorMsg.error.message));
        } else if (message.type.endsWith("_response")) {
          const responseData = message.getData ? message.getData() : message;
          if (responseData.error) {
            request2.reject(new Error(responseData.error.message));
          } else {
            request2.resolve(message);
          }
        } else {
          request2.resolve(message);
        }
        return;
      }
      this.emit("message", message);
    } catch (error) {
      this.emit("error", new Error(`Failed to parse message: ${error}`));
    }
  }
  sendRequest(message) {
    return new Promise((resolve, reject) => {
      if (!this.isConnected || !this.ws) {
        reject(new Error("Not connected"));
        return;
      }
      const requestId = `req_${++this.messageId}_${Date.now()}`;
      const messageWithId = message;
      messageWithId.requestId = requestId;
      const timeout = setTimeout(() => {
        this.pendingRequests.delete(requestId);
        reject(new Error("Request timeout"));
      }, 3e4);
      this.pendingRequests.set(requestId, {
        resolve,
        reject,
        timeout
      });
      try {
        const serializedMessage = this.serializeMessage(messageWithId);
        this.ws.send(serializedMessage);
      } catch (error) {
        this.pendingRequests.delete(requestId);
        clearTimeout(timeout);
        reject(error);
      }
    });
  }
  serializeMessage(message) {
    try {
      if (message && typeof message.encode === "function") {
        const encoded = message.encode();
        if (message.requestId) {
          encoded.requestId = message.requestId;
        }
        return JSON.stringify(encoded);
      }
      return JSON.stringify(message);
    } catch (error) {
      throw new Error(`Failed to serialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  deserializeMessage(data) {
    try {
      const parsed = JSON.parse(data);
      if (!messageRegistry) {
        throw new Error("messageRegistry is undefined");
      }
      if (typeof messageRegistry.decode !== "function") {
        throw new Error("messageRegistry.decode is not a function");
      }
      const result = messageRegistry.decode(parsed);
      if (Either_exports.isLeft(result)) {
        return parsed;
      }
      return result.right;
    } catch (error) {
      throw new Error(`Failed to deserialize message: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  async handshake() {
    const { encapsulationKey, decapsulationKey } = generateMlKem768Keypair();
    this.decapsulationKey = decapsulationKey;
    const nonceBytes = randomBytes3(32);
    this.handshakeNonce = nonceBytes;
    const request2 = new HandshakeV1RequestMessage({
      challenge: encapsulationKey,
      nonce: nonceBytes
    });
    const response = await this.sendRequest(request2);
    const responseData = response.getData();
    if (responseData.encapsulatedSharedSecret && responseData.connectionId && this.decapsulationKey) {
      this.connectionId = responseData.connectionId;
      const cipherText = hexToBytes5(responseData.encapsulatedSharedSecret);
      this.sharedSecret = decapsulateMlKem768(this.decapsulationKey, cipherText);
    }
    if (this.attestationVerifier && responseData.attestationDoc && responseData.encapsulatedSharedSecret) {
      const cipherText = hexToBytes5(responseData.encapsulatedSharedSecret);
      this.verifyAttestationDocument(responseData.attestationDoc, cipherText).catch((error) => {
        this.emit("error", new Error(`Background attestation verification failed: ${error.message}`));
      });
    }
    return response;
  }
  async signMessage(params) {
    const { sharedSecret, connectionId } = await this.ensureWsConnection();
    let messageToSign;
    if (typeof params.message === "string") {
      const cleanHex = params.message.startsWith("0x") ? params.message.slice(2) : params.message;
      messageToSign = hexToBytes5(cleanHex);
    } else {
      messageToSign = params.message;
    }
    const encryptedKeyshare = await encryptKeyshare(params.keyshare, sharedSecret, connectionId, params.signingAlgo);
    const request2 = new SignMessageV1RequestMessage({
      relayDomain: params.relayDomain,
      signingAlgo: params.signingAlgo,
      hashAlgo: params.hashAlgo,
      derivationPath: params.derivationPath,
      tweak: params.tweak,
      keyshare: encryptedKeyshare,
      message: messageToSign,
      roomUuid: params.roomUuid
    });
    return this.sendRequest(request2);
  }
  get connected() {
    return this.isConnected;
  }
  /**
  * Generate a unique connection ID
  */
  /**
  * Verify attestation document from handshake response
  * Uses base64-encoded attestation document directly
  */
  async verifyAttestationDocument(attestationDocBase64, cipherText) {
    if (!this.attestationVerifier) {
      return;
    }
    try {
      const challengeHash = sha2567(cipherText);
      const expectedChallenge = Array.from(challengeHash).map((b6) => b6.toString(16).padStart(2, "0")).join("");
      if (!this.handshakeNonce) {
        throw new Error("Nonce not found - handshake may not have completed properly");
      }
      const result = await this.attestationVerifier.verify(attestationDocBase64, expectedChallenge, this.handshakeNonce);
      if (!result.valid) {
        const errorMsg = `Attestation verification failed: ${result.errors.join(", ")}`;
        this.emit("error", new Error(errorMsg));
        throw new Error(errorMsg);
      }
      this.emit("message", {
        type: "attestation-verified",
        timestamp: Date.now(),
        data: result
      });
    } catch (error) {
      const errorMsg = `Attestation verification error: ${error instanceof Error ? error.message : String(error)}`;
      this.emit("error", new Error(errorMsg));
      throw new Error(errorMsg);
    }
  }
}, __name2(_a12, "ForwardMPCClient"), _a12);

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/core/index.esm.js
var ENVIRONMENT_ENUM2 = function(ENVIRONMENT_ENUM3) {
  ENVIRONMENT_ENUM3["development"] = "development";
  ENVIRONMENT_ENUM3["preprod"] = "preprod";
  ENVIRONMENT_ENUM3["production"] = "production";
  return ENVIRONMENT_ENUM3;
}({});
var WalletOperation2 = function(WalletOperation3) {
  WalletOperation3["REACH_THRESHOLD"] = "REACH_THRESHOLD";
  WalletOperation3["REACH_ALL_PARTIES"] = "REACH_ALL_PARTIES";
  WalletOperation3["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  WalletOperation3["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  WalletOperation3["REFRESH"] = "REFRESH";
  WalletOperation3["RESHARE"] = "RESHARE";
  WalletOperation3["EXPORT_PRIVATE_KEY"] = "EXPORT_PRIVATE_KEY";
  WalletOperation3["NO_OPERATION"] = "NO_OPERATION";
  return WalletOperation3;
}({});
var BackupLocation2 = function(BackupLocation3) {
  BackupLocation3["DYNAMIC"] = "dynamic";
  BackupLocation3["GOOGLE_DRIVE"] = "googleDrive";
  BackupLocation3["ICLOUD"] = "iCloud";
  BackupLocation3["USER"] = "user";
  BackupLocation3["EXTERNAL"] = "external";
  BackupLocation3["DELEGATED"] = "delegated";
  return BackupLocation3;
}({});
var IFRAME_DOMAIN_MAP = {
  development: "http://localhost:4200",
  preprod: "https://app.dynamic-preprod.xyz",
  production: "https://app.dynamicauth.com"
};
var SigningAlgorithm2 = function(SigningAlgorithm3) {
  SigningAlgorithm3["ECDSA"] = "ECDSA";
  SigningAlgorithm3["ED25519"] = "ED25519";
  SigningAlgorithm3["BIP340"] = "BIP340";
  return SigningAlgorithm3;
}({});
var BITCOIN_DERIVATION_PATHS2 = {
  LEGACY: [
    44,
    0,
    0,
    0,
    0
  ],
  // m/49'/0'/0'/0/0  - SegWit (P2SH-P2WPKH)
  NATIVE_SEGWIT: [
    84,
    0,
    0,
    0,
    0
  ],
  // m/44'/0'/0'/0/0  - Legacy (P2PKH)
  SEGWIT: [
    49,
    0,
    0,
    0,
    0
  ]
};
var MPC_CHAIN_CONFIG2 = {
  EVM: {
    // Uses secp256k1 ECDSA
    derivationPath: [
      44,
      60,
      0,
      0,
      0
    ],
    signingAlgorithm: "ECDSA"
  },
  SVM: {
    // Uses Ed25519
    derivationPath: [
      44,
      501,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  BTC: {
    // Uses secp256k1 BIP340
    derivationPath: BITCOIN_DERIVATION_PATHS2.NATIVE_SEGWIT,
    signingAlgorithm: "BIP340"
  },
  COSMOS: {
    // Uses Ed25519
    derivationPath: [
      44,
      118,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  FLOW: {
    // Uses Ed25519
    derivationPath: [
      44,
      539,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  },
  SUI: {
    // Uses Ed25519
    derivationPath: [
      44,
      784,
      0,
      0,
      0
    ],
    signingAlgorithm: "ED25519"
  }
};
var ThresholdSignatureScheme2 = function(ThresholdSignatureScheme3) {
  ThresholdSignatureScheme3["TWO_OF_TWO"] = "TWO_OF_TWO";
  ThresholdSignatureScheme3["TWO_OF_THREE"] = "TWO_OF_THREE";
  ThresholdSignatureScheme3["THREE_OF_FIVE"] = "THREE_OF_FIVE";
  return ThresholdSignatureScheme3;
}({});
var CreateRoomPartiesOptions2 = function(CreateRoomPartiesOptions3) {
  CreateRoomPartiesOptions3["THRESHOLD"] = "threshold";
  CreateRoomPartiesOptions3["FULL"] = "full";
  return CreateRoomPartiesOptions3;
}({});
var URL_PATTERNS2 = {
  [ENVIRONMENT_ENUM2.development]: /^http:\/\/localhost:\d+$/,
  [ENVIRONMENT_ENUM2.preprod]: /dynamic-preprod/,
  [ENVIRONMENT_ENUM2.production]: /^(?!.*dynamic-preprod)(?!http:\/\/localhost:\d+).*/
};
function getEnvironmentFromUrl(url2) {
  if (!url2) {
    return ENVIRONMENT_ENUM2.production;
  }
  if (URL_PATTERNS2[ENVIRONMENT_ENUM2.development].test(url2)) {
    return ENVIRONMENT_ENUM2.development;
  }
  if (URL_PATTERNS2[ENVIRONMENT_ENUM2.preprod].test(url2)) {
    return ENVIRONMENT_ENUM2.preprod;
  }
  return ENVIRONMENT_ENUM2.production;
}
var AuthMode2 = function(AuthMode3) {
  AuthMode3["HEADER"] = "header";
  AuthMode3["COOKIE"] = "cookie";
  return AuthMode3;
}({});
var SuccessEventType2 = function(SuccessEventType3) {
  SuccessEventType3["KeygenComplete"] = "keygen_complete";
  SuccessEventType3["RoomCreated"] = "room_created";
  SuccessEventType3["CeremonyComplete"] = "ceremony_complete";
  return SuccessEventType3;
}({});

// node_modules/@dynamic-labs/message-transport/package.js
var version10 = "4.43.0";

// node_modules/@dynamic-labs/message-transport/src/messageTransport/messageTransport.js
var createMessageTransport = () => {
  const listeners = /* @__PURE__ */ new Set();
  return {
    emit: (message) => listeners.forEach((callback) => callback(message)),
    off: (callback) => listeners.delete(callback),
    on: (callback) => listeners.add(callback)
  };
};

// node_modules/@dynamic-labs/message-transport/src/messageTransport/decorators/applyDefaultMessageOrigin/applyDefaultMessageOrigin.js
var applyDefaultMessageOrigin = ({ defaultOrigin, messageTransport }) => Object.assign(Object.assign({}, messageTransport), { defaultOrigin, emit: (message) => {
  var _a14;
  messageTransport.emit(Object.assign(Object.assign({}, message), { origin: (_a14 = message.origin) !== null && _a14 !== void 0 ? _a14 : defaultOrigin }));
} });

// node_modules/@dynamic-labs/message-transport/src/messageTransport/decorators/applyRecoveryManager/applyRecoveryManager.js
var hasRecoveryManager = (messageTransport) => "recoveryManager" in messageTransport;

// node_modules/@dynamic-labs/message-transport/_virtual/_tslib.js
function __rest5(s5, e11) {
  var t6 = {};
  for (var p9 in s5) if (Object.prototype.hasOwnProperty.call(s5, p9) && e11.indexOf(p9) < 0)
    t6[p9] = s5[p9];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i9 = 0, p9 = Object.getOwnPropertySymbols(s5); i9 < p9.length; i9++) {
      if (e11.indexOf(p9[i9]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p9[i9]))
        t6[p9[i9]] = s5[p9[i9]];
    }
  return t6;
}
function __awaiter8(thisArg, _arguments, P7, generator) {
  function adopt(value2) {
    return value2 instanceof P7 ? value2 : new P7(function(resolve) {
      resolve(value2);
    });
  }
  return new (P7 || (P7 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e11) {
        reject(e11);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/message-transport/src/debug/debug.js
var globalDebugEnabled = false;
var isGlobalDebugEnabled = () => globalDebugEnabled;

// node_modules/@dynamic-labs/message-transport/src/utils/isSerializedError/isSerializedError.js
var isSerializedError = (serializedError) => {
  if (typeof serializedError !== "object" || serializedError === null) {
    return false;
  }
  const { message, stack } = serializedError;
  return typeof message === "string" && typeof stack === "string";
};

// node_modules/@dynamic-labs/message-transport/src/utils/logger.js
var logger6 = new Logger("message-transport");

// node_modules/@dynamic-labs/message-transport/src/utils/parseErrorFromTransport/parseErrorFromTransport.js
var parseErrorFromTransport = (serializedError) => {
  const { message, name, stack } = serializedError, otherProps = __rest5(serializedError, ["message", "name", "stack"]);
  let error;
  if (message) {
    try {
      const data = JSON.parse(message);
      if (Array.isArray(data))
        return data;
    } catch (_a14) {
    }
  }
  switch (name) {
    case "TypeError":
      error = new TypeError(message);
      break;
    case "ReferenceError":
      error = new ReferenceError(message);
      break;
    case "SyntaxError":
      error = new SyntaxError(message);
      break;
    case "RangeError":
      error = new RangeError(message);
      break;
    case "EvalError":
      error = new EvalError(message);
      break;
    case "URIError":
      error = new URIError(message);
      break;
    default:
      error = new Error(message);
      error.name = name || "Error";
  }
  if (stack) {
    error.stack = [message, stack].join("\n");
  }
  Object.assign(error, otherProps);
  return error;
};

// node_modules/@dynamic-labs/message-transport/src/utils/serializeErrorForTransport/serializeErrorForTransport.js
var serializeErrorForTransport = (err) => {
  if (err instanceof Error) {
    return convertError(err);
  } else if (Array.isArray(err)) {
    return { message: JSON.stringify(err) };
  } else if (typeof err === "object" && err !== null) {
    const errorMessage = serializeObjectToMessage(err);
    return convertError(Object.assign({ message: errorMessage, name: "Error", stack: "" }, err));
  }
  return { message: String(err) };
};
var convertError = (err) => Object.assign({
  // @ts-expect-error message is a standard property of Error
  message: err.message,
  // @ts-expect-error name is a standard property of Error
  name: err.name,
  stack: err.stack
}, err);
var serializeObjectToMessage = (obj) => {
  try {
    const data = JSON.stringify(obj);
    return data;
  } catch (_a14) {
    return String(obj);
  }
};

// node_modules/@dynamic-labs/message-transport/src/requestChannel/utils/utils.js
var getResolveMessageType = (type7) => `${type7}__resolve`;
var getRejectMessageType = (type7) => `${type7}__reject`;
var getAckMessageType = (type7) => `${type7}__ack`;
var createNoHandlerError = (type7) => {
  const message = `No handlers were registered for message of type ${type7}`;
  logger6.error(message);
  return new RequestChannelNotHandledError(message);
};
var TIMEOUT_DURATION = 5e3;

// node_modules/@dynamic-labs/message-transport/src/requestChannel/createRequestChannelMessageSender/createRequestChannelMessageSender.js
var createRequestChannelMessageSender = ({ requestType, messageSessionId, timeoutMap, onReceiveAck, messageTransport, onTimeout, params, debugOverride, disableAckForOutgoingMessage = false }) => {
  let messageTimedOut = false;
  const ackMessageType = getAckMessageType(requestType);
  const isDebugEnabled = () => debugOverride !== null && debugOverride !== void 0 ? debugOverride : isGlobalDebugEnabled();
  const outgoingMessage = {
    args: params,
    doNotAck: disableAckForOutgoingMessage,
    messageSessionId,
    type: requestType
  };
  const getTimestamp = () => (/* @__PURE__ */ new Date()).toISOString();
  const handleAckMessage = ({ messageSessionId: incomingSessionId, type: incomingType, doNotAck: incomingDoNotAck }) => {
    if (incomingSessionId !== messageSessionId || incomingType !== ackMessageType || incomingDoNotAck) {
      return;
    }
    if (isDebugEnabled()) {
      logger6.debug(`[messageSender ${requestType} ${getTimestamp()}]  received ack message (messageSessionId: ${messageSessionId}). Message timeout ID: ${timeoutMap[messageSessionId]}. Content of timeoutMap: ${JSON.stringify(timeoutMap)}`);
    }
    clearTimeout(timeoutMap[messageSessionId]);
    delete timeoutMap[messageSessionId];
    onReceiveAck === null || onReceiveAck === void 0 ? void 0 : onReceiveAck();
    if (messageTimedOut) {
      if (isDebugEnabled()) {
        logger6.debug(`[messageSender ${requestType} ${getTimestamp()}]  identified a false negative for message time out. Message: ${requestType} with session id ${messageSessionId}`);
      }
      logger6.instrument(`Identified a false negative for message time out. Message: ${requestType} with session id ${messageSessionId}. Params: ${JSON.stringify(params)}`);
    }
  };
  const sendMessage = () => {
    if (disableAckForOutgoingMessage) {
      messageTransport.emit(outgoingMessage);
      return;
    }
    const startTimer = () => {
      const timeoutTimer = setTimeout(() => {
        if (hasRecoveryManager(messageTransport) && messageTransport.recoveryManager.canRetryMessageSessionId(messageSessionId)) {
          if (isDebugEnabled()) {
            logger6.debug(`[messageSender ${requestType} ${getTimestamp()}]  timed out, triggering recovery (messageSessionId: ${messageSessionId})`);
          }
          messageTransport.recoveryManager.triggerRecovery(messageSessionId);
          if (isDebugEnabled()) {
            logger6.debug(`[messageSender ${requestType} ${getTimestamp()}]  attempting to send message again (messageSessionId: ${messageSessionId})`);
          }
          sendMessage();
        } else {
          onTimeout();
          messageTimedOut = true;
        }
      }, TIMEOUT_DURATION);
      if (isDebugEnabled()) {
        logger6.debug(`[messageSender ${requestType} ${getTimestamp()}]  setting timeout timer (messageSessionId: ${messageSessionId}). Timeout ID: ${timeoutTimer}. Content of timeoutMap: ${JSON.stringify(timeoutMap)}`);
      }
      timeoutMap[messageSessionId] = timeoutTimer;
    };
    if ("isBlocked" in messageTransport && messageTransport.isBlocked()) {
      messageTransport.emit(outgoingMessage, { onEmit: startTimer });
      return;
    }
    startTimer();
    messageTransport.emit(outgoingMessage);
  };
  return { handleAckMessage, sendMessage };
};

// node_modules/@dynamic-labs/message-transport/src/requestChannel/requestChannel.js
var createRequestChannel = (messageTransport, { debugOverride, disableAcknowledgement } = {}) => {
  let uniqueIdCounter = 0;
  const idPrefix = Math.random().toString();
  const getUniqueId = () => `${idPrefix}-${uniqueIdCounter++}`;
  const timeoutMap = {};
  const isDebugEnabled = () => debugOverride !== null && debugOverride !== void 0 ? debugOverride : isGlobalDebugEnabled();
  const getTimestamp = () => (/* @__PURE__ */ new Date()).toISOString();
  return {
    emit: (requestType, ...params) => new Promise((resolve, reject) => {
      const messageSessionId = getUniqueId();
      const { handleAckMessage, sendMessage } = createRequestChannelMessageSender({
        debugOverride,
        disableAckForOutgoingMessage: disableAcknowledgement,
        messageSessionId,
        messageTransport,
        onReceiveAck: () => {
          cleanupMessageHandler();
          resolve();
        },
        onTimeout: () => {
          reject(createNoHandlerError(requestType));
          cleanupMessageHandler();
        },
        params,
        requestType,
        timeoutMap
      });
      const cleanupMessageHandler = () => messageTransport.off(handleAckMessage);
      if (disableAcknowledgement) {
        resolve();
      } else {
        messageTransport.on(handleAckMessage);
      }
      sendMessage();
    }),
    handle: (requestType, handler) => {
      const messageHandler = (_a14) => __awaiter8(void 0, [_a14], void 0, function* ({ args, messageSessionId, type: incomingType, doNotAck = false }) {
        if (requestType !== incomingType)
          return;
        if (!doNotAck) {
          messageTransport.emit({
            args: [],
            messageSessionId,
            type: getAckMessageType(requestType)
          });
        }
        const result = handler(...args);
        if (!(result instanceof Promise))
          return;
        try {
          const response = yield result;
          messageTransport.emit({
            args: [response],
            messageSessionId,
            type: getResolveMessageType(requestType)
          });
        } catch (error) {
          messageTransport.emit({
            args: [serializeErrorForTransport(error)],
            messageSessionId,
            type: getRejectMessageType(requestType)
          });
        }
      });
      messageTransport.on(messageHandler);
      return () => {
        messageTransport.off(messageHandler);
      };
    },
    request: (requestType, ...params) => new Promise((resolve, reject) => {
      const messageSessionId = getUniqueId();
      const resolveMessageType = getResolveMessageType(requestType);
      const rejectMessageType = getRejectMessageType(requestType);
      const { handleAckMessage, sendMessage } = createRequestChannelMessageSender({
        debugOverride,
        disableAckForOutgoingMessage: disableAcknowledgement,
        messageSessionId,
        messageTransport,
        onTimeout: () => {
          reject(createNoHandlerError(requestType));
          cleanupMessageHandler();
        },
        params,
        requestType,
        timeoutMap
      });
      const handleMessage = (message) => {
        if (message.messageSessionId !== messageSessionId)
          return;
        if (isDebugEnabled()) {
          logger6.debug(`[request ${requestType} ${getTimestamp()}]  received response message (messageSessionId: ${messageSessionId})`);
        }
        const { args: [result], type: incomingType } = message;
        if (incomingType === resolveMessageType) {
          cleanupMessageHandler();
          resolve(result);
          if (isDebugEnabled()) {
            logger6.debug(`[request ${requestType} ${getTimestamp()}]  resolved message (messageSessionId: ${messageSessionId})`);
          }
          return;
        }
        if (incomingType === rejectMessageType) {
          cleanupMessageHandler();
          if (isSerializedError(result)) {
            reject(parseErrorFromTransport(result));
          } else {
            reject(result);
          }
          if (isDebugEnabled()) {
            logger6.debug(`[request ${requestType} ${getTimestamp()}]  rejected message (messageSessionId: ${messageSessionId})`);
          }
          return;
        }
        handleAckMessage(message);
      };
      const cleanupMessageHandler = () => messageTransport.off(handleMessage);
      messageTransport.on(handleMessage);
      sendMessage();
    })
  };
};

// node_modules/@dynamic-labs/message-transport/src/utils/parseMessageTransportData/parseMessageTransportData.js
var parseMessageTransportData = (parsedData) => {
  if (!parsedData || typeof parsedData !== "object") {
    return void 0;
  }
  const message = {
    args: parsedData.args,
    doNotAck: parsedData.doNotAck,
    messageSessionId: parsedData.messageSessionId,
    origin: parsedData.origin,
    transportStamps: parsedData.transportStamps,
    type: parsedData.type
  };
  if (!Array.isArray(message.args) || typeof message.messageSessionId !== "string" || typeof message.origin !== "string" || typeof message.type !== "string") {
    return void 0;
  }
  return message;
};

// node_modules/@vue/shared/dist/shared.esm-bundler.js
function makeMap(str) {
  const map36 = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map36[key] = 1;
  return (val) => val in map36;
}
var EMPTY_OBJ = true ? Object.freeze({}) : {};
var EMPTY_ARR = true ? Object.freeze([]) : [];
var extend14 = Object.assign;
var hasOwnProperty5 = Object.prototype.hasOwnProperty;
var hasOwn = (val, key) => hasOwnProperty5.call(val, key);
var isArray3 = Array.isArray;
var isMap = (val) => toTypeString(val) === "[object Map]";
var isString3 = (val) => typeof val === "string";
var isSymbol = (val) => typeof val === "symbol";
var isObject3 = (val) => val !== null && typeof val === "object";
var objectToString = Object.prototype.toString;
var toTypeString = (value2) => objectToString.call(value2);
var toRawType = (value2) => {
  return toTypeString(value2).slice(8, -1);
};
var isIntegerKey = (key) => isString3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
var isReservedProp = makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
var isBuiltInDirective = makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
var cacheStringFunction = (fn4) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn4(str));
  };
};
var camelizeRE = /-\w/g;
var camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (c9) => c9.slice(1).toUpperCase());
  }
);
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
var capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
var toHandlerKey = cacheStringFunction(
  (str) => {
    const s5 = str ? `on${capitalize(str)}` : ``;
    return s5;
  }
);
var hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
var GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
var isGloballyAllowed = makeMap(GLOBALS_ALLOWED);
var HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
var MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
var VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
var isHTMLTag = makeMap(HTML_TAGS);
var isSVGTag = makeMap(SVG_TAGS);
var isMathMLTag = makeMap(MATH_TAGS);
var isVoidTag = makeMap(VOID_TAGS);
var specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
var isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
var isBooleanAttr = makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
var isKnownHtmlAttr = makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
);
var isKnownSvgAttr = makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
);
var isKnownMathMLAttr = makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
);

// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
var activeSub;
var batchDepth = 0;
var batchedSub;
var batchedComputed;
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e11 = batchedComputed;
    batchedComputed = void 0;
    while (e11) {
      const next = e11.next;
      e11.next = void 0;
      e11.flags &= -9;
      e11 = next;
    }
  }
  let error;
  while (batchedSub) {
    let e11 = batchedSub;
    batchedSub = void 0;
    while (e11) {
      const next = e11.next;
      e11.next = void 0;
      e11.flags &= -9;
      if (e11.flags & 1) {
        try {
          ;
          e11.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e11 = next;
    }
  }
  if (error) throw error;
}
var shouldTrack = true;
var trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last5 = trackStack.pop();
  shouldTrack = last5 === void 0 ? true : last5;
}
var globalVersion = 0;
var Link = class {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
var Dep = class {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
    this.__v_skip = true;
    if (true) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if (activeSub.onTrack) {
      activeSub.onTrack(
        extend14(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (true) {
        for (let head5 = this.subsHead; head5; head5 = head5.nextSub) {
          if (head5.sub.onTrigger && !(head5.sub.flags & 8)) {
            head5.sub.onTrigger(
              extend14(
                {
                  effect: head5.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
};
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l9 = computed.deps; l9; l9 = l9.nextDep) {
        addSub(l9);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if (link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
var targetMap = /* @__PURE__ */ new WeakMap();
var ITERATE_KEY = Symbol(
  true ? "Object iterate" : ""
);
var MAP_KEY_ITERATE_KEY = Symbol(
  true ? "Map keys iterate" : ""
);
var ARRAY_ITERATE_KEY = Symbol(
  true ? "Array iterate" : ""
);
function track(target, type7, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (true) {
      dep.track({
        target,
        type: type7,
        key
      });
    } else {
      dep.track();
    }
  }
}
function trigger(target, type7, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (true) {
        dep.trigger({
          target,
          type: type7,
          key,
          newValue,
          oldValue,
          oldTarget
        });
      } else {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type7 === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray3(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type7) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
var arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator3(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x7) => isArray3(x7) ? reactiveReadArray(x7) : x7)
    );
  },
  entries() {
    return iterator3(this, "entries", (value2) => {
      value2[1] = toReactive(value2[1]);
      return value2;
    });
  },
  every(fn4, thisArg) {
    return apply(this, "every", fn4, thisArg, void 0, arguments);
  },
  filter(fn4, thisArg) {
    return apply(this, "filter", fn4, thisArg, (v9) => v9.map(toReactive), arguments);
  },
  find(fn4, thisArg) {
    return apply(this, "find", fn4, thisArg, toReactive, arguments);
  },
  findIndex(fn4, thisArg) {
    return apply(this, "findIndex", fn4, thisArg, void 0, arguments);
  },
  findLast(fn4, thisArg) {
    return apply(this, "findLast", fn4, thisArg, toReactive, arguments);
  },
  findLastIndex(fn4, thisArg) {
    return apply(this, "findLastIndex", fn4, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn4, thisArg) {
    return apply(this, "forEach", fn4, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn4, thisArg) {
    return apply(this, "map", fn4, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn4, ...args) {
    return reduce10(this, "reduce", fn4, args);
  },
  reduceRight(fn4, ...args) {
    return reduce10(this, "reduceRight", fn4, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn4, thisArg) {
    return apply(this, "some", fn4, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator3(this, "values", toReactive);
  }
};
function iterator3(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (!result.done) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
var arrayProto = Array.prototype;
function apply(self2, method, fn4, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn4;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index2) {
        return fn4.call(this, toReactive(item), index2, self2);
      };
    } else if (fn4.length > 2) {
      wrappedFn = function(item, index2) {
        return fn4.call(this, item, index2, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce10(self2, method, fn4, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn4;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index2) {
        return fn4.call(this, acc, toReactive(item), index2, self2);
      };
    } else if (fn4.length > 3) {
      wrappedFn = function(acc, item, index2) {
        return fn4.call(this, acc, item, index2, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
var isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
var builtInSymbols = new Set(
  Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty6(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
var BaseReactiveHandler = class {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray3(target);
    if (!isReadonly2) {
      let fn4;
      if (targetIsArray && (fn4 = arrayInstrumentations[key])) {
        return fn4;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty6;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      const value2 = targetIsArray && isIntegerKey(key) ? res : res.value;
      return isReadonly2 && isObject3(value2) ? readonly(value2) : value2;
    }
    if (isObject3(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
};
var MutableReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value2, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value2) && !isReadonly(value2)) {
        oldValue = toRaw(oldValue);
        value2 = toRaw(value2);
      }
      if (!isArray3(target) && isRef(oldValue) && !isRef(value2)) {
        if (isOldValueReadonly) {
          if (true) {
            warn(
              `Set operation on key "${String(key)}" failed: target is readonly.`,
              target[key]
            );
          }
          return true;
        } else {
          oldValue.value = value2;
          return true;
        }
      }
    }
    const hadKey = isArray3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value2,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger(target, "set", key, value2, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray3(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
};
var ReadonlyReactiveHandler = class extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (true) {
      warn(
        `Set operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
  deleteProperty(target, key) {
    if (true) {
      warn(
        `Delete operation on key "${String(key)}" failed: target is readonly.`,
        target
      );
    }
    return true;
  }
};
var mutableHandlers = new MutableReactiveHandler();
var readonlyHandlers = new ReadonlyReactiveHandler();
var shallowReactiveHandlers = new MutableReactiveHandler(true);
var shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
var toShallow = (value2) => value2;
var getProto = (v9) => Reflect.getPrototypeOf(v9);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value: value2, done } = innerIterator.next();
        return done ? { value: value2, done } : {
          value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type7) {
  return function(...args) {
    if (true) {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      warn(
        `${capitalize(type7)} operation ${key}failed: target is readonly.`,
        toRaw(this)
      );
    }
    return type7 === "delete" ? false : type7 === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has3 } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has3.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has3.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return target.size;
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value2, key) => {
        return callback.call(thisArg, wrap(value2), wrap(key), observed);
      });
    }
  };
  extend14(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value2) {
        if (!shallow && !isShallow(value2) && !isReadonly(value2)) {
          value2 = toRaw(value2);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value2);
        if (!hadKey) {
          target.add(value2);
          trigger(target, "add", value2, value2);
        }
        return this;
      },
      set(key, value2) {
        if (!shallow && !isShallow(value2) && !isReadonly(value2)) {
          value2 = toRaw(value2);
        }
        const target = toRaw(this);
        const { has: has3, get: get8 } = getProto(target);
        let hadKey = has3.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has3.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has3, key);
        }
        const oldValue = get8.call(target, key);
        target.set(key, value2);
        if (!hadKey) {
          trigger(target, "add", key, value2);
        } else if (hasChanged(value2, oldValue)) {
          trigger(target, "set", key, value2, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has: has3, get: get8 } = getProto(target);
        let hadKey = has3.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has3.call(target, key);
        } else if (true) {
          checkIdentityKeys(target, has3, key);
        }
        const oldValue = get8 ? get8.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget = true ? isMap(target) ? new Map(target) : new Set(target) : void 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
var mutableCollectionHandlers = {
  get: createInstrumentationGetter(false, false)
};
var shallowCollectionHandlers = {
  get: createInstrumentationGetter(false, true)
};
var readonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, false)
};
var shallowReadonlyCollectionHandlers = {
  get: createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has3, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has3.call(target, rawKey)) {
    const type7 = toRawType(target);
    warn(
      `Reactive ${type7} contains both the raw and reactive versions of the same object${type7 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
var readonlyMap = /* @__PURE__ */ new WeakMap();
var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject3(target)) {
    if (true) {
      warn(
        `value cannot be made ${isReadonly2 ? "readonly" : "reactive"}: ${String(
          target
        )}`
      );
    }
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isShallow(value2) {
  return !!(value2 && value2["__v_isShallow"]);
}
function isProxy(value2) {
  return value2 ? !!value2["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
var toReactive = (value2) => isObject3(value2) ? reactive(value2) : value2;
var toReadonly = (value2) => isObject3(value2) ? readonly(value2) : value2;
function isRef(r8) {
  return r8 ? r8["__v_isRef"] === true : false;
}

// node_modules/@dynamic-labs/message-transport/src/index.js
assertPackageVersion("@dynamic-labs/message-transport", version10);

// node_modules/@dynamic-labs/waas/node_modules/@dynamic-labs-wallet/browser-wallet-client/index.esm.js
function _extends4() {
  _extends4 = Object.assign || function assign(target) {
    for (var i9 = 1; i9 < arguments.length; i9++) {
      var source = arguments[i9];
      for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var iframeMessageHandler = class {
  // Handle error response from iframe message handler
  handleIframeMessageResponseError(response) {
    if (typeof response === "object" && response !== null && "error" in response) {
      throw new Error(String(response.error));
    }
  }
  async getWallets(request2) {
    const response = await this.requestChannel.request("getWallets", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async getWallet(request2) {
    const response = await this.requestChannel.request("getWallet", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async createWalletAccount(request2) {
    const response = await this.requestChannel.request("createWalletAccount", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async requiresPasswordForOperation(request2) {
    const response = await this.requestChannel.request("requiresPasswordForOperation", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signMessage(request2) {
    const response = await this.requestChannel.request("signMessage", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signRawMessage(request2) {
    const response = await this.requestChannel.request("signRawMessage", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signTransaction(request2) {
    const response = await this.requestChannel.request("signTransaction", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async isPasswordEncrypted(request2) {
    const response = await this.requestChannel.request("isPasswordEncrypted", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async backupKeySharesToGoogleDrive(request2) {
    const response = await this.requestChannel.request("backupKeySharesToGoogleDrive", request2);
    this.handleIframeMessageResponseError(response);
  }
  async delegateKeyShares(request2) {
    const response = await this.requestChannel.request("delegateKeyShares", request2);
    this.handleIframeMessageResponseError(response);
  }
  async revokeDelegation(request2) {
    const response = await this.requestChannel.request("revokeDelegation", request2);
    this.handleIframeMessageResponseError(response);
  }
  async restoreBackupFromGoogleDrive(request2) {
    const response = await this.requestChannel.request("restoreBackupFromGoogleDrive", request2);
    this.handleIframeMessageResponseError(response);
  }
  async refreshWalletAccountShares(request2) {
    const response = await this.requestChannel.request("refreshWalletAccountShares", request2);
    this.handleIframeMessageResponseError(response);
  }
  async reshare(request2) {
    const response = await this.requestChannel.request("reshare", request2);
    this.handleIframeMessageResponseError(response);
  }
  async exportPrivateKey(request2) {
    const response = await this.requestChannel.request("exportPrivateKey", request2);
    this.handleIframeMessageResponseError(response);
  }
  async verifyPassword(request2) {
    const response = await this.requestChannel.request("verifyPassword", request2);
    this.handleIframeMessageResponseError(response);
  }
  async updatePassword(request2) {
    const response = await this.requestChannel.request("updatePassword", request2);
    this.handleIframeMessageResponseError(response);
  }
  async importPrivateKey(request2) {
    const response = await this.requestChannel.request("importPrivateKey", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async sendAuthToken(token, authMode) {
    return this.requestChannel.request("sendAuthToken", token, authMode);
  }
  async exportClientKeyshares(request2) {
    const response = await this.requestChannel.request("exportClientKeyshares", request2);
    this.handleIframeMessageResponseError(response);
  }
  async offlineExportPrivateKey(request2) {
    const response = await this.requestChannel.request("offlineExportPrivateKey", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async signTypedData(request2) {
    const response = await this.requestChannel.request("signTypedData", request2);
    this.handleIframeMessageResponseError(response);
    return response;
  }
  async cleanup() {
    return this.requestChannel.request("cleanup");
  }
  constructor(messageTransport) {
    this.requestChannel = createRequestChannel(messageTransport);
  }
};
var logger7 = new Logger("DynamicWaasWalletClient");
var setupMessageTransportBridge = (messageTransport, iframe, iframeOrigin) => {
  if (!(iframe == null ? void 0 : iframe.contentWindow)) {
    throw new Error("Iframe or contentWindow not available");
  }
  const logger9 = new Logger("debug");
  messageTransport.on((message) => {
    if (message.origin === "host") {
      var _iframe_contentWindow;
      iframe == null ? void 0 : (_iframe_contentWindow = iframe.contentWindow) == null ? void 0 : _iframe_contentWindow.postMessage(message, iframeOrigin);
    }
  });
  const handleIncomingMessage = (message) => {
    const { data } = message;
    if (!data) return;
    if ((data == null ? void 0 : data.origin) !== "webview") {
      return;
    }
    if (typeof data !== "object") {
      return;
    }
    try {
      const message2 = parseMessageTransportData(data);
      messageTransport.emit(message2);
    } catch (error) {
      if (!(error instanceof SyntaxError)) {
        logger9.error("Error handling incoming message:", error);
      }
    }
  };
  document.addEventListener("message", handleIncomingMessage);
  window.addEventListener("message", handleIncomingMessage);
};
var IframeManager = class _IframeManager {
  // Simply load the iframe from localhost
  async initialize() {
    await this.doInitializeIframeCommunication();
  }
  /**
  * this is called on class construction time
  * @returns {Promise<void>} that resolves when the iframe is loaded and the message transport and iframe storage are initialized
  */
  initializeIframeCommunication() {
    var _IframeManager2;
    var _iframeLoadPromise;
    (_iframeLoadPromise = (_IframeManager2 = _IframeManager).iframeLoadPromise) != null ? _iframeLoadPromise : _IframeManager2.iframeLoadPromise = this.doInitializeIframeCommunication();
    return _IframeManager.iframeLoadPromise;
  }
  /**
  * initialize the iframe communication by awaiting the iframe load promise
  * and initializing the message transport and iframe storage after iframe is successfully loaded
  */
  async doInitializeIframeCommunication() {
    try {
      await this.loadIframe();
    } catch (error) {
      this.logger.error("Error initializing iframe:", error);
      throw error;
    }
  }
  /**
  * initialize the message transport after iframe is successfully loaded
  */
  async initializeMessageTransport() {
    if (this.messageTransport && this.iframeMessageHandler) {
      this.logger.debug("Skipping initializeMessageTransport: transport and message handler already initialized");
      return;
    }
    await this.initializeIframeCommunication();
    const transport = applyDefaultMessageOrigin({
      defaultOrigin: "host",
      messageTransport: createMessageTransport()
    });
    this.messageTransport = transport;
    if (!this.iframe) {
      throw new Error("Iframe not available");
    }
    setupMessageTransportBridge(this.messageTransport, this.iframe, this.iframeDomain);
    this.iframeMessageHandler = new iframeMessageHandler(this.messageTransport);
    await this.initAuthToken();
  }
  /**
  * securely exchange the auth token with iframe securely
  */
  async initAuthToken() {
    if (!this.iframeMessageHandler) {
      throw new Error("Iframe message handler not initialized");
    }
    try {
      await this.iframeMessageHandler.sendAuthToken(this.authToken, this.authMode);
    } catch (error) {
      throw new Error("Failed to establish secure token exchange: " + error);
    }
  }
  /**
  * Reset the shared iframe and iframe load promise, and iframe instance count
  */
  async resetSharedIframe() {
    _IframeManager.sharedIframe = null;
    _IframeManager.iframeInstanceCount = 0;
    _IframeManager.iframeLoadPromise = null;
    this.iframe = null;
    this.iframeMessageHandler = null;
    this.messageTransport = null;
    _IframeManager.iframeLoadTimeout = Math.min(_IframeManager.iframeLoadTimeout * 2, 6e4);
  }
  async loadIframe() {
    if (_IframeManager.sharedIframe) {
      this.assignExistingIframe();
      return Promise.resolve();
    }
    if (_IframeManager.iframeLoadPromise) {
      return _IframeManager.iframeLoadPromise.then(() => {
        this.assignExistingIframe();
      });
    }
    _IframeManager.iframeLoadPromise = this.createIframeLoadPromise();
    return _IframeManager.iframeLoadPromise;
  }
  assignExistingIframe() {
    this.iframe = _IframeManager.sharedIframe;
    _IframeManager.iframeInstanceCount++;
  }
  createIframeLoadPromise() {
    return new Promise((resolve, reject) => {
      const attemptLoad = () => {
        _IframeManager.iframeLoadAttempts++;
        this.logger.info(`Loading iframe for waas wallet client... (attempt ${_IframeManager.iframeLoadAttempts}/${_IframeManager.maxRetryAttempts + 1})`, this.getIframeContext());
        const iframe = document.createElement("iframe");
        let messageListener = null;
        const context = _extends4({}, this.getIframeContext(), {
          attempt: _IframeManager.iframeLoadAttempts
        });
        const iframeTimeoutId = setTimeout(() => {
          if (iframe.onerror) {
            iframe.onerror("Iframe load timeout");
          }
        }, _IframeManager.iframeLoadTimeout);
        messageListener = this.createMessageListener(iframe, iframeTimeoutId, resolve);
        window.addEventListener("message", messageListener);
        this.configureIframe(iframe);
        this.setIframeSource(iframe);
        this.logger.debug("Creating iframe with src:", iframe.src);
        document.body.appendChild(iframe);
        this.setupIframeEventHandlersWithRetry(iframe, messageListener, iframeTimeoutId, reject, attemptLoad, context);
      };
      attemptLoad();
    });
  }
  setupIframeEventHandlersWithRetry(iframe, messageListener, iframeTimeoutId, reject, attemptLoad, context) {
    iframe.onload = () => {
      this.logger.debug("Iframe onload fired, waiting for ready message...");
    };
    iframe.onerror = (error) => {
      if (messageListener) {
        window.removeEventListener("message", messageListener);
      }
      clearTimeout(iframeTimeoutId);
      if (_IframeManager.iframeLoadAttempts <= _IframeManager.maxRetryAttempts) {
        const errorMsg = error instanceof Error ? error.message : "Unknown error occurred.";
        this.logger.warn(`(loadIframe) Iframe failed to load on attempt ${_IframeManager.iframeLoadAttempts}, retrying... context: ${JSON.stringify(context)}, error: ${errorMsg}`);
        if (iframe.parentNode) {
          iframe.parentNode.removeChild(iframe);
        }
        setTimeout(() => {
          attemptLoad();
        }, 1e3);
      } else {
        this.logger.error("Iframe failed to load after all retry attempts: ", error);
        this.resetSharedIframe();
        _IframeManager.iframeLoadAttempts = 0;
        reject(new Error(`Failed to load iframe after all retry attempts... context: ${JSON.stringify(context)}`));
      }
    };
  }
  getIframeContext() {
    var _this_sdkVersion;
    return {
      iframeDomain: this.iframeDomain,
      environmentId: this.environmentId,
      sdkVersion: (_this_sdkVersion = this.sdkVersion) != null ? _this_sdkVersion : "",
      instanceId: this.instanceId,
      chainName: this.chainName,
      iframeLoadTimeout: _IframeManager.iframeLoadTimeout
    };
  }
  createMessageListener(iframe, iframeTimeoutId, resolve) {
    const messageListener = (event) => {
      if (event.source === iframe.contentWindow && event.data === `iframe-ready-${this.instanceId}`) {
        window.removeEventListener("message", messageListener);
        clearTimeout(iframeTimeoutId);
        _IframeManager.sharedIframe = iframe;
        this.iframe = iframe;
        _IframeManager.iframeInstanceCount++;
        _IframeManager.iframeLoadAttempts = 0;
        resolve();
        this.logger.info("Iframe loaded successfully...", this.getIframeContext());
      }
    };
    return messageListener;
  }
  configureIframe(iframe) {
    iframe.style.display = "none";
    iframe.setAttribute("title", "Dynamic Wallet Iframe");
    iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-downloads");
    iframe.setAttribute("referrerpolicy", "origin");
    iframe.style.position = "fixed";
    iframe.style.top = "0";
    iframe.style.left = "0";
    iframe.style.width = "0";
    iframe.style.height = "0";
    iframe.style.border = "none";
    iframe.style.pointerEvents = "none";
  }
  setIframeSource(iframe) {
    var _this_instanceId, _this_sdkVersion;
    const params = new URLSearchParams({
      instanceId: (_this_instanceId = this.instanceId) != null ? _this_instanceId : "",
      hostOrigin: window.location.origin,
      environmentId: this.environmentId,
      baseApiUrl: this.baseApiUrl,
      baseMPCRelayApiUrl: this.baseMPCRelayApiUrl,
      sdkVersion: (_this_sdkVersion = this.sdkVersion) != null ? _this_sdkVersion : ""
    });
    iframe.src = `${this.iframeDomain}/waas-v1/${this.environmentId}?${params.toString()}`;
  }
  /**
  * Load an iframe for a specific container
  * @param {HTMLElement} container - The container to which the iframe will be attached
  * @returns {Promise<HTMLIFrameElement>} that resolves when the iframe is loaded
  */
  loadIframeForContainer(container) {
    return new Promise((resolve, reject) => {
      var _this_sdkVersion;
      const context = {
        iframeDomain: this.iframeDomain,
        environmentId: this.environmentId,
        sdkVersion: (_this_sdkVersion = this.sdkVersion) != null ? _this_sdkVersion : "",
        instanceId: this.instanceId,
        chainName: this.chainName,
        iframeLoadTimeout: _IframeManager.iframeLoadTimeout
      };
      this.logger.info(`Loading iframe for container...`, context);
      const iframe = document.createElement("iframe");
      let messageListener = null;
      const iframeTimeoutId = setTimeout(() => {
        if (messageListener) {
          window.removeEventListener("message", messageListener);
        }
        this.logger.error(`(loadIframeForContainer) Iframe load timeout due to no handshake message from iframe, this could be network issues, incorrect iframe domain, or CORS errors that prevents iframe from being loaded or sending handshake message, context: ${JSON.stringify(context)}`);
        reject(new Error(`(loadIframeForContainer) Iframe load timeout due to no handshake message from iframe, this could be network issues, incorrect iframe domain, or CORS errors that prevents iframe from being loaded or sending handshake message, context: ${JSON.stringify(context)}`));
      }, _IframeManager.iframeLoadTimeout);
      iframe.style.display = "block";
      iframe.style.width = "100%";
      iframe.style.height = "100%";
      iframe.setAttribute("title", "Dynamic Wallet Storage");
      iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
      iframe.setAttribute("referrerpolicy", "origin");
      var _this_instanceId, _this_sdkVersion1;
      const params = new URLSearchParams({
        instanceId: (_this_instanceId = this.instanceId) != null ? _this_instanceId : "",
        hostOrigin: window.location.origin,
        environmentId: this.environmentId,
        baseApiUrl: this.baseApiUrl,
        baseMPCRelayApiUrl: this.baseMPCRelayApiUrl,
        sdkVersion: (_this_sdkVersion1 = this.sdkVersion) != null ? _this_sdkVersion1 : ""
      });
      iframe.src = `${this.iframeDomain}/waas-v1/${this.environmentId}?${params.toString()}`;
      this.logger.debug("Creating iframe with src:", iframe.src);
      container.appendChild(iframe);
      iframe.onload = () => {
        this.logger.debug("Iframe onload fired, waiting for ready message...");
      };
      iframe.onerror = (error) => {
        if (messageListener) {
          window.removeEventListener("message", messageListener);
        }
        clearTimeout(iframeTimeoutId);
        this.logger.error("Iframe failed to load due to errors: ", error);
        reject(new Error("Failed to load iframe due to unknown load errors, this is likely a browser or network issue."));
      };
      messageListener = (event) => {
        if (event.source === iframe.contentWindow && event.data === `iframe-ready-${this.instanceId}`) {
          if (messageListener) {
            window.removeEventListener("message", messageListener);
          }
          clearTimeout(iframeTimeoutId);
          _IframeManager.sharedIframe = iframe;
          this.iframe = iframe;
          _IframeManager.iframeInstanceCount++;
          resolve(iframe);
          var _this_sdkVersion2;
          this.logger.info("Iframe loaded successfully...", {
            iframeDomain: this.iframeDomain,
            environmentId: this.environmentId,
            sdkVersion: (_this_sdkVersion2 = this.sdkVersion) != null ? _this_sdkVersion2 : "",
            instanceId: this.instanceId,
            chainName: this.chainName
          });
        }
      };
      window.addEventListener("message", messageListener);
    });
  }
  /**
  * Initializes the iframe display for a specific container.
  *
  * @param {HTMLElement} container - The container to which the iframe will be attached.
  * @returns:
  *   iframe: HTMLIFrameElement;
  *   iframeDisplay: IframeDisplayChannelAdapter;
  *   cleanup: () => void;
  */
  async initializeIframeDisplayForContainer({ container }) {
    try {
      const iframe = await this.loadIframeForContainer(container);
      const transport = applyDefaultMessageOrigin({
        defaultOrigin: "host",
        messageTransport: createMessageTransport()
      });
      setupMessageTransportBridge(transport, iframe, this.iframeDomain);
      const iframeDisplay = new iframeMessageHandler(transport);
      var _this_authMode;
      await iframeDisplay.sendAuthToken(this.authToken, (_this_authMode = this.authMode) != null ? _this_authMode : AuthMode2.HEADER);
      return {
        iframe,
        iframeDisplay,
        cleanup: () => {
          container.removeChild(iframe);
        }
      };
    } catch (error) {
      this.logger.error("Error initializing iframe:", error);
      throw error;
    }
  }
  async cleanup() {
    await this.initializeMessageTransport();
    if (!this.iframeMessageHandler) {
      throw new Error("Iframe message handler not initialized");
    }
    await this.iframeMessageHandler.cleanup();
    if (this.iframe) {
      _IframeManager.iframeInstanceCount--;
      if (_IframeManager.sharedIframe && _IframeManager.iframeInstanceCount === 0) {
        document.body.removeChild(_IframeManager.sharedIframe);
        _IframeManager.sharedIframe = null;
        _IframeManager.iframeLoadPromise = null;
      }
      this.iframe = null;
    }
  }
  constructor({ environmentId, baseApiUrl, baseMPCRelayApiUrl, chainName, sdkVersion, authMode = AuthMode2.HEADER, authToken, debug }) {
    this.logger = logger7;
    this.instanceId = null;
    this.iframeDomain = null;
    this.messageTransport = null;
    this.iframeMessageHandler = null;
    this.iframe = null;
    this.environmentId = environmentId;
    this.authToken = authToken;
    this.authMode = authMode;
    this.baseApiUrl = baseApiUrl;
    this.baseMPCRelayApiUrl = baseMPCRelayApiUrl;
    this.chainName = chainName;
    this.sdkVersion = sdkVersion;
    const environment = getEnvironmentFromUrl(baseApiUrl);
    this.iframeDomain = IFRAME_DOMAIN_MAP[environment];
    if (this.authMode === AuthMode2.COOKIE) {
      this.iframeDomain = this.baseApiUrl;
    }
    this.instanceId = v4_default();
    this.debug = Boolean(debug);
    this.logger.setLogLevel(this.debug ? "DEBUG" : "INFO");
  }
};
IframeManager.iframeLoadPromise = null;
IframeManager.iframeLoadTimeout = 1e4;
IframeManager.iframeLoadAttempts = 0;
IframeManager.maxRetryAttempts = 1;
IframeManager.sharedIframe = null;
IframeManager.iframeInstanceCount = 0;
var DynamicWalletClient = class extends IframeManager {
  async withHandler(operation) {
    await this.initializeMessageTransport();
    if (!this.iframeMessageHandler) {
      throw new Error("Iframe message handler not initialized");
    }
    return operation(this.iframeMessageHandler);
  }
  async getWallets() {
    return this.withHandler((handler) => handler.getWallets({
      chainName: this.chainName
    }));
  }
  async getWallet({ accountAddress, walletOperation = WalletOperation2.NO_OPERATION, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.getWallet({
      chainName: this.chainName,
      accountAddress,
      walletOperation,
      signedSessionId,
      authToken
    }));
  }
  async createWalletAccount({ thresholdSignatureScheme, password = void 0, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.createWalletAccount({
      chainName: this.chainName,
      thresholdSignatureScheme,
      password,
      signedSessionId,
      authToken
    }));
  }
  async requiresPasswordForOperation({ accountAddress, walletOperation = WalletOperation2.REACH_THRESHOLD, authToken }) {
    return this.withHandler((handler) => handler.requiresPasswordForOperation({
      chainName: this.chainName,
      accountAddress,
      walletOperation,
      authToken
    }));
  }
  async isPasswordEncrypted({ accountAddress, authToken }) {
    return this.withHandler((handler) => handler.isPasswordEncrypted({
      chainName: this.chainName,
      accountAddress,
      authToken
    }));
  }
  async signMessage({ message, accountAddress, password = void 0, signedSessionId, authToken, mfaToken, context }) {
    const contextString = JSON.stringify(context, (_key, value2) => typeof value2 === "bigint" ? value2.toString() : value2);
    return this.withHandler((handler) => handler.signMessage({
      chainName: this.chainName,
      message,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      context: contextString
    }));
  }
  async signRawMessage({ message, accountAddress, password = void 0, signedSessionId, authToken, mfaToken, context }) {
    return this.withHandler((handler) => handler.signRawMessage({
      chainName: this.chainName,
      message,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      context
    }));
  }
  /**
  * Signs a transaction and returns the signature, @transaction is a string of the serialized transaction
  * EVM:
  *   transaction = serializeTransaction()
  * SOL:
  *   const messageBytes = transaction.serializeMessage();
  *   const messageToSign = Buffer.from(messageBytes).toString("hex");
  * SUI:
  *  const txBytes = await txb.build({ client });
  *  const txString = Buffer.from(txBytes).toString("hex");
  */
  async signTransaction({ senderAddress, transaction, password = void 0, signedSessionId, authToken, mfaToken, chainId }) {
    return this.withHandler((handler) => handler.signTransaction({
      chainName: this.chainName,
      senderAddress,
      transaction,
      password,
      signedSessionId,
      authToken,
      mfaToken,
      chainId
    }));
  }
  async signTypedData({ accountAddress, typedData, password = void 0, signedSessionId, authToken, mfaToken }) {
    return this.withHandler((handler) => handler.signTypedData({
      chainName: this.chainName,
      accountAddress,
      typedData: JSON.stringify(typedData),
      password,
      signedSessionId,
      authToken,
      mfaToken
    }));
  }
  async backupKeySharesToGoogleDrive({ accountAddress, password = void 0, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.backupKeySharesToGoogleDrive({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken
    }));
  }
  async delegateKeyShares({ accountAddress, password, signedSessionId, authToken, mfaToken }) {
    return this.withHandler((handler) => handler.delegateKeyShares({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken
    }));
  }
  async revokeDelegation({ accountAddress, password, signedSessionId, authToken, mfaToken }) {
    return this.withHandler((handler) => handler.revokeDelegation({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken
    }));
  }
  async restoreBackupFromGoogleDrive({ accountAddress, displayContainer, password, signedSessionId, authToken }) {
    const { iframeDisplay } = await this.initializeIframeDisplayForContainer({
      container: displayContainer
    });
    if (!iframeDisplay) {
      throw new Error("Failed to initialize iframe handler with display functionality");
    }
    return iframeDisplay.restoreBackupFromGoogleDrive({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken
    });
  }
  async refreshWalletAccountShares({ accountAddress, password, signedSessionId, authToken, mfaToken }) {
    return this.withHandler((handler) => handler.refreshWalletAccountShares({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken
    }));
  }
  async reshare({ accountAddress, oldThresholdSignatureScheme, newThresholdSignatureScheme, password, signedSessionId, authToken, mfaToken }) {
    return this.withHandler((handler) => handler.reshare({
      chainName: this.chainName,
      accountAddress,
      oldThresholdSignatureScheme,
      newThresholdSignatureScheme,
      password,
      signedSessionId,
      authToken,
      mfaToken
    }));
  }
  async exportPrivateKey({ accountAddress, displayContainer, password, signedSessionId, authToken, mfaToken }) {
    const { iframeDisplay } = await this.initializeIframeDisplayForContainer({
      container: displayContainer
    });
    if (!iframeDisplay) {
      throw new Error("Failed to initialize iframe handler with display functionality");
    }
    return iframeDisplay.exportPrivateKey({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken,
      mfaToken
    });
  }
  async verifyPassword({ accountAddress, password, walletOperation = WalletOperation2.NO_OPERATION, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.verifyPassword({
      chainName: this.chainName,
      accountAddress,
      password,
      walletOperation,
      signedSessionId,
      authToken
    }));
  }
  async updatePassword({ accountAddress, existingPassword, newPassword, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.updatePassword({
      chainName: this.chainName,
      accountAddress,
      existingPassword,
      newPassword,
      signedSessionId,
      authToken
    }));
  }
  async importPrivateKey({ privateKey, thresholdSignatureScheme, signedSessionId, authToken, publicAddressCheck }) {
    return this.withHandler((handler) => handler.importPrivateKey({
      chainName: this.chainName,
      privateKey,
      thresholdSignatureScheme,
      signedSessionId,
      authToken,
      publicAddressCheck
    }));
  }
  async exportClientKeyshares({ accountAddress, password, signedSessionId, authToken }) {
    return this.withHandler((handler) => handler.exportClientKeyshares({
      chainName: this.chainName,
      accountAddress,
      password,
      signedSessionId,
      authToken
    }));
  }
  /**
  * keyShares is stringified list of EcdsaKeygenResult[] and Ed25519KeygenResult[]
  */
  async offlineExportPrivateKey({ keyShares, derivationPath }) {
    const args = {
      chainName: this.chainName,
      keyShares,
      derivationPath
    };
    const serializedArgs = JSON.stringify(args);
    const argsBuffer = new TextEncoder().encode(serializedArgs);
    const base64Args = Buffer.from(argsBuffer).toString("base64");
    return this.withHandler((handler) => handler.offlineExportPrivateKey({
      chainName: this.chainName,
      base64Args
    }));
  }
  constructor({ environmentId, authToken, baseApiUrl, baseMPCRelayApiUrl, chainName, sdkVersion, debug, authMode = AuthMode2.HEADER }) {
    super({
      environmentId,
      authToken,
      baseApiUrl,
      baseMPCRelayApiUrl,
      chainName,
      sdkVersion,
      debug,
      authMode
    });
  }
};

// node_modules/@dynamic-labs/waas/utils/constants.js
var DEFAULT_BASE_API_URL = "https://app.dynamicauth.com";
var DEFAULT_BASE_MPC_RELAY_API_URL = "https://relay.dynamicauth.com";

// node_modules/@dynamic-labs/waas/src/DynamicWaasMixin.js
var WaasExportHandler = class {
  constructor() {
    this.iframeStamper = null;
  }
  setIframeStamper(iframe) {
    this.iframeStamper = iframe;
  }
  clear() {
    if (this.iframeStamper) {
      this.iframeStamper.remove();
      this.iframeStamper = null;
    }
  }
};
var withDynamicWaas = (BaseClass) => {
  class DynamicWaasMixin extends BaseClass {
    setGetAuthTokenFunction(getAuthToken) {
      this.getAuthToken = getAuthToken;
    }
    setWaasAuthMode(authMode) {
      this.authMode = authMode;
    }
    setGetMfaTokenFunction(getMfaToken) {
      this.getMfaToken = getMfaToken;
    }
    setEnvironmentId(environmentId) {
      this.environmentId = environmentId;
    }
    setBaseApiUrl(baseApiUrl) {
      this.baseApiUrl = baseApiUrl;
    }
    setRelayUrl(relayUrl) {
      this.relayUrl = relayUrl;
    }
    setGetSignedSessionIdFunction(getSignedSessionId) {
      this.getSignedSessionId = getSignedSessionId;
    }
    delegateKeyShares(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new Error("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new Error("Signed session ID is required");
        }
        const authToken = (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this);
        if (!authToken) {
          throw new Error("Auth token is required");
        }
        return walletClient.delegateKeyShares({
          accountAddress,
          authToken,
          password,
          signedSessionId
        });
      });
    }
    constructor(...args) {
      super(...args);
      this.name = "Dynamic Waas";
      this.overrideKey = "dynamicwaas";
      this.isEmbeddedWallet = true;
      this.authMode = "header";
      this.__exportHandler = new WaasExportHandler();
      const { connectedChain } = this;
      const chainNameMap = {
        EVM: "EVM",
        SOL: "SVM",
        SUI: "SUI"
      };
      const chainName = chainNameMap[connectedChain];
      if (!chainName) {
        throw new DynamicError(`Unsupported chain: ${connectedChain}`);
      }
      this.chainName = chainName;
    }
    createDynamicWaasClient() {
      return __awaiter7(this, void 0, void 0, function* () {
        var _a14;
        const authToken = (_a14 = this.getAuthToken) === null || _a14 === void 0 ? void 0 : _a14.call(this);
        if (!authToken && this.authMode === "header") {
          throw new DynamicError("Auth token is required in non-cookie auth mode");
        }
        if (!this.environmentId) {
          throw new DynamicError("Environment ID is required");
        }
        const client = new DynamicWalletClient({
          authMode: this.authMode || "header",
          authToken: authToken || "",
          baseApiUrl: this.baseApiUrl || DEFAULT_BASE_API_URL,
          baseMPCRelayApiUrl: this.relayUrl || DEFAULT_BASE_MPC_RELAY_API_URL,
          chainName: this.chainName,
          environmentId: this.environmentId,
          sdkVersion: version9
        });
        yield client.initialize();
        return client;
      });
    }
    getWaasWalletClient() {
      return __awaiter7(this, void 0, void 0, function* () {
        if (!this.dynamicWaasClient) {
          this.dynamicWaasClient = yield this.createDynamicWaasClient();
        }
        return this.dynamicWaasClient;
      });
    }
    // Common methods that are identical across all connectors
    createWalletAccount() {
      return __awaiter7(this, arguments, void 0, function* ({ thresholdSignatureScheme = "TWO_OF_TWO", password } = {}) {
        var _a14, _b;
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_a14 = this.getSignedSessionId) === null || _a14 === void 0 ? void 0 : _a14.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const createdWallet = yield walletClient.createWalletAccount({
          authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
          password,
          signedSessionId,
          thresholdSignatureScheme
        });
        return createdWallet;
      });
    }
    importPrivateKey(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ privateKey, thresholdSignatureScheme = "TWO_OF_TWO", publicAddressCheck }) {
        var _b, _c3;
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        yield walletClient.importPrivateKey({
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          privateKey,
          publicAddressCheck,
          signedSessionId,
          thresholdSignatureScheme
        });
      });
    }
    exportPrivateKey() {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, displayContainer, password } = {}) {
        var _a14, _b, _c3;
        const walletClient = yield this.getWaasWalletClient();
        const targetAccountAddress = accountAddress || (yield this.getActiveAccountAddress());
        if (!targetAccountAddress) {
          throw new DynamicError("Account address is required");
        }
        if (!displayContainer) {
          throw new DynamicError("Missing display container for export private key");
        }
        const signedSessionId = yield (_a14 = this.getSignedSessionId) === null || _a14 === void 0 ? void 0 : _a14.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        this.__exportHandler.setIframeStamper(displayContainer);
        const mfaToken = yield (_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
          mfaAction: MFAAction.WalletWaasExport
        });
        yield walletClient.exportPrivateKey({
          accountAddress: targetAccountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          displayContainer,
          mfaToken,
          password,
          signedSessionId
        });
      });
    }
    getExportHandler() {
      return this.__exportHandler;
    }
    exportClientKeyshares(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        yield walletClient.exportClientKeyshares({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    backupKeySharesToGoogleDrive(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.backupKeySharesToGoogleDrive({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    refreshWalletAccountShares(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3, _d2;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const mfaToken = yield (_c3 = this.getMfaToken) === null || _c3 === void 0 ? void 0 : _c3.call(this, {
          mfaAction: MFAAction.WalletWaasRefresh
        });
        return walletClient.refreshWalletAccountShares({
          accountAddress,
          authToken: (_d2 = this.getAuthToken) === null || _d2 === void 0 ? void 0 : _d2.call(this),
          mfaToken,
          password,
          signedSessionId
        });
      });
    }
    reshareWalletAccountShares(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, thresholdSignatureScheme, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const wallets = yield walletClient.getWallets();
        const wallet = wallets.find((w8) => w8.accountAddress === accountAddress);
        if (!wallet) {
          throw new DynamicError("Wallet not found");
        }
        const oldThresholdSignatureScheme = wallet.thresholdSignatureScheme;
        return walletClient.reshare({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          newThresholdSignatureScheme: thresholdSignatureScheme,
          oldThresholdSignatureScheme,
          password,
          signedSessionId
        });
      });
    }
    revokeDelegation(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, password }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.revokeDelegation({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          password,
          signedSessionId
        });
      });
    }
    updatePassword(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, existingPassword, newPassword }) {
        var _b, _c3;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        return walletClient.updatePassword({
          accountAddress,
          authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
          existingPassword,
          newPassword,
          signedSessionId
        });
      });
    }
    signRawMessage(_a14) {
      return __awaiter7(this, arguments, void 0, function* ({ accountAddress, message, password }) {
        var _b, _c3, _d2;
        if (!accountAddress) {
          throw new DynamicError("Account address is required");
        }
        if (message.length !== 64) {
          throw new DynamicError("Message must be 64 characters long");
        }
        const walletClient = yield this.getWaasWalletClient();
        const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
        if (!signedSessionId) {
          throw new DynamicError("Signed session ID is required");
        }
        const mfaToken = yield (_c3 = this.getMfaToken) === null || _c3 === void 0 ? void 0 : _c3.call(this, {
          mfaAction: MFAAction.WalletWaasSign
        });
        return walletClient.signRawMessage({
          accountAddress,
          authToken: (_d2 = this.getAuthToken) === null || _d2 === void 0 ? void 0 : _d2.call(this),
          message,
          mfaToken,
          password,
          signedSessionId
        });
      });
    }
    endSession() {
      return __awaiter7(this, void 0, void 0, function* () {
        const waasClient = yield this.getWaasWalletClient();
        if (!waasClient) {
          return;
        }
        yield waasClient.cleanup();
        this.dynamicWaasClient = void 0;
      });
    }
  }
  return DynamicWaasMixin;
};

// node_modules/@dynamic-labs/waas/src/index.js
assertPackageVersion("@dynamic-labs/waas", version9);

// node_modules/@dynamic-labs/waas-evm/src/DynamicWaasEVMConnector.js
var logger8 = new Logger("DynamicWaasConnector");
var DynamicWaasEVMConnector = class _DynamicWaasEVMConnector extends withDynamicWaas(EthereumWalletConnector) {
  constructor(props) {
    super(props);
    this.name = "Dynamic Waas";
    this.overrideKey = "dynamicwaas";
    this.isEmbeddedWallet = true;
    this._selectedChainId = this.getLastUsedChainId();
    this.__exportHandler = new WaasExportHandler();
  }
  getLastUsedChainId() {
    var _a14;
    logger8.logVerboseTroubleshootingMessage("[DynamicWaasEVMConnector] getLastUsedChainId", {
      evmNetworks: this.evmNetworks,
      lastUsedChainId: this.lastUsedChainId
    });
    if (this.lastUsedChainId) {
      return this.lastUsedChainId;
    }
    if (!((_a14 = this.evmNetworks) === null || _a14 === void 0 ? void 0 : _a14.length)) {
      return void 0;
    }
    return this.evmNetworks[0].chainId;
  }
  set verifiedCredentials(verifiedCredentials) {
    this._verifiedCredentials = verifiedCredentials;
  }
  get verifiedCredentials() {
    return this._verifiedCredentials;
  }
  set verifiedCredential(verifiedCredential) {
    this._verifiedCredential = verifiedCredential;
  }
  get verifiedCredential() {
    return this._verifiedCredential;
  }
  setVerifiedCredentials(verifiedCredentials) {
    const dynamicWaasVerifiedCredentials = verifiedCredentials === null || verifiedCredentials === void 0 ? void 0 : verifiedCredentials.reduce((acc, vc3) => {
      if (vc3.walletName === "dynamicwaas" && vc3.chain === "eip155") {
        const smartWallet = verifiedCredentials.find((v9) => v9.signerRefId === vc3.id);
        const smartWalletRefId = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.id;
        const smartWalletRefAddress = smartWallet === null || smartWallet === void 0 ? void 0 : smartWallet.address;
        acc.push(Object.assign(Object.assign({}, vc3), { smartWalletRefAddress, smartWalletRefId }));
      }
      return acc;
    }, []);
    const [dynamicWaasVerifiedCredential] = dynamicWaasVerifiedCredentials;
    const didDynamicWaasVerifiedCredentialsChanged = JSON.stringify(this.verifiedCredentials) !== JSON.stringify(dynamicWaasVerifiedCredentials);
    if (!didDynamicWaasVerifiedCredentialsChanged) {
      return;
    }
    this.verifiedCredential = dynamicWaasVerifiedCredential;
    this.verifiedCredentials = dynamicWaasVerifiedCredentials;
  }
  set lastUsedChainId(chainId) {
    if (chainId === void 0) {
      localStorage.removeItem(_DynamicWaasEVMConnector.lastUsedChainIdStorageKey);
    } else {
      localStorage.setItem(_DynamicWaasEVMConnector.lastUsedChainIdStorageKey, chainId.toString());
    }
    this._selectedChainId = chainId;
  }
  get lastUsedChainId() {
    const lastUsedChainIdLS = localStorage.getItem(_DynamicWaasEVMConnector.lastUsedChainIdStorageKey);
    if (!lastUsedChainIdLS)
      return void 0;
    try {
      const chainId = parseInt(lastUsedChainIdLS);
      if (isNaN(chainId)) {
        return void 0;
      }
      const isChainCurrentlyEnabled = this.evmNetworks.some((network) => network.chainId === chainId);
      if (!isChainCurrentlyEnabled) {
        const lastUsedChainId = this.evmNetworks[0].chainId;
        this.lastUsedChainId = lastUsedChainId;
        return lastUsedChainId;
      }
      return chainId;
    } catch (err) {
      logger8.error(err);
      return void 0;
    }
  }
  get currentChainId() {
    var _a14, _b, _c3;
    return (_a14 = this._selectedChainId) !== null && _a14 !== void 0 ? _a14 : (_c3 = (_b = this.evmNetworks) === null || _b === void 0 ? void 0 : _b[0]) === null || _c3 === void 0 ? void 0 : _c3.chainId;
  }
  getNetwork() {
    return __awaiter6(this, void 0, void 0, function* () {
      return this.currentChainId;
    });
  }
  getEvmNetworkByChainId(chainId) {
    return this.evmNetworks.find((network) => network.chainId === chainId);
  }
  currentEvmNetwork() {
    const chainId = this.currentChainId;
    if (!chainId) {
      return void 0;
    }
    return this.getEvmNetworkByChainId(chainId);
  }
  switchNetwork(_a14) {
    return __awaiter6(this, arguments, void 0, function* ({ networkChainId }) {
      if (!networkChainId) {
        return;
      }
      let networkChainIdInt = networkChainId;
      if (typeof networkChainId === "string") {
        networkChainIdInt = parseInt(networkChainId);
      }
      this.lastUsedChainId = networkChainIdInt;
      this._selectedChainId = networkChainIdInt;
      this.emit("chainChange", {
        chain: networkChainIdInt.toString()
      });
    });
  }
  getRpcUrl() {
    var _a14;
    const evmNetwork = this.currentEvmNetwork();
    if (!evmNetwork) {
      throw new Error("EVM network not found");
    }
    return ((_a14 = evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.privateCustomerRpcUrls) === null || _a14 === void 0 ? void 0 : _a14[0]) || (evmNetwork === null || evmNetwork === void 0 ? void 0 : evmNetwork.rpcUrls[0]);
  }
  validateActiveWallet(expectedAddress) {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a14, _b, _c3;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_a14 = this.getSignedSessionId) === null || _a14 === void 0 ? void 0 : _a14.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      const targetWallet = yield walletClient.getWallet({
        accountAddress: expectedAddress,
        authToken: (_b = this.getAuthToken) === null || _b === void 0 ? void 0 : _b.call(this),
        signedSessionId
      });
      if (!targetWallet) {
        throw new DynamicError("Account not found");
      }
      const isWalletActive = isSameAddress(targetWallet.accountAddress, ((_c3 = this.getActiveAccount()) === null || _c3 === void 0 ? void 0 : _c3.address) || "", this.connectedChain);
      if (!isWalletActive) {
        this.setActiveAccount(targetWallet.accountAddress);
      }
    });
  }
  getActiveAccountAddress() {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a14;
      return (_a14 = this.getActiveAccount()) === null || _a14 === void 0 ? void 0 : _a14.address;
    });
  }
  getViemAccount(_a14) {
    return __awaiter6(this, arguments, void 0, function* ({ accountAddress }) {
      var _b;
      const client = yield this.getWaasWalletClient();
      const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      return toAccount({
        address: accountAddress,
        signAuthorization: (parameters) => __awaiter6(this, void 0, void 0, function* () {
          return this.signAuthorization(parameters);
        }),
        signMessage: (_c3) => __awaiter6(this, [_c3], void 0, function* ({ message }) {
          var _d2, _e6;
          const mfaToken = yield (_d2 = this.getMfaToken) === null || _d2 === void 0 ? void 0 : _d2.call(this, {
            mfaAction: MFAAction.WalletWaasSign
          });
          return client.signMessage({
            accountAddress,
            authToken: (_e6 = this.getAuthToken) === null || _e6 === void 0 ? void 0 : _e6.call(this),
            message,
            mfaToken,
            signedSessionId
          });
        }),
        signTransaction: (transaction) => __awaiter6(this, void 0, void 0, function* () {
          var _f3, _g;
          const mfaToken = yield (_f3 = this.getMfaToken) === null || _f3 === void 0 ? void 0 : _f3.call(this, {
            mfaAction: MFAAction.WalletWaasSign
          });
          return client.signTransaction({
            authToken: (_g = this.getAuthToken) === null || _g === void 0 ? void 0 : _g.call(this),
            mfaToken,
            senderAddress: accountAddress,
            signedSessionId,
            transaction: serializeTransaction(transaction)
          }).then((tx) => tx);
        }),
        signTypedData: (typedData) => __awaiter6(this, void 0, void 0, function* () {
          var _h2, _j;
          const mfaToken = yield (_h2 = this.getMfaToken) === null || _h2 === void 0 ? void 0 : _h2.call(this, {
            mfaAction: MFAAction.WalletWaasSign
          });
          return client.signTypedData({
            accountAddress,
            authToken: (_j = this.getAuthToken) === null || _j === void 0 ? void 0 : _j.call(this),
            mfaToken,
            signedSessionId,
            typedData
          });
        })
      });
    });
  }
  getWalletClient(chainId) {
    var _a14;
    const targetAccountAddress = (_a14 = this.getActiveAccount()) === null || _a14 === void 0 ? void 0 : _a14.address;
    if (!targetAccountAddress) {
      return this.getPublicClient();
    }
    const rpcUrl = this.getRpcUrl();
    const evmNetwork = chainId ? this.getEvmNetworkByChainId(parseInt(chainId)) : this.currentEvmNetwork();
    if (!evmNetwork) {
      throw new Error("EVM network not found");
    }
    return createWalletClientWithUiConfirmation({
      account: () => __awaiter6(this, void 0, void 0, function* () {
        return this.getViemAccount({
          accountAddress: targetAccountAddress
        });
      }),
      address: targetAccountAddress,
      chain: getOrMapViemChain(evmNetwork),
      transport: http(rpcUrl, this.providersConfig.httpTransportConfig),
      // TODO: remove this. We should not be passing references to wallet connectors
      walletConnector: this,
      walletUiUtils: this.walletUiUtils
    });
  }
  signMessage(message) {
    var _a14;
    return (_a14 = this.getWalletClient()) === null || _a14 === void 0 ? void 0 : _a14.signMessage({ message });
  }
  signMessageWithContext(_a14) {
    return __awaiter6(this, arguments, void 0, function* ({ message, context }) {
      var _b, _c3, _d2;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_b = this.getSignedSessionId) === null || _b === void 0 ? void 0 : _b.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      return walletClient.signMessage({
        accountAddress: (_c3 = this.getActiveAccount()) === null || _c3 === void 0 ? void 0 : _c3.address,
        authToken: (_d2 = this.getAuthToken) === null || _d2 === void 0 ? void 0 : _d2.call(this),
        context,
        message,
        signedSessionId
      });
    });
  }
  getSigner() {
    return __awaiter6(this, void 0, void 0, function* () {
      return this.getWalletClient();
    });
  }
  getWalletClientByAddress({ accountAddress }) {
    this.setActiveAccount(accountAddress);
    return this.getWalletClient();
  }
  // Chain-specific override for exportClientKeyshares - EVM needs to set active account first
  exportClientKeyshares(_a14) {
    const _super = Object.create(null, {
      exportClientKeyshares: { get: () => super.exportClientKeyshares }
    });
    return __awaiter6(this, arguments, void 0, function* ({ accountAddress, password }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.exportClientKeyshares.call(this, { accountAddress, password });
    });
  }
  // Chain-specific override for backupKeySharesToGoogleDrive - EVM needs to set active account first
  backupKeySharesToGoogleDrive(_a14) {
    const _super = Object.create(null, {
      backupKeySharesToGoogleDrive: { get: () => super.backupKeySharesToGoogleDrive }
    });
    return __awaiter6(this, arguments, void 0, function* ({ accountAddress, password }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.backupKeySharesToGoogleDrive.call(this, { accountAddress, password });
    });
  }
  // Chain-specific override for refreshWalletAccountShares - EVM needs to set active account first
  refreshWalletAccountShares(_a14) {
    const _super = Object.create(null, {
      refreshWalletAccountShares: { get: () => super.refreshWalletAccountShares }
    });
    return __awaiter6(this, arguments, void 0, function* ({ accountAddress, password }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.refreshWalletAccountShares.call(this, { accountAddress, password });
    });
  }
  // Chain-specific override for reshareWalletAccountShares - EVM needs to set active account first
  reshareWalletAccountShares(_a14) {
    const _super = Object.create(null, {
      reshareWalletAccountShares: { get: () => super.reshareWalletAccountShares }
    });
    return __awaiter6(this, arguments, void 0, function* ({ accountAddress, password, thresholdSignatureScheme }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.reshareWalletAccountShares.call(this, {
        accountAddress,
        password,
        thresholdSignatureScheme
      });
    });
  }
  // Chain-specific override for updatePassword - EVM needs to set active account first
  updatePassword(_a14) {
    const _super = Object.create(null, {
      updatePassword: { get: () => super.updatePassword }
    });
    return __awaiter6(this, arguments, void 0, function* ({ accountAddress, existingPassword, newPassword }) {
      if (!accountAddress) {
        throw new Error("Account address is required");
      }
      this.setActiveAccount(accountAddress);
      return _super.updatePassword.call(this, {
        accountAddress,
        existingPassword,
        newPassword
      });
    });
  }
  createUiTransaction(from40) {
    return __awaiter6(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(from40);
      const walletClient = this.getWalletClient();
      const publicClient = yield this.getPublicClient();
      if (!publicClient || !walletClient) {
        throw new DynamicError("No public client available");
      }
      return new ViemUiTransaction({
        account: from40,
        onSubmit: (transaction) => __awaiter6(this, void 0, void 0, function* () {
          if (transaction.nonNativeAddress) {
            return walletClient.writeContract({
              abi: erc20Abi,
              account: walletClient.account,
              address: transaction.nonNativeAddress,
              args: [transaction.to, transaction.nonNativeValue],
              functionName: "transfer",
              maxFeePerGas: transaction.maxFeePerGas,
              maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
            });
          }
          return walletClient.sendTransaction({
            account: walletClient.account,
            data: "0x",
            maxFeePerGas: transaction.maxFeePerGas,
            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
            to: transaction.to,
            value: transaction.value
          });
        }),
        publicClient,
        transaction: {}
      });
    });
  }
  getConnectedAccounts() {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a14;
      const verifiedCredentials = this.verifiedCredentials || [];
      const addresses = verifiedCredentials.map((vc3) => vc3 === null || vc3 === void 0 ? void 0 : vc3.address).filter((a6) => typeof a6 === "string");
      if (addresses.length > 0 && ((_a14 = this.verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.address)) {
        this.setActiveAccount(this.verifiedCredential.address);
      }
      return addresses;
    });
  }
  getAddress() {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a14;
      const activeAccount = this.getActiveAccount();
      if (!activeAccount || !activeAccount.address) {
        if ((_a14 = this.verifiedCredential) === null || _a14 === void 0 ? void 0 : _a14.address) {
          const { address } = this.verifiedCredential;
          this.setActiveAccount(address);
          return address;
        }
        throw new DynamicError("No active wallet address found");
      }
      return activeAccount.address;
    });
  }
  signAuthorization(parameters, password) {
    return __awaiter6(this, void 0, void 0, function* () {
      var _a14, _b, _c3;
      const { address: contractAddress, nonce, chainId } = parameters;
      if (!contractAddress) {
        throw new Error("Contract address not found");
      }
      const [signer, publicClient] = yield Promise.all([
        this.getSigner(),
        this.getPublicClient()
      ]);
      if (!signer || !publicClient) {
        throw new Error("Required clients not found");
      }
      const { address } = signer.account;
      const walletClient = yield this.getWaasWalletClient();
      const signedSessionId = yield (_a14 = this.getSignedSessionId) === null || _a14 === void 0 ? void 0 : _a14.call(this);
      if (!signedSessionId) {
        throw new DynamicError("Signed session ID is required");
      }
      const mfaToken = yield (_b = this.getMfaToken) === null || _b === void 0 ? void 0 : _b.call(this, {
        mfaAction: MFAAction.WalletWaasSign
      });
      const authorization = {
        address: contractAddress,
        chainId,
        nonce
      };
      const signature = yield walletClient.signRawMessage({
        accountAddress: address,
        authToken: (_c3 = this.getAuthToken) === null || _c3 === void 0 ? void 0 : _c3.call(this),
        context: { eip7702Auth: authorization },
        message: hashAuthorization(authorization).slice(2),
        mfaToken,
        password,
        signedSessionId
      });
      const parsedSignature = parseSignature(signature);
      return {
        address: contractAddress,
        chainId,
        nonce,
        r: parsedSignature.r,
        s: parsedSignature.s,
        v: parsedSignature.v,
        yParity: parsedSignature.yParity
      };
    });
  }
  isAtomicSupported(chainId) {
    return __awaiter6(this, void 0, void 0, function* () {
      logger8.debug("[DynamicWaasEVMConnector] isAtomicSupported - not supported", {
        chainId
      });
      return false;
    });
  }
  isPaymasterServiceSupported(chainId) {
    return __awaiter6(this, void 0, void 0, function* () {
      logger8.debug("[DynamicWaasEVMConnector] isPaymasterServiceSupported - not supported", {
        chainId
      });
      return false;
    });
  }
  isSignAuthorizationSupported() {
    return true;
  }
  endSession() {
    const _super = Object.create(null, {
      endSession: { get: () => super.endSession }
    });
    return __awaiter6(this, void 0, void 0, function* () {
      yield _super.endSession.call(this);
    });
  }
};
DynamicWaasEVMConnector.lastUsedChainIdStorageKey = "dynamic-waas-evm-last-used-chain-id";

// node_modules/@dynamic-labs/waas-evm/src/DynamicWaasEVMConnectors.js
var DynamicWaasEVMConnectors = () => [DynamicWaasEVMConnector];

// node_modules/@dynamic-labs/waas-evm/src/index.js
assertPackageVersion("@dynamic-labs/waas-evm", version8);

// node_modules/@dynamic-labs/ethereum/src/walletConnect/utils/fetchWalletConnectWallets.js
var fetchWalletConnectWallets = ({ walletBook }) => {
  var _a14;
  return Object.entries((_a14 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a14 !== void 0 ? _a14 : {}).filter(([, wallet]) => {
    var _a15;
    return wallet.walletConnect && !wallet.filterFromWalletConnect && // Exclude wallets that don't support Evm
    ((_a15 = wallet.chains) === null || _a15 === void 0 ? void 0 : _a15.some((chain6) => chain6.includes("eip155:")));
  }).map(([key, wallet]) => {
    const { shortName } = wallet;
    const name = shortName || wallet.name;
    return class extends WalletConnectConnector {
      constructor(props) {
        super(Object.assign(Object.assign({}, props), { walletName: name }));
        this.overrideKey = key;
      }
    };
  });
};

// node_modules/@dynamic-labs/ethereum/src/walletConnect/utils/getWalletConnectConnector.js
var getWalletConnectConnector = () => class extends WalletConnectConnector {
  constructor(props) {
    super(Object.assign(Object.assign({}, props), { walletName: "WalletConnect" }));
  }
};

// node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js
var walletLogo = (type7, width) => {
  let height;
  switch (type7) {
    case "standard":
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    case "circle":
      height = width;
      return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
    case "text":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogo":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    case "textLight":
      height = (0.1 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
    case "textWithLogoLight":
      height = (0.25 * width).toFixed(2);
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
    default:
      height = width;
      return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/storage/ScopedLocalStorage.js
var ScopedLocalStorage = class _ScopedLocalStorage {
  constructor(scope, module) {
    this.scope = scope;
    this.module = module;
  }
  storeObject(key, item) {
    this.setItem(key, JSON.stringify(item));
  }
  loadObject(key) {
    const item = this.getItem(key);
    return item ? JSON.parse(item) : void 0;
  }
  setItem(key, value2) {
    localStorage.setItem(this.scopedKey(key), value2);
  }
  getItem(key) {
    return localStorage.getItem(this.scopedKey(key));
  }
  removeItem(key) {
    localStorage.removeItem(this.scopedKey(key));
  }
  clear() {
    const prefix = this.scopedKey("");
    const keysToRemove = [];
    for (let i9 = 0; i9 < localStorage.length; i9++) {
      const key = localStorage.key(i9);
      if (typeof key === "string" && key.startsWith(prefix)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => localStorage.removeItem(key));
  }
  scopedKey(key) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${key}`;
  }
  static clearAll() {
    new _ScopedLocalStorage("CBWSDK").clear();
    new _ScopedLocalStorage("walletlink").clear();
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/constants.js
var standardErrorCodes2 = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
};
var errorValues2 = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  "4902": {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/utils.js
var FALLBACK_MESSAGE2 = "Unspecified error message.";
var JSON_RPC_SERVER_ERROR_MESSAGE2 = "Unspecified server error.";
function getMessageFromCode2(code, fallbackMessage = FALLBACK_MESSAGE2) {
  if (code && Number.isInteger(code)) {
    const codeString = code.toString();
    if (hasKey2(errorValues2, codeString)) {
      return errorValues2[codeString].message;
    }
    if (isJsonRpcServerError2(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE2;
    }
  }
  return fallbackMessage;
}
function isValidCode2(code) {
  if (!Number.isInteger(code)) {
    return false;
  }
  const codeString = code.toString();
  if (errorValues2[codeString]) {
    return true;
  }
  if (isJsonRpcServerError2(code)) {
    return true;
  }
  return false;
}
function serialize8(error, { shouldIncludeStack = false } = {}) {
  const serialized = {};
  if (error && typeof error === "object" && !Array.isArray(error) && hasKey2(error, "code") && isValidCode2(error.code)) {
    const _error = error;
    serialized.code = _error.code;
    if (_error.message && typeof _error.message === "string") {
      serialized.message = _error.message;
      if (hasKey2(_error, "data")) {
        serialized.data = _error.data;
      }
    } else {
      serialized.message = getMessageFromCode2(serialized.code);
      serialized.data = { originalError: assignOriginalError2(error) };
    }
  } else {
    serialized.code = standardErrorCodes2.rpc.internal;
    serialized.message = hasStringProperty2(error, "message") ? error.message : FALLBACK_MESSAGE2;
    serialized.data = { originalError: assignOriginalError2(error) };
  }
  if (shouldIncludeStack) {
    serialized.stack = hasStringProperty2(error, "stack") ? error.stack : void 0;
  }
  return serialized;
}
function isJsonRpcServerError2(code) {
  return code >= -32099 && code <= -32e3;
}
function assignOriginalError2(error) {
  if (error && typeof error === "object" && !Array.isArray(error)) {
    return Object.assign({}, error);
  }
  return error;
}
function hasKey2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function hasStringProperty2(obj, prop) {
  return typeof obj === "object" && obj !== null && prop in obj && typeof obj[prop] === "string";
}

// node_modules/@coinbase/wallet-sdk/dist/core/error/errors.js
var standardErrors2 = {
  rpc: {
    parse: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.parse, arg),
    invalidRequest: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.invalidRequest, arg),
    invalidParams: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.invalidParams, arg),
    methodNotFound: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.methodNotFound, arg),
    internal: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.internal, arg),
    server: (opts2) => {
      if (!opts2 || typeof opts2 !== "object" || Array.isArray(opts2)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code } = opts2;
      if (!Number.isInteger(code) || code > -32005 || code < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError2(code, opts2);
    },
    invalidInput: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.invalidInput, arg),
    resourceNotFound: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.resourceNotFound, arg),
    resourceUnavailable: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.resourceUnavailable, arg),
    transactionRejected: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.transactionRejected, arg),
    methodNotSupported: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.methodNotSupported, arg),
    limitExceeded: (arg) => getEthJsonRpcError2(standardErrorCodes2.rpc.limitExceeded, arg)
  },
  provider: {
    userRejectedRequest: (arg) => {
      return getEthProviderError2(standardErrorCodes2.provider.userRejectedRequest, arg);
    },
    unauthorized: (arg) => {
      return getEthProviderError2(standardErrorCodes2.provider.unauthorized, arg);
    },
    unsupportedMethod: (arg) => {
      return getEthProviderError2(standardErrorCodes2.provider.unsupportedMethod, arg);
    },
    disconnected: (arg) => {
      return getEthProviderError2(standardErrorCodes2.provider.disconnected, arg);
    },
    chainDisconnected: (arg) => {
      return getEthProviderError2(standardErrorCodes2.provider.chainDisconnected, arg);
    },
    unsupportedChain: (arg) => {
      return getEthProviderError2(standardErrorCodes2.provider.unsupportedChain, arg);
    },
    custom: (opts2) => {
      if (!opts2 || typeof opts2 !== "object" || Array.isArray(opts2)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code, message, data } = opts2;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new EthereumProviderError2(code, message, data);
    }
  }
};
function getEthJsonRpcError2(code, arg) {
  const [message, data] = parseOpts2(arg);
  return new EthereumRpcError2(code, message || getMessageFromCode2(code), data);
}
function getEthProviderError2(code, arg) {
  const [message, data] = parseOpts2(arg);
  return new EthereumProviderError2(code, message || getMessageFromCode2(code), data);
}
function parseOpts2(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
var EthereumRpcError2 = class extends Error {
  constructor(code, message, data) {
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code;
    if (data !== void 0) {
      this.data = data;
    }
  }
};
var EthereumProviderError2 = class extends EthereumRpcError2 {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(code, message, data) {
    if (!isValidEthProviderCode2(code)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code, message, data);
  }
};
function isValidEthProviderCode2(code) {
  return Number.isInteger(code) && code >= 1e3 && code <= 4999;
}

// node_modules/@coinbase/wallet-sdk/dist/core/type/index.js
function OpaqueType2() {
  return (value2) => value2;
}
var HexString2 = OpaqueType2();
var AddressString = OpaqueType2();
var BigIntString2 = OpaqueType2();
function IntNumber2(num3) {
  return Math.floor(num3);
}
var RegExpString2 = OpaqueType2();

// node_modules/@coinbase/wallet-sdk/dist/core/type/util.js
var INT_STRING_REGEX2 = /^[0-9]*$/;
var HEXADECIMAL_STRING_REGEX2 = /^[a-f0-9]*$/;
function randomBytesHex(length) {
  return uint8ArrayToHex2(crypto.getRandomValues(new Uint8Array(length)));
}
function uint8ArrayToHex2(value2) {
  return [...value2].map((b6) => b6.toString(16).padStart(2, "0")).join("");
}
function hexStringToUint8Array2(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => Number.parseInt(byte, 16)));
}
function hexStringFromBuffer(buf, includePrefix = false) {
  const hex2 = buf.toString("hex");
  return HexString2(includePrefix ? `0x${hex2}` : hex2);
}
function encodeToHexString(str) {
  return hexStringFromBuffer(ensureBuffer(str), true);
}
function bigIntStringFromBigInt(bi4) {
  return BigIntString2(bi4.toString(10));
}
function hexStringFromNumber2(num3) {
  return HexString2(`0x${BigInt(num3).toString(16)}`);
}
function has0xPrefix2(str) {
  return str.startsWith("0x") || str.startsWith("0X");
}
function strip0x2(hex2) {
  if (has0xPrefix2(hex2)) {
    return hex2.slice(2);
  }
  return hex2;
}
function prepend0x(hex2) {
  if (has0xPrefix2(hex2)) {
    return `0x${hex2.slice(2)}`;
  }
  return `0x${hex2}`;
}
function isHexString2(hex2) {
  if (typeof hex2 !== "string") {
    return false;
  }
  const s5 = strip0x2(hex2).toLowerCase();
  return HEXADECIMAL_STRING_REGEX2.test(s5);
}
function ensureHexString2(hex2, includePrefix = false) {
  if (typeof hex2 === "string") {
    const s5 = strip0x2(hex2).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX2.test(s5)) {
      return HexString2(includePrefix ? `0x${s5}` : s5);
    }
  }
  throw standardErrors2.rpc.invalidParams(`"${String(hex2)}" is not a hexadecimal string`);
}
function ensureEvenLengthHexString2(hex2, includePrefix = false) {
  let h9 = ensureHexString2(hex2, false);
  if (h9.length % 2 === 1) {
    h9 = HexString2(`0${h9}`);
  }
  return includePrefix ? HexString2(`0x${h9}`) : h9;
}
function ensureAddressString(str) {
  if (typeof str === "string") {
    const s5 = strip0x2(str).toLowerCase();
    if (isHexString2(s5) && s5.length === 40) {
      return AddressString(prepend0x(s5));
    }
  }
  throw standardErrors2.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
}
function ensureBuffer(str) {
  if (Buffer.isBuffer(str)) {
    return str;
  }
  if (typeof str === "string") {
    if (isHexString2(str)) {
      const s5 = ensureEvenLengthHexString2(str, false);
      return Buffer.from(s5, "hex");
    }
    return Buffer.from(str, "utf8");
  }
  throw standardErrors2.rpc.invalidParams(`Not binary data: ${String(str)}`);
}
function ensureIntNumber2(num3) {
  if (typeof num3 === "number" && Number.isInteger(num3)) {
    return IntNumber2(num3);
  }
  if (typeof num3 === "string") {
    if (INT_STRING_REGEX2.test(num3)) {
      return IntNumber2(Number(num3));
    }
    if (isHexString2(num3)) {
      return IntNumber2(Number(BigInt(ensureEvenLengthHexString2(num3, true))));
    }
  }
  throw standardErrors2.rpc.invalidParams(`Not an integer: ${String(num3)}`);
}
function ensureBigInt(val) {
  if (val !== null && (typeof val === "bigint" || isBigNumber(val))) {
    return BigInt(val.toString(10));
  }
  if (typeof val === "number") {
    return BigInt(ensureIntNumber2(val));
  }
  if (typeof val === "string") {
    if (INT_STRING_REGEX2.test(val)) {
      return BigInt(val);
    }
    if (isHexString2(val)) {
      return BigInt(ensureEvenLengthHexString2(val, true));
    }
  }
  throw standardErrors2.rpc.invalidParams(`Not an integer: ${String(val)}`);
}
function ensureParsedJSONObject(val) {
  if (typeof val === "string") {
    return JSON.parse(val);
  }
  if (typeof val === "object") {
    return val;
  }
  throw standardErrors2.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
}
function isBigNumber(val) {
  if (val == null || typeof val.constructor !== "function") {
    return false;
  }
  const { constructor } = val;
  return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
}
function getFavicon() {
  const el2 = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
  const { protocol: protocol4, host } = document.location;
  const href = el2 ? el2.getAttribute("href") : null;
  if (!href || href.startsWith("javascript:") || href.startsWith("vbscript:")) {
    return `${protocol4}//${host}/favicon.ico`;
  }
  if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
    return href;
  }
  if (href.startsWith("//")) {
    return protocol4 + href;
  }
  return `${protocol4}//${host}${href}`;
}

// node_modules/@coinbase/wallet-sdk/dist/util/cipher.js
async function generateKeyPair3() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, true, ["deriveKey"]);
}
async function deriveSharedSecret2(ownPrivateKey, peerPublicKey) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: peerPublicKey
  }, ownPrivateKey, {
    name: "AES-GCM",
    length: 256
  }, false, ["encrypt", "decrypt"]);
}
async function encrypt4(sharedSecret, plainText) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const cipherText = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, new TextEncoder().encode(plainText));
  return { iv, cipherText };
}
async function decrypt4(sharedSecret, { iv, cipherText }) {
  const plainText = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, sharedSecret, cipherText);
  return new TextDecoder().decode(plainText);
}
function getFormat2(keyType) {
  switch (keyType) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function exportKeyToHexString2(type7, key) {
  const format9 = getFormat2(type7);
  const exported = await crypto.subtle.exportKey(format9, key);
  return uint8ArrayToHex2(new Uint8Array(exported));
}
async function importKeyFromHexString2(type7, hexString) {
  const format9 = getFormat2(type7);
  const arrayBuffer = hexStringToUint8Array2(hexString).buffer;
  return await crypto.subtle.importKey(format9, new Uint8Array(arrayBuffer), {
    name: "ECDH",
    namedCurve: "P-256"
  }, true, type7 === "private" ? ["deriveKey"] : []);
}
async function encryptContent2(content, sharedSecret) {
  const serialized = JSON.stringify(content, (_6, value2) => {
    if (!(value2 instanceof Error))
      return value2;
    const error = value2;
    return Object.assign(Object.assign({}, error.code ? { code: error.code } : {}), { message: error.message });
  });
  return encrypt4(sharedSecret, serialized);
}
async function decryptContent2(encryptedData, sharedSecret) {
  return JSON.parse(await decrypt4(sharedSecret, encryptedData));
}

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWKeyManager.js
var OWN_PRIVATE_KEY2 = {
  storageKey: "ownPrivateKey",
  keyType: "private"
};
var OWN_PUBLIC_KEY2 = {
  storageKey: "ownPublicKey",
  keyType: "public"
};
var PEER_PUBLIC_KEY2 = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
var SCWKeyManager2 = class {
  constructor() {
    this.storage = new ScopedLocalStorage("CBWSDK", "SCWKeyManager");
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    await this.loadKeysIfNeeded();
    return this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    await this.loadKeysIfNeeded();
    return this.sharedSecret;
  }
  async setPeerPublicKey(key) {
    this.sharedSecret = null;
    this.peerPublicKey = key;
    await this.storeKey(PEER_PUBLIC_KEY2, key);
    await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null;
    this.ownPublicKey = null;
    this.peerPublicKey = null;
    this.sharedSecret = null;
    this.storage.removeItem(OWN_PUBLIC_KEY2.storageKey);
    this.storage.removeItem(OWN_PRIVATE_KEY2.storageKey);
    this.storage.removeItem(PEER_PUBLIC_KEY2.storageKey);
  }
  async generateKeyPair() {
    const newKeyPair = await generateKeyPair3();
    this.ownPrivateKey = newKeyPair.privateKey;
    this.ownPublicKey = newKeyPair.publicKey;
    await this.storeKey(OWN_PRIVATE_KEY2, newKeyPair.privateKey);
    await this.storeKey(OWN_PUBLIC_KEY2, newKeyPair.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null) {
      this.ownPrivateKey = await this.loadKey(OWN_PRIVATE_KEY2);
    }
    if (this.ownPublicKey === null) {
      this.ownPublicKey = await this.loadKey(OWN_PUBLIC_KEY2);
    }
    if (this.ownPrivateKey === null || this.ownPublicKey === null) {
      await this.generateKeyPair();
    }
    if (this.peerPublicKey === null) {
      this.peerPublicKey = await this.loadKey(PEER_PUBLIC_KEY2);
    }
    if (this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await deriveSharedSecret2(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(item) {
    const key = this.storage.getItem(item.storageKey);
    if (!key)
      return null;
    return importKeyFromHexString2(item.keyType, key);
  }
  async storeKey(item, key) {
    const hexString = await exportKeyToHexString2(item.keyType, key);
    this.storage.setItem(item.storageKey, hexString);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/utils.js
function assertGetCapabilitiesParams2(params) {
  if (!params || !Array.isArray(params) || params.length !== 1 && params.length !== 2) {
    throw standardErrors2.rpc.invalidParams();
  }
  if (typeof params[0] !== "string" || !isAddress(params[0])) {
    throw standardErrors2.rpc.invalidParams();
  }
  if (params.length === 2) {
    if (!Array.isArray(params[1])) {
      throw standardErrors2.rpc.invalidParams();
    }
    for (const param of params[1]) {
      if (typeof param !== "string" || !param.startsWith("0x")) {
        throw standardErrors2.rpc.invalidParams();
      }
    }
  }
}

// node_modules/@coinbase/wallet-sdk/dist/sdk-info.js
var VERSION6 = "4.3.7";
var NAME = "@coinbase/wallet-sdk";

// node_modules/@coinbase/wallet-sdk/dist/util/provider.js
async function fetchRPCRequest2(request2, rpcUrl) {
  const requestBody = Object.assign(Object.assign({}, request2), { jsonrpc: "2.0", id: crypto.randomUUID() });
  const res = await window.fetch(rpcUrl, {
    method: "POST",
    body: JSON.stringify(requestBody),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": VERSION6,
      "X-Cbw-Sdk-Platform": NAME
    }
  });
  const { result, error } = await res.json();
  if (error)
    throw error;
  return result;
}
function getCoinbaseInjectedLegacyProvider() {
  const window2 = globalThis;
  return window2.coinbaseWalletExtension;
}
function getInjectedEthereum() {
  var _a14, _b;
  try {
    const window2 = globalThis;
    return (_b = (_a14 = window2.top) === null || _a14 === void 0 ? void 0 : _a14.ethereum) !== null && _b !== void 0 ? _b : window2.ethereum;
  } catch (_c3) {
    return void 0;
  }
}
function getCoinbaseInjectedProvider({ metadata, preference }) {
  var _a14, _b;
  const { appName, appLogoUrl, appChainIds } = metadata;
  if (preference.options !== "smartWalletOnly") {
    const extension = getCoinbaseInjectedLegacyProvider();
    if (extension) {
      (_a14 = extension.setAppInfo) === null || _a14 === void 0 ? void 0 : _a14.call(extension, appName, appLogoUrl, appChainIds, preference);
      return extension;
    }
  }
  const ethereum = getInjectedEthereum();
  if (ethereum === null || ethereum === void 0 ? void 0 : ethereum.isCoinbaseBrowser) {
    (_b = ethereum.setAppInfo) === null || _b === void 0 ? void 0 : _b.call(ethereum, appName, appLogoUrl, appChainIds, preference);
    return ethereum;
  }
  return void 0;
}
function checkErrorForInvalidRequestArgs2(args) {
  if (!args || typeof args !== "object" || Array.isArray(args)) {
    throw standardErrors2.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: args
    });
  }
  const { method, params } = args;
  if (typeof method !== "string" || method.length === 0) {
    throw standardErrors2.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: args
    });
  }
  if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
    throw standardErrors2.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: args
    });
  }
  switch (method) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw standardErrors2.provider.unsupportedMethod();
  }
}

// node_modules/@coinbase/wallet-sdk/dist/sign/scw/SCWSigner.js
var ACCOUNTS_KEY = "accounts";
var ACTIVE_CHAIN_STORAGE_KEY = "activeChain";
var AVAILABLE_CHAINS_STORAGE_KEY = "availableChains";
var WALLET_CAPABILITIES_STORAGE_KEY = "walletCapabilities";
var SCWSigner = class {
  constructor(params) {
    var _a14, _b, _c3;
    this.metadata = params.metadata;
    this.communicator = params.communicator;
    this.callback = params.callback;
    this.keyManager = new SCWKeyManager2();
    this.storage = new ScopedLocalStorage("CBWSDK", "SCWStateManager");
    this.accounts = (_a14 = this.storage.loadObject(ACCOUNTS_KEY)) !== null && _a14 !== void 0 ? _a14 : [];
    this.chain = this.storage.loadObject(ACTIVE_CHAIN_STORAGE_KEY) || {
      id: (_c3 = (_b = params.metadata.appChainIds) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c3 !== void 0 ? _c3 : 1
    };
    this.handshake = this.handshake.bind(this);
    this.request = this.request.bind(this);
    this.createRequestMessage = this.createRequestMessage.bind(this);
    this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(args) {
    var _a14, _b, _c3, _d2;
    await ((_b = (_a14 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a14));
    const handshakeMessage = await this.createRequestMessage({
      handshake: {
        method: args.method,
        params: Object.assign({}, this.metadata, (_c3 = args.params) !== null && _c3 !== void 0 ? _c3 : {})
      }
    });
    const response = await this.communicator.postRequestAndWaitForResponse(handshakeMessage);
    if ("failure" in response.content)
      throw response.content.failure;
    const peerPublicKey = await importKeyFromHexString2("public", response.sender);
    await this.keyManager.setPeerPublicKey(peerPublicKey);
    const decrypted = await this.decryptResponseMessage(response);
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    switch (args.method) {
      case "eth_requestAccounts": {
        const accounts = result.value;
        this.accounts = accounts;
        this.storage.storeObject(ACCOUNTS_KEY, accounts);
        (_d2 = this.callback) === null || _d2 === void 0 ? void 0 : _d2.call(this, "accountsChanged", accounts);
        break;
      }
    }
  }
  async request(request2) {
    var _a14;
    if (this.accounts.length === 0) {
      switch (request2.method) {
        case "wallet_sendCalls":
          return this.sendRequestToPopup(request2);
        default:
          throw standardErrors2.provider.unauthorized();
      }
    }
    switch (request2.method) {
      case "eth_requestAccounts":
        (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "connect", { chainId: hexStringFromNumber2(this.chain.id) });
        return this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return hexStringFromNumber2(this.chain.id);
      case "wallet_getCapabilities":
        return this.handleGetCapabilitiesRequest(request2);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(request2);
      case "eth_ecRecover":
      case "personal_sign":
      case "wallet_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(request2);
      default:
        if (!this.chain.rpcUrl)
          throw standardErrors2.rpc.internal("No RPC URL set for chain");
        return fetchRPCRequest2(request2, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(request2) {
    var _a14, _b;
    await ((_b = (_a14 = this.communicator).waitForPopupLoaded) === null || _b === void 0 ? void 0 : _b.call(_a14));
    const response = await this.sendEncryptedRequest(request2);
    const decrypted = await this.decryptResponseMessage(response);
    const result = decrypted.result;
    if ("error" in result)
      throw result.error;
    return result.value;
  }
  async cleanup() {
    var _a14, _b;
    this.storage.clear();
    await this.keyManager.clear();
    this.accounts = [];
    this.chain = {
      id: (_b = (_a14 = this.metadata.appChainIds) === null || _a14 === void 0 ? void 0 : _a14[0]) !== null && _b !== void 0 ? _b : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(request2) {
    var _a14;
    const params = request2.params;
    if (!params || !((_a14 = params[0]) === null || _a14 === void 0 ? void 0 : _a14.chainId)) {
      throw standardErrors2.rpc.invalidParams();
    }
    const chainId = ensureIntNumber2(params[0].chainId);
    const localResult = this.updateChain(chainId);
    if (localResult)
      return null;
    const popupResult = await this.sendRequestToPopup(request2);
    if (popupResult === null) {
      this.updateChain(chainId);
    }
    return popupResult;
  }
  async handleGetCapabilitiesRequest(request2) {
    assertGetCapabilitiesParams2(request2.params);
    const requestedAccount = request2.params[0];
    const filterChainIds = request2.params[1];
    if (!this.accounts.some((account2) => isAddressEqual(account2, requestedAccount))) {
      throw standardErrors2.provider.unauthorized("no active account found");
    }
    const capabilities = this.storage.loadObject(WALLET_CAPABILITIES_STORAGE_KEY);
    if (!capabilities) {
      return {};
    }
    if (!filterChainIds || filterChainIds.length === 0) {
      return capabilities;
    }
    const filterChainNumbers = new Set(filterChainIds.map((chainId) => hexToNumber(chainId)));
    const filteredCapabilities = Object.fromEntries(Object.entries(capabilities).filter(([capabilityKey]) => {
      try {
        const capabilityChainNumber = hexToNumber(capabilityKey);
        return filterChainNumbers.has(capabilityChainNumber);
      } catch (_a14) {
        return false;
      }
    }));
    return filteredCapabilities;
  }
  async sendEncryptedRequest(request2) {
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors2.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    }
    const encrypted = await encryptContent2({
      action: request2,
      chainId: this.chain.id
    }, sharedSecret);
    const message = await this.createRequestMessage({ encrypted });
    return this.communicator.postRequestAndWaitForResponse(message);
  }
  async createRequestMessage(content) {
    const publicKey = await exportKeyToHexString2("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: publicKey,
      content,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(message) {
    var _a14, _b;
    const content = message.content;
    if ("failure" in content) {
      throw content.failure;
    }
    const sharedSecret = await this.keyManager.getSharedSecret();
    if (!sharedSecret) {
      throw standardErrors2.provider.unauthorized("Invalid session");
    }
    const response = await decryptContent2(content.encrypted, sharedSecret);
    const availableChains = (_a14 = response.data) === null || _a14 === void 0 ? void 0 : _a14.chains;
    if (availableChains) {
      const chains2 = Object.entries(availableChains).map(([id2, rpcUrl]) => ({
        id: Number(id2),
        rpcUrl
      }));
      this.storage.storeObject(AVAILABLE_CHAINS_STORAGE_KEY, chains2);
      this.updateChain(this.chain.id, chains2);
    }
    const walletCapabilities = (_b = response.data) === null || _b === void 0 ? void 0 : _b.capabilities;
    if (walletCapabilities) {
      this.storage.storeObject(WALLET_CAPABILITIES_STORAGE_KEY, walletCapabilities);
    }
    return response;
  }
  updateChain(chainId, newAvailableChains) {
    var _a14;
    const chains2 = newAvailableChains !== null && newAvailableChains !== void 0 ? newAvailableChains : this.storage.loadObject(AVAILABLE_CHAINS_STORAGE_KEY);
    const chain6 = chains2 === null || chains2 === void 0 ? void 0 : chains2.find((chain7) => chain7.id === chainId);
    if (!chain6)
      return false;
    if (chain6 !== this.chain) {
      this.chain = chain6;
      this.storage.storeObject(ACTIVE_CHAIN_STORAGE_KEY, chain6);
      (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "chainChanged", hexStringFromNumber2(chain6.id));
    }
    return true;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js
var import_eth_eip712_util = __toESM(require_eth_eip712_util(), 1);

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/constants.js
var WALLET_USER_NAME_KEY = "walletUsername";
var LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
var APP_VERSION_KEY = "AppVersion";

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/Web3Response.js
function isErrorResponse2(response) {
  return response.errorMessage !== void 0;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkCipher.js
var WalletLinkCipher = class {
  // @param secret hex representation of 32-byte secret
  constructor(secret) {
    this.secret = secret;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(plainText) {
    const secret = this.secret;
    if (secret.length !== 64)
      throw Error(`secret must be 256 bits`);
    const ivBytes = crypto.getRandomValues(new Uint8Array(12));
    const secretKey = await crypto.subtle.importKey("raw", hexStringToUint8Array2(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
    const enc = new TextEncoder();
    const encryptedResult = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: ivBytes
    }, secretKey, enc.encode(plainText));
    const tagLength = 16;
    const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
    const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
    const authTagBytes = new Uint8Array(authTag);
    const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
    const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
    return uint8ArrayToHex2(concatted);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(cipherText) {
    const secret = this.secret;
    if (secret.length !== 64)
      throw Error(`secret must be 256 bits`);
    return new Promise((resolve, reject) => {
      void async function() {
        const secretKey = await crypto.subtle.importKey("raw", hexStringToUint8Array2(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
        const encrypted = hexStringToUint8Array2(cipherText);
        const ivBytes = encrypted.slice(0, 12);
        const authTagBytes = encrypted.slice(12, 28);
        const encryptedPlaintextBytes = encrypted.slice(28);
        const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
        const algo = {
          name: "AES-GCM",
          iv: new Uint8Array(ivBytes)
        };
        try {
          const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
          const decoder4 = new TextDecoder();
          resolve(decoder4.decode(decrypted));
        } catch (err) {
          reject(err);
        }
      }();
    });
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkHTTP.js
var WalletLinkHTTP = class {
  constructor(linkAPIUrl, sessionId, sessionKey) {
    this.linkAPIUrl = linkAPIUrl;
    this.sessionId = sessionId;
    const credentials = `${sessionId}:${sessionKey}`;
    this.auth = `Basic ${btoa(credentials)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(events) {
    return Promise.all(events.map((e11) => fetch(`${this.linkAPIUrl}/events/${e11.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((error) => console.error("Unabled to mark event as failed:", error));
  }
  async fetchUnseenEvents() {
    var _a14;
    const response = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (response.ok) {
      const { events, error } = await response.json();
      if (error) {
        throw new Error(`Check unseen events failed: ${error}`);
      }
      const responseEvents = (_a14 = events === null || events === void 0 ? void 0 : events.filter((e11) => e11.event === "Web3Response").map((e11) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: e11.id,
        event: e11.event,
        data: e11.data
      }))) !== null && _a14 !== void 0 ? _a14 : [];
      this.markUnseenEventsAsSeen(responseEvents);
      return responseEvents;
    }
    throw new Error(`Check unseen events failed: ${response.status}`);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkWebSocket.js
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
  ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
  ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
})(ConnectionState || (ConnectionState = {}));
var WalletLinkWebSocket = class _WalletLinkWebSocket {
  setConnectionStateListener(listener) {
    this.connectionStateListener = listener;
  }
  setIncomingDataListener(listener) {
    this.incomingDataListener = listener;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(url2, WebSocketClass = WebSocket) {
    this.WebSocketClass = WebSocketClass;
    this.webSocket = null;
    this.isDisconnecting = false;
    this.url = url2.replace(/^http/, "ws");
    this.instanceId = _WalletLinkWebSocket.instanceCounter++;
    _WalletLinkWebSocket.activeInstances.add(this.instanceId);
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket) {
      throw new Error("webSocket object is not null");
    }
    if (this.isDisconnecting) {
      throw new Error("WebSocket is disconnecting, cannot reconnect on same instance");
    }
    return new Promise((resolve, reject) => {
      var _a14;
      let webSocket2;
      try {
        this.webSocket = webSocket2 = new this.WebSocketClass(this.url);
      } catch (err) {
        reject(err);
        return;
      }
      (_a14 = this.connectionStateListener) === null || _a14 === void 0 ? void 0 : _a14.call(this, ConnectionState.CONNECTING);
      webSocket2.onclose = (evt) => {
        var _a15;
        this.clearWebSocket();
        if (webSocket2.readyState !== WebSocket.OPEN) {
          reject(new Error(`websocket error ${evt.code}: ${evt.reason}`));
        }
        (_a15 = this.connectionStateListener) === null || _a15 === void 0 ? void 0 : _a15.call(this, ConnectionState.DISCONNECTED);
      };
      webSocket2.onopen = (_6) => {
        var _a15;
        resolve();
        (_a15 = this.connectionStateListener) === null || _a15 === void 0 ? void 0 : _a15.call(this, ConnectionState.CONNECTED);
        if (_WalletLinkWebSocket.pendingData.length > 0) {
          const pending = [..._WalletLinkWebSocket.pendingData];
          pending.forEach((data) => this.sendData(data));
          _WalletLinkWebSocket.pendingData = [];
        }
      };
      webSocket2.onmessage = (evt) => {
        var _a15, _b;
        if (evt.data === "h") {
          (_a15 = this.incomingDataListener) === null || _a15 === void 0 ? void 0 : _a15.call(this, {
            type: "Heartbeat"
          });
        } else {
          try {
            const message = JSON.parse(evt.data);
            (_b = this.incomingDataListener) === null || _b === void 0 ? void 0 : _b.call(this, message);
          } catch (_c3) {
          }
        }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var _a14;
    const { webSocket: webSocket2 } = this;
    if (!webSocket2) {
      return;
    }
    this.isDisconnecting = true;
    this.clearWebSocket();
    (_a14 = this.connectionStateListener) === null || _a14 === void 0 ? void 0 : _a14.call(this, ConnectionState.DISCONNECTED);
    this.connectionStateListener = void 0;
    this.incomingDataListener = void 0;
    try {
      webSocket2.close();
    } catch (_b) {
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(data) {
    const { webSocket: webSocket2 } = this;
    if (!webSocket2) {
      _WalletLinkWebSocket.pendingData.push(data);
      if (!this.isDisconnecting) {
        this.connect();
      }
      return;
    }
    if (webSocket2.readyState !== WebSocket.OPEN) {
      _WalletLinkWebSocket.pendingData.push(data);
      return;
    }
    webSocket2.send(data);
  }
  clearWebSocket() {
    const { webSocket: webSocket2 } = this;
    if (!webSocket2) {
      return;
    }
    this.webSocket = null;
    webSocket2.onclose = null;
    webSocket2.onerror = null;
    webSocket2.onmessage = null;
    webSocket2.onopen = null;
  }
  /**
   * remove ws from active instances
   */
  cleanup() {
    _WalletLinkWebSocket.activeInstances.delete(this.instanceId);
  }
};
WalletLinkWebSocket.instanceCounter = 0;
WalletLinkWebSocket.activeInstances = /* @__PURE__ */ new Set();
WalletLinkWebSocket.pendingData = [];

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/connection/WalletLinkConnection.js
var HEARTBEAT_INTERVAL = 1e4;
var REQUEST_TIMEOUT = 6e4;
var WalletLinkConnection = class {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session, linkAPIUrl, listener }) {
    this.destroyed = false;
    this.lastHeartbeatResponse = 0;
    this.nextReqId = IntNumber2(1);
    this.reconnectAttempts = 0;
    this.isReconnecting = false;
    this._connected = false;
    this._linked = false;
    this.requestResolutions = /* @__PURE__ */ new Map();
    this.handleSessionMetadataUpdated = (metadata) => {
      if (!metadata)
        return;
      const handlers = /* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (v9) => metadata.JsonRpcUrl && this.handleChainUpdated(v9, metadata.JsonRpcUrl)
        ]
      ]);
      handlers.forEach((handler, key) => {
        const value2 = metadata[key];
        if (value2 === void 0)
          return;
        handler(value2);
      });
    };
    this.handleDestroyed = (__destroyed) => {
      var _a14;
      if (__destroyed !== "1")
        return;
      (_a14 = this.listener) === null || _a14 === void 0 ? void 0 : _a14.resetAndReload();
    };
    this.handleAccountUpdated = async (encryptedEthereumAddress) => {
      var _a14;
      try {
        const address = await this.cipher.decrypt(encryptedEthereumAddress);
        (_a14 = this.listener) === null || _a14 === void 0 ? void 0 : _a14.accountUpdated(address);
      } catch (_b) {
      }
    };
    this.handleMetadataUpdated = async (key, encryptedMetadataValue) => {
      var _a14;
      try {
        const decryptedValue = await this.cipher.decrypt(encryptedMetadataValue);
        (_a14 = this.listener) === null || _a14 === void 0 ? void 0 : _a14.metadataUpdated(key, decryptedValue);
      } catch (_b) {
      }
    };
    this.handleWalletUsernameUpdated = async (walletUsername) => {
      this.handleMetadataUpdated(WALLET_USER_NAME_KEY, walletUsername);
    };
    this.handleAppVersionUpdated = async (appVersion) => {
      this.handleMetadataUpdated(APP_VERSION_KEY, appVersion);
    };
    this.handleChainUpdated = async (encryptedChainId, encryptedJsonRpcUrl) => {
      var _a14;
      try {
        const chainId = await this.cipher.decrypt(encryptedChainId);
        const jsonRpcUrl = await this.cipher.decrypt(encryptedJsonRpcUrl);
        (_a14 = this.listener) === null || _a14 === void 0 ? void 0 : _a14.chainUpdated(chainId, jsonRpcUrl);
      } catch (_b) {
      }
    };
    this.session = session;
    this.cipher = new WalletLinkCipher(session.secret);
    this.listener = listener;
    this.linkAPIUrl = linkAPIUrl;
    this.WebSocketClass = WebSocket;
    const ws5 = this.createWebSocket();
    this.ws = ws5;
    this.http = new WalletLinkHTTP(linkAPIUrl, session.id, session.key);
    this.setupVisibilityChangeHandler();
  }
  createWebSocket() {
    const ws5 = new WalletLinkWebSocket(`${this.linkAPIUrl}/rpc`, this.WebSocketClass);
    this.activeWsInstance = ws5;
    ws5.setConnectionStateListener(async (state) => {
      if (ws5 !== this.activeWsInstance) {
        return;
      }
      let connected = false;
      switch (state) {
        case ConnectionState.DISCONNECTED:
          if (this.heartbeatIntervalId) {
            clearInterval(this.heartbeatIntervalId);
            this.heartbeatIntervalId = void 0;
          }
          this.lastHeartbeatResponse = 0;
          connected = false;
          if (!this.destroyed) {
            const reconnect = async () => {
              if (this.isReconnecting) {
                return;
              }
              this.isReconnecting = true;
              const delay = this.reconnectAttempts === 0 ? 0 : 3e3;
              await new Promise((resolve) => setTimeout(resolve, delay));
              if (!this.destroyed && ws5 === this.activeWsInstance) {
                this.reconnectAttempts++;
                if ("cleanup" in this.ws && typeof this.ws.cleanup === "function") {
                  this.ws.cleanup();
                }
                this.ws = this.createWebSocket();
                this.ws.connect().catch(() => {
                }).finally(() => {
                  this.isReconnecting = false;
                });
              } else {
                this.isReconnecting = false;
              }
            };
            reconnect();
          }
          break;
        case ConnectionState.CONNECTED:
          this.reconnectAttempts = 0;
          try {
            connected = await this.handleConnected();
            this.fetchUnseenEventsAPI().catch(() => {
            });
          } catch (_error) {
            break;
          }
          this.connected = connected;
          this.updateLastHeartbeat();
          if (this.heartbeatIntervalId) {
            clearInterval(this.heartbeatIntervalId);
          }
          this.heartbeatIntervalId = window.setInterval(() => {
            this.heartbeat();
          }, HEARTBEAT_INTERVAL);
          setTimeout(() => {
            this.heartbeat();
          }, 100);
          break;
        case ConnectionState.CONNECTING:
          break;
      }
      if (state !== ConnectionState.CONNECTED) {
        this.connected = connected;
      }
    });
    ws5.setIncomingDataListener((m6) => {
      var _a14;
      switch (m6.type) {
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        case "IsLinkedOK":
        case "Linked": {
          const linked = m6.type === "IsLinkedOK" ? m6.linked : void 0;
          this.linked = linked || m6.onlineGuests > 0;
          break;
        }
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(m6.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(m6);
          break;
        }
      }
      if (m6.id !== void 0) {
        (_a14 = this.requestResolutions.get(m6.id)) === null || _a14 === void 0 ? void 0 : _a14(m6);
      }
    });
    return ws5;
  }
  setupVisibilityChangeHandler() {
    this.visibilityChangeHandler = () => {
      if (!document.hidden && !this.destroyed) {
        if (!this.connected) {
          this.reconnectWithFreshWebSocket();
        } else {
          this.heartbeat();
        }
      }
    };
    this.focusHandler = () => {
      if (!this.destroyed && !this.connected) {
        this.reconnectWithFreshWebSocket();
      }
    };
    document.addEventListener("visibilitychange", this.visibilityChangeHandler);
    window.addEventListener("focus", this.focusHandler);
    window.addEventListener("pageshow", (event) => {
      if (event.persisted) {
        if (this.focusHandler) {
          this.focusHandler();
        }
      }
    });
  }
  reconnectWithFreshWebSocket() {
    if (this.destroyed)
      return;
    const oldWs = this.ws;
    this.activeWsInstance = void 0;
    oldWs.disconnect();
    if ("cleanup" in oldWs && typeof oldWs.cleanup === "function") {
      oldWs.cleanup();
    }
    this.ws = this.createWebSocket();
    this.ws.connect().catch(() => {
    });
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed) {
      throw new Error("instance is destroyed");
    }
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    if (this.destroyed)
      return;
    await this.makeRequest({
      type: "SetSessionConfig",
      id: IntNumber2(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 });
    this.destroyed = true;
    this.activeWsInstance = void 0;
    if (this.heartbeatIntervalId) {
      clearInterval(this.heartbeatIntervalId);
      this.heartbeatIntervalId = void 0;
    }
    if (this.visibilityChangeHandler) {
      document.removeEventListener("visibilitychange", this.visibilityChangeHandler);
    }
    if (this.focusHandler) {
      window.removeEventListener("focus", this.focusHandler);
    }
    this.ws.disconnect();
    if ("cleanup" in this.ws && typeof this.ws.cleanup === "function") {
      this.ws.cleanup();
    }
    this.listener = void 0;
  }
  get connected() {
    return this._connected;
  }
  set connected(connected) {
    this._connected = connected;
  }
  get linked() {
    return this._linked;
  }
  set linked(linked) {
    var _a14, _b;
    this._linked = linked;
    if (linked)
      (_a14 = this.onceLinked) === null || _a14 === void 0 ? void 0 : _a14.call(this);
    (_b = this.listener) === null || _b === void 0 ? void 0 : _b.linkedUpdated(linked);
  }
  setOnceLinked(callback) {
    return new Promise((resolve) => {
      if (this.linked) {
        callback().then(resolve);
      } else {
        this.onceLinked = () => {
          callback().then(resolve);
          this.onceLinked = void 0;
        };
      }
    });
  }
  async handleIncomingEvent(m6) {
    var _a14;
    if (m6.type !== "Event" || m6.event !== "Web3Response") {
      return;
    }
    try {
      const decryptedData = await this.cipher.decrypt(m6.data);
      const message = JSON.parse(decryptedData);
      if (message.type !== "WEB3_RESPONSE")
        return;
      (_a14 = this.listener) === null || _a14 === void 0 ? void 0 : _a14.handleWeb3ResponseMessage(message.id, message.response);
    } catch (_error) {
    }
  }
  async checkUnseenEvents() {
    await new Promise((resolve) => setTimeout(resolve, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e11) {
      console.error("Unable to check for unseen events", e11);
    }
  }
  async fetchUnseenEventsAPI() {
    try {
      const responseEvents = await this.http.fetchUnseenEvents();
      responseEvents.forEach((e11) => {
        this.handleIncomingEvent(e11);
      });
    } catch (_error) {
    }
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(event, unencryptedData, callWebhook = false) {
    const data = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, unencryptedData), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" })));
    const message = {
      type: "PublishEvent",
      id: IntNumber2(this.nextReqId++),
      sessionId: this.session.id,
      event,
      data,
      callWebhook
    };
    return this.setOnceLinked(async () => {
      const res = await this.makeRequest(message);
      if (res.type === "Fail") {
        throw new Error(res.error || "failed to publish event");
      }
      return res.eventId;
    });
  }
  sendData(message) {
    this.ws.sendData(JSON.stringify(message));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
      this.ws.disconnect();
      return;
    }
    if (!this.connected) {
      return;
    }
    try {
      this.ws.sendData("h");
    } catch (_error) {
    }
  }
  async makeRequest(message, options = { timeout: REQUEST_TIMEOUT }) {
    const reqId = message.id;
    this.sendData(message);
    let timeoutId;
    return Promise.race([
      new Promise((_6, reject) => {
        timeoutId = window.setTimeout(() => {
          reject(new Error(`request ${reqId} timed out`));
        }, options.timeout);
      }),
      new Promise((resolve) => {
        this.requestResolutions.set(reqId, (m6) => {
          clearTimeout(timeoutId);
          resolve(m6);
          this.requestResolutions.delete(reqId);
        });
      })
    ]);
  }
  async handleConnected() {
    const res = await this.makeRequest({
      type: "HostSession",
      id: IntNumber2(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    });
    if (res.type === "Fail") {
      return false;
    }
    this.sendData({
      type: "IsLinked",
      id: IntNumber2(this.nextReqId++),
      sessionId: this.session.id
    });
    this.sendData({
      type: "GetSessionConfig",
      id: IntNumber2(this.nextReqId++),
      sessionId: this.session.id
    });
    return true;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/RelayEventManager.js
var RelayEventManager = class {
  constructor() {
    this._nextRequestId = 0;
    this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const id2 = this._nextRequestId;
    const idStr = prepend0x(id2.toString(16));
    const callback = this.callbacks.get(idStr);
    if (callback) {
      this.callbacks.delete(idStr);
    }
    return id2;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/type/WalletLinkSession.js
var STORAGE_KEY_SESSION_ID = "session:id";
var STORAGE_KEY_SESSION_SECRET = "session:secret";
var STORAGE_KEY_SESSION_LINKED = "session:linked";
var WalletLinkSession = class _WalletLinkSession {
  constructor(storage3, id2, secret, linked = false) {
    this.storage = storage3;
    this.id = id2;
    this.secret = secret;
    this.key = bytesToHex(sha2562(`${id2}, ${secret} WalletLink`));
    this._linked = !!linked;
  }
  static create(storage3) {
    const id2 = randomBytesHex(16);
    const secret = randomBytesHex(32);
    return new _WalletLinkSession(storage3, id2, secret).save();
  }
  static load(storage3) {
    const id2 = storage3.getItem(STORAGE_KEY_SESSION_ID);
    const linked = storage3.getItem(STORAGE_KEY_SESSION_LINKED);
    const secret = storage3.getItem(STORAGE_KEY_SESSION_SECRET);
    if (id2 && secret) {
      return new _WalletLinkSession(storage3, id2, secret, linked === "1");
    }
    return null;
  }
  get linked() {
    return this._linked;
  }
  set linked(val) {
    this._linked = val;
    this.persistLinked();
  }
  save() {
    this.storage.setItem(STORAGE_KEY_SESSION_ID, this.id);
    this.storage.setItem(STORAGE_KEY_SESSION_SECRET, this.secret);
    this.persistLinked();
    return this;
  }
  persistLinked() {
    this.storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/util.js
function isInIFrame() {
  try {
    return window.frameElement !== null;
  } catch (e11) {
    return false;
  }
}
function getLocation() {
  try {
    if (isInIFrame() && window.top) {
      return window.top.location;
    }
    return window.location;
  } catch (e11) {
    return window.location;
  }
}
function isMobileWeb() {
  var _a14;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((_a14 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a14 === void 0 ? void 0 : _a14.userAgent);
}
function isDarkMode() {
  var _a14, _b;
  return (_b = (_a14 = window === null || window === void 0 ? void 0 : window.matchMedia) === null || _a14 === void 0 ? void 0 : _a14.call(window, "(prefers-color-scheme: dark)").matches) !== null && _b !== void 0 ? _b : false;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset-css.js
var cssReset_css_default = /* @__PURE__ */ (() => `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/cssReset/cssReset.js
function injectCssReset() {
  const styleEl = document.createElement("style");
  styleEl.type = "text/css";
  styleEl.appendChild(document.createTextNode(cssReset_css_default));
  document.documentElement.appendChild(styleEl);
}

// node_modules/preact/dist/preact.module.js
var n3;
var l6;
var u6;
var t3;
var i6;
var r5;
var o4;
var e3;
var f12;
var c6;
var s3;
var a4;
var h6;
var p6 = {};
var v6 = [];
var y8 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var w5 = Array.isArray;
function d4(n5, l9) {
  for (var u10 in l9) n5[u10] = l9[u10];
  return n5;
}
function g2(n5) {
  n5 && n5.parentNode && n5.parentNode.removeChild(n5);
}
function _4(l9, u10, t6) {
  var i9, r8, o6, e11 = {};
  for (o6 in u10) "key" == o6 ? i9 = u10[o6] : "ref" == o6 ? r8 = u10[o6] : e11[o6] = u10[o6];
  if (arguments.length > 2 && (e11.children = arguments.length > 3 ? n3.call(arguments, 2) : t6), "function" == typeof l9 && null != l9.defaultProps) for (o6 in l9.defaultProps) void 0 === e11[o6] && (e11[o6] = l9.defaultProps[o6]);
  return m3(l9, e11, i9, r8, null);
}
function m3(n5, t6, i9, r8, o6) {
  var e11 = { type: n5, props: t6, key: i9, ref: r8, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o6 ? ++u6 : o6, __i: -1, __u: 0 };
  return null == o6 && null != l6.vnode && l6.vnode(e11), e11;
}
function k8(n5) {
  return n5.children;
}
function x5(n5, l9) {
  this.props = n5, this.context = l9;
}
function S6(n5, l9) {
  if (null == l9) return n5.__ ? S6(n5.__, n5.__i + 1) : null;
  for (var u10; l9 < n5.__k.length; l9++) if (null != (u10 = n5.__k[l9]) && null != u10.__e) return u10.__e;
  return "function" == typeof n5.type ? S6(n5) : null;
}
function C7(n5) {
  var l9, u10;
  if (null != (n5 = n5.__) && null != n5.__c) {
    for (n5.__e = n5.__c.base = null, l9 = 0; l9 < n5.__k.length; l9++) if (null != (u10 = n5.__k[l9]) && null != u10.__e) {
      n5.__e = n5.__c.base = u10.__e;
      break;
    }
    return C7(n5);
  }
}
function M6(n5) {
  (!n5.__d && (n5.__d = true) && i6.push(n5) && !$6.__r++ || r5 != l6.debounceRendering) && ((r5 = l6.debounceRendering) || o4)($6);
}
function $6() {
  for (var n5, u10, t6, r8, o6, f16, c9, s5 = 1; i6.length; ) i6.length > s5 && i6.sort(e3), n5 = i6.shift(), s5 = i6.length, n5.__d && (t6 = void 0, r8 = void 0, o6 = (r8 = (u10 = n5).__v).__e, f16 = [], c9 = [], u10.__P && ((t6 = d4({}, r8)).__v = r8.__v + 1, l6.vnode && l6.vnode(t6), O6(u10.__P, t6, r8, u10.__n, u10.__P.namespaceURI, 32 & r8.__u ? [o6] : null, f16, null == o6 ? S6(r8) : o6, !!(32 & r8.__u), c9), t6.__v = r8.__v, t6.__.__k[t6.__i] = t6, N7(f16, t6, c9), r8.__e = r8.__ = null, t6.__e != o6 && C7(t6)));
  $6.__r = 0;
}
function I6(n5, l9, u10, t6, i9, r8, o6, e11, f16, c9, s5) {
  var a6, h9, y11, w8, d7, g4, _6, m6 = t6 && t6.__k || v6, b6 = l9.length;
  for (f16 = P5(u10, l9, m6, f16, b6), a6 = 0; a6 < b6; a6++) null != (y11 = u10.__k[a6]) && (h9 = -1 == y11.__i ? p6 : m6[y11.__i] || p6, y11.__i = a6, g4 = O6(n5, y11, h9, i9, r8, o6, e11, f16, c9, s5), w8 = y11.__e, y11.ref && h9.ref != y11.ref && (h9.ref && B6(h9.ref, null, y11), s5.push(y11.ref, y11.__c || w8, y11)), null == d7 && null != w8 && (d7 = w8), (_6 = !!(4 & y11.__u)) || h9.__k === y11.__k ? f16 = A7(y11, f16, n5, _6) : "function" == typeof y11.type && void 0 !== g4 ? f16 = g4 : w8 && (f16 = w8.nextSibling), y11.__u &= -7);
  return u10.__e = d7, f16;
}
function P5(n5, l9, u10, t6, i9) {
  var r8, o6, e11, f16, c9, s5 = u10.length, a6 = s5, h9 = 0;
  for (n5.__k = new Array(i9), r8 = 0; r8 < i9; r8++) null != (o6 = l9[r8]) && "boolean" != typeof o6 && "function" != typeof o6 ? (f16 = r8 + h9, (o6 = n5.__k[r8] = "string" == typeof o6 || "number" == typeof o6 || "bigint" == typeof o6 || o6.constructor == String ? m3(null, o6, null, null, null) : w5(o6) ? m3(k8, { children: o6 }, null, null, null) : null == o6.constructor && o6.__b > 0 ? m3(o6.type, o6.props, o6.key, o6.ref ? o6.ref : null, o6.__v) : o6).__ = n5, o6.__b = n5.__b + 1, e11 = null, -1 != (c9 = o6.__i = L5(o6, u10, f16, a6)) && (a6--, (e11 = u10[c9]) && (e11.__u |= 2)), null == e11 || null == e11.__v ? (-1 == c9 && (i9 > s5 ? h9-- : i9 < s5 && h9++), "function" != typeof o6.type && (o6.__u |= 4)) : c9 != f16 && (c9 == f16 - 1 ? h9-- : c9 == f16 + 1 ? h9++ : (c9 > f16 ? h9-- : h9++, o6.__u |= 4))) : n5.__k[r8] = null;
  if (a6) for (r8 = 0; r8 < s5; r8++) null != (e11 = u10[r8]) && 0 == (2 & e11.__u) && (e11.__e == t6 && (t6 = S6(e11)), D6(e11, e11));
  return t6;
}
function A7(n5, l9, u10, t6) {
  var i9, r8;
  if ("function" == typeof n5.type) {
    for (i9 = n5.__k, r8 = 0; i9 && r8 < i9.length; r8++) i9[r8] && (i9[r8].__ = n5, l9 = A7(i9[r8], l9, u10, t6));
    return l9;
  }
  n5.__e != l9 && (t6 && (l9 && n5.type && !l9.parentNode && (l9 = S6(n5)), u10.insertBefore(n5.__e, l9 || null)), l9 = n5.__e);
  do {
    l9 = l9 && l9.nextSibling;
  } while (null != l9 && 8 == l9.nodeType);
  return l9;
}
function L5(n5, l9, u10, t6) {
  var i9, r8, o6, e11 = n5.key, f16 = n5.type, c9 = l9[u10], s5 = null != c9 && 0 == (2 & c9.__u);
  if (null === c9 && null == n5.key || s5 && e11 == c9.key && f16 == c9.type) return u10;
  if (t6 > (s5 ? 1 : 0)) {
    for (i9 = u10 - 1, r8 = u10 + 1; i9 >= 0 || r8 < l9.length; ) if (null != (c9 = l9[o6 = i9 >= 0 ? i9-- : r8++]) && 0 == (2 & c9.__u) && e11 == c9.key && f16 == c9.type) return o6;
  }
  return -1;
}
function T6(n5, l9, u10) {
  "-" == l9[0] ? n5.setProperty(l9, null == u10 ? "" : u10) : n5[l9] = null == u10 ? "" : "number" != typeof u10 || y8.test(l9) ? u10 : u10 + "px";
}
function j6(n5, l9, u10, t6, i9) {
  var r8, o6;
  n: if ("style" == l9) if ("string" == typeof u10) n5.style.cssText = u10;
  else {
    if ("string" == typeof t6 && (n5.style.cssText = t6 = ""), t6) for (l9 in t6) u10 && l9 in u10 || T6(n5.style, l9, "");
    if (u10) for (l9 in u10) t6 && u10[l9] == t6[l9] || T6(n5.style, l9, u10[l9]);
  }
  else if ("o" == l9[0] && "n" == l9[1]) r8 = l9 != (l9 = l9.replace(f12, "$1")), o6 = l9.toLowerCase(), l9 = o6 in n5 || "onFocusOut" == l9 || "onFocusIn" == l9 ? o6.slice(2) : l9.slice(2), n5.l || (n5.l = {}), n5.l[l9 + r8] = u10, u10 ? t6 ? u10.u = t6.u : (u10.u = c6, n5.addEventListener(l9, r8 ? a4 : s3, r8)) : n5.removeEventListener(l9, r8 ? a4 : s3, r8);
  else {
    if ("http://www.w3.org/2000/svg" == i9) l9 = l9.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l9 && "height" != l9 && "href" != l9 && "list" != l9 && "form" != l9 && "tabIndex" != l9 && "download" != l9 && "rowSpan" != l9 && "colSpan" != l9 && "role" != l9 && "popover" != l9 && l9 in n5) try {
      n5[l9] = null == u10 ? "" : u10;
      break n;
    } catch (n6) {
    }
    "function" == typeof u10 || (null == u10 || false === u10 && "-" != l9[4] ? n5.removeAttribute(l9) : n5.setAttribute(l9, "popover" == l9 && 1 == u10 ? "" : u10));
  }
}
function F6(n5) {
  return function(u10) {
    if (this.l) {
      var t6 = this.l[u10.type + n5];
      if (null == u10.t) u10.t = c6++;
      else if (u10.t < t6.u) return;
      return t6(l6.event ? l6.event(u10) : u10);
    }
  };
}
function O6(n5, u10, t6, i9, r8, o6, e11, f16, c9, s5) {
  var a6, h9, p9, v9, y11, _6, m6, b6, S8, C10, M8, $8, P7, A9, H4, L7, T8, j9 = u10.type;
  if (null != u10.constructor) return null;
  128 & t6.__u && (c9 = !!(32 & t6.__u), o6 = [f16 = u10.__e = t6.__e]), (a6 = l6.__b) && a6(u10);
  n: if ("function" == typeof j9) try {
    if (b6 = u10.props, S8 = "prototype" in j9 && j9.prototype.render, C10 = (a6 = j9.contextType) && i9[a6.__c], M8 = a6 ? C10 ? C10.props.value : a6.__ : i9, t6.__c ? m6 = (h9 = u10.__c = t6.__c).__ = h9.__E : (S8 ? u10.__c = h9 = new j9(b6, M8) : (u10.__c = h9 = new x5(b6, M8), h9.constructor = j9, h9.render = E6), C10 && C10.sub(h9), h9.props = b6, h9.state || (h9.state = {}), h9.context = M8, h9.__n = i9, p9 = h9.__d = true, h9.__h = [], h9._sb = []), S8 && null == h9.__s && (h9.__s = h9.state), S8 && null != j9.getDerivedStateFromProps && (h9.__s == h9.state && (h9.__s = d4({}, h9.__s)), d4(h9.__s, j9.getDerivedStateFromProps(b6, h9.__s))), v9 = h9.props, y11 = h9.state, h9.__v = u10, p9) S8 && null == j9.getDerivedStateFromProps && null != h9.componentWillMount && h9.componentWillMount(), S8 && null != h9.componentDidMount && h9.__h.push(h9.componentDidMount);
    else {
      if (S8 && null == j9.getDerivedStateFromProps && b6 !== v9 && null != h9.componentWillReceiveProps && h9.componentWillReceiveProps(b6, M8), !h9.__e && null != h9.shouldComponentUpdate && false === h9.shouldComponentUpdate(b6, h9.__s, M8) || u10.__v == t6.__v) {
        for (u10.__v != t6.__v && (h9.props = b6, h9.state = h9.__s, h9.__d = false), u10.__e = t6.__e, u10.__k = t6.__k, u10.__k.some(function(n6) {
          n6 && (n6.__ = u10);
        }), $8 = 0; $8 < h9._sb.length; $8++) h9.__h.push(h9._sb[$8]);
        h9._sb = [], h9.__h.length && e11.push(h9);
        break n;
      }
      null != h9.componentWillUpdate && h9.componentWillUpdate(b6, h9.__s, M8), S8 && null != h9.componentDidUpdate && h9.__h.push(function() {
        h9.componentDidUpdate(v9, y11, _6);
      });
    }
    if (h9.context = M8, h9.props = b6, h9.__P = n5, h9.__e = false, P7 = l6.__r, A9 = 0, S8) {
      for (h9.state = h9.__s, h9.__d = false, P7 && P7(u10), a6 = h9.render(h9.props, h9.state, h9.context), H4 = 0; H4 < h9._sb.length; H4++) h9.__h.push(h9._sb[H4]);
      h9._sb = [];
    } else do {
      h9.__d = false, P7 && P7(u10), a6 = h9.render(h9.props, h9.state, h9.context), h9.state = h9.__s;
    } while (h9.__d && ++A9 < 25);
    h9.state = h9.__s, null != h9.getChildContext && (i9 = d4(d4({}, i9), h9.getChildContext())), S8 && !p9 && null != h9.getSnapshotBeforeUpdate && (_6 = h9.getSnapshotBeforeUpdate(v9, y11)), L7 = a6, null != a6 && a6.type === k8 && null == a6.key && (L7 = V6(a6.props.children)), f16 = I6(n5, w5(L7) ? L7 : [L7], u10, t6, i9, r8, o6, e11, f16, c9, s5), h9.base = u10.__e, u10.__u &= -161, h9.__h.length && e11.push(h9), m6 && (h9.__E = h9.__ = null);
  } catch (n6) {
    if (u10.__v = null, c9 || null != o6) if (n6.then) {
      for (u10.__u |= c9 ? 160 : 128; f16 && 8 == f16.nodeType && f16.nextSibling; ) f16 = f16.nextSibling;
      o6[o6.indexOf(f16)] = null, u10.__e = f16;
    } else {
      for (T8 = o6.length; T8--; ) g2(o6[T8]);
      z6(u10);
    }
    else u10.__e = t6.__e, u10.__k = t6.__k, n6.then || z6(u10);
    l6.__e(n6, u10, t6);
  }
  else null == o6 && u10.__v == t6.__v ? (u10.__k = t6.__k, u10.__e = t6.__e) : f16 = u10.__e = q4(t6.__e, u10, t6, i9, r8, o6, e11, c9, s5);
  return (a6 = l6.diffed) && a6(u10), 128 & u10.__u ? void 0 : f16;
}
function z6(n5) {
  n5 && n5.__c && (n5.__c.__e = true), n5 && n5.__k && n5.__k.forEach(z6);
}
function N7(n5, u10, t6) {
  for (var i9 = 0; i9 < t6.length; i9++) B6(t6[i9], t6[++i9], t6[++i9]);
  l6.__c && l6.__c(u10, n5), n5.some(function(u11) {
    try {
      n5 = u11.__h, u11.__h = [], n5.some(function(n6) {
        n6.call(u11);
      });
    } catch (n6) {
      l6.__e(n6, u11.__v);
    }
  });
}
function V6(n5) {
  return "object" != typeof n5 || null == n5 || n5.__b && n5.__b > 0 ? n5 : w5(n5) ? n5.map(V6) : d4({}, n5);
}
function q4(u10, t6, i9, r8, o6, e11, f16, c9, s5) {
  var a6, h9, v9, y11, d7, _6, m6, b6 = i9.props, k11 = t6.props, x7 = t6.type;
  if ("svg" == x7 ? o6 = "http://www.w3.org/2000/svg" : "math" == x7 ? o6 = "http://www.w3.org/1998/Math/MathML" : o6 || (o6 = "http://www.w3.org/1999/xhtml"), null != e11) {
    for (a6 = 0; a6 < e11.length; a6++) if ((d7 = e11[a6]) && "setAttribute" in d7 == !!x7 && (x7 ? d7.localName == x7 : 3 == d7.nodeType)) {
      u10 = d7, e11[a6] = null;
      break;
    }
  }
  if (null == u10) {
    if (null == x7) return document.createTextNode(k11);
    u10 = document.createElementNS(o6, x7, k11.is && k11), c9 && (l6.__m && l6.__m(t6, e11), c9 = false), e11 = null;
  }
  if (null == x7) b6 === k11 || c9 && u10.data == k11 || (u10.data = k11);
  else {
    if (e11 = e11 && n3.call(u10.childNodes), b6 = i9.props || p6, !c9 && null != e11) for (b6 = {}, a6 = 0; a6 < u10.attributes.length; a6++) b6[(d7 = u10.attributes[a6]).name] = d7.value;
    for (a6 in b6) if (d7 = b6[a6], "children" == a6) ;
    else if ("dangerouslySetInnerHTML" == a6) v9 = d7;
    else if (!(a6 in k11)) {
      if ("value" == a6 && "defaultValue" in k11 || "checked" == a6 && "defaultChecked" in k11) continue;
      j6(u10, a6, null, d7, o6);
    }
    for (a6 in k11) d7 = k11[a6], "children" == a6 ? y11 = d7 : "dangerouslySetInnerHTML" == a6 ? h9 = d7 : "value" == a6 ? _6 = d7 : "checked" == a6 ? m6 = d7 : c9 && "function" != typeof d7 || b6[a6] === d7 || j6(u10, a6, d7, b6[a6], o6);
    if (h9) c9 || v9 && (h9.__html == v9.__html || h9.__html == u10.innerHTML) || (u10.innerHTML = h9.__html), t6.__k = [];
    else if (v9 && (u10.innerHTML = ""), I6("template" == t6.type ? u10.content : u10, w5(y11) ? y11 : [y11], t6, i9, r8, "foreignObject" == x7 ? "http://www.w3.org/1999/xhtml" : o6, e11, f16, e11 ? e11[0] : i9.__k && S6(i9, 0), c9, s5), null != e11) for (a6 = e11.length; a6--; ) g2(e11[a6]);
    c9 || (a6 = "value", "progress" == x7 && null == _6 ? u10.removeAttribute("value") : null != _6 && (_6 !== u10[a6] || "progress" == x7 && !_6 || "option" == x7 && _6 != b6[a6]) && j6(u10, a6, _6, b6[a6], o6), a6 = "checked", null != m6 && m6 != u10[a6] && j6(u10, a6, m6, b6[a6], o6));
  }
  return u10;
}
function B6(n5, u10, t6) {
  try {
    if ("function" == typeof n5) {
      var i9 = "function" == typeof n5.__u;
      i9 && n5.__u(), i9 && null == u10 || (n5.__u = n5(u10));
    } else n5.current = u10;
  } catch (n6) {
    l6.__e(n6, t6);
  }
}
function D6(n5, u10, t6) {
  var i9, r8;
  if (l6.unmount && l6.unmount(n5), (i9 = n5.ref) && (i9.current && i9.current != n5.__e || B6(i9, null, u10)), null != (i9 = n5.__c)) {
    if (i9.componentWillUnmount) try {
      i9.componentWillUnmount();
    } catch (n6) {
      l6.__e(n6, u10);
    }
    i9.base = i9.__P = null;
  }
  if (i9 = n5.__k) for (r8 = 0; r8 < i9.length; r8++) i9[r8] && D6(i9[r8], u10, t6 || "function" != typeof n5.type);
  t6 || g2(n5.__e), n5.__c = n5.__ = n5.__e = void 0;
}
function E6(n5, l9, u10) {
  return this.constructor(n5, u10);
}
function G5(u10, t6, i9) {
  var r8, o6, e11, f16;
  t6 == document && (t6 = document.documentElement), l6.__ && l6.__(u10, t6), o6 = (r8 = "function" == typeof i9) ? null : i9 && i9.__k || t6.__k, e11 = [], f16 = [], O6(t6, u10 = (!r8 && i9 || t6).__k = _4(k8, null, [u10]), o6 || p6, p6, t6.namespaceURI, !r8 && i9 ? [i9] : o6 ? null : t6.firstChild ? n3.call(t6.childNodes) : null, e11, !r8 && i9 ? i9 : o6 ? o6.__e : t6.firstChild, r8, f16), N7(e11, u10, f16);
}
n3 = v6.slice, l6 = { __e: function(n5, l9, u10, t6) {
  for (var i9, r8, o6; l9 = l9.__; ) if ((i9 = l9.__c) && !i9.__) try {
    if ((r8 = i9.constructor) && null != r8.getDerivedStateFromError && (i9.setState(r8.getDerivedStateFromError(n5)), o6 = i9.__d), null != i9.componentDidCatch && (i9.componentDidCatch(n5, t6 || {}), o6 = i9.__d), o6) return i9.__E = i9;
  } catch (l10) {
    n5 = l10;
  }
  throw n5;
} }, u6 = 0, t3 = function(n5) {
  return null != n5 && null == n5.constructor;
}, x5.prototype.setState = function(n5, l9) {
  var u10;
  u10 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d4({}, this.state), "function" == typeof n5 && (n5 = n5(d4({}, u10), this.props)), n5 && d4(u10, n5), null != n5 && this.__v && (l9 && this._sb.push(l9), M6(this));
}, x5.prototype.forceUpdate = function(n5) {
  this.__v && (this.__e = true, n5 && this.__h.push(n5), M6(this));
}, x5.prototype.render = k8, i6 = [], o4 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e3 = function(n5, l9) {
  return n5.__v.__b - l9.__v.__b;
}, $6.__r = 0, f12 = /(PointerCapture)$|Capture$/i, c6 = 0, s3 = F6(false), a4 = F6(true), h6 = 0;

// node_modules/preact/hooks/dist/hooks.module.js
var t4;
var r6;
var u7;
var i7;
var o5 = 0;
var f13 = [];
var c7 = l6;
var e4 = c7.__b;
var a5 = c7.__r;
var v7 = c7.diffed;
var l7 = c7.__c;
var m4 = c7.unmount;
var s4 = c7.__;
function p7(n5, t6) {
  c7.__h && c7.__h(r6, n5, o5 || t6), o5 = 0;
  var u10 = r6.__H || (r6.__H = { __: [], __h: [] });
  return n5 >= u10.__.length && u10.__.push({}), u10.__[n5];
}
function d5(n5) {
  return o5 = 1, h7(D7, n5);
}
function h7(n5, u10, i9) {
  var o6 = p7(t4++, 2);
  if (o6.t = n5, !o6.__c && (o6.__ = [i9 ? i9(u10) : D7(void 0, u10), function(n6) {
    var t6 = o6.__N ? o6.__N[0] : o6.__[0], r8 = o6.t(t6, n6);
    t6 !== r8 && (o6.__N = [r8, o6.__[1]], o6.__c.setState({}));
  }], o6.__c = r6, !r6.__f)) {
    var f16 = function(n6, t6, r8) {
      if (!o6.__c.__H) return true;
      var u11 = o6.__c.__H.__.filter(function(n7) {
        return !!n7.__c;
      });
      if (u11.every(function(n7) {
        return !n7.__N;
      })) return !c9 || c9.call(this, n6, t6, r8);
      var i10 = o6.__c.props !== n6;
      return u11.forEach(function(n7) {
        if (n7.__N) {
          var t7 = n7.__[0];
          n7.__ = n7.__N, n7.__N = void 0, t7 !== n7.__[0] && (i10 = true);
        }
      }), c9 && c9.call(this, n6, t6, r8) || i10;
    };
    r6.__f = true;
    var c9 = r6.shouldComponentUpdate, e11 = r6.componentWillUpdate;
    r6.componentWillUpdate = function(n6, t6, r8) {
      if (this.__e) {
        var u11 = c9;
        c9 = void 0, f16(n6, t6, r8), c9 = u11;
      }
      e11 && e11.call(this, n6, t6, r8);
    }, r6.shouldComponentUpdate = f16;
  }
  return o6.__N || o6.__;
}
function y9(n5, u10) {
  var i9 = p7(t4++, 3);
  !c7.__s && C8(i9.__H, u10) && (i9.__ = n5, i9.u = u10, r6.__H.__h.push(i9));
}
function j7() {
  for (var n5; n5 = f13.shift(); ) if (n5.__P && n5.__H) try {
    n5.__H.__h.forEach(z7), n5.__H.__h.forEach(B7), n5.__H.__h = [];
  } catch (t6) {
    n5.__H.__h = [], c7.__e(t6, n5.__v);
  }
}
c7.__b = function(n5) {
  r6 = null, e4 && e4(n5);
}, c7.__ = function(n5, t6) {
  n5 && t6.__k && t6.__k.__m && (n5.__m = t6.__k.__m), s4 && s4(n5, t6);
}, c7.__r = function(n5) {
  a5 && a5(n5), t4 = 0;
  var i9 = (r6 = n5.__c).__H;
  i9 && (u7 === r6 ? (i9.__h = [], r6.__h = [], i9.__.forEach(function(n6) {
    n6.__N && (n6.__ = n6.__N), n6.u = n6.__N = void 0;
  })) : (i9.__h.forEach(z7), i9.__h.forEach(B7), i9.__h = [], t4 = 0)), u7 = r6;
}, c7.diffed = function(n5) {
  v7 && v7(n5);
  var t6 = n5.__c;
  t6 && t6.__H && (t6.__H.__h.length && (1 !== f13.push(t6) && i7 === c7.requestAnimationFrame || ((i7 = c7.requestAnimationFrame) || w6)(j7)), t6.__H.__.forEach(function(n6) {
    n6.u && (n6.__H = n6.u), n6.u = void 0;
  })), u7 = r6 = null;
}, c7.__c = function(n5, t6) {
  t6.some(function(n6) {
    try {
      n6.__h.forEach(z7), n6.__h = n6.__h.filter(function(n7) {
        return !n7.__ || B7(n7);
      });
    } catch (r8) {
      t6.some(function(n7) {
        n7.__h && (n7.__h = []);
      }), t6 = [], c7.__e(r8, n6.__v);
    }
  }), l7 && l7(n5, t6);
}, c7.unmount = function(n5) {
  m4 && m4(n5);
  var t6, r8 = n5.__c;
  r8 && r8.__H && (r8.__H.__.forEach(function(n6) {
    try {
      z7(n6);
    } catch (n7) {
      t6 = n7;
    }
  }), r8.__H = void 0, t6 && c7.__e(t6, r8.__v));
};
var k9 = "function" == typeof requestAnimationFrame;
function w6(n5) {
  var t6, r8 = function() {
    clearTimeout(u10), k9 && cancelAnimationFrame(t6), setTimeout(n5);
  }, u10 = setTimeout(r8, 35);
  k9 && (t6 = requestAnimationFrame(r8));
}
function z7(n5) {
  var t6 = r6, u10 = n5.__c;
  "function" == typeof u10 && (n5.__c = void 0, u10()), r6 = t6;
}
function B7(n5) {
  var t6 = r6;
  n5.__c = n5.__(), r6 = t6;
}
function C8(n5, t6) {
  return !n5 || n5.length !== t6.length || t6.some(function(t7, r8) {
    return t7 !== n5[r8];
  });
}
function D7(n5, t6) {
  return "function" == typeof t6 ? t6(n5) : t6;
}

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar-css.js
var Snackbar_css_default = /* @__PURE__ */ (() => `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/Snackbar/Snackbar.js
var cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
var Snackbar = class {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
    this.nextItemKey = 0;
    this.root = null;
    this.darkMode = isDarkMode();
  }
  attach(el2) {
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-snackbar-root";
    el2.appendChild(this.root);
    this.render();
  }
  presentItem(itemProps) {
    const key = this.nextItemKey++;
    this.items.set(key, itemProps);
    this.render();
    return () => {
      this.items.delete(key);
      this.render();
    };
  }
  clear() {
    this.items.clear();
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    G5(_4(
      "div",
      null,
      _4(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key, itemProps]) => _4(SnackbarInstance, Object.assign({}, itemProps, { key }))))
    ), this.root);
  }
};
var SnackbarContainer = (props) => _4(
  "div",
  { class: clsx("-cbwsdk-snackbar-container") },
  _4("style", null, Snackbar_css_default),
  _4("div", { class: "-cbwsdk-snackbar" }, props.children)
);
var SnackbarInstance = ({ autoExpand, message, menuItems }) => {
  const [hidden, setHidden] = d5(true);
  const [expanded, setExpanded] = d5(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
  y9(() => {
    const timers = [
      window.setTimeout(() => {
        setHidden(false);
      }, 1),
      window.setTimeout(() => {
        setExpanded(true);
      }, 1e4)
    ];
    return () => {
      timers.forEach(window.clearTimeout);
    };
  });
  const toggleExpanded = () => {
    setExpanded(!expanded);
  };
  return _4(
    "div",
    { class: clsx("-cbwsdk-snackbar-instance", hidden && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
    _4(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
      _4("img", { src: cblogo, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      _4("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
      _4(
        "div",
        { class: "-gear-container" },
        !expanded && _4(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          _4("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        _4("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
      )
    ),
    menuItems && menuItems.length > 0 && _4("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i9) => _4(
      "div",
      { class: clsx("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i9 },
      _4(
        "svg",
        { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        _4("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
      ),
      _4("span", { class: clsx("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
    )))
  );
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WalletLinkRelayUI.js
var RETRY_SVG_PATH = "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z";
var WalletLinkRelayUI = class {
  constructor() {
    this.attached = false;
    this.snackbar = new Snackbar();
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    const el2 = document.documentElement;
    const container = document.createElement("div");
    container.className = "-cbwsdk-css-reset";
    el2.appendChild(container);
    this.snackbar.attach(container);
    this.attached = true;
    injectCssReset();
  }
  showConnecting(options) {
    let snackbarProps;
    if (options.isUnlinkedErrorState) {
      snackbarProps = {
        autoExpand: true,
        message: "Connection lost",
        menuItems: [
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    } else {
      snackbarProps = {
        message: "Confirm on phone",
        menuItems: [
          {
            isRed: true,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: options.onCancel
          },
          {
            isRed: false,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: RETRY_SVG_PATH,
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: options.onResetConnection
          }
        ]
      };
    }
    return this.snackbar.presentItem(snackbarProps);
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog-css.js
var RedirectDialog_css_default = /* @__PURE__ */ (() => `.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}`)();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/components/RedirectDialog/RedirectDialog.js
var RedirectDialog = class {
  constructor() {
    this.root = null;
    this.darkMode = isDarkMode();
  }
  attach() {
    const el2 = document.documentElement;
    this.root = document.createElement("div");
    this.root.className = "-cbwsdk-css-reset";
    el2.appendChild(this.root);
    injectCssReset();
  }
  present(props) {
    this.render(props);
  }
  clear() {
    this.render(null);
  }
  render(props) {
    if (!this.root)
      return;
    G5(null, this.root);
    if (!props)
      return;
    G5(_4(RedirectDialogContent, Object.assign({}, props, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root);
  }
};
var RedirectDialogContent = ({ title, buttonText, darkMode, onButtonClick, onDismiss }) => {
  const theme = darkMode ? "dark" : "light";
  return _4(
    SnackbarContainer,
    { darkMode },
    _4(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      _4("style", null, RedirectDialog_css_default),
      _4("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: onDismiss }),
      _4(
        "div",
        { class: clsx("-cbwsdk-redirect-dialog-box", theme) },
        _4("p", null, title),
        _4("button", { onClick: onButtonClick }, buttonText)
      )
    )
  );
};

// node_modules/@coinbase/wallet-sdk/dist/core/constants.js
var CB_KEYS_URL2 = "https://keys.coinbase.com/connect";
var CB_WALLET_RPC_URL2 = "https://rpc.wallet.coinbase.com";
var WALLETLINK_URL = "https://www.walletlink.org";
var CBW_MOBILE_DEEPLINK_URL = "https://go.cb-w.com/walletlink";

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/ui/WLMobileRelayUI.js
var WLMobileRelayUI = class {
  constructor() {
    this.attached = false;
    this.redirectDialog = new RedirectDialog();
  }
  attach() {
    if (this.attached) {
      throw new Error("Coinbase Wallet SDK UI is already attached");
    }
    this.redirectDialog.attach();
    this.attached = true;
  }
  redirectToCoinbaseWallet(walletLinkUrl) {
    const url2 = new URL(CBW_MOBILE_DEEPLINK_URL);
    url2.searchParams.append("redirect_url", getLocation().href);
    if (walletLinkUrl) {
      url2.searchParams.append("wl_url", walletLinkUrl);
    }
    const anchorTag = document.createElement("a");
    anchorTag.target = "cbw-opener";
    anchorTag.href = url2.href;
    anchorTag.rel = "noreferrer noopener";
    anchorTag.click();
  }
  openCoinbaseWalletDeeplink(walletLinkUrl) {
    this.redirectToCoinbaseWallet(walletLinkUrl);
    setTimeout(() => {
      this.redirectDialog.present({
        title: "Redirecting to Coinbase Wallet...",
        buttonText: "Open",
        onButtonClick: () => {
          this.redirectToCoinbaseWallet(walletLinkUrl);
        }
      });
    }, 99);
  }
  showConnecting(_options) {
    return () => {
      this.redirectDialog.clear();
    };
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/relay/WalletLinkRelay.js
var WalletLinkRelay = class _WalletLinkRelay {
  constructor(options) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" };
    this.isMobileWeb = isMobileWeb();
    this.linkedUpdated = (linked) => {
      this.isLinked = linked;
      const cachedAddresses = this.storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);
      if (linked) {
        this._session.linked = linked;
      }
      this.isUnlinkedErrorState = false;
      if (cachedAddresses) {
        const addresses = cachedAddresses.split(" ");
        const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
        if (addresses[0] !== "" && !linked && this._session.linked && !wasConnectedViaStandalone) {
          this.isUnlinkedErrorState = true;
        }
      }
    };
    this.metadataUpdated = (key, value2) => {
      this.storage.setItem(key, value2);
    };
    this.chainUpdated = (chainId, jsonRpcUrl) => {
      if (this.chainCallbackParams.chainId === chainId && this.chainCallbackParams.jsonRpcUrl === jsonRpcUrl) {
        return;
      }
      this.chainCallbackParams = {
        chainId,
        jsonRpcUrl
      };
      if (this.chainCallback) {
        this.chainCallback(jsonRpcUrl, Number.parseInt(chainId, 10));
      }
    };
    this.accountUpdated = (selectedAddress) => {
      if (this.accountsCallback) {
        this.accountsCallback([selectedAddress]);
      }
      if (_WalletLinkRelay.accountRequestCallbackIds.size > 0) {
        Array.from(_WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id2) => {
          this.invokeCallback(id2, {
            method: "requestEthereumAccounts",
            result: [selectedAddress]
          });
        });
        _WalletLinkRelay.accountRequestCallbackIds.clear();
      }
    };
    this.resetAndReload = this.resetAndReload.bind(this);
    this.linkAPIUrl = options.linkAPIUrl;
    this.storage = options.storage;
    this.metadata = options.metadata;
    this.accountsCallback = options.accountsCallback;
    this.chainCallback = options.chainCallback;
    const { session, ui: ui5, connection } = this.subscribe();
    this._session = session;
    this.connection = connection;
    this.relayEventManager = new RelayEventManager();
    this.ui = ui5;
    this.ui.attach();
  }
  subscribe() {
    const session = WalletLinkSession.load(this.storage) || WalletLinkSession.create(this.storage);
    const { linkAPIUrl } = this;
    const connection = new WalletLinkConnection({
      session,
      linkAPIUrl,
      listener: this
    });
    const ui5 = this.isMobileWeb ? new WLMobileRelayUI() : new WalletLinkRelayUI();
    connection.connect();
    return { session, ui: ui5, connection };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const storedSession = WalletLinkSession.load(this.storage);
      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
        ScopedLocalStorage.clearAll();
      }
      document.location.reload();
    }).catch((_6) => {
    });
  }
  signEthereumTransaction(params) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: bigIntStringFromBigInt(params.weiValue),
        data: hexStringFromBuffer(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxPriorityFeePerGas: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: false
      }
    });
  }
  signAndSubmitEthereumTransaction(params) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: bigIntStringFromBigInt(params.weiValue),
        data: hexStringFromBuffer(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? bigIntStringFromBigInt(params.gasPriceInWei) : null,
        maxFeePerGas: params.maxFeePerGas ? bigIntStringFromBigInt(params.maxFeePerGas) : null,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? bigIntStringFromBigInt(params.maxPriorityFeePerGas) : null,
        gasLimit: params.gasLimit ? bigIntStringFromBigInt(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: true
      }
    });
  }
  submitEthereumTransaction(signedTransaction, chainId) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: hexStringFromBuffer(signedTransaction, true),
        chainId
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(request2) {
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request2.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    return new Promise((resolve, reject) => {
      {
        hideSnackbarItem = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: cancel,
          onResetConnection: this.resetAndReload
          // eslint-disable-line @typescript-eslint/unbound-method
        });
      }
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse2(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request2);
    });
  }
  publishWeb3RequestEvent(id2, request2) {
    const message = { type: "WEB3_REQUEST", id: id2, request: request2 };
    this.publishEvent("Web3Request", message, true).then((_6) => {
    }).catch((err) => {
      this.handleWeb3ResponseMessage(message.id, {
        method: request2.method,
        errorMessage: err.message
      });
    });
    if (this.isMobileWeb) {
      this.openCoinbaseWalletDeeplink(request2.method);
    }
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(method) {
    if (!(this.ui instanceof WLMobileRelayUI))
      return;
    switch (method) {
      case "requestEthereumAccounts":
      case "switchEthereumChain":
        return;
      default:
        window.addEventListener("blur", () => {
          window.addEventListener("focus", () => {
            this.connection.checkUnseenEvents();
          }, { once: true });
        }, { once: true });
        this.ui.openCoinbaseWalletDeeplink();
        break;
    }
  }
  publishWeb3RequestCanceledEvent(id2) {
    const message = {
      type: "WEB3_REQUEST_CANCELED",
      id: id2
    };
    this.publishEvent("Web3RequestCanceled", message, false).then();
  }
  publishEvent(event, message, callWebhook) {
    return this.connection.publishEvent(event, message, callWebhook);
  }
  handleWeb3ResponseMessage(id2, response) {
    if (response.method === "requestEthereumAccounts") {
      _WalletLinkRelay.accountRequestCallbackIds.forEach((id3) => this.invokeCallback(id3, response));
      _WalletLinkRelay.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(id2, response);
  }
  handleErrorResponse(id2, method, error) {
    var _a14;
    const errorMessage = (_a14 = error === null || error === void 0 ? void 0 : error.message) !== null && _a14 !== void 0 ? _a14 : "Unspecified error message.";
    this.handleWeb3ResponseMessage(id2, {
      method,
      errorMessage
    });
  }
  invokeCallback(id2, response) {
    const callback = this.relayEventManager.callbacks.get(id2);
    if (callback) {
      callback(response);
      this.relayEventManager.callbacks.delete(id2);
    }
  }
  requestEthereumAccounts() {
    const { appName, appLogoUrl } = this.metadata;
    const request2 = {
      method: "requestEthereumAccounts",
      params: {
        appName,
        appLogoUrl
      }
    };
    const hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse2(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      _WalletLinkRelay.accountRequestCallbackIds.add(id2);
      this.publishWeb3RequestEvent(id2, request2);
    });
  }
  watchAsset(type7, address, symbol, decimals, image, chainId) {
    const request2 = {
      method: "watchAsset",
      params: {
        type: type7,
        options: {
          address,
          symbol,
          decimals,
          image
        },
        chainId
      }
    };
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request2.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse2(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request2);
    });
  }
  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
    const request2 = {
      method: "addEthereumChain",
      params: {
        chainId,
        rpcUrls,
        blockExplorerUrls,
        chainName,
        iconUrls,
        nativeCurrency
      }
    };
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request2.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse2(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request2);
    });
  }
  switchEthereumChain(chainId, address) {
    const request2 = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId }, { address })
    };
    let hideSnackbarItem = null;
    const id2 = randomBytesHex(8);
    const cancel = (error) => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleErrorResponse(id2, request2.method, error);
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    {
      hideSnackbarItem = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: cancel,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      });
    }
    return new Promise((resolve, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (isErrorResponse2(response) && response.errorCode) {
          return reject(standardErrors2.provider.custom({
            code: response.errorCode,
            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
          }));
        } else if (isErrorResponse2(response)) {
          return reject(new Error(response.errorMessage));
        }
        resolve(response);
      });
      this.publishWeb3RequestEvent(id2, request2);
    });
  }
};
WalletLinkRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();

// node_modules/@coinbase/wallet-sdk/dist/sign/walletlink/WalletLinkSigner.js
var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
var WalletLinkSigner = class {
  constructor(options) {
    this._relay = null;
    this._addresses = [];
    this.metadata = options.metadata;
    this._storage = new ScopedLocalStorage("walletlink", WALLETLINK_URL);
    this.callback = options.callback || null;
    const cachedAddresses = this._storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);
    if (cachedAddresses) {
      const addresses = cachedAddresses.split(" ");
      if (addresses[0] !== "") {
        this._addresses = addresses.map((address) => ensureAddressString(address));
      }
    }
    this.initializeRelay();
  }
  getSession() {
    const relay = this.initializeRelay();
    const { id: id2, secret } = relay.getWalletLinkSession();
    return { id: id2, secret };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var _a14;
    return (_a14 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a14 !== void 0 ? _a14 : void 0;
  }
  set jsonRpcUrl(value2) {
    this._storage.setItem(DEFAULT_JSON_RPC_URL, value2);
  }
  updateProviderInfo(jsonRpcUrl, chainId) {
    var _a14;
    this.jsonRpcUrl = jsonRpcUrl;
    const originalChainId = this.getChainId();
    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
    const chainChanged = ensureIntNumber2(chainId) !== originalChainId;
    if (chainChanged) {
      (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "chainChanged", hexStringFromNumber2(chainId));
    }
  }
  async watchAsset(params) {
    const request2 = Array.isArray(params) ? params[0] : params;
    if (!request2.type) {
      throw standardErrors2.rpc.invalidParams("Type is required");
    }
    if ((request2 === null || request2 === void 0 ? void 0 : request2.type) !== "ERC20") {
      throw standardErrors2.rpc.invalidParams(`Asset of type '${request2.type}' is not supported`);
    }
    if (!(request2 === null || request2 === void 0 ? void 0 : request2.options)) {
      throw standardErrors2.rpc.invalidParams("Options are required");
    }
    if (!(request2 === null || request2 === void 0 ? void 0 : request2.options.address)) {
      throw standardErrors2.rpc.invalidParams("Address is required");
    }
    const chainId = this.getChainId();
    const { address, symbol, image, decimals } = request2.options;
    const relay = this.initializeRelay();
    const result = await relay.watchAsset(request2.type, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString());
    if (isErrorResponse2(result))
      return false;
    return !!result.result;
  }
  async addEthereumChain(params) {
    var _a14, _b;
    const request2 = params[0];
    if (((_a14 = request2.rpcUrls) === null || _a14 === void 0 ? void 0 : _a14.length) === 0) {
      throw standardErrors2.rpc.invalidParams("please pass in at least 1 rpcUrl");
    }
    if (!request2.chainName || request2.chainName.trim() === "") {
      throw standardErrors2.rpc.invalidParams("chainName is a required field");
    }
    if (!request2.nativeCurrency) {
      throw standardErrors2.rpc.invalidParams("nativeCurrency is a required field");
    }
    const chainIdNumber = Number.parseInt(request2.chainId, 16);
    if (chainIdNumber === this.getChainId()) {
      return false;
    }
    const relay = this.initializeRelay();
    const { rpcUrls = [], blockExplorerUrls = [], chainName, iconUrls = [], nativeCurrency } = request2;
    const res = await relay.addEthereumChain(chainIdNumber.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency);
    if (isErrorResponse2(res))
      return false;
    if (((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true) {
      this.updateProviderInfo(rpcUrls[0], chainIdNumber);
      return null;
    }
    throw standardErrors2.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(params) {
    const request2 = params[0];
    const chainId = Number.parseInt(request2.chainId, 16);
    const relay = this.initializeRelay();
    const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0);
    if (isErrorResponse2(res))
      throw res;
    const switchResponse = res.result;
    if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
      this.updateProviderInfo(switchResponse.rpcUrl, chainId);
    }
    return null;
  }
  async cleanup() {
    this.callback = null;
    if (this._relay) {
      this._relay.resetAndReload();
    }
    this._storage.clear();
  }
  _setAddresses(addresses, _6) {
    var _a14;
    if (!Array.isArray(addresses)) {
      throw new Error("addresses is not an array");
    }
    const newAddresses = addresses.map((address) => ensureAddressString(address));
    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
      return;
    }
    this._addresses = newAddresses;
    (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "accountsChanged", newAddresses);
    this._storage.setItem(LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
  }
  async request(request2) {
    const params = request2.params || [];
    switch (request2.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return hexStringFromNumber2(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(request2);
      case "personal_sign":
        return this.personalSign(request2);
      case "eth_signTransaction":
        return this._eth_signTransaction(params);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(params);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(params);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(request2);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(params);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(params);
      case "wallet_watchAsset":
        return this.watchAsset(params);
      default:
        if (!this.jsonRpcUrl)
          throw standardErrors2.rpc.internal("No RPC URL set for chain");
        return fetchRPCRequest2(request2, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(addressString) {
    const addressStr = ensureAddressString(addressString);
    const lowercaseAddresses = this._addresses.map((address) => ensureAddressString(address));
    if (!lowercaseAddresses.includes(addressStr)) {
      throw new Error("Unknown Ethereum address");
    }
  }
  _prepareTransactionParams(tx) {
    const fromAddress = tx.from ? ensureAddressString(tx.from) : this.selectedAddress;
    if (!fromAddress) {
      throw new Error("Ethereum address is unavailable");
    }
    this._ensureKnownAddress(fromAddress);
    const toAddress = tx.to ? ensureAddressString(tx.to) : null;
    const weiValue = tx.value != null ? ensureBigInt(tx.value) : BigInt(0);
    const data = tx.data ? ensureBuffer(tx.data) : Buffer.alloc(0);
    const nonce = tx.nonce != null ? ensureIntNumber2(tx.nonce) : null;
    const gasPriceInWei = tx.gasPrice != null ? ensureBigInt(tx.gasPrice) : null;
    const maxFeePerGas = tx.maxFeePerGas != null ? ensureBigInt(tx.maxFeePerGas) : null;
    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? ensureBigInt(tx.maxPriorityFeePerGas) : null;
    const gasLimit = tx.gas != null ? ensureBigInt(tx.gas) : null;
    const chainId = tx.chainId ? ensureIntNumber2(tx.chainId) : this.getChainId();
    return {
      fromAddress,
      toAddress,
      weiValue,
      data,
      nonce,
      gasPriceInWei,
      maxFeePerGas,
      maxPriorityFeePerGas,
      gasLimit,
      chainId
    };
  }
  async ecRecover(request2) {
    const { method, params } = request2;
    if (!Array.isArray(params))
      throw standardErrors2.rpc.invalidParams();
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: encodeToHexString(params[0]),
        signature: encodeToHexString(params[1]),
        addPrefix: method === "personal_ecRecover"
      }
    });
    if (isErrorResponse2(res))
      throw res;
    return res.result;
  }
  getChainId() {
    var _a14;
    return Number.parseInt((_a14 = this._storage.getItem(DEFAULT_CHAIN_ID_KEY)) !== null && _a14 !== void 0 ? _a14 : "1", 10);
  }
  async _eth_requestAccounts() {
    var _a14, _b;
    if (this._addresses.length > 0) {
      (_a14 = this.callback) === null || _a14 === void 0 ? void 0 : _a14.call(this, "connect", { chainId: hexStringFromNumber2(this.getChainId()) });
      return this._addresses;
    }
    const relay = this.initializeRelay();
    const res = await relay.requestEthereumAccounts();
    if (isErrorResponse2(res))
      throw res;
    if (!res.result) {
      throw new Error("accounts received is empty");
    }
    this._setAddresses(res.result);
    (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, "connect", { chainId: hexStringFromNumber2(this.getChainId()) });
    return this._addresses;
  }
  async personalSign({ params }) {
    if (!Array.isArray(params))
      throw standardErrors2.rpc.invalidParams();
    const address = params[1];
    const rawData = params[0];
    this._ensureKnownAddress(address);
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ensureAddressString(address),
        message: encodeToHexString(rawData),
        addPrefix: true,
        typedDataJson: null
      }
    });
    if (isErrorResponse2(res))
      throw res;
    return res.result;
  }
  async _eth_signTransaction(params) {
    const tx = this._prepareTransactionParams(params[0] || {});
    const relay = this.initializeRelay();
    const res = await relay.signEthereumTransaction(tx);
    if (isErrorResponse2(res))
      throw res;
    return res.result;
  }
  async _eth_sendRawTransaction(params) {
    const signedTransaction = ensureBuffer(params[0]);
    const relay = this.initializeRelay();
    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId());
    if (isErrorResponse2(res))
      throw res;
    return res.result;
  }
  async _eth_sendTransaction(params) {
    const tx = this._prepareTransactionParams(params[0] || {});
    const relay = this.initializeRelay();
    const res = await relay.signAndSubmitEthereumTransaction(tx);
    if (isErrorResponse2(res))
      throw res;
    return res.result;
  }
  async signTypedData(request2) {
    const { method, params } = request2;
    if (!Array.isArray(params))
      throw standardErrors2.rpc.invalidParams();
    const encode20 = (input) => {
      const hashFuncMap = {
        eth_signTypedData_v1: import_eth_eip712_util.default.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: import_eth_eip712_util.default.hashForSignTypedData_v3,
        eth_signTypedData_v4: import_eth_eip712_util.default.hashForSignTypedData_v4,
        eth_signTypedData: import_eth_eip712_util.default.hashForSignTypedData_v4
      };
      return hexStringFromBuffer(hashFuncMap[method]({
        data: ensureParsedJSONObject(input)
      }), true);
    };
    const address = params[method === "eth_signTypedData_v1" ? 1 : 0];
    const rawData = params[method === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(address);
    const relay = this.initializeRelay();
    const res = await relay.sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ensureAddressString(address),
        message: encode20(rawData),
        typedDataJson: JSON.stringify(rawData, null, 2),
        addPrefix: false
      }
    });
    if (isErrorResponse2(res))
      throw res;
    return res.result;
  }
  initializeRelay() {
    if (!this._relay) {
      this._relay = new WalletLinkRelay({
        linkAPIUrl: WALLETLINK_URL,
        storage: this._storage,
        metadata: this.metadata,
        accountsCallback: this._setAddresses.bind(this),
        chainCallback: this.updateProviderInfo.bind(this)
      });
    }
    return this._relay;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/sign/util.js
var SIGNER_TYPE_KEY = "SignerType";
var storage2 = new ScopedLocalStorage("CBWSDK", "SignerConfigurator");
function loadSignerType() {
  return storage2.getItem(SIGNER_TYPE_KEY);
}
function storeSignerType(signerType) {
  storage2.setItem(SIGNER_TYPE_KEY, signerType);
}
async function fetchSignerType(params) {
  const { communicator, metadata, handshakeRequest, callback } = params;
  listenForWalletLinkSessionRequest(communicator, metadata, callback).catch(() => {
  });
  const request2 = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, params.preference), { handshakeRequest })
  };
  const { data } = await communicator.postRequestAndWaitForResponse(request2);
  return data;
}
function createSigner(params) {
  const { signerType, metadata, communicator, callback } = params;
  switch (signerType) {
    case "scw": {
      return new SCWSigner({
        metadata,
        callback,
        communicator
      });
    }
    case "walletlink": {
      return new WalletLinkSigner({
        metadata,
        callback
      });
    }
  }
}
async function listenForWalletLinkSessionRequest(communicator, metadata, callback) {
  await communicator.onMessage(({ event }) => event === "WalletLinkSessionRequest");
  const walletlink = new WalletLinkSigner({
    metadata,
    callback
  });
  communicator.postMessage({
    event: "WalletLinkUpdate",
    data: { session: walletlink.getSession() }
  });
  await walletlink.handshake();
  communicator.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: true }
  });
}

// node_modules/@coinbase/wallet-sdk/dist/util/checkCrossOriginOpenerPolicy.js
var COOP_ERROR_MESSAGE2 = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`;
var createCoopChecker2 = () => {
  let crossOriginOpenerPolicy;
  return {
    getCrossOriginOpenerPolicy: () => {
      if (crossOriginOpenerPolicy === void 0) {
        return "undefined";
      }
      return crossOriginOpenerPolicy;
    },
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window === "undefined") {
        crossOriginOpenerPolicy = "non-browser-env";
        return;
      }
      try {
        const url2 = `${window.location.origin}${window.location.pathname}`;
        const response = await fetch(url2, {
          method: "HEAD"
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = response.headers.get("Cross-Origin-Opener-Policy");
        crossOriginOpenerPolicy = result !== null && result !== void 0 ? result : "null";
        if (crossOriginOpenerPolicy === "same-origin") {
          console.error(COOP_ERROR_MESSAGE2);
        }
      } catch (error) {
        console.error("Error checking Cross-Origin-Opener-Policy:", error.message);
        crossOriginOpenerPolicy = "error";
      }
    }
  };
};
var { checkCrossOriginOpenerPolicy: checkCrossOriginOpenerPolicy2, getCrossOriginOpenerPolicy: getCrossOriginOpenerPolicy2 } = createCoopChecker2();

// node_modules/@coinbase/wallet-sdk/dist/util/web.js
var POPUP_WIDTH2 = 420;
var POPUP_HEIGHT2 = 540;
var RETRY_BUTTON = {
  isRed: false,
  info: "Retry",
  svgWidth: "10",
  svgHeight: "11",
  path: RETRY_SVG_PATH,
  defaultFillRule: "evenodd",
  defaultClipRule: "evenodd"
};
var POPUP_BLOCKED_MESSAGE2 = "Popup was blocked. Try again.";
var snackbar = null;
function openPopup2(url2) {
  const left13 = (window.innerWidth - POPUP_WIDTH2) / 2 + window.screenX;
  const top = (window.innerHeight - POPUP_HEIGHT2) / 2 + window.screenY;
  appendAppInfoQueryParams2(url2);
  function tryOpenPopup() {
    const popupId = `wallet_${crypto.randomUUID()}`;
    const popup2 = window.open(url2, popupId, `width=${POPUP_WIDTH2}, height=${POPUP_HEIGHT2}, left=${left13}, top=${top}`);
    popup2 === null || popup2 === void 0 ? void 0 : popup2.focus();
    if (!popup2) {
      return null;
    }
    return popup2;
  }
  let popup = tryOpenPopup();
  if (!popup) {
    const sb = initSnackbar();
    return new Promise((resolve, reject) => {
      sb.presentItem({
        autoExpand: true,
        message: POPUP_BLOCKED_MESSAGE2,
        menuItems: [
          Object.assign(Object.assign({}, RETRY_BUTTON), { onClick: () => {
            popup = tryOpenPopup();
            if (popup) {
              resolve(popup);
            } else {
              reject(standardErrors2.rpc.internal("Popup window was blocked"));
            }
            sb.clear();
          } })
        ]
      });
    });
  }
  return Promise.resolve(popup);
}
function closePopup2(popup) {
  if (popup && !popup.closed) {
    popup.close();
  }
}
function appendAppInfoQueryParams2(url2) {
  const params = {
    sdkName: NAME,
    sdkVersion: VERSION6,
    origin: window.location.origin,
    coop: getCrossOriginOpenerPolicy2()
  };
  for (const [key, value2] of Object.entries(params)) {
    url2.searchParams.append(key, value2.toString());
  }
}
function initSnackbar() {
  if (!snackbar) {
    const root = document.createElement("div");
    root.className = "-cbwsdk-css-reset";
    document.body.appendChild(root);
    snackbar = new Snackbar();
    snackbar.attach(root);
  }
  return snackbar;
}

// node_modules/@coinbase/wallet-sdk/dist/core/communicator/Communicator.js
var Communicator2 = class {
  constructor({ url: url2 = CB_KEYS_URL2, metadata, preference }) {
    this.popup = null;
    this.listeners = /* @__PURE__ */ new Map();
    this.postMessage = async (message) => {
      const popup = await this.waitForPopupLoaded();
      popup.postMessage(message, this.url.origin);
    };
    this.postRequestAndWaitForResponse = async (request2) => {
      const responsePromise = this.onMessage(({ requestId }) => requestId === request2.id);
      this.postMessage(request2);
      return await responsePromise;
    };
    this.onMessage = async (predicate) => {
      return new Promise((resolve, reject) => {
        const listener = (event) => {
          if (event.origin !== this.url.origin)
            return;
          const message = event.data;
          if (predicate(message)) {
            resolve(message);
            window.removeEventListener("message", listener);
            this.listeners.delete(listener);
          }
        };
        window.addEventListener("message", listener);
        this.listeners.set(listener, { reject });
      });
    };
    this.disconnect = () => {
      closePopup2(this.popup);
      this.popup = null;
      this.listeners.forEach(({ reject }, listener) => {
        reject(standardErrors2.provider.userRejectedRequest("Request rejected"));
        window.removeEventListener("message", listener);
      });
      this.listeners.clear();
    };
    this.waitForPopupLoaded = async () => {
      if (this.popup && !this.popup.closed) {
        this.popup.focus();
        return this.popup;
      }
      this.popup = await openPopup2(this.url);
      this.onMessage(({ event }) => event === "PopupUnload").then(this.disconnect).catch(() => {
      });
      return this.onMessage(({ event }) => event === "PopupLoaded").then((message) => {
        this.postMessage({
          requestId: message.id,
          data: {
            version: VERSION6,
            metadata: this.metadata,
            preference: this.preference,
            location: window.location.toString()
          }
        });
      }).then(() => {
        if (!this.popup)
          throw standardErrors2.rpc.internal();
        return this.popup;
      });
    };
    this.url = new URL(url2);
    this.metadata = metadata;
    this.preference = preference;
  }
};

// node_modules/@coinbase/wallet-sdk/dist/core/error/serialize.js
function serializeError2(error) {
  const serialized = serialize8(getErrorObject2(error), {
    shouldIncludeStack: true
  });
  const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  docUrl.searchParams.set("version", VERSION6);
  docUrl.searchParams.set("code", serialized.code.toString());
  docUrl.searchParams.set("message", serialized.message);
  return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
}
function getErrorObject2(error) {
  var _a14;
  if (typeof error === "string") {
    return {
      message: error,
      code: standardErrorCodes2.rpc.internal
    };
  } else if (isErrorResponse2(error)) {
    const message = error.errorMessage;
    const code = (_a14 = error.errorCode) !== null && _a14 !== void 0 ? _a14 : message.match(/(denied|rejected)/i) ? standardErrorCodes2.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, error), {
      message,
      code,
      data: { method: error.method }
    });
  }
  return error;
}

// node_modules/@coinbase/wallet-sdk/dist/core/provider/interface.js
var ProviderEventEmitter2 = class extends import_index.default {
};

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletProvider.js
var __rest6 = function(s5, e11) {
  var t6 = {};
  for (var p9 in s5) if (Object.prototype.hasOwnProperty.call(s5, p9) && e11.indexOf(p9) < 0)
    t6[p9] = s5[p9];
  if (s5 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i9 = 0, p9 = Object.getOwnPropertySymbols(s5); i9 < p9.length; i9++) {
      if (e11.indexOf(p9[i9]) < 0 && Object.prototype.propertyIsEnumerable.call(s5, p9[i9]))
        t6[p9[i9]] = s5[p9[i9]];
    }
  return t6;
};
var CoinbaseWalletProvider = class extends ProviderEventEmitter2 {
  constructor(_a14) {
    var { metadata } = _a14, _b = _a14.preference, { keysUrl } = _b, preference = __rest6(_b, ["keysUrl"]);
    super();
    this.signer = null;
    this.isCoinbaseWallet = true;
    this.metadata = metadata;
    this.preference = preference;
    this.communicator = new Communicator2({
      url: keysUrl,
      metadata,
      preference
    });
    const signerType = loadSignerType();
    if (signerType) {
      this.signer = this.initSigner(signerType);
    }
  }
  async request(args) {
    try {
      checkErrorForInvalidRequestArgs2(args);
      if (!this.signer) {
        switch (args.method) {
          case "eth_requestAccounts": {
            const signerType = await this.requestSignerSelection(args);
            const signer = this.initSigner(signerType);
            await signer.handshake(args);
            this.signer = signer;
            storeSignerType(signerType);
            break;
          }
          case "wallet_sendCalls": {
            const ephemeralSigner = this.initSigner("scw");
            await ephemeralSigner.handshake({ method: "handshake" });
            const result = await ephemeralSigner.request(args);
            await ephemeralSigner.cleanup();
            return result;
          }
          case "wallet_getCallsStatus":
            return fetchRPCRequest2(args, CB_WALLET_RPC_URL2);
          case "net_version":
            return 1;
          case "eth_chainId":
            return hexStringFromNumber2(1);
          default: {
            throw standardErrors2.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
          }
        }
      }
      return await this.signer.request(args);
    } catch (error) {
      const { code } = error;
      if (code === standardErrorCodes2.provider.unauthorized)
        this.disconnect();
      return Promise.reject(serializeError2(error));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    console.warn(`.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.`);
    return await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var _a14;
    await ((_a14 = this.signer) === null || _a14 === void 0 ? void 0 : _a14.cleanup());
    this.signer = null;
    ScopedLocalStorage.clearAll();
    this.emit("disconnect", standardErrors2.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(handshakeRequest) {
    return fetchSignerType({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest,
      callback: this.emit.bind(this)
    });
  }
  initSigner(signerType) {
    return createSigner({
      signerType,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
};

// node_modules/@coinbase/wallet-sdk/dist/util/validatePreferences.js
function validatePreferences2(preference) {
  if (!preference) {
    return;
  }
  if (!["all", "smartWalletOnly", "eoaOnly"].includes(preference.options)) {
    throw new Error(`Invalid options: ${preference.options}`);
  }
  if (preference.attribution) {
    if (preference.attribution.auto !== void 0 && preference.attribution.dataSuffix !== void 0) {
      throw new Error(`Attribution cannot contain both auto and dataSuffix properties`);
    }
  }
}

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
var CoinbaseWalletSDK = class {
  constructor(metadata) {
    this.metadata = {
      appName: metadata.appName || "Dapp",
      appLogoUrl: metadata.appLogoUrl || getFavicon(),
      appChainIds: metadata.appChainIds || []
    };
    this.storeLatestVersion();
    void checkCrossOriginOpenerPolicy2();
  }
  makeWeb3Provider(preference = { options: "all" }) {
    var _a14;
    validatePreferences2(preference);
    const params = { metadata: this.metadata, preference };
    return (_a14 = getCoinbaseInjectedProvider(params)) !== null && _a14 !== void 0 ? _a14 : new CoinbaseWalletProvider(params);
  }
  /**
   * Official Coinbase Wallet logo for developers to use on their frontend
   * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
   * @param width Width of the logo (Optional)
   * @returns SVG Data URI
   */
  getCoinbaseWalletLogo(type7, width = 240) {
    return walletLogo(type7, width);
  }
  storeLatestVersion() {
    const versionStorage = new ScopedLocalStorage("CBWSDK");
    versionStorage.setItem("VERSION", VERSION6);
  }
};

// node_modules/@dynamic-labs/ethereum/src/coinbase/helpers.js
var coinbaseProvider;
var baseSepolia3 = 84532;
var baseMainnet2 = 8453;
var getCoinbaseProvider = ({ appLogoUrl, appName, evmNetworks, walletPreference } = {}) => {
  const appChainIds = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.map((network) => Number(network.chainId));
  const hasBaseSepolia = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.some((network) => network.chainId === baseSepolia3);
  if (hasBaseSepolia) {
    appChainIds === null || appChainIds === void 0 ? void 0 : appChainIds.sort((a6, b6) => a6 === baseSepolia3 ? -1 : b6 === baseSepolia3 ? 1 : 0);
  }
  const hasBaseMainnet = evmNetworks === null || evmNetworks === void 0 ? void 0 : evmNetworks.some((network) => network.chainId === baseMainnet2);
  if (hasBaseMainnet) {
    appChainIds === null || appChainIds === void 0 ? void 0 : appChainIds.sort((a6, b6) => a6 === baseMainnet2 ? -1 : b6 === baseMainnet2 ? 1 : 0);
  }
  if (!coinbaseProvider) {
    const coinbaseSdk = new CoinbaseWalletSDK({
      appChainIds,
      appLogoUrl,
      appName
    });
    coinbaseProvider = coinbaseSdk.makeWeb3Provider({
      options: walletPreference !== null && walletPreference !== void 0 ? walletPreference : "all"
    });
  }
  return coinbaseProvider;
};

// node_modules/@dynamic-labs/ethereum/src/coinbase/coinbase.js
var Coinbase = class extends EthereumWalletConnector {
  constructor(_a14) {
    var { appName, appLogoUrl, evmNetworks, coinbaseWalletPreference } = _a14, props = __rest2(_a14, ["appName", "appLogoUrl", "evmNetworks", "coinbaseWalletPreference"]);
    super(Object.assign({ evmNetworks }, props));
    this.name = "Coinbase";
    this.overrideKey = "coinbase";
    this.canConnectViaQrCode = false;
    this.canConnectViaCustodialService = !this.isInstalledOnBrowser();
    this.coinbaseProviderOpts = {
      appLogoUrl,
      appName,
      evmNetworks,
      walletPreference: coinbaseWalletPreference
    };
  }
  get coinbaseProvider() {
    return getCoinbaseProvider(this.coinbaseProviderOpts);
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        const accounts = yield this.coinbaseProvider.request({
          method: "eth_accounts"
        });
        if (accounts[0]) {
          this.setActiveAccount(this.parseAddress(accounts[0]));
        }
        return accounts.map(this.parseAddress);
      } catch (error) {
        logger3.error("Error getting connected accounts", error);
        return [];
      }
    });
  }
  isInstalledOnBrowser() {
    var _a14, _b;
    return Boolean((_a14 = window === null || window === void 0 ? void 0 : window.coinbaseWalletExtension) === null || _a14 === void 0 ? void 0 : _a14.isCoinbaseWallet) || Boolean((_b = window === null || window === void 0 ? void 0 : window.ethereum) === null || _b === void 0 ? void 0 : _b.isCoinbaseWallet);
  }
  getAddress() {
    return __awaiter2(this, void 0, void 0, function* () {
      const didOpenInAppBrowser = this.openInAppBrowserIfRequired();
      if (didOpenInAppBrowser) {
        return;
      }
      const [address] = yield this.coinbaseProvider.request({
        method: "eth_requestAccounts"
      });
      const parsedAddress = this.parseAddress(address);
      this.setActiveAccount(parsedAddress);
      return parsedAddress;
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      const [address] = yield this.coinbaseProvider.request({
        method: "eth_requestAccounts"
      });
      const parsedAddress = this.parseAddress(address);
      try {
        return yield this.coinbaseProvider.request({
          method: "personal_sign",
          params: [toHex(toBytes(messageToSign)), parsedAddress]
        });
      } catch (err) {
        logger3.error("Error signing message", err);
        return void 0;
      }
    });
  }
  setupEventListeners() {
    const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
    this.coinbaseProvider.on("accountsChanged", handleAccountChange);
    this.coinbaseProvider.on("chainChanged", handleChainChange);
    this.coinbaseProvider.on("disconnect", handleDisconnect);
    this.teardownEventListeners = () => {
      this.coinbaseProvider.removeListener("accountsChanged", handleAccountChange);
      this.coinbaseProvider.removeListener("chainChanged", handleChainChange);
      this.coinbaseProvider.removeListener("disconnect", handleDisconnect);
    };
  }
  getWalletClient(chainId) {
    return createWalletClient({
      account: this.getActiveAccount(),
      chain: chainId ? chainsMap[chainId] : this.getActiveChain(),
      transport: custom(this.coinbaseProvider, this.providersConfig.httpTransportConfig)
    });
  }
};

// node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var import_debug4 = __toESM(require_browser2());
var import_sdk_analytics = __toESM(require_dist());
var import_eventemitter2 = __toESM(require_eventemitter2());

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues2;
var rnds82 = new Uint8Array(16);
function rng2() {
  if (!getRandomValues2) {
    getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues2) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues2(rnds82);
}

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/regex.js
var regex_default2 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/validate.js
function validate21(uuid) {
  return typeof uuid === "string" && regex_default2.test(uuid);
}
var validate_default2 = validate21;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex2 = [];
for (i9 = 0; i9 < 256; ++i9) {
  byteToHex2.push((i9 + 256).toString(16).substr(1));
}
var i9;
function stringify7(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex2[arr[offset + 0]] + byteToHex2[arr[offset + 1]] + byteToHex2[arr[offset + 2]] + byteToHex2[arr[offset + 3]] + "-" + byteToHex2[arr[offset + 4]] + byteToHex2[arr[offset + 5]] + "-" + byteToHex2[arr[offset + 6]] + byteToHex2[arr[offset + 7]] + "-" + byteToHex2[arr[offset + 8]] + byteToHex2[arr[offset + 9]] + "-" + byteToHex2[arr[offset + 10]] + byteToHex2[arr[offset + 11]] + byteToHex2[arr[offset + 12]] + byteToHex2[arr[offset + 13]] + byteToHex2[arr[offset + 14]] + byteToHex2[arr[offset + 15]]).toLowerCase();
  if (!validate_default2(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default2 = stringify7;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/parse.js
function parse4(uuid) {
  if (!validate_default2(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v9;
  var arr = new Uint8Array(16);
  arr[0] = (v9 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v9 >>> 16 & 255;
  arr[2] = v9 >>> 8 & 255;
  arr[3] = v9 & 255;
  arr[4] = (v9 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v9 & 255;
  arr[6] = (v9 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v9 & 255;
  arr[8] = (v9 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v9 & 255;
  arr[10] = (v9 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v9 / 4294967296 & 255;
  arr[12] = v9 >>> 24 & 255;
  arr[13] = v9 >>> 16 & 255;
  arr[14] = v9 >>> 8 & 255;
  arr[15] = v9 & 255;
  return arr;
}
var parse_default2 = parse4;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes4(str) {
  str = unescape(encodeURIComponent(str));
  var bytes2 = [];
  for (var i9 = 0; i9 < str.length; ++i9) {
    bytes2.push(str.charCodeAt(i9));
  }
  return bytes2;
}
var DNS2 = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL3 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version11, hashfunc) {
  function generateUUID2(value2, namespace, buf, offset) {
    if (typeof value2 === "string") {
      value2 = stringToBytes4(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse_default2(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes2 = new Uint8Array(16 + value2.length);
    bytes2.set(namespace);
    bytes2.set(value2, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version11;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i9 = 0; i9 < 16; ++i9) {
        buf[offset + i9] = bytes2[i9];
      }
      return buf;
    }
    return stringify_default2(bytes2);
  }
  try {
    generateUUID2.name = name;
  } catch (err) {
  }
  generateUUID2.DNS = DNS2;
  generateUUID2.URL = URL3;
  return generateUUID2;
}

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/md5.js
function md52(bytes2) {
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (var i9 = 0; i9 < msg.length; ++i9) {
      bytes2[i9] = msg.charCodeAt(i9);
    }
  }
  return md5ToHexEncodedArray(wordsToMd52(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output2 = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i9 = 0; i9 < length32; i9 += 8) {
    var x7 = input[i9 >> 5] >>> i9 % 32 & 255;
    var hex2 = parseInt(hexTab.charAt(x7 >>> 4 & 15) + hexTab.charAt(x7 & 15), 16);
    output2.push(hex2);
  }
  return output2;
}
function getOutputLength2(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd52(x7, len) {
  x7[len >> 5] |= 128 << len % 32;
  x7[getOutputLength2(len) - 1] = len;
  var a6 = 1732584193;
  var b6 = -271733879;
  var c9 = -1732584194;
  var d7 = 271733878;
  for (var i9 = 0; i9 < x7.length; i9 += 16) {
    var olda = a6;
    var oldb = b6;
    var oldc = c9;
    var oldd = d7;
    a6 = md5ff2(a6, b6, c9, d7, x7[i9], 7, -680876936);
    d7 = md5ff2(d7, a6, b6, c9, x7[i9 + 1], 12, -389564586);
    c9 = md5ff2(c9, d7, a6, b6, x7[i9 + 2], 17, 606105819);
    b6 = md5ff2(b6, c9, d7, a6, x7[i9 + 3], 22, -1044525330);
    a6 = md5ff2(a6, b6, c9, d7, x7[i9 + 4], 7, -176418897);
    d7 = md5ff2(d7, a6, b6, c9, x7[i9 + 5], 12, 1200080426);
    c9 = md5ff2(c9, d7, a6, b6, x7[i9 + 6], 17, -1473231341);
    b6 = md5ff2(b6, c9, d7, a6, x7[i9 + 7], 22, -45705983);
    a6 = md5ff2(a6, b6, c9, d7, x7[i9 + 8], 7, 1770035416);
    d7 = md5ff2(d7, a6, b6, c9, x7[i9 + 9], 12, -1958414417);
    c9 = md5ff2(c9, d7, a6, b6, x7[i9 + 10], 17, -42063);
    b6 = md5ff2(b6, c9, d7, a6, x7[i9 + 11], 22, -1990404162);
    a6 = md5ff2(a6, b6, c9, d7, x7[i9 + 12], 7, 1804603682);
    d7 = md5ff2(d7, a6, b6, c9, x7[i9 + 13], 12, -40341101);
    c9 = md5ff2(c9, d7, a6, b6, x7[i9 + 14], 17, -1502002290);
    b6 = md5ff2(b6, c9, d7, a6, x7[i9 + 15], 22, 1236535329);
    a6 = md5gg2(a6, b6, c9, d7, x7[i9 + 1], 5, -165796510);
    d7 = md5gg2(d7, a6, b6, c9, x7[i9 + 6], 9, -1069501632);
    c9 = md5gg2(c9, d7, a6, b6, x7[i9 + 11], 14, 643717713);
    b6 = md5gg2(b6, c9, d7, a6, x7[i9], 20, -373897302);
    a6 = md5gg2(a6, b6, c9, d7, x7[i9 + 5], 5, -701558691);
    d7 = md5gg2(d7, a6, b6, c9, x7[i9 + 10], 9, 38016083);
    c9 = md5gg2(c9, d7, a6, b6, x7[i9 + 15], 14, -660478335);
    b6 = md5gg2(b6, c9, d7, a6, x7[i9 + 4], 20, -405537848);
    a6 = md5gg2(a6, b6, c9, d7, x7[i9 + 9], 5, 568446438);
    d7 = md5gg2(d7, a6, b6, c9, x7[i9 + 14], 9, -1019803690);
    c9 = md5gg2(c9, d7, a6, b6, x7[i9 + 3], 14, -187363961);
    b6 = md5gg2(b6, c9, d7, a6, x7[i9 + 8], 20, 1163531501);
    a6 = md5gg2(a6, b6, c9, d7, x7[i9 + 13], 5, -1444681467);
    d7 = md5gg2(d7, a6, b6, c9, x7[i9 + 2], 9, -51403784);
    c9 = md5gg2(c9, d7, a6, b6, x7[i9 + 7], 14, 1735328473);
    b6 = md5gg2(b6, c9, d7, a6, x7[i9 + 12], 20, -1926607734);
    a6 = md5hh2(a6, b6, c9, d7, x7[i9 + 5], 4, -378558);
    d7 = md5hh2(d7, a6, b6, c9, x7[i9 + 8], 11, -2022574463);
    c9 = md5hh2(c9, d7, a6, b6, x7[i9 + 11], 16, 1839030562);
    b6 = md5hh2(b6, c9, d7, a6, x7[i9 + 14], 23, -35309556);
    a6 = md5hh2(a6, b6, c9, d7, x7[i9 + 1], 4, -1530992060);
    d7 = md5hh2(d7, a6, b6, c9, x7[i9 + 4], 11, 1272893353);
    c9 = md5hh2(c9, d7, a6, b6, x7[i9 + 7], 16, -155497632);
    b6 = md5hh2(b6, c9, d7, a6, x7[i9 + 10], 23, -1094730640);
    a6 = md5hh2(a6, b6, c9, d7, x7[i9 + 13], 4, 681279174);
    d7 = md5hh2(d7, a6, b6, c9, x7[i9], 11, -358537222);
    c9 = md5hh2(c9, d7, a6, b6, x7[i9 + 3], 16, -722521979);
    b6 = md5hh2(b6, c9, d7, a6, x7[i9 + 6], 23, 76029189);
    a6 = md5hh2(a6, b6, c9, d7, x7[i9 + 9], 4, -640364487);
    d7 = md5hh2(d7, a6, b6, c9, x7[i9 + 12], 11, -421815835);
    c9 = md5hh2(c9, d7, a6, b6, x7[i9 + 15], 16, 530742520);
    b6 = md5hh2(b6, c9, d7, a6, x7[i9 + 2], 23, -995338651);
    a6 = md5ii2(a6, b6, c9, d7, x7[i9], 6, -198630844);
    d7 = md5ii2(d7, a6, b6, c9, x7[i9 + 7], 10, 1126891415);
    c9 = md5ii2(c9, d7, a6, b6, x7[i9 + 14], 15, -1416354905);
    b6 = md5ii2(b6, c9, d7, a6, x7[i9 + 5], 21, -57434055);
    a6 = md5ii2(a6, b6, c9, d7, x7[i9 + 12], 6, 1700485571);
    d7 = md5ii2(d7, a6, b6, c9, x7[i9 + 3], 10, -1894986606);
    c9 = md5ii2(c9, d7, a6, b6, x7[i9 + 10], 15, -1051523);
    b6 = md5ii2(b6, c9, d7, a6, x7[i9 + 1], 21, -2054922799);
    a6 = md5ii2(a6, b6, c9, d7, x7[i9 + 8], 6, 1873313359);
    d7 = md5ii2(d7, a6, b6, c9, x7[i9 + 15], 10, -30611744);
    c9 = md5ii2(c9, d7, a6, b6, x7[i9 + 6], 15, -1560198380);
    b6 = md5ii2(b6, c9, d7, a6, x7[i9 + 13], 21, 1309151649);
    a6 = md5ii2(a6, b6, c9, d7, x7[i9 + 4], 6, -145523070);
    d7 = md5ii2(d7, a6, b6, c9, x7[i9 + 11], 10, -1120210379);
    c9 = md5ii2(c9, d7, a6, b6, x7[i9 + 2], 15, 718787259);
    b6 = md5ii2(b6, c9, d7, a6, x7[i9 + 9], 21, -343485551);
    a6 = safeAdd2(a6, olda);
    b6 = safeAdd2(b6, oldb);
    c9 = safeAdd2(c9, oldc);
    d7 = safeAdd2(d7, oldd);
  }
  return [a6, b6, c9, d7];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output2 = new Uint32Array(getOutputLength2(length8));
  for (var i9 = 0; i9 < length8; i9 += 8) {
    output2[i9 >> 5] |= (input[i9 / 8] & 255) << i9 % 32;
  }
  return output2;
}
function safeAdd2(x7, y11) {
  var lsw = (x7 & 65535) + (y11 & 65535);
  var msw = (x7 >> 16) + (y11 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft2(num3, cnt) {
  return num3 << cnt | num3 >>> 32 - cnt;
}
function md5cmn2(q6, a6, b6, x7, s5, t6) {
  return safeAdd2(bitRotateLeft2(safeAdd2(safeAdd2(a6, q6), safeAdd2(x7, t6)), s5), b6);
}
function md5ff2(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn2(b6 & c9 | ~b6 & d7, a6, b6, x7, s5, t6);
}
function md5gg2(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn2(b6 & d7 | c9 & ~d7, a6, b6, x7, s5, t6);
}
function md5hh2(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn2(b6 ^ c9 ^ d7, a6, b6, x7, s5, t6);
}
function md5ii2(a6, b6, c9, d7, x7, s5, t6) {
  return md5cmn2(c9 ^ (b6 | ~d7), a6, b6, x7, s5, t6);
}
var md5_default2 = md52;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v3.js
var v33 = v35_default("v3", 48, md5_default2);

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v4.js
function v43(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng2)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i9 = 0; i9 < 16; ++i9) {
      buf[offset + i9] = rnds[i9];
    }
    return buf;
  }
  return stringify_default2(rnds);
}
var v4_default2 = v43;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/sha1.js
function f14(s5, x7, y11, z9) {
  switch (s5) {
    case 0:
      return x7 & y11 ^ ~x7 & z9;
    case 1:
      return x7 ^ y11 ^ z9;
    case 2:
      return x7 & y11 ^ x7 & z9 ^ y11 & z9;
    case 3:
      return x7 ^ y11 ^ z9;
  }
}
function ROTL2(x7, n5) {
  return x7 << n5 | x7 >>> 32 - n5;
}
function sha12(bytes2) {
  var K5 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    var msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (var i9 = 0; i9 < msg.length; ++i9) {
      bytes2.push(msg.charCodeAt(i9));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  var l9 = bytes2.length / 4 + 2;
  var N9 = Math.ceil(l9 / 16);
  var M8 = new Array(N9);
  for (var _i4 = 0; _i4 < N9; ++_i4) {
    var arr = new Uint32Array(16);
    for (var j9 = 0; j9 < 16; ++j9) {
      arr[j9] = bytes2[_i4 * 64 + j9 * 4] << 24 | bytes2[_i4 * 64 + j9 * 4 + 1] << 16 | bytes2[_i4 * 64 + j9 * 4 + 2] << 8 | bytes2[_i4 * 64 + j9 * 4 + 3];
    }
    M8[_i4] = arr;
  }
  M8[N9 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M8[N9 - 1][14] = Math.floor(M8[N9 - 1][14]);
  M8[N9 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (var _i22 = 0; _i22 < N9; ++_i22) {
    var W6 = new Uint32Array(80);
    for (var t6 = 0; t6 < 16; ++t6) {
      W6[t6] = M8[_i22][t6];
    }
    for (var _t4 = 16; _t4 < 80; ++_t4) {
      W6[_t4] = ROTL2(W6[_t4 - 3] ^ W6[_t4 - 8] ^ W6[_t4 - 14] ^ W6[_t4 - 16], 1);
    }
    var a6 = H4[0];
    var b6 = H4[1];
    var c9 = H4[2];
    var d7 = H4[3];
    var e11 = H4[4];
    for (var _t22 = 0; _t22 < 80; ++_t22) {
      var s5 = Math.floor(_t22 / 20);
      var T8 = ROTL2(a6, 5) + f14(s5, b6, c9, d7) + e11 + K5[s5] + W6[_t22] >>> 0;
      e11 = d7;
      d7 = c9;
      c9 = ROTL2(b6, 30) >>> 0;
      b6 = a6;
      a6 = T8;
    }
    H4[0] = H4[0] + a6 >>> 0;
    H4[1] = H4[1] + b6 >>> 0;
    H4[2] = H4[2] + c9 >>> 0;
    H4[3] = H4[3] + d7 >>> 0;
    H4[4] = H4[4] + e11 >>> 0;
  }
  return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
}
var sha1_default2 = sha12;

// node_modules/@metamask/sdk/node_modules/uuid/dist/esm-browser/v5.js
var v53 = v35_default("v5", 80, sha1_default2);

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type: type7, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type7] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray4(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray4).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray4(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}

// node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup4 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i9 = 0; i9 < chars.length; i9++) {
  lookup4[chars.charCodeAt(i9)] = i9;
}
var decode8 = (base642) => {
  let bufferLength = base642.length * 0.75, len = base642.length, i9, p9 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i9 = 0; i9 < len; i9 += 4) {
    encoded1 = lookup4[base642.charCodeAt(i9)];
    encoded2 = lookup4[base642.charCodeAt(i9 + 1)];
    encoded3 = lookup4[base642.charCodeAt(i9 + 2)];
    encoded4 = lookup4[base642.charCodeAt(i9 + 3)];
    bytes2[p9++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p9++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p9++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type7 = encodedPacket.charAt(0);
  if (type7 === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type7];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type7],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type7]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode8(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};

// node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i9) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i9] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i9 = 0; i9 < encodedPackets.length; i9++) {
    const decodedPacket = decodePacket(encodedPackets[i9], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size11) {
  if (chunks[0].length === size11) {
    return chunks.shift();
  }
  const buffer2 = new Uint8Array(size11);
  let j9 = 0;
  for (let i9 = 0; i9 < size11; i9++) {
    buffer2[i9] = chunks[0][j9++];
    if (j9 === chunks[0].length) {
      chunks.shift();
      j9 = 0;
    }
  }
  if (chunks.length && j9 < chunks[0].length) {
    chunks[0] = chunks[0].slice(j9);
  }
  return buffer2;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n5 = view.getUint32(0);
          if (n5 > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n5 * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var protocol = 4;

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn4) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn4);
  return this;
};
Emitter.prototype.once = function(event, fn4) {
  function on5() {
    this.off(event, on5);
    fn4.apply(this, arguments);
  }
  on5.fn = fn4;
  this.on(event, on5);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn4) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i9 = 0; i9 < callbacks.length; i9++) {
    cb = callbacks[i9];
    if (cb === fn4 || cb.fn === fn4) {
      callbacks.splice(i9, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i9 = 1; i9 < arguments.length; i9++) {
    args[i9 - 1] = arguments[i9];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i9 = 0, len = callbacks.length; i9 < len; ++i9) {
      callbacks[i9].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// node_modules/engine.io-client/build/esm/globals.js
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
var defaultBinaryType = "arraybuffer";
function createCookieJar() {
}

// node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k11) => {
    if (obj.hasOwnProperty(k11)) {
      acc[k11] = obj[k11];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts2) {
  if (opts2.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c9 = 0, length = 0;
  for (let i9 = 0, l9 = str.length; i9 < l9; i9++) {
    c9 = str.charCodeAt(i9);
    if (c9 < 128) {
      length += 1;
    } else if (c9 < 2048) {
      length += 2;
    } else if (c9 < 55296 || c9 >= 57344) {
      length += 3;
    } else {
      i9++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}

// node_modules/engine.io-client/build/esm/contrib/parseqs.js
function encode19(obj) {
  let str = "";
  for (let i9 in obj) {
    if (obj.hasOwnProperty(i9)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i9) + "=" + encodeURIComponent(obj[i9]);
    }
  }
  return str;
}
function decode9(qs3) {
  let qry = {};
  let pairs = qs3.split("&");
  for (let i9 = 0, l9 = pairs.length; i9 < l9; i9++) {
    let pair = pairs[i9].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts2) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts2);
    this.opts = opts2;
    this.query = opts2.query;
    this.socket = opts2.socket;
    this.supportsBinary = !opts2.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode19(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};

// node_modules/engine.io-client/build/esm/transports/polling.js
var Polling = class extends Transport {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};

// node_modules/engine.io-client/build/esm/contrib/has-cors.js
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value;

// node_modules/engine.io-client/build/esm/transports/polling-xhr.js
function empty5() {
}
var BaseXHR = class extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts2) {
    super(opts2);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts2.hostname !== location.hostname || port !== opts2.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn4) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn4);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request2 = class _Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts2) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts2);
    this._opts = opts2;
    this._method = opts2.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts2.data ? opts2.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a14;
    const opts2 = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts2.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts2);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i9 in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i9)) {
              xhr.setRequestHeader(i9, this._opts.extraHeaders[i9]);
            }
          }
        }
      } catch (e11) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e11) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e11) {
      }
      (_a14 = this._opts.cookieJar) === null || _a14 === void 0 ? void 0 : _a14.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a15;
        if (xhr.readyState === 3) {
          (_a15 = this._opts.cookieJar) === null || _a15 === void 0 ? void 0 : _a15.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e11) {
      this.setTimeoutFn(() => {
        this._onError(e11);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = _Request.requestsCount++;
      _Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty5;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e11) {
      }
    }
    if (typeof document !== "undefined") {
      delete _Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
};
Request2.requestsCount = 0;
Request2.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i9 in Request2.requests) {
    if (Request2.requests.hasOwnProperty(i9)) {
      Request2.requests[i9].abort();
    }
  }
}
var hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
var XHR = class extends BaseXHR {
  constructor(opts2) {
    super(opts2);
    const forceBase64 = opts2 && opts2.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts2 = {}) {
    Object.assign(opts2, { xd: this.xd }, this.opts);
    return new Request2(newRequest, this.uri(), opts2);
  }
};
function newRequest(opts2) {
  const xdomain = opts2.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e11) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e11) {
    }
  }
}

// node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var BaseWS = class extends Transport {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts2 = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts2.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts2);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e11) => this.onError("websocket error", e11);
  }
  write(packets) {
    this.writable = false;
    for (let i9 = 0; i9 < packets.length; i9++) {
      const packet = packets[i9];
      const lastPacket = i9 === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e11) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
};
var WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var WS = class extends BaseWS {
  createSocket(uri, protocols, opts2) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts2);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
};

// node_modules/engine.io-client/build/esm/transports/webtransport.js
var WT = class extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i9 = 0; i9 < packets.length; i9++) {
      const packet = packets[i9];
      const lastPacket = i9 === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a14;
    (_a14 = this._transport) === null || _a14 === void 0 ? void 0 : _a14.close();
  }
};

// node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};

// node_modules/engine.io-client/build/esm/contrib/parseuri.js
var re3 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse5(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b6 = str.indexOf("["), e11 = str.indexOf("]");
  if (b6 != -1 && e11 != -1) {
    str = str.substring(0, b6) + str.substring(b6, e11).replace(/:/g, ";") + str.substring(e11, str.length);
  }
  let m6 = re3.exec(str || ""), uri = {}, i9 = 14;
  while (i9--) {
    uri[parts[i9]] = m6[i9] || "";
  }
  if (b6 != -1 && e11 != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path2) {
  const regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
  if (path2.slice(0, 1) == "/" || path2.length === 0) {
    names.splice(0, 1);
  }
  if (path2.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $22) {
    if ($1) {
      data[$1] = $22;
    }
  });
  return data;
}

// node_modules/engine.io-client/build/esm/socket.js
var withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
var OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
var SocketWithoutUpgrade = class _SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts2) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts2 = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse5(uri);
      opts2.hostname = parsedUri.host;
      opts2.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts2.port = parsedUri.port;
      if (parsedUri.query)
        opts2.query = parsedUri.query;
    } else if (opts2.host) {
      opts2.hostname = parse5(opts2.host).host;
    }
    installTimerFunctions(this, opts2);
    this.secure = null != opts2.secure ? opts2.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts2.hostname && !opts2.port) {
      opts2.port = this.secure ? "443" : "80";
    }
    this.hostname = opts2.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts2.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts2.transports.forEach((t6) => {
      const transportName = t6.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t6;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts2);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode9(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts2 = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts2);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && _SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    _SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i9 = 0; i9 < this.writeBuffer.length; i9++) {
      const data = this.writeBuffer[i9].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i9 > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i9);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn4) {
    this._sendPacket("message", msg, options, fn4);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn4) {
    this._sendPacket("message", msg, options, fn4);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type7, data, options, fn4) {
    if ("function" === typeof data) {
      fn4 = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn4 = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type: type7,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn4)
      this.once("flush", fn4);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    _SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i9 = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i9 !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i9, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
};
SocketWithoutUpgrade.protocol = protocol;
var SocketWithUpgrade = class extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i9 = 0; i9 < this._upgrades.length; i9++) {
        this._probe(this._upgrades[i9]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to6) {
      if (transport && to6.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i9 = 0; i9 < upgrades.length; i9++) {
      if (~this.transports.indexOf(upgrades[i9]))
        filteredUpgrades.push(upgrades[i9]);
    }
    return filteredUpgrades;
  }
};
var Socket = class extends SocketWithUpgrade {
  constructor(uri, opts2 = {}) {
    const o6 = typeof uri === "object" ? uri : opts2;
    if (!o6.transports || o6.transports && typeof o6.transports[0] === "string") {
      o6.transports = (o6.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t6) => !!t6);
    }
    super(uri, o6);
  }
};

// node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// node_modules/socket.io-client/build/esm/url.js
function url(uri, path2 = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse5(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// node_modules/socket.io-parser/build/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  Decoder: () => Decoder2,
  Encoder: () => Encoder2,
  PacketType: () => PacketType,
  protocol: () => protocol3
});

// node_modules/socket.io-parser/build/esm/is-binary.js
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString12 = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString12.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString12.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON3) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i9 = 0, l9 = obj.length; i9 < l9; i9++) {
      if (hasBinary(obj[i9])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i9 = 0; i9 < data.length; i9++) {
      newData[i9] = _deconstructPacket(data[i9], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i9 = 0; i9 < data.length; i9++) {
      data[i9] = _reconstructPacket(data[i9], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// node_modules/socket.io-parser/build/esm/index.js
var RESERVED_EVENTS = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder2 = class {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
function isObject4(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
var Decoder2 = class _Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i9 = 0;
    const p9 = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p9.type] === void 0) {
      throw new Error("unknown packet type " + p9.type);
    }
    if (p9.type === PacketType.BINARY_EVENT || p9.type === PacketType.BINARY_ACK) {
      const start = i9 + 1;
      while (str.charAt(++i9) !== "-" && i9 != str.length) {
      }
      const buf = str.substring(start, i9);
      if (buf != Number(buf) || str.charAt(i9) !== "-") {
        throw new Error("Illegal attachments");
      }
      p9.attachments = Number(buf);
    }
    if ("/" === str.charAt(i9 + 1)) {
      const start = i9 + 1;
      while (++i9) {
        const c9 = str.charAt(i9);
        if ("," === c9)
          break;
        if (i9 === str.length)
          break;
      }
      p9.nsp = str.substring(start, i9);
    } else {
      p9.nsp = "/";
    }
    const next = str.charAt(i9 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i9 + 1;
      while (++i9) {
        const c9 = str.charAt(i9);
        if (null == c9 || Number(c9) != c9) {
          --i9;
          break;
        }
        if (i9 === str.length)
          break;
      }
      p9.id = Number(str.substring(start, i9 + 1));
    }
    if (str.charAt(++i9)) {
      const payload = this.tryParse(str.substr(i9));
      if (_Decoder.isPayloadValid(p9.type, payload)) {
        p9.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p9;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e11) {
      return false;
    }
  }
  static isPayloadValid(type7, payload) {
    switch (type7) {
      case PacketType.CONNECT:
        return isObject4(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject4(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// node_modules/socket.io-client/build/esm/on.js
function on3(obj, ev, fn4) {
  obj.on(ev, fn4);
  return function subDestroy() {
    obj.off(ev, fn4);
  };
}

// node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS2 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io4, nsp, opts2) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io4;
    this.nsp = nsp;
    if (opts2 && opts2.auth) {
      this.auth = opts2.auth;
    }
    this._opts = Object.assign({}, opts2);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io4 = this.io;
    this.subs = [
      on3(io4, "open", this.onopen.bind(this)),
      on3(io4, "packet", this.onpacket.bind(this)),
      on3(io4, "error", this.onerror.bind(this)),
      on3(io4, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a14, _b, _c3;
    if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id2 = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id2, ack);
      packet.id = id2;
    }
    const isTransportWritable = (_b = (_a14 = this.io.engine) === null || _a14 === void 0 ? void 0 : _a14.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c3 = this.io.engine) === null || _c3 === void 0 ? void 0 : _c3._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) {
    } else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id2, ack) {
    var _a14;
    const timeout = (_a14 = this.flags.timeout) !== null && _a14 !== void 0 ? _a14 : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id2] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id2];
      for (let i9 = 0; i9 < this.sendBuffer.length; i9++) {
        if (this.sendBuffer[i9].id === id2) {
          this.sendBuffer.splice(i9, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn4 = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn4.withError = true;
    this.acks[id2] = fn4;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn4 = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn4.withError = true;
      args.push(fn4);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id2) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id2);
      if (!isBuffered) {
        const ack = this.acks[id2];
        delete this.acks[id2];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id2) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id: id2,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id2, pid) {
    this.id = id2;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress4) {
    this.flags.compress = compress4;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i9 = 0; i9 < listeners.length; i9++) {
        if (listener === listeners[i9]) {
          listeners.splice(i9, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i9 = 0; i9 < listeners.length; i9++) {
        if (listener === listeners[i9]) {
          listeners.splice(i9, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// node_modules/socket.io-client/build/esm/contrib/backo2.js
function Backoff(opts2) {
  opts2 = opts2 || {};
  this.ms = opts2.min || 100;
  this.max = opts2.max || 1e4;
  this.factor = opts2.factor || 2;
  this.jitter = opts2.jitter > 0 && opts2.jitter <= 1 ? opts2.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms3 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms3);
    ms3 = (Math.floor(rand * 10) & 1) == 0 ? ms3 - deviation : ms3 + deviation;
  }
  return Math.min(ms3, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min4) {
  this.ms = min4;
};
Backoff.prototype.setMax = function(max4) {
  this.max = max4;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts2) {
    var _a14;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts2 = uri;
      uri = void 0;
    }
    opts2 = opts2 || {};
    opts2.path = opts2.path || "/socket.io";
    this.opts = opts2;
    installTimerFunctions(this, opts2);
    this.reconnection(opts2.reconnection !== false);
    this.reconnectionAttempts(opts2.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts2.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts2.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a14 = opts2.randomizationFactor) !== null && _a14 !== void 0 ? _a14 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts2.timeout ? 2e4 : opts2.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts2.parser || esm_exports2;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts2.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v9) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v9;
    if (!v9) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v9) {
    if (v9 === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v9;
    return this;
  }
  reconnectionDelay(v9) {
    var _a14;
    if (v9 === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v9;
    (_a14 = this.backoff) === null || _a14 === void 0 ? void 0 : _a14.setMin(v9);
    return this;
  }
  randomizationFactor(v9) {
    var _a14;
    if (v9 === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v9;
    (_a14 = this.backoff) === null || _a14 === void 0 ? void 0 : _a14.setJitter(v9);
    return this;
  }
  reconnectionDelayMax(v9) {
    var _a14;
    if (v9 === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v9;
    (_a14 = this.backoff) === null || _a14 === void 0 ? void 0 : _a14.setMax(v9);
    return this;
  }
  timeout(v9) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v9;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn4) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on3(socket, "open", function() {
      self2.onopen();
      fn4 && fn4();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn4) {
        fn4(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on3(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn4) {
    return this.open(fn4);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on3(socket, "ping", this.onping.bind(this)),
      on3(socket, "data", this.ondata.bind(this)),
      on3(socket, "error", this.onerror.bind(this)),
      on3(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on3(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e11) {
      this.onclose("parse error", e11);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts2) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts2);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i9 = 0; i9 < encodedPackets.length; i9++) {
      this.engine.write(encodedPackets[i9], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a14;
    this.cleanup();
    (_a14 = this.engine) === null || _a14 === void 0 ? void 0 : _a14.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup5(uri, opts2) {
  if (typeof uri === "object") {
    opts2 = uri;
    uri = void 0;
  }
  opts2 = opts2 || {};
  const parsed = url(uri, opts2.path || "/socket.io");
  const source = parsed.source;
  const id2 = parsed.id;
  const path2 = parsed.path;
  const sameNamespace = cache[id2] && path2 in cache[id2]["nsps"];
  const newConnection = opts2.forceNew || opts2["force new connection"] || false === opts2.multiplex || sameNamespace;
  let io4;
  if (newConnection) {
    io4 = new Manager(source, opts2);
  } else {
    if (!cache[id2]) {
      cache[id2] = new Manager(source, opts2);
    }
    io4 = cache[id2];
  }
  if (parsed.query && !opts2.query) {
    opts2.query = parsed.queryKey;
  }
  return io4.socket(parsed.path, opts2);
}
Object.assign(lookup5, {
  Manager,
  Socket: Socket2,
  io: lookup5,
  connect: lookup5
});

// import("./**/*.entry.js") in node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
var globImport_entry_js = __glob({});

// node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js
function c8(e11, t6, n5, r8) {
  return new (n5 || (n5 = Promise))(function(i9, o6) {
    function s5(e12) {
      try {
        c9(r8.next(e12));
      } catch (e13) {
        o6(e13);
      }
    }
    function a6(e12) {
      try {
        c9(r8.throw(e12));
      } catch (e13) {
        o6(e13);
      }
    }
    function c9(e12) {
      var t7;
      e12.done ? i9(e12.value) : (t7 = e12.value, t7 instanceof n5 ? t7 : new n5(function(e13) {
        e13(t7);
      })).then(s5, a6);
    }
    c9((r8 = r8.apply(e11, t6 || [])).next());
  });
}
var l8 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
var d6 = [];
var u9 = [];
var h8 = "undefined" != typeof Uint8Array ? Uint8Array : Array;
var f15 = false;
function p8() {
  f15 = true;
  for (var e11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t6 = 0; t6 < 64; ++t6) d6[t6] = e11[t6], u9[e11.charCodeAt(t6)] = t6;
  u9["-".charCodeAt(0)] = 62, u9["_".charCodeAt(0)] = 63;
}
function g3(e11, t6, n5) {
  for (var r8, i9, o6 = [], s5 = t6; s5 < n5; s5 += 3) r8 = (e11[s5] << 16) + (e11[s5 + 1] << 8) + e11[s5 + 2], o6.push(d6[(i9 = r8) >> 18 & 63] + d6[i9 >> 12 & 63] + d6[i9 >> 6 & 63] + d6[63 & i9]);
  return o6.join("");
}
function m5(e11) {
  var t6;
  f15 || p8();
  for (var n5 = e11.length, r8 = n5 % 3, i9 = "", o6 = [], s5 = 16383, a6 = 0, c9 = n5 - r8; a6 < c9; a6 += s5) o6.push(g3(e11, a6, a6 + s5 > c9 ? c9 : a6 + s5));
  return 1 === r8 ? (t6 = e11[n5 - 1], i9 += d6[t6 >> 2], i9 += d6[t6 << 4 & 63], i9 += "==") : 2 === r8 && (t6 = (e11[n5 - 2] << 8) + e11[n5 - 1], i9 += d6[t6 >> 10], i9 += d6[t6 >> 4 & 63], i9 += d6[t6 << 2 & 63], i9 += "="), o6.push(i9), o6.join("");
}
function y10(e11, t6, n5, r8, i9) {
  var o6, s5, a6 = 8 * i9 - r8 - 1, c9 = (1 << a6) - 1, l9 = c9 >> 1, d7 = -7, u10 = n5 ? i9 - 1 : 0, h9 = n5 ? -1 : 1, f16 = e11[t6 + u10];
  for (u10 += h9, o6 = f16 & (1 << -d7) - 1, f16 >>= -d7, d7 += a6; d7 > 0; o6 = 256 * o6 + e11[t6 + u10], u10 += h9, d7 -= 8) ;
  for (s5 = o6 & (1 << -d7) - 1, o6 >>= -d7, d7 += r8; d7 > 0; s5 = 256 * s5 + e11[t6 + u10], u10 += h9, d7 -= 8) ;
  if (0 === o6) o6 = 1 - l9;
  else {
    if (o6 === c9) return s5 ? NaN : 1 / 0 * (f16 ? -1 : 1);
    s5 += Math.pow(2, r8), o6 -= l9;
  }
  return (f16 ? -1 : 1) * s5 * Math.pow(2, o6 - r8);
}
function v8(e11, t6, n5, r8, i9, o6) {
  var s5, a6, c9, l9 = 8 * o6 - i9 - 1, d7 = (1 << l9) - 1, u10 = d7 >> 1, h9 = 23 === i9 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f16 = r8 ? 0 : o6 - 1, p9 = r8 ? 1 : -1, g4 = t6 < 0 || 0 === t6 && 1 / t6 < 0 ? 1 : 0;
  for (t6 = Math.abs(t6), isNaN(t6) || t6 === 1 / 0 ? (a6 = isNaN(t6) ? 1 : 0, s5 = d7) : (s5 = Math.floor(Math.log(t6) / Math.LN2), t6 * (c9 = Math.pow(2, -s5)) < 1 && (s5--, c9 *= 2), (t6 += s5 + u10 >= 1 ? h9 / c9 : h9 * Math.pow(2, 1 - u10)) * c9 >= 2 && (s5++, c9 /= 2), s5 + u10 >= d7 ? (a6 = 0, s5 = d7) : s5 + u10 >= 1 ? (a6 = (t6 * c9 - 1) * Math.pow(2, i9), s5 += u10) : (a6 = t6 * Math.pow(2, u10 - 1) * Math.pow(2, i9), s5 = 0)); i9 >= 8; e11[n5 + f16] = 255 & a6, f16 += p9, a6 /= 256, i9 -= 8) ;
  for (s5 = s5 << i9 | a6, l9 += i9; l9 > 0; e11[n5 + f16] = 255 & s5, f16 += p9, s5 /= 256, l9 -= 8) ;
  e11[n5 + f16 - p9] |= 128 * g4;
}
var b5 = {}.toString;
var w7 = Array.isArray || function(e11) {
  return "[object Array]" == b5.call(e11);
};
C9.TYPED_ARRAY_SUPPORT = void 0 === l8.TYPED_ARRAY_SUPPORT || l8.TYPED_ARRAY_SUPPORT;
var E7 = S7();
function S7() {
  return C9.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function _5(e11, t6) {
  if (S7() < t6) throw new RangeError("Invalid typed array length");
  return C9.TYPED_ARRAY_SUPPORT ? (e11 = new Uint8Array(t6)).__proto__ = C9.prototype : (null === e11 && (e11 = new C9(t6)), e11.length = t6), e11;
}
function C9(e11, t6, n5) {
  if (!(C9.TYPED_ARRAY_SUPPORT || this instanceof C9)) return new C9(e11, t6, n5);
  if ("number" == typeof e11) {
    if ("string" == typeof t6) throw new Error("If encoding is specified then the first argument must be a string");
    return x6(this, e11);
  }
  return k10(this, e11, t6, n5);
}
function k10(e11, t6, n5, r8) {
  if ("number" == typeof t6) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t6 instanceof ArrayBuffer ? function(e12, t7, n6, r9) {
    if (t7.byteLength, n6 < 0 || t7.byteLength < n6) throw new RangeError("'offset' is out of bounds");
    if (t7.byteLength < n6 + (r9 || 0)) throw new RangeError("'length' is out of bounds");
    t7 = void 0 === n6 && void 0 === r9 ? new Uint8Array(t7) : void 0 === r9 ? new Uint8Array(t7, n6) : new Uint8Array(t7, n6, r9);
    C9.TYPED_ARRAY_SUPPORT ? (e12 = t7).__proto__ = C9.prototype : e12 = M7(e12, t7);
    return e12;
  }(e11, t6, n5, r8) : "string" == typeof t6 ? function(e12, t7, n6) {
    "string" == typeof n6 && "" !== n6 || (n6 = "utf8");
    if (!C9.isEncoding(n6)) throw new TypeError('"encoding" must be a valid string encoding');
    var r9 = 0 | R5(t7, n6);
    e12 = _5(e12, r9);
    var i9 = e12.write(t7, n6);
    i9 !== r9 && (e12 = e12.slice(0, i9));
    return e12;
  }(e11, t6, n5) : function(e12, t7) {
    if (T7(t7)) {
      var n6 = 0 | I7(t7.length);
      return 0 === (e12 = _5(e12, n6)).length || t7.copy(e12, 0, 0, n6), e12;
    }
    if (t7) {
      if ("undefined" != typeof ArrayBuffer && t7.buffer instanceof ArrayBuffer || "length" in t7) return "number" != typeof t7.length || (r9 = t7.length) != r9 ? _5(e12, 0) : M7(e12, t7);
      if ("Buffer" === t7.type && w7(t7.data)) return M7(e12, t7.data);
    }
    var r9;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(e11, t6);
}
function A8(e11) {
  if ("number" != typeof e11) throw new TypeError('"size" argument must be a number');
  if (e11 < 0) throw new RangeError('"size" argument must not be negative');
}
function x6(e11, t6) {
  if (A8(t6), e11 = _5(e11, t6 < 0 ? 0 : 0 | I7(t6)), !C9.TYPED_ARRAY_SUPPORT) for (var n5 = 0; n5 < t6; ++n5) e11[n5] = 0;
  return e11;
}
function M7(e11, t6) {
  var n5 = t6.length < 0 ? 0 : 0 | I7(t6.length);
  e11 = _5(e11, n5);
  for (var r8 = 0; r8 < n5; r8 += 1) e11[r8] = 255 & t6[r8];
  return e11;
}
function I7(e11) {
  if (e11 >= S7()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S7().toString(16) + " bytes");
  return 0 | e11;
}
function T7(e11) {
  return !(null == e11 || !e11._isBuffer);
}
function R5(e11, t6) {
  if (T7(e11)) return e11.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e11) || e11 instanceof ArrayBuffer)) return e11.byteLength;
  "string" != typeof e11 && (e11 = "" + e11);
  var n5 = e11.length;
  if (0 === n5) return 0;
  for (var r8 = false; ; ) switch (t6) {
    case "ascii":
    case "latin1":
    case "binary":
      return n5;
    case "utf8":
    case "utf-8":
    case void 0:
      return ie4(e11).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * n5;
    case "hex":
      return n5 >>> 1;
    case "base64":
      return oe2(e11).length;
    default:
      if (r8) return ie4(e11).length;
      t6 = ("" + t6).toLowerCase(), r8 = true;
  }
}
function P6(e11, t6, n5) {
  var r8 = false;
  if ((void 0 === t6 || t6 < 0) && (t6 = 0), t6 > this.length) return "";
  if ((void 0 === n5 || n5 > this.length) && (n5 = this.length), n5 <= 0) return "";
  if ((n5 >>>= 0) <= (t6 >>>= 0)) return "";
  for (e11 || (e11 = "utf8"); ; ) switch (e11) {
    case "hex":
      return V7(this, t6, n5);
    case "utf8":
    case "utf-8":
      return F7(this, t6, n5);
    case "ascii":
      return q5(this, t6, n5);
    case "latin1":
    case "binary":
      return W5(this, t6, n5);
    case "base64":
      return H3(this, t6, n5);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return G6(this, t6, n5);
    default:
      if (r8) throw new TypeError("Unknown encoding: " + e11);
      e11 = (e11 + "").toLowerCase(), r8 = true;
  }
}
function O7(e11, t6, n5) {
  var r8 = e11[t6];
  e11[t6] = e11[n5], e11[n5] = r8;
}
function N8(e11, t6, n5, r8, i9) {
  if (0 === e11.length) return -1;
  if ("string" == typeof n5 ? (r8 = n5, n5 = 0) : n5 > 2147483647 ? n5 = 2147483647 : n5 < -2147483648 && (n5 = -2147483648), n5 = +n5, isNaN(n5) && (n5 = i9 ? 0 : e11.length - 1), n5 < 0 && (n5 = e11.length + n5), n5 >= e11.length) {
    if (i9) return -1;
    n5 = e11.length - 1;
  } else if (n5 < 0) {
    if (!i9) return -1;
    n5 = 0;
  }
  if ("string" == typeof t6 && (t6 = C9.from(t6, r8)), T7(t6)) return 0 === t6.length ? -1 : L6(e11, t6, n5, r8, i9);
  if ("number" == typeof t6) return t6 &= 255, C9.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i9 ? Uint8Array.prototype.indexOf.call(e11, t6, n5) : Uint8Array.prototype.lastIndexOf.call(e11, t6, n5) : L6(e11, [t6], n5, r8, i9);
  throw new TypeError("val must be string, number or Buffer");
}
function L6(e11, t6, n5, r8, i9) {
  var o6, s5 = 1, a6 = e11.length, c9 = t6.length;
  if (void 0 !== r8 && ("ucs2" === (r8 = String(r8).toLowerCase()) || "ucs-2" === r8 || "utf16le" === r8 || "utf-16le" === r8)) {
    if (e11.length < 2 || t6.length < 2) return -1;
    s5 = 2, a6 /= 2, c9 /= 2, n5 /= 2;
  }
  function l9(e12, t7) {
    return 1 === s5 ? e12[t7] : e12.readUInt16BE(t7 * s5);
  }
  if (i9) {
    var d7 = -1;
    for (o6 = n5; o6 < a6; o6++) if (l9(e11, o6) === l9(t6, -1 === d7 ? 0 : o6 - d7)) {
      if (-1 === d7 && (d7 = o6), o6 - d7 + 1 === c9) return d7 * s5;
    } else -1 !== d7 && (o6 -= o6 - d7), d7 = -1;
  } else for (n5 + c9 > a6 && (n5 = a6 - c9), o6 = n5; o6 >= 0; o6--) {
    for (var u10 = true, h9 = 0; h9 < c9; h9++) if (l9(e11, o6 + h9) !== l9(t6, h9)) {
      u10 = false;
      break;
    }
    if (u10) return o6;
  }
  return -1;
}
function D8(e11, t6, n5, r8) {
  n5 = Number(n5) || 0;
  var i9 = e11.length - n5;
  r8 ? (r8 = Number(r8)) > i9 && (r8 = i9) : r8 = i9;
  var o6 = t6.length;
  if (o6 % 2 != 0) throw new TypeError("Invalid hex string");
  r8 > o6 / 2 && (r8 = o6 / 2);
  for (var s5 = 0; s5 < r8; ++s5) {
    var a6 = parseInt(t6.substr(2 * s5, 2), 16);
    if (isNaN(a6)) return s5;
    e11[n5 + s5] = a6;
  }
  return s5;
}
function $7(e11, t6, n5, r8) {
  return se4(ie4(t6, e11.length - n5), e11, n5, r8);
}
function B8(e11, t6, n5, r8) {
  return se4(function(e12) {
    for (var t7 = [], n6 = 0; n6 < e12.length; ++n6) t7.push(255 & e12.charCodeAt(n6));
    return t7;
  }(t6), e11, n5, r8);
}
function K4(e11, t6, n5, r8) {
  return B8(e11, t6, n5, r8);
}
function j8(e11, t6, n5, r8) {
  return se4(oe2(t6), e11, n5, r8);
}
function U5(e11, t6, n5, r8) {
  return se4(function(e12, t7) {
    for (var n6, r9, i9, o6 = [], s5 = 0; s5 < e12.length && !((t7 -= 2) < 0); ++s5) r9 = (n6 = e12.charCodeAt(s5)) >> 8, i9 = n6 % 256, o6.push(i9), o6.push(r9);
    return o6;
  }(t6, e11.length - n5), e11, n5, r8);
}
function H3(e11, t6, n5) {
  return 0 === t6 && n5 === e11.length ? m5(e11) : m5(e11.slice(t6, n5));
}
function F7(e11, t6, n5) {
  n5 = Math.min(e11.length, n5);
  for (var r8 = [], i9 = t6; i9 < n5; ) {
    var o6, s5, a6, c9, l9 = e11[i9], d7 = null, u10 = l9 > 239 ? 4 : l9 > 223 ? 3 : l9 > 191 ? 2 : 1;
    if (i9 + u10 <= n5) switch (u10) {
      case 1:
        l9 < 128 && (d7 = l9);
        break;
      case 2:
        128 == (192 & (o6 = e11[i9 + 1])) && (c9 = (31 & l9) << 6 | 63 & o6) > 127 && (d7 = c9);
        break;
      case 3:
        o6 = e11[i9 + 1], s5 = e11[i9 + 2], 128 == (192 & o6) && 128 == (192 & s5) && (c9 = (15 & l9) << 12 | (63 & o6) << 6 | 63 & s5) > 2047 && (c9 < 55296 || c9 > 57343) && (d7 = c9);
        break;
      case 4:
        o6 = e11[i9 + 1], s5 = e11[i9 + 2], a6 = e11[i9 + 3], 128 == (192 & o6) && 128 == (192 & s5) && 128 == (192 & a6) && (c9 = (15 & l9) << 18 | (63 & o6) << 12 | (63 & s5) << 6 | 63 & a6) > 65535 && c9 < 1114112 && (d7 = c9);
    }
    null === d7 ? (d7 = 65533, u10 = 1) : d7 > 65535 && (d7 -= 65536, r8.push(d7 >>> 10 & 1023 | 55296), d7 = 56320 | 1023 & d7), r8.push(d7), i9 += u10;
  }
  return function(e12) {
    var t7 = e12.length;
    if (t7 <= z8) return String.fromCharCode.apply(String, e12);
    var n6 = "", r9 = 0;
    for (; r9 < t7; ) n6 += String.fromCharCode.apply(String, e12.slice(r9, r9 += z8));
    return n6;
  }(r8);
}
C9.poolSize = 8192, C9._augment = function(e11) {
  return e11.__proto__ = C9.prototype, e11;
}, C9.from = function(e11, t6, n5) {
  return k10(null, e11, t6, n5);
}, C9.TYPED_ARRAY_SUPPORT && (C9.prototype.__proto__ = Uint8Array.prototype, C9.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && C9[Symbol.species]), C9.alloc = function(e11, t6, n5) {
  return function(e12, t7, n6, r8) {
    return A8(t7), t7 <= 0 ? _5(e12, t7) : void 0 !== n6 ? "string" == typeof r8 ? _5(e12, t7).fill(n6, r8) : _5(e12, t7).fill(n6) : _5(e12, t7);
  }(null, e11, t6, n5);
}, C9.allocUnsafe = function(e11) {
  return x6(null, e11);
}, C9.allocUnsafeSlow = function(e11) {
  return x6(null, e11);
}, C9.isBuffer = ae4, C9.compare = function(e11, t6) {
  if (!T7(e11) || !T7(t6)) throw new TypeError("Arguments must be Buffers");
  if (e11 === t6) return 0;
  for (var n5 = e11.length, r8 = t6.length, i9 = 0, o6 = Math.min(n5, r8); i9 < o6; ++i9) if (e11[i9] !== t6[i9]) {
    n5 = e11[i9], r8 = t6[i9];
    break;
  }
  return n5 < r8 ? -1 : r8 < n5 ? 1 : 0;
}, C9.isEncoding = function(e11) {
  switch (String(e11).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, C9.concat = function(e11, t6) {
  if (!w7(e11)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e11.length) return C9.alloc(0);
  var n5;
  if (void 0 === t6) for (t6 = 0, n5 = 0; n5 < e11.length; ++n5) t6 += e11[n5].length;
  var r8 = C9.allocUnsafe(t6), i9 = 0;
  for (n5 = 0; n5 < e11.length; ++n5) {
    var o6 = e11[n5];
    if (!T7(o6)) throw new TypeError('"list" argument must be an Array of Buffers');
    o6.copy(r8, i9), i9 += o6.length;
  }
  return r8;
}, C9.byteLength = R5, C9.prototype._isBuffer = true, C9.prototype.swap16 = function() {
  var e11 = this.length;
  if (e11 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t6 = 0; t6 < e11; t6 += 2) O7(this, t6, t6 + 1);
  return this;
}, C9.prototype.swap32 = function() {
  var e11 = this.length;
  if (e11 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t6 = 0; t6 < e11; t6 += 4) O7(this, t6, t6 + 3), O7(this, t6 + 1, t6 + 2);
  return this;
}, C9.prototype.swap64 = function() {
  var e11 = this.length;
  if (e11 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t6 = 0; t6 < e11; t6 += 8) O7(this, t6, t6 + 7), O7(this, t6 + 1, t6 + 6), O7(this, t6 + 2, t6 + 5), O7(this, t6 + 3, t6 + 4);
  return this;
}, C9.prototype.toString = function() {
  var e11 = 0 | this.length;
  return 0 === e11 ? "" : 0 === arguments.length ? F7(this, 0, e11) : P6.apply(this, arguments);
}, C9.prototype.equals = function(e11) {
  if (!T7(e11)) throw new TypeError("Argument must be a Buffer");
  return this === e11 || 0 === C9.compare(this, e11);
}, C9.prototype.inspect = function() {
  var e11 = "";
  return this.length > 0 && (e11 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e11 += " ... ")), "<Buffer " + e11 + ">";
}, C9.prototype.compare = function(e11, t6, n5, r8, i9) {
  if (!T7(e11)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === t6 && (t6 = 0), void 0 === n5 && (n5 = e11 ? e11.length : 0), void 0 === r8 && (r8 = 0), void 0 === i9 && (i9 = this.length), t6 < 0 || n5 > e11.length || r8 < 0 || i9 > this.length) throw new RangeError("out of range index");
  if (r8 >= i9 && t6 >= n5) return 0;
  if (r8 >= i9) return -1;
  if (t6 >= n5) return 1;
  if (this === e11) return 0;
  for (var o6 = (i9 >>>= 0) - (r8 >>>= 0), s5 = (n5 >>>= 0) - (t6 >>>= 0), a6 = Math.min(o6, s5), c9 = this.slice(r8, i9), l9 = e11.slice(t6, n5), d7 = 0; d7 < a6; ++d7) if (c9[d7] !== l9[d7]) {
    o6 = c9[d7], s5 = l9[d7];
    break;
  }
  return o6 < s5 ? -1 : s5 < o6 ? 1 : 0;
}, C9.prototype.includes = function(e11, t6, n5) {
  return -1 !== this.indexOf(e11, t6, n5);
}, C9.prototype.indexOf = function(e11, t6, n5) {
  return N8(this, e11, t6, n5, true);
}, C9.prototype.lastIndexOf = function(e11, t6, n5) {
  return N8(this, e11, t6, n5, false);
}, C9.prototype.write = function(e11, t6, n5, r8) {
  if (void 0 === t6) r8 = "utf8", n5 = this.length, t6 = 0;
  else if (void 0 === n5 && "string" == typeof t6) r8 = t6, n5 = this.length, t6 = 0;
  else {
    if (!isFinite(t6)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t6 |= 0, isFinite(n5) ? (n5 |= 0, void 0 === r8 && (r8 = "utf8")) : (r8 = n5, n5 = void 0);
  }
  var i9 = this.length - t6;
  if ((void 0 === n5 || n5 > i9) && (n5 = i9), e11.length > 0 && (n5 < 0 || t6 < 0) || t6 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  r8 || (r8 = "utf8");
  for (var o6 = false; ; ) switch (r8) {
    case "hex":
      return D8(this, e11, t6, n5);
    case "utf8":
    case "utf-8":
      return $7(this, e11, t6, n5);
    case "ascii":
      return B8(this, e11, t6, n5);
    case "latin1":
    case "binary":
      return K4(this, e11, t6, n5);
    case "base64":
      return j8(this, e11, t6, n5);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U5(this, e11, t6, n5);
    default:
      if (o6) throw new TypeError("Unknown encoding: " + r8);
      r8 = ("" + r8).toLowerCase(), o6 = true;
  }
}, C9.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var z8 = 4096;
function q5(e11, t6, n5) {
  var r8 = "";
  n5 = Math.min(e11.length, n5);
  for (var i9 = t6; i9 < n5; ++i9) r8 += String.fromCharCode(127 & e11[i9]);
  return r8;
}
function W5(e11, t6, n5) {
  var r8 = "";
  n5 = Math.min(e11.length, n5);
  for (var i9 = t6; i9 < n5; ++i9) r8 += String.fromCharCode(e11[i9]);
  return r8;
}
function V7(e11, t6, n5) {
  var r8 = e11.length;
  (!t6 || t6 < 0) && (t6 = 0), (!n5 || n5 < 0 || n5 > r8) && (n5 = r8);
  for (var i9 = "", o6 = t6; o6 < n5; ++o6) i9 += re4(e11[o6]);
  return i9;
}
function G6(e11, t6, n5) {
  for (var r8 = e11.slice(t6, n5), i9 = "", o6 = 0; o6 < r8.length; o6 += 2) i9 += String.fromCharCode(r8[o6] + 256 * r8[o6 + 1]);
  return i9;
}
function Y4(e11, t6, n5) {
  if (e11 % 1 != 0 || e11 < 0) throw new RangeError("offset is not uint");
  if (e11 + t6 > n5) throw new RangeError("Trying to access beyond buffer length");
}
function Z4(e11, t6, n5, r8, i9, o6) {
  if (!T7(e11)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t6 > i9 || t6 < o6) throw new RangeError('"value" argument is out of bounds');
  if (n5 + r8 > e11.length) throw new RangeError("Index out of range");
}
function J4(e11, t6, n5, r8) {
  t6 < 0 && (t6 = 65535 + t6 + 1);
  for (var i9 = 0, o6 = Math.min(e11.length - n5, 2); i9 < o6; ++i9) e11[n5 + i9] = (t6 & 255 << 8 * (r8 ? i9 : 1 - i9)) >>> 8 * (r8 ? i9 : 1 - i9);
}
function Q6(e11, t6, n5, r8) {
  t6 < 0 && (t6 = 4294967295 + t6 + 1);
  for (var i9 = 0, o6 = Math.min(e11.length - n5, 4); i9 < o6; ++i9) e11[n5 + i9] = t6 >>> 8 * (r8 ? i9 : 3 - i9) & 255;
}
function X5(e11, t6, n5, r8, i9, o6) {
  if (n5 + r8 > e11.length) throw new RangeError("Index out of range");
  if (n5 < 0) throw new RangeError("Index out of range");
}
function ee4(e11, t6, n5, r8, i9) {
  return i9 || X5(e11, 0, n5, 4), v8(e11, t6, n5, r8, 23, 4), n5 + 4;
}
function te3(e11, t6, n5, r8, i9) {
  return i9 || X5(e11, 0, n5, 8), v8(e11, t6, n5, r8, 52, 8), n5 + 8;
}
C9.prototype.slice = function(e11, t6) {
  var n5, r8 = this.length;
  if ((e11 = ~~e11) < 0 ? (e11 += r8) < 0 && (e11 = 0) : e11 > r8 && (e11 = r8), (t6 = void 0 === t6 ? r8 : ~~t6) < 0 ? (t6 += r8) < 0 && (t6 = 0) : t6 > r8 && (t6 = r8), t6 < e11 && (t6 = e11), C9.TYPED_ARRAY_SUPPORT) (n5 = this.subarray(e11, t6)).__proto__ = C9.prototype;
  else {
    var i9 = t6 - e11;
    n5 = new C9(i9, void 0);
    for (var o6 = 0; o6 < i9; ++o6) n5[o6] = this[o6 + e11];
  }
  return n5;
}, C9.prototype.readUIntLE = function(e11, t6, n5) {
  e11 |= 0, t6 |= 0, n5 || Y4(e11, t6, this.length);
  for (var r8 = this[e11], i9 = 1, o6 = 0; ++o6 < t6 && (i9 *= 256); ) r8 += this[e11 + o6] * i9;
  return r8;
}, C9.prototype.readUIntBE = function(e11, t6, n5) {
  e11 |= 0, t6 |= 0, n5 || Y4(e11, t6, this.length);
  for (var r8 = this[e11 + --t6], i9 = 1; t6 > 0 && (i9 *= 256); ) r8 += this[e11 + --t6] * i9;
  return r8;
}, C9.prototype.readUInt8 = function(e11, t6) {
  return t6 || Y4(e11, 1, this.length), this[e11];
}, C9.prototype.readUInt16LE = function(e11, t6) {
  return t6 || Y4(e11, 2, this.length), this[e11] | this[e11 + 1] << 8;
}, C9.prototype.readUInt16BE = function(e11, t6) {
  return t6 || Y4(e11, 2, this.length), this[e11] << 8 | this[e11 + 1];
}, C9.prototype.readUInt32LE = function(e11, t6) {
  return t6 || Y4(e11, 4, this.length), (this[e11] | this[e11 + 1] << 8 | this[e11 + 2] << 16) + 16777216 * this[e11 + 3];
}, C9.prototype.readUInt32BE = function(e11, t6) {
  return t6 || Y4(e11, 4, this.length), 16777216 * this[e11] + (this[e11 + 1] << 16 | this[e11 + 2] << 8 | this[e11 + 3]);
}, C9.prototype.readIntLE = function(e11, t6, n5) {
  e11 |= 0, t6 |= 0, n5 || Y4(e11, t6, this.length);
  for (var r8 = this[e11], i9 = 1, o6 = 0; ++o6 < t6 && (i9 *= 256); ) r8 += this[e11 + o6] * i9;
  return r8 >= (i9 *= 128) && (r8 -= Math.pow(2, 8 * t6)), r8;
}, C9.prototype.readIntBE = function(e11, t6, n5) {
  e11 |= 0, t6 |= 0, n5 || Y4(e11, t6, this.length);
  for (var r8 = t6, i9 = 1, o6 = this[e11 + --r8]; r8 > 0 && (i9 *= 256); ) o6 += this[e11 + --r8] * i9;
  return o6 >= (i9 *= 128) && (o6 -= Math.pow(2, 8 * t6)), o6;
}, C9.prototype.readInt8 = function(e11, t6) {
  return t6 || Y4(e11, 1, this.length), 128 & this[e11] ? -1 * (255 - this[e11] + 1) : this[e11];
}, C9.prototype.readInt16LE = function(e11, t6) {
  t6 || Y4(e11, 2, this.length);
  var n5 = this[e11] | this[e11 + 1] << 8;
  return 32768 & n5 ? 4294901760 | n5 : n5;
}, C9.prototype.readInt16BE = function(e11, t6) {
  t6 || Y4(e11, 2, this.length);
  var n5 = this[e11 + 1] | this[e11] << 8;
  return 32768 & n5 ? 4294901760 | n5 : n5;
}, C9.prototype.readInt32LE = function(e11, t6) {
  return t6 || Y4(e11, 4, this.length), this[e11] | this[e11 + 1] << 8 | this[e11 + 2] << 16 | this[e11 + 3] << 24;
}, C9.prototype.readInt32BE = function(e11, t6) {
  return t6 || Y4(e11, 4, this.length), this[e11] << 24 | this[e11 + 1] << 16 | this[e11 + 2] << 8 | this[e11 + 3];
}, C9.prototype.readFloatLE = function(e11, t6) {
  return t6 || Y4(e11, 4, this.length), y10(this, e11, true, 23, 4);
}, C9.prototype.readFloatBE = function(e11, t6) {
  return t6 || Y4(e11, 4, this.length), y10(this, e11, false, 23, 4);
}, C9.prototype.readDoubleLE = function(e11, t6) {
  return t6 || Y4(e11, 8, this.length), y10(this, e11, true, 52, 8);
}, C9.prototype.readDoubleBE = function(e11, t6) {
  return t6 || Y4(e11, 8, this.length), y10(this, e11, false, 52, 8);
}, C9.prototype.writeUIntLE = function(e11, t6, n5, r8) {
  (e11 = +e11, t6 |= 0, n5 |= 0, r8) || Z4(this, e11, t6, n5, Math.pow(2, 8 * n5) - 1, 0);
  var i9 = 1, o6 = 0;
  for (this[t6] = 255 & e11; ++o6 < n5 && (i9 *= 256); ) this[t6 + o6] = e11 / i9 & 255;
  return t6 + n5;
}, C9.prototype.writeUIntBE = function(e11, t6, n5, r8) {
  (e11 = +e11, t6 |= 0, n5 |= 0, r8) || Z4(this, e11, t6, n5, Math.pow(2, 8 * n5) - 1, 0);
  var i9 = n5 - 1, o6 = 1;
  for (this[t6 + i9] = 255 & e11; --i9 >= 0 && (o6 *= 256); ) this[t6 + i9] = e11 / o6 & 255;
  return t6 + n5;
}, C9.prototype.writeUInt8 = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 1, 255, 0), C9.TYPED_ARRAY_SUPPORT || (e11 = Math.floor(e11)), this[t6] = 255 & e11, t6 + 1;
}, C9.prototype.writeUInt16LE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 2, 65535, 0), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = 255 & e11, this[t6 + 1] = e11 >>> 8) : J4(this, e11, t6, true), t6 + 2;
}, C9.prototype.writeUInt16BE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 2, 65535, 0), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = e11 >>> 8, this[t6 + 1] = 255 & e11) : J4(this, e11, t6, false), t6 + 2;
}, C9.prototype.writeUInt32LE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 4, 4294967295, 0), C9.TYPED_ARRAY_SUPPORT ? (this[t6 + 3] = e11 >>> 24, this[t6 + 2] = e11 >>> 16, this[t6 + 1] = e11 >>> 8, this[t6] = 255 & e11) : Q6(this, e11, t6, true), t6 + 4;
}, C9.prototype.writeUInt32BE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 4, 4294967295, 0), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = e11 >>> 24, this[t6 + 1] = e11 >>> 16, this[t6 + 2] = e11 >>> 8, this[t6 + 3] = 255 & e11) : Q6(this, e11, t6, false), t6 + 4;
}, C9.prototype.writeIntLE = function(e11, t6, n5, r8) {
  if (e11 = +e11, t6 |= 0, !r8) {
    var i9 = Math.pow(2, 8 * n5 - 1);
    Z4(this, e11, t6, n5, i9 - 1, -i9);
  }
  var o6 = 0, s5 = 1, a6 = 0;
  for (this[t6] = 255 & e11; ++o6 < n5 && (s5 *= 256); ) e11 < 0 && 0 === a6 && 0 !== this[t6 + o6 - 1] && (a6 = 1), this[t6 + o6] = (e11 / s5 >> 0) - a6 & 255;
  return t6 + n5;
}, C9.prototype.writeIntBE = function(e11, t6, n5, r8) {
  if (e11 = +e11, t6 |= 0, !r8) {
    var i9 = Math.pow(2, 8 * n5 - 1);
    Z4(this, e11, t6, n5, i9 - 1, -i9);
  }
  var o6 = n5 - 1, s5 = 1, a6 = 0;
  for (this[t6 + o6] = 255 & e11; --o6 >= 0 && (s5 *= 256); ) e11 < 0 && 0 === a6 && 0 !== this[t6 + o6 + 1] && (a6 = 1), this[t6 + o6] = (e11 / s5 >> 0) - a6 & 255;
  return t6 + n5;
}, C9.prototype.writeInt8 = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 1, 127, -128), C9.TYPED_ARRAY_SUPPORT || (e11 = Math.floor(e11)), e11 < 0 && (e11 = 255 + e11 + 1), this[t6] = 255 & e11, t6 + 1;
}, C9.prototype.writeInt16LE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 2, 32767, -32768), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = 255 & e11, this[t6 + 1] = e11 >>> 8) : J4(this, e11, t6, true), t6 + 2;
}, C9.prototype.writeInt16BE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 2, 32767, -32768), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = e11 >>> 8, this[t6 + 1] = 255 & e11) : J4(this, e11, t6, false), t6 + 2;
}, C9.prototype.writeInt32LE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 4, 2147483647, -2147483648), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = 255 & e11, this[t6 + 1] = e11 >>> 8, this[t6 + 2] = e11 >>> 16, this[t6 + 3] = e11 >>> 24) : Q6(this, e11, t6, true), t6 + 4;
}, C9.prototype.writeInt32BE = function(e11, t6, n5) {
  return e11 = +e11, t6 |= 0, n5 || Z4(this, e11, t6, 4, 2147483647, -2147483648), e11 < 0 && (e11 = 4294967295 + e11 + 1), C9.TYPED_ARRAY_SUPPORT ? (this[t6] = e11 >>> 24, this[t6 + 1] = e11 >>> 16, this[t6 + 2] = e11 >>> 8, this[t6 + 3] = 255 & e11) : Q6(this, e11, t6, false), t6 + 4;
}, C9.prototype.writeFloatLE = function(e11, t6, n5) {
  return ee4(this, e11, t6, true, n5);
}, C9.prototype.writeFloatBE = function(e11, t6, n5) {
  return ee4(this, e11, t6, false, n5);
}, C9.prototype.writeDoubleLE = function(e11, t6, n5) {
  return te3(this, e11, t6, true, n5);
}, C9.prototype.writeDoubleBE = function(e11, t6, n5) {
  return te3(this, e11, t6, false, n5);
}, C9.prototype.copy = function(e11, t6, n5, r8) {
  if (n5 || (n5 = 0), r8 || 0 === r8 || (r8 = this.length), t6 >= e11.length && (t6 = e11.length), t6 || (t6 = 0), r8 > 0 && r8 < n5 && (r8 = n5), r8 === n5) return 0;
  if (0 === e11.length || 0 === this.length) return 0;
  if (t6 < 0) throw new RangeError("targetStart out of bounds");
  if (n5 < 0 || n5 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (r8 < 0) throw new RangeError("sourceEnd out of bounds");
  r8 > this.length && (r8 = this.length), e11.length - t6 < r8 - n5 && (r8 = e11.length - t6 + n5);
  var i9, o6 = r8 - n5;
  if (this === e11 && n5 < t6 && t6 < r8) for (i9 = o6 - 1; i9 >= 0; --i9) e11[i9 + t6] = this[i9 + n5];
  else if (o6 < 1e3 || !C9.TYPED_ARRAY_SUPPORT) for (i9 = 0; i9 < o6; ++i9) e11[i9 + t6] = this[i9 + n5];
  else Uint8Array.prototype.set.call(e11, this.subarray(n5, n5 + o6), t6);
  return o6;
}, C9.prototype.fill = function(e11, t6, n5, r8) {
  if ("string" == typeof e11) {
    if ("string" == typeof t6 ? (r8 = t6, t6 = 0, n5 = this.length) : "string" == typeof n5 && (r8 = n5, n5 = this.length), 1 === e11.length) {
      var i9 = e11.charCodeAt(0);
      i9 < 256 && (e11 = i9);
    }
    if (void 0 !== r8 && "string" != typeof r8) throw new TypeError("encoding must be a string");
    if ("string" == typeof r8 && !C9.isEncoding(r8)) throw new TypeError("Unknown encoding: " + r8);
  } else "number" == typeof e11 && (e11 &= 255);
  if (t6 < 0 || this.length < t6 || this.length < n5) throw new RangeError("Out of range index");
  if (n5 <= t6) return this;
  var o6;
  if (t6 >>>= 0, n5 = void 0 === n5 ? this.length : n5 >>> 0, e11 || (e11 = 0), "number" == typeof e11) for (o6 = t6; o6 < n5; ++o6) this[o6] = e11;
  else {
    var s5 = T7(e11) ? e11 : ie4(new C9(e11, r8).toString()), a6 = s5.length;
    for (o6 = 0; o6 < n5 - t6; ++o6) this[o6 + t6] = s5[o6 % a6];
  }
  return this;
};
var ne4 = /[^+\/0-9A-Za-z-_]/g;
function re4(e11) {
  return e11 < 16 ? "0" + e11.toString(16) : e11.toString(16);
}
function ie4(e11, t6) {
  var n5;
  t6 = t6 || 1 / 0;
  for (var r8 = e11.length, i9 = null, o6 = [], s5 = 0; s5 < r8; ++s5) {
    if ((n5 = e11.charCodeAt(s5)) > 55295 && n5 < 57344) {
      if (!i9) {
        if (n5 > 56319) {
          (t6 -= 3) > -1 && o6.push(239, 191, 189);
          continue;
        }
        if (s5 + 1 === r8) {
          (t6 -= 3) > -1 && o6.push(239, 191, 189);
          continue;
        }
        i9 = n5;
        continue;
      }
      if (n5 < 56320) {
        (t6 -= 3) > -1 && o6.push(239, 191, 189), i9 = n5;
        continue;
      }
      n5 = 65536 + (i9 - 55296 << 10 | n5 - 56320);
    } else i9 && (t6 -= 3) > -1 && o6.push(239, 191, 189);
    if (i9 = null, n5 < 128) {
      if ((t6 -= 1) < 0) break;
      o6.push(n5);
    } else if (n5 < 2048) {
      if ((t6 -= 2) < 0) break;
      o6.push(n5 >> 6 | 192, 63 & n5 | 128);
    } else if (n5 < 65536) {
      if ((t6 -= 3) < 0) break;
      o6.push(n5 >> 12 | 224, n5 >> 6 & 63 | 128, 63 & n5 | 128);
    } else {
      if (!(n5 < 1114112)) throw new Error("Invalid code point");
      if ((t6 -= 4) < 0) break;
      o6.push(n5 >> 18 | 240, n5 >> 12 & 63 | 128, n5 >> 6 & 63 | 128, 63 & n5 | 128);
    }
  }
  return o6;
}
function oe2(e11) {
  return function(e12) {
    var t6, n5, r8, i9, o6, s5;
    f15 || p8();
    var a6 = e12.length;
    if (a6 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    o6 = "=" === e12[a6 - 2] ? 2 : "=" === e12[a6 - 1] ? 1 : 0, s5 = new h8(3 * a6 / 4 - o6), r8 = o6 > 0 ? a6 - 4 : a6;
    var c9 = 0;
    for (t6 = 0, n5 = 0; t6 < r8; t6 += 4, n5 += 3) i9 = u9[e12.charCodeAt(t6)] << 18 | u9[e12.charCodeAt(t6 + 1)] << 12 | u9[e12.charCodeAt(t6 + 2)] << 6 | u9[e12.charCodeAt(t6 + 3)], s5[c9++] = i9 >> 16 & 255, s5[c9++] = i9 >> 8 & 255, s5[c9++] = 255 & i9;
    return 2 === o6 ? (i9 = u9[e12.charCodeAt(t6)] << 2 | u9[e12.charCodeAt(t6 + 1)] >> 4, s5[c9++] = 255 & i9) : 1 === o6 && (i9 = u9[e12.charCodeAt(t6)] << 10 | u9[e12.charCodeAt(t6 + 1)] << 4 | u9[e12.charCodeAt(t6 + 2)] >> 2, s5[c9++] = i9 >> 8 & 255, s5[c9++] = 255 & i9), s5;
  }(function(e12) {
    if ((e12 = function(e13) {
      return e13.trim ? e13.trim() : e13.replace(/^\s+|\s+$/g, "");
    }(e12).replace(ne4, "")).length < 2) return "";
    for (; e12.length % 4 != 0; ) e12 += "=";
    return e12;
  }(e11));
}
function se4(e11, t6, n5, r8) {
  for (var i9 = 0; i9 < r8 && !(i9 + n5 >= t6.length || i9 >= e11.length); ++i9) t6[i9 + n5] = e11[i9];
  return i9;
}
function ae4(e11) {
  return null != e11 && (!!e11._isBuffer || ce4(e11) || function(e12) {
    return "function" == typeof e12.readFloatLE && "function" == typeof e12.slice && ce4(e12.slice(0, 0));
  }(e11));
}
function ce4(e11) {
  return !!e11.constructor && "function" == typeof e11.constructor.isBuffer && e11.constructor.isBuffer(e11);
}
var le4 = Object.freeze({ __proto__: null, Buffer: C9, INSPECT_MAX_BYTES: 50, SlowBuffer: function(e11) {
  return +e11 != e11 && (e11 = 0), C9.alloc(+e11);
}, isBuffer: ae4, kMaxLength: E7 });
var de4 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ue4(e11) {
  return e11 && e11.__esModule && Object.prototype.hasOwnProperty.call(e11, "default") ? e11.default : e11;
}
function he4(e11) {
  if (e11.__esModule) return e11;
  var t6 = e11.default;
  if ("function" == typeof t6) {
    var n5 = function e12() {
      return this instanceof e12 ? Reflect.construct(t6, arguments, this.constructor) : t6.apply(this, arguments);
    };
    n5.prototype = t6.prototype;
  } else n5 = {};
  return Object.defineProperty(n5, "__esModule", { value: true }), Object.keys(e11).forEach(function(t7) {
    var r8 = Object.getOwnPropertyDescriptor(e11, t7);
    Object.defineProperty(n5, t7, r8.get ? r8 : { enumerable: true, get: function() {
      return e11[t7];
    } });
  }), n5;
}
var fe4 = {};
var pe4 = {};
var ge4 = {};
function me4(e11) {
  if (!Number.isSafeInteger(e11) || e11 < 0) throw new Error(`positive integer expected, not ${e11}`);
}
function ye4(e11) {
  if ("boolean" != typeof e11) throw new Error(`boolean expected, not ${e11}`);
}
function ve3(e11) {
  return e11 instanceof Uint8Array || null != e11 && "object" == typeof e11 && "Uint8Array" === e11.constructor.name;
}
function be4(e11, ...t6) {
  if (!ve3(e11)) throw new Error("Uint8Array expected");
  if (t6.length > 0 && !t6.includes(e11.length)) throw new Error(`Uint8Array expected of length ${t6}, not of length=${e11.length}`);
}
function we4(e11) {
  if ("function" != typeof e11 || "function" != typeof e11.create) throw new Error("hash must be wrapped by utils.wrapConstructor");
  me4(e11.outputLen), me4(e11.blockLen);
}
function Ee4(e11, t6 = true) {
  if (e11.destroyed) throw new Error("Hash instance has been destroyed");
  if (t6 && e11.finished) throw new Error("Hash#digest() has already been called");
}
function Se4(e11, t6) {
  be4(e11);
  const n5 = t6.outputLen;
  if (e11.length < n5) throw new Error(`digestInto() expects output buffer of length at least ${n5}`);
}
Object.defineProperty(ge4, "__esModule", { value: true }), ge4.isBytes = ve3, ge4.number = me4, ge4.bool = ye4, ge4.bytes = be4, ge4.hash = we4, ge4.exists = Ee4, ge4.output = Se4;
var _e5 = { number: me4, bool: ye4, bytes: be4, hash: we4, exists: Ee4, output: Se4 };
ge4.default = _e5, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.wrapCipher = e11.Hash = e11.nextTick = e11.isLE = e11.createView = e11.u32 = e11.u16 = e11.u8 = void 0, e11.bytesToHex = r8, e11.hexToBytes = s5, e11.hexToNumber = a6, e11.bytesToNumberBE = function(e12) {
    return a6(r8(e12));
  }, e11.numberToBytesBE = function(e12, t7) {
    return s5(e12.toString(16).padStart(2 * t7, "0"));
  }, e11.asyncLoop = async function(t7, n6, r9) {
    let i10 = Date.now();
    for (let o7 = 0; o7 < t7; o7++) {
      r9(o7);
      const t8 = Date.now() - i10;
      t8 >= 0 && t8 < n6 || (await (0, e11.nextTick)(), i10 += t8);
    }
  }, e11.utf8ToBytes = c9, e11.bytesToUtf8 = function(e12) {
    return new TextDecoder().decode(e12);
  }, e11.toBytes = function(e12) {
    if ("string" == typeof e12) e12 = c9(e12);
    else {
      if (!(0, t6.isBytes)(e12)) throw new Error("Uint8Array expected, got " + typeof e12);
      e12 = d7(e12);
    }
    return e12;
  }, e11.concatBytes = function(...e12) {
    let n6 = 0;
    for (let r10 = 0; r10 < e12.length; r10++) {
      const i10 = e12[r10];
      (0, t6.bytes)(i10), n6 += i10.length;
    }
    const r9 = new Uint8Array(n6);
    for (let t7 = 0, n7 = 0; t7 < e12.length; t7++) {
      const i10 = e12[t7];
      r9.set(i10, n7), n7 += i10.length;
    }
    return r9;
  }, e11.checkOpts = function(e12, t7) {
    if (null == t7 || "object" != typeof t7) throw new Error("options must be defined");
    return Object.assign(e12, t7);
  }, e11.equalBytes = function(e12, t7) {
    if (e12.length !== t7.length) return false;
    let n6 = 0;
    for (let r9 = 0; r9 < e12.length; r9++) n6 |= e12[r9] ^ t7[r9];
    return 0 === n6;
  }, e11.setBigUint64 = l9, e11.u64Lengths = function(t7, n6) {
    const r9 = new Uint8Array(16), i10 = (0, e11.createView)(r9);
    return l9(i10, 0, BigInt(n6 ? n6.length : 0), true), l9(i10, 8, BigInt(t7.length), true), r9;
  }, e11.isAligned32 = function(e12) {
    return e12.byteOffset % 4 == 0;
  }, e11.copyBytes = d7, e11.clean = function(...e12) {
    for (let t7 = 0; t7 < e12.length; t7++) e12[t7].fill(0);
  };
  const t6 = ge4;
  e11.u8 = (e12) => new Uint8Array(e12.buffer, e12.byteOffset, e12.byteLength);
  e11.u16 = (e12) => new Uint16Array(e12.buffer, e12.byteOffset, Math.floor(e12.byteLength / 2));
  e11.u32 = (e12) => new Uint32Array(e12.buffer, e12.byteOffset, Math.floor(e12.byteLength / 4));
  if (e11.createView = (e12) => new DataView(e12.buffer, e12.byteOffset, e12.byteLength), e11.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], !e11.isLE) throw new Error("Non little-endian hardware is not supported");
  const n5 = Array.from({ length: 256 }, (e12, t7) => t7.toString(16).padStart(2, "0"));
  function r8(e12) {
    (0, t6.bytes)(e12);
    let r9 = "";
    for (let t7 = 0; t7 < e12.length; t7++) r9 += n5[e12[t7]];
    return r9;
  }
  const i9 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o6(e12) {
    return e12 >= i9._0 && e12 <= i9._9 ? e12 - i9._0 : e12 >= i9._A && e12 <= i9._F ? e12 - (i9._A - 10) : e12 >= i9._a && e12 <= i9._f ? e12 - (i9._a - 10) : void 0;
  }
  function s5(e12) {
    if ("string" != typeof e12) throw new Error("hex string expected, got " + typeof e12);
    const t7 = e12.length, n6 = t7 / 2;
    if (t7 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t7);
    const r9 = new Uint8Array(n6);
    for (let t8 = 0, i10 = 0; t8 < n6; t8++, i10 += 2) {
      const n7 = o6(e12.charCodeAt(i10)), s6 = o6(e12.charCodeAt(i10 + 1));
      if (void 0 === n7 || void 0 === s6) {
        const t9 = e12[i10] + e12[i10 + 1];
        throw new Error('hex string expected, got non-hex character "' + t9 + '" at index ' + i10);
      }
      r9[t8] = 16 * n7 + s6;
    }
    return r9;
  }
  function a6(e12) {
    if ("string" != typeof e12) throw new Error("hex string expected, got " + typeof e12);
    return BigInt("" === e12 ? "0" : `0x${e12}`);
  }
  function c9(e12) {
    if ("string" != typeof e12) throw new Error("string expected, got " + typeof e12);
    return new Uint8Array(new TextEncoder().encode(e12));
  }
  e11.nextTick = async () => {
  };
  e11.Hash = class {
  };
  function l9(e12, t7, n6, r9) {
    if ("function" == typeof e12.setBigUint64) return e12.setBigUint64(t7, n6, r9);
    const i10 = BigInt(32), o7 = BigInt(4294967295), s6 = Number(n6 >> i10 & o7), a7 = Number(n6 & o7), c10 = r9 ? 4 : 0, l10 = r9 ? 0 : 4;
    e12.setUint32(t7 + c10, s6, r9), e12.setUint32(t7 + l10, a7, r9);
  }
  function d7(e12) {
    return Uint8Array.from(e12);
  }
  e11.wrapCipher = (e12, t7) => (Object.assign(t7, e12), t7);
}(pe4);
var Ce5 = {};
var ke5 = {};
Object.defineProperty(ke5, "__esModule", { value: true }), ke5.AEAD_TAG_LENGTH = ke5.XCHACHA20_NONCE_LENGTH = ke5.CURVE25519_PUBLIC_KEY_SIZE = ke5.ETH_PUBLIC_KEY_SIZE = ke5.UNCOMPRESSED_PUBLIC_KEY_SIZE = ke5.COMPRESSED_PUBLIC_KEY_SIZE = ke5.SECRET_KEY_LENGTH = void 0, ke5.SECRET_KEY_LENGTH = 32, ke5.COMPRESSED_PUBLIC_KEY_SIZE = 33, ke5.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, ke5.ETH_PUBLIC_KEY_SIZE = 64, ke5.CURVE25519_PUBLIC_KEY_SIZE = 32, ke5.XCHACHA20_NONCE_LENGTH = 24, ke5.AEAD_TAG_LENGTH = 16, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.ephemeralKeySize = e11.symmetricNonceLength = e11.symmetricAlgorithm = e11.isHkdfKeyCompressed = e11.isEphemeralKeyCompressed = e11.ellipticCurve = e11.ECIES_CONFIG = void 0;
  var t6 = ke5, n5 = function() {
    this.ellipticCurve = "secp256k1", this.isEphemeralKeyCompressed = false, this.isHkdfKeyCompressed = false, this.symmetricAlgorithm = "aes-256-gcm", this.symmetricNonceLength = 16;
  };
  e11.ECIES_CONFIG = new n5();
  e11.ellipticCurve = function() {
    return e11.ECIES_CONFIG.ellipticCurve;
  };
  e11.isEphemeralKeyCompressed = function() {
    return e11.ECIES_CONFIG.isEphemeralKeyCompressed;
  };
  e11.isHkdfKeyCompressed = function() {
    return e11.ECIES_CONFIG.isHkdfKeyCompressed;
  };
  e11.symmetricAlgorithm = function() {
    return e11.ECIES_CONFIG.symmetricAlgorithm;
  };
  e11.symmetricNonceLength = function() {
    return e11.ECIES_CONFIG.symmetricNonceLength;
  };
  e11.ephemeralKeySize = function() {
    var n6 = { secp256k1: e11.ECIES_CONFIG.isEphemeralKeyCompressed ? t6.COMPRESSED_PUBLIC_KEY_SIZE : t6.UNCOMPRESSED_PUBLIC_KEY_SIZE, x25519: t6.CURVE25519_PUBLIC_KEY_SIZE, ed25519: t6.CURVE25519_PUBLIC_KEY_SIZE };
    if (e11.ECIES_CONFIG.ellipticCurve in n6) return n6[e11.ECIES_CONFIG.ellipticCurve];
    throw new Error("Not implemented");
  };
}(Ce5);
var Ae3 = {};
var xe3 = {};
var Me5 = {};
var Ie4 = {};
var Te4 = {};
var Re3 = {};
Object.defineProperty(Re3, "__esModule", { value: true }), Re3.crypto = void 0, Re3.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.gcm = e11.ctr = e11.cbc = e11.utils = void 0, e11.randomBytes = i9, e11.getWebcryptoSubtle = o6, e11.managedNonce = function(e12) {
    return (0, n5.number)(e12.nonceLength), (t7, ...n6) => ({ encrypt(o7, ...s6) {
      const { nonceLength: a7 } = e12, c9 = i9(a7), l9 = e12(t7, c9, ...n6).encrypt(o7, ...s6), d7 = (0, r8.concatBytes)(c9, l9);
      return l9.fill(0), d7;
    }, decrypt(r9, ...i10) {
      const { nonceLength: o7 } = e12, s6 = r9.subarray(0, o7), a7 = r9.subarray(o7);
      return e12(t7, s6, ...n6).decrypt(a7, ...i10);
    } });
  };
  const t6 = Re3, n5 = ge4, r8 = pe4;
  function i9(e12 = 32) {
    if (t6.crypto && "function" == typeof t6.crypto.getRandomValues) return t6.crypto.getRandomValues(new Uint8Array(e12));
    if (t6.crypto && "function" == typeof t6.crypto.randomBytes) return t6.crypto.randomBytes(e12);
    throw new Error("crypto.getRandomValues must be defined");
  }
  function o6() {
    if (t6.crypto && "object" == typeof t6.crypto.subtle && null != t6.crypto.subtle) return t6.crypto.subtle;
    throw new Error("crypto.subtle must be defined");
  }
  e11.utils = { async encrypt(e12, t7, n6, r9) {
    const i10 = o6(), s6 = await i10.importKey("raw", e12, t7, true, ["encrypt"]), a7 = await i10.encrypt(n6, s6, r9);
    return new Uint8Array(a7);
  }, async decrypt(e12, t7, n6, r9) {
    const i10 = o6(), s6 = await i10.importKey("raw", e12, t7, true, ["decrypt"]), a7 = await i10.decrypt(n6, s6, r9);
    return new Uint8Array(a7);
  } };
  const s5 = { CBC: "AES-CBC", CTR: "AES-CTR", GCM: "AES-GCM" };
  function a6(t7) {
    return (r9, i10, o7) => {
      (0, n5.bytes)(r9), (0, n5.bytes)(i10);
      const a7 = { name: t7, length: 8 * r9.length }, c9 = function(e12, t8, n6) {
        if (e12 === s5.CBC) return { name: s5.CBC, iv: t8 };
        if (e12 === s5.CTR) return { name: s5.CTR, counter: t8, length: 64 };
        if (e12 === s5.GCM) return n6 ? { name: s5.GCM, iv: t8, additionalData: n6 } : { name: s5.GCM, iv: t8 };
        throw new Error("unknown aes block mode");
      }(t7, i10, o7);
      return { encrypt: (t8) => ((0, n5.bytes)(t8), e11.utils.encrypt(r9, a7, c9, t8)), decrypt: (t8) => ((0, n5.bytes)(t8), e11.utils.decrypt(r9, a7, c9, t8)) };
    };
  }
  e11.cbc = a6(s5.CBC), e11.ctr = a6(s5.CTR), e11.gcm = a6(s5.GCM);
}(Te4);
var Pe4 = {};
var Oe3 = {};
var Ne3 = {};
var Le5 = {};
function De4(e11) {
  if (!Number.isSafeInteger(e11) || e11 < 0) throw new Error(`positive integer expected, not ${e11}`);
}
function $e4(e11) {
  if ("boolean" != typeof e11) throw new Error(`boolean expected, not ${e11}`);
}
function Be4(e11) {
  return e11 instanceof Uint8Array || null != e11 && "object" == typeof e11 && "Uint8Array" === e11.constructor.name;
}
function Ke5(e11, ...t6) {
  if (!Be4(e11)) throw new Error("Uint8Array expected");
  if (t6.length > 0 && !t6.includes(e11.length)) throw new Error(`Uint8Array expected of length ${t6}, not of length=${e11.length}`);
}
function je4(e11) {
  if ("function" != typeof e11 || "function" != typeof e11.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
  De4(e11.outputLen), De4(e11.blockLen);
}
function Ue4(e11, t6 = true) {
  if (e11.destroyed) throw new Error("Hash instance has been destroyed");
  if (t6 && e11.finished) throw new Error("Hash#digest() has already been called");
}
function He4(e11, t6) {
  Ke5(e11);
  const n5 = t6.outputLen;
  if (e11.length < n5) throw new Error(`digestInto() expects output buffer of length at least ${n5}`);
}
Object.defineProperty(Le5, "__esModule", { value: true }), Le5.isBytes = Be4, Le5.number = De4, Le5.bool = $e4, Le5.bytes = Ke5, Le5.hash = je4, Le5.exists = Ue4, Le5.output = He4;
var Fe4 = { number: De4, bool: $e4, bytes: Ke5, hash: je4, exists: Ue4, output: He4 };
Le5.default = Fe4;
var ze3 = {};
var qe4 = {};
Object.defineProperty(qe4, "__esModule", { value: true }), qe4.crypto = void 0, qe4.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.Hash = e11.nextTick = e11.byteSwapIfBE = e11.byteSwap = e11.isLE = e11.rotl = e11.rotr = e11.createView = e11.u32 = e11.u8 = void 0, e11.isBytes = function(e12) {
    return e12 instanceof Uint8Array || null != e12 && "object" == typeof e12 && "Uint8Array" === e12.constructor.name;
  }, e11.byteSwap32 = function(t7) {
    for (let n6 = 0; n6 < t7.length; n6++) t7[n6] = (0, e11.byteSwap)(t7[n6]);
  }, e11.bytesToHex = function(e12) {
    (0, n5.bytes)(e12);
    let t7 = "";
    for (let n6 = 0; n6 < e12.length; n6++) t7 += r8[e12[n6]];
    return t7;
  }, e11.hexToBytes = function(e12) {
    if ("string" != typeof e12) throw new Error("hex string expected, got " + typeof e12);
    const t7 = e12.length, n6 = t7 / 2;
    if (t7 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t7);
    const r9 = new Uint8Array(n6);
    for (let t8 = 0, i10 = 0; t8 < n6; t8++, i10 += 2) {
      const n7 = o6(e12.charCodeAt(i10)), s6 = o6(e12.charCodeAt(i10 + 1));
      if (void 0 === n7 || void 0 === s6) {
        const t9 = e12[i10] + e12[i10 + 1];
        throw new Error('hex string expected, got non-hex character "' + t9 + '" at index ' + i10);
      }
      r9[t8] = 16 * n7 + s6;
    }
    return r9;
  }, e11.asyncLoop = async function(t7, n6, r9) {
    let i10 = Date.now();
    for (let o7 = 0; o7 < t7; o7++) {
      r9(o7);
      const t8 = Date.now() - i10;
      t8 >= 0 && t8 < n6 || (await (0, e11.nextTick)(), i10 += t8);
    }
  }, e11.utf8ToBytes = s5, e11.toBytes = a6, e11.concatBytes = function(...e12) {
    let t7 = 0;
    for (let r10 = 0; r10 < e12.length; r10++) {
      const i10 = e12[r10];
      (0, n5.bytes)(i10), t7 += i10.length;
    }
    const r9 = new Uint8Array(t7);
    for (let t8 = 0, n6 = 0; t8 < e12.length; t8++) {
      const i10 = e12[t8];
      r9.set(i10, n6), n6 += i10.length;
    }
    return r9;
  }, e11.checkOpts = function(e12, t7) {
    if (void 0 !== t7 && "[object Object]" !== c9.call(t7)) throw new Error("Options should be object or undefined");
    return Object.assign(e12, t7);
  }, e11.wrapConstructor = function(e12) {
    const t7 = (t8) => e12().update(a6(t8)).digest(), n6 = e12();
    return t7.outputLen = n6.outputLen, t7.blockLen = n6.blockLen, t7.create = () => e12(), t7;
  }, e11.wrapConstructorWithOpts = function(e12) {
    const t7 = (t8, n7) => e12(n7).update(a6(t8)).digest(), n6 = e12({});
    return t7.outputLen = n6.outputLen, t7.blockLen = n6.blockLen, t7.create = (t8) => e12(t8), t7;
  }, e11.wrapXOFConstructorWithOpts = function(e12) {
    const t7 = (t8, n7) => e12(n7).update(a6(t8)).digest(), n6 = e12({});
    return t7.outputLen = n6.outputLen, t7.blockLen = n6.blockLen, t7.create = (t8) => e12(t8), t7;
  }, e11.randomBytes = function(e12 = 32) {
    if (t6.crypto && "function" == typeof t6.crypto.getRandomValues) return t6.crypto.getRandomValues(new Uint8Array(e12));
    if (t6.crypto && "function" == typeof t6.crypto.randomBytes) return t6.crypto.randomBytes(e12);
    throw new Error("crypto.getRandomValues must be defined");
  };
  const t6 = qe4, n5 = Le5;
  e11.u8 = (e12) => new Uint8Array(e12.buffer, e12.byteOffset, e12.byteLength);
  e11.u32 = (e12) => new Uint32Array(e12.buffer, e12.byteOffset, Math.floor(e12.byteLength / 4));
  e11.createView = (e12) => new DataView(e12.buffer, e12.byteOffset, e12.byteLength);
  e11.rotr = (e12, t7) => e12 << 32 - t7 | e12 >>> t7;
  e11.rotl = (e12, t7) => e12 << t7 | e12 >>> 32 - t7 >>> 0, e11.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0];
  e11.byteSwap = (e12) => e12 << 24 & 4278190080 | e12 << 8 & 16711680 | e12 >>> 8 & 65280 | e12 >>> 24 & 255, e11.byteSwapIfBE = e11.isLE ? (e12) => e12 : (t7) => (0, e11.byteSwap)(t7);
  const r8 = Array.from({ length: 256 }, (e12, t7) => t7.toString(16).padStart(2, "0"));
  const i9 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function o6(e12) {
    return e12 >= i9._0 && e12 <= i9._9 ? e12 - i9._0 : e12 >= i9._A && e12 <= i9._F ? e12 - (i9._A - 10) : e12 >= i9._a && e12 <= i9._f ? e12 - (i9._a - 10) : void 0;
  }
  function s5(e12) {
    if ("string" != typeof e12) throw new Error("utf8ToBytes expected string, got " + typeof e12);
    return new Uint8Array(new TextEncoder().encode(e12));
  }
  function a6(e12) {
    return "string" == typeof e12 && (e12 = s5(e12)), (0, n5.bytes)(e12), e12;
  }
  e11.nextTick = async () => {
  };
  e11.Hash = class {
    clone() {
      return this._cloneInto();
    }
  };
  const c9 = {}.toString;
}(ze3), Object.defineProperty(Ne3, "__esModule", { value: true }), Ne3.HashMD = Ne3.Maj = Ne3.Chi = void 0;
var We3 = Le5;
var Ve4 = ze3;
Ne3.Chi = (e11, t6, n5) => e11 & t6 ^ ~e11 & n5;
Ne3.Maj = (e11, t6, n5) => e11 & t6 ^ e11 & n5 ^ t6 & n5;
Ne3.HashMD = class extends Ve4.Hash {
  constructor(e11, t6, n5, r8) {
    super(), this.blockLen = e11, this.outputLen = t6, this.padOffset = n5, this.isLE = r8, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e11), this.view = (0, Ve4.createView)(this.buffer);
  }
  update(e11) {
    (0, We3.exists)(this);
    const { view: t6, buffer: n5, blockLen: r8 } = this, i9 = (e11 = (0, Ve4.toBytes)(e11)).length;
    for (let o6 = 0; o6 < i9; ) {
      const s5 = Math.min(r8 - this.pos, i9 - o6);
      if (s5 !== r8) n5.set(e11.subarray(o6, o6 + s5), this.pos), this.pos += s5, o6 += s5, this.pos === r8 && (this.process(t6, 0), this.pos = 0);
      else {
        const t7 = (0, Ve4.createView)(e11);
        for (; r8 <= i9 - o6; o6 += r8) this.process(t7, o6);
      }
    }
    return this.length += e11.length, this.roundClean(), this;
  }
  digestInto(e11) {
    (0, We3.exists)(this), (0, We3.output)(e11, this), this.finished = true;
    const { buffer: t6, view: n5, blockLen: r8, isLE: i9 } = this;
    let { pos: o6 } = this;
    t6[o6++] = 128, this.buffer.subarray(o6).fill(0), this.padOffset > r8 - o6 && (this.process(n5, 0), o6 = 0);
    for (let e12 = o6; e12 < r8; e12++) t6[e12] = 0;
    !function(e12, t7, n6, r9) {
      if ("function" == typeof e12.setBigUint64) return e12.setBigUint64(t7, n6, r9);
      const i10 = BigInt(32), o7 = BigInt(4294967295), s6 = Number(n6 >> i10 & o7), a7 = Number(n6 & o7), c10 = r9 ? 4 : 0, l10 = r9 ? 0 : 4;
      e12.setUint32(t7 + c10, s6, r9), e12.setUint32(t7 + l10, a7, r9);
    }(n5, r8 - 8, BigInt(8 * this.length), i9), this.process(n5, 0);
    const s5 = (0, Ve4.createView)(e11), a6 = this.outputLen;
    if (a6 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c9 = a6 / 4, l9 = this.get();
    if (c9 > l9.length) throw new Error("_sha2: outputLen bigger than state");
    for (let e12 = 0; e12 < c9; e12++) s5.setUint32(4 * e12, l9[e12], i9);
  }
  digest() {
    const { buffer: e11, outputLen: t6 } = this;
    this.digestInto(e11);
    const n5 = e11.slice(0, t6);
    return this.destroy(), n5;
  }
  _cloneInto(e11) {
    e11 || (e11 = new this.constructor()), e11.set(...this.get());
    const { blockLen: t6, buffer: n5, length: r8, finished: i9, destroyed: o6, pos: s5 } = this;
    return e11.length = r8, e11.pos = s5, e11.finished = i9, e11.destroyed = o6, r8 % t6 && e11.buffer.set(n5), e11;
  }
};
var Ge3 = {};
Object.defineProperty(Ge3, "__esModule", { value: true }), Ge3.add5L = Ge3.add5H = Ge3.add4H = Ge3.add4L = Ge3.add3H = Ge3.add3L = Ge3.rotlBL = Ge3.rotlBH = Ge3.rotlSL = Ge3.rotlSH = Ge3.rotr32L = Ge3.rotr32H = Ge3.rotrBL = Ge3.rotrBH = Ge3.rotrSL = Ge3.rotrSH = Ge3.shrSL = Ge3.shrSH = Ge3.toBig = void 0, Ge3.fromBig = Je3, Ge3.split = Qe5, Ge3.add = ht4;
var Ye4 = BigInt(2 ** 32 - 1);
var Ze4 = BigInt(32);
function Je3(e11, t6 = false) {
  return t6 ? { h: Number(e11 & Ye4), l: Number(e11 >> Ze4 & Ye4) } : { h: 0 | Number(e11 >> Ze4 & Ye4), l: 0 | Number(e11 & Ye4) };
}
function Qe5(e11, t6 = false) {
  let n5 = new Uint32Array(e11.length), r8 = new Uint32Array(e11.length);
  for (let i9 = 0; i9 < e11.length; i9++) {
    const { h: o6, l: s5 } = Je3(e11[i9], t6);
    [n5[i9], r8[i9]] = [o6, s5];
  }
  return [n5, r8];
}
var Xe4 = (e11, t6) => BigInt(e11 >>> 0) << Ze4 | BigInt(t6 >>> 0);
Ge3.toBig = Xe4;
var et2 = (e11, t6, n5) => e11 >>> n5;
Ge3.shrSH = et2;
var tt4 = (e11, t6, n5) => e11 << 32 - n5 | t6 >>> n5;
Ge3.shrSL = tt4;
var nt4 = (e11, t6, n5) => e11 >>> n5 | t6 << 32 - n5;
Ge3.rotrSH = nt4;
var rt3 = (e11, t6, n5) => e11 << 32 - n5 | t6 >>> n5;
Ge3.rotrSL = rt3;
var it3 = (e11, t6, n5) => e11 << 64 - n5 | t6 >>> n5 - 32;
Ge3.rotrBH = it3;
var ot3 = (e11, t6, n5) => e11 >>> n5 - 32 | t6 << 64 - n5;
Ge3.rotrBL = ot3;
var st2 = (e11, t6) => t6;
Ge3.rotr32H = st2;
var at3 = (e11, t6) => e11;
Ge3.rotr32L = at3;
var ct4 = (e11, t6, n5) => e11 << n5 | t6 >>> 32 - n5;
Ge3.rotlSH = ct4;
var lt4 = (e11, t6, n5) => t6 << n5 | e11 >>> 32 - n5;
Ge3.rotlSL = lt4;
var dt4 = (e11, t6, n5) => t6 << n5 - 32 | e11 >>> 64 - n5;
Ge3.rotlBH = dt4;
var ut4 = (e11, t6, n5) => e11 << n5 - 32 | t6 >>> 64 - n5;
function ht4(e11, t6, n5, r8) {
  const i9 = (t6 >>> 0) + (r8 >>> 0);
  return { h: e11 + n5 + (i9 / 2 ** 32 | 0) | 0, l: 0 | i9 };
}
Ge3.rotlBL = ut4;
var ft3 = (e11, t6, n5) => (e11 >>> 0) + (t6 >>> 0) + (n5 >>> 0);
Ge3.add3L = ft3;
var pt4 = (e11, t6, n5, r8) => t6 + n5 + r8 + (e11 / 2 ** 32 | 0) | 0;
Ge3.add3H = pt4;
var gt4 = (e11, t6, n5, r8) => (e11 >>> 0) + (t6 >>> 0) + (n5 >>> 0) + (r8 >>> 0);
Ge3.add4L = gt4;
var mt4 = (e11, t6, n5, r8, i9) => t6 + n5 + r8 + i9 + (e11 / 2 ** 32 | 0) | 0;
Ge3.add4H = mt4;
var yt3 = (e11, t6, n5, r8, i9) => (e11 >>> 0) + (t6 >>> 0) + (n5 >>> 0) + (r8 >>> 0) + (i9 >>> 0);
Ge3.add5L = yt3;
var vt4 = (e11, t6, n5, r8, i9, o6) => t6 + n5 + r8 + i9 + o6 + (e11 / 2 ** 32 | 0) | 0;
Ge3.add5H = vt4;
var bt3 = { fromBig: Je3, split: Qe5, toBig: Xe4, shrSH: et2, shrSL: tt4, rotrSH: nt4, rotrSL: rt3, rotrBH: it3, rotrBL: ot3, rotr32H: st2, rotr32L: at3, rotlSH: ct4, rotlSL: lt4, rotlBH: dt4, rotlBL: ut4, add: ht4, add3L: ft3, add3H: pt4, add4L: gt4, add4H: mt4, add5H: vt4, add5L: yt3 };
Ge3.default = bt3, Object.defineProperty(Oe3, "__esModule", { value: true }), Oe3.sha384 = Oe3.sha512_256 = Oe3.sha512_224 = Oe3.sha512 = Oe3.SHA384 = Oe3.SHA512_256 = Oe3.SHA512_224 = Oe3.SHA512 = void 0;
var wt4 = Ne3;
var Et5 = Ge3;
var St5 = ze3;
var [_t3, Ct4] = (() => Et5.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e11) => BigInt(e11))))();
var kt4 = new Uint32Array(80);
var At4 = new Uint32Array(80);
var xt4 = class extends wt4.HashMD {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e11, Al: t6, Bh: n5, Bl: r8, Ch: i9, Cl: o6, Dh: s5, Dl: a6, Eh: c9, El: l9, Fh: d7, Fl: u10, Gh: h9, Gl: f16, Hh: p9, Hl: g4 } = this;
    return [e11, t6, n5, r8, i9, o6, s5, a6, c9, l9, d7, u10, h9, f16, p9, g4];
  }
  set(e11, t6, n5, r8, i9, o6, s5, a6, c9, l9, d7, u10, h9, f16, p9, g4) {
    this.Ah = 0 | e11, this.Al = 0 | t6, this.Bh = 0 | n5, this.Bl = 0 | r8, this.Ch = 0 | i9, this.Cl = 0 | o6, this.Dh = 0 | s5, this.Dl = 0 | a6, this.Eh = 0 | c9, this.El = 0 | l9, this.Fh = 0 | d7, this.Fl = 0 | u10, this.Gh = 0 | h9, this.Gl = 0 | f16, this.Hh = 0 | p9, this.Hl = 0 | g4;
  }
  process(e11, t6) {
    for (let n6 = 0; n6 < 16; n6++, t6 += 4) kt4[n6] = e11.getUint32(t6), At4[n6] = e11.getUint32(t6 += 4);
    for (let e12 = 16; e12 < 80; e12++) {
      const t7 = 0 | kt4[e12 - 15], n6 = 0 | At4[e12 - 15], r9 = Et5.default.rotrSH(t7, n6, 1) ^ Et5.default.rotrSH(t7, n6, 8) ^ Et5.default.shrSH(t7, n6, 7), i10 = Et5.default.rotrSL(t7, n6, 1) ^ Et5.default.rotrSL(t7, n6, 8) ^ Et5.default.shrSL(t7, n6, 7), o7 = 0 | kt4[e12 - 2], s6 = 0 | At4[e12 - 2], a7 = Et5.default.rotrSH(o7, s6, 19) ^ Et5.default.rotrBH(o7, s6, 61) ^ Et5.default.shrSH(o7, s6, 6), c10 = Et5.default.rotrSL(o7, s6, 19) ^ Et5.default.rotrBL(o7, s6, 61) ^ Et5.default.shrSL(o7, s6, 6), l10 = Et5.default.add4L(i10, c10, At4[e12 - 7], At4[e12 - 16]), d8 = Et5.default.add4H(l10, r9, a7, kt4[e12 - 7], kt4[e12 - 16]);
      kt4[e12] = 0 | d8, At4[e12] = 0 | l10;
    }
    let { Ah: n5, Al: r8, Bh: i9, Bl: o6, Ch: s5, Cl: a6, Dh: c9, Dl: l9, Eh: d7, El: u10, Fh: h9, Fl: f16, Gh: p9, Gl: g4, Hh: m6, Hl: y11 } = this;
    for (let e12 = 0; e12 < 80; e12++) {
      const t7 = Et5.default.rotrSH(d7, u10, 14) ^ Et5.default.rotrSH(d7, u10, 18) ^ Et5.default.rotrBH(d7, u10, 41), v9 = Et5.default.rotrSL(d7, u10, 14) ^ Et5.default.rotrSL(d7, u10, 18) ^ Et5.default.rotrBL(d7, u10, 41), b6 = d7 & h9 ^ ~d7 & p9, w8 = u10 & f16 ^ ~u10 & g4, E8 = Et5.default.add5L(y11, v9, w8, Ct4[e12], At4[e12]), S8 = Et5.default.add5H(E8, m6, t7, b6, _t3[e12], kt4[e12]), _6 = 0 | E8, C10 = Et5.default.rotrSH(n5, r8, 28) ^ Et5.default.rotrBH(n5, r8, 34) ^ Et5.default.rotrBH(n5, r8, 39), k11 = Et5.default.rotrSL(n5, r8, 28) ^ Et5.default.rotrBL(n5, r8, 34) ^ Et5.default.rotrBL(n5, r8, 39), A9 = n5 & i9 ^ n5 & s5 ^ i9 & s5, x7 = r8 & o6 ^ r8 & a6 ^ o6 & a6;
      m6 = 0 | p9, y11 = 0 | g4, p9 = 0 | h9, g4 = 0 | f16, h9 = 0 | d7, f16 = 0 | u10, { h: d7, l: u10 } = Et5.default.add(0 | c9, 0 | l9, 0 | S8, 0 | _6), c9 = 0 | s5, l9 = 0 | a6, s5 = 0 | i9, a6 = 0 | o6, i9 = 0 | n5, o6 = 0 | r8;
      const M8 = Et5.default.add3L(_6, k11, x7);
      n5 = Et5.default.add3H(M8, S8, C10, A9), r8 = 0 | M8;
    }
    ({ h: n5, l: r8 } = Et5.default.add(0 | this.Ah, 0 | this.Al, 0 | n5, 0 | r8)), { h: i9, l: o6 } = Et5.default.add(0 | this.Bh, 0 | this.Bl, 0 | i9, 0 | o6), { h: s5, l: a6 } = Et5.default.add(0 | this.Ch, 0 | this.Cl, 0 | s5, 0 | a6), { h: c9, l: l9 } = Et5.default.add(0 | this.Dh, 0 | this.Dl, 0 | c9, 0 | l9), { h: d7, l: u10 } = Et5.default.add(0 | this.Eh, 0 | this.El, 0 | d7, 0 | u10), { h: h9, l: f16 } = Et5.default.add(0 | this.Fh, 0 | this.Fl, 0 | h9, 0 | f16), { h: p9, l: g4 } = Et5.default.add(0 | this.Gh, 0 | this.Gl, 0 | p9, 0 | g4), { h: m6, l: y11 } = Et5.default.add(0 | this.Hh, 0 | this.Hl, 0 | m6, 0 | y11), this.set(n5, r8, i9, o6, s5, a6, c9, l9, d7, u10, h9, f16, p9, g4, m6, y11);
  }
  roundClean() {
    kt4.fill(0), At4.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
Oe3.SHA512 = xt4;
var Mt4 = class extends xt4 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
};
Oe3.SHA512_224 = Mt4;
var It4 = class extends xt4 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
};
Oe3.SHA512_256 = It4;
var Tt4 = class extends xt4 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
};
Oe3.SHA384 = Tt4, Oe3.sha512 = (0, St5.wrapConstructor)(() => new xt4()), Oe3.sha512_224 = (0, St5.wrapConstructor)(() => new Mt4()), Oe3.sha512_256 = (0, St5.wrapConstructor)(() => new It4()), Oe3.sha384 = (0, St5.wrapConstructor)(() => new Tt4());
var Rt4 = {};
var Pt4 = {};
var Ot4 = {};
var Nt4 = {};
Object.defineProperty(Nt4, "__esModule", { value: true }), Nt4.notImplemented = Nt4.bitMask = void 0, Nt4.isBytes = Bt4, Nt4.abytes = Kt4, Nt4.abool = function(e11, t6) {
  if ("boolean" != typeof t6) throw new Error(`${e11} must be valid boolean, got "${t6}".`);
}, Nt4.bytesToHex = Ut3, Nt4.numberToHexUnpadded = Ht4, Nt4.hexToNumber = Ft2, Nt4.hexToBytes = Wt4, Nt4.bytesToNumberBE = function(e11) {
  return Ft2(Ut3(e11));
}, Nt4.bytesToNumberLE = function(e11) {
  return Kt4(e11), Ft2(Ut3(Uint8Array.from(e11).reverse()));
}, Nt4.numberToBytesBE = Vt4, Nt4.numberToBytesLE = function(e11, t6) {
  return Vt4(e11, t6).reverse();
}, Nt4.numberToVarBytesBE = function(e11) {
  return Wt4(Ht4(e11));
}, Nt4.ensureBytes = function(e11, t6, n5) {
  let r8;
  if ("string" == typeof t6) try {
    r8 = Wt4(t6);
  } catch (n6) {
    throw new Error(`${e11} must be valid hex string, got "${t6}". Cause: ${n6}`);
  }
  else {
    if (!Bt4(t6)) throw new Error(`${e11} must be hex string or Uint8Array`);
    r8 = Uint8Array.from(t6);
  }
  const i9 = r8.length;
  if ("number" == typeof n5 && i9 !== n5) throw new Error(`${e11} expected ${n5} bytes, got ${i9}`);
  return r8;
}, Nt4.concatBytes = Gt4, Nt4.equalBytes = function(e11, t6) {
  if (e11.length !== t6.length) return false;
  let n5 = 0;
  for (let r8 = 0; r8 < e11.length; r8++) n5 |= e11[r8] ^ t6[r8];
  return 0 === n5;
}, Nt4.utf8ToBytes = function(e11) {
  if ("string" != typeof e11) throw new Error("utf8ToBytes expected string, got " + typeof e11);
  return new Uint8Array(new TextEncoder().encode(e11));
}, Nt4.inRange = Zt4, Nt4.aInRange = function(e11, t6, n5, r8) {
  if (!Zt4(t6, n5, r8)) throw new Error(`expected valid ${e11}: ${n5} <= n < ${r8}, got ${typeof t6} ${t6}`);
}, Nt4.bitLen = function(e11) {
  let t6;
  for (t6 = 0; e11 > Lt4; e11 >>= Dt3, t6 += 1) ;
  return t6;
}, Nt4.bitGet = function(e11, t6) {
  return e11 >> BigInt(t6) & Dt3;
}, Nt4.bitSet = function(e11, t6, n5) {
  return e11 | (n5 ? Dt3 : Lt4) << BigInt(t6);
}, Nt4.createHmacDrbg = function(e11, t6, n5) {
  if ("number" != typeof e11 || e11 < 2) throw new Error("hashLen must be a number");
  if ("number" != typeof t6 || t6 < 2) throw new Error("qByteLen must be a number");
  if ("function" != typeof n5) throw new Error("hmacFn must be a function");
  let r8 = Jt4(e11), i9 = Jt4(e11), o6 = 0;
  const s5 = () => {
    r8.fill(1), i9.fill(0), o6 = 0;
  }, a6 = (...e12) => n5(i9, r8, ...e12), c9 = (e12 = Jt4()) => {
    i9 = a6(Qt4([0]), e12), r8 = a6(), 0 !== e12.length && (i9 = a6(Qt4([1]), e12), r8 = a6());
  }, l9 = () => {
    if (o6++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let e12 = 0;
    const n6 = [];
    for (; e12 < t6; ) {
      r8 = a6();
      const t7 = r8.slice();
      n6.push(t7), e12 += r8.length;
    }
    return Gt4(...n6);
  };
  return (e12, t7) => {
    let n6;
    for (s5(), c9(e12); !(n6 = t7(l9())); ) c9();
    return s5(), n6;
  };
}, Nt4.validateObject = function(e11, t6, n5 = {}) {
  const r8 = (t7, n6, r9) => {
    const i9 = Xt4[n6];
    if ("function" != typeof i9) throw new Error(`Invalid validator "${n6}", expected function`);
    const o6 = e11[t7];
    if (!(r9 && void 0 === o6 || i9(o6, e11))) throw new Error(`Invalid param ${String(t7)}=${o6} (${typeof o6}), expected ${n6}`);
  };
  for (const [e12, n6] of Object.entries(t6)) r8(e12, n6, false);
  for (const [e12, t7] of Object.entries(n5)) r8(e12, t7, true);
  return e11;
}, Nt4.memoized = function(e11) {
  const t6 = /* @__PURE__ */ new WeakMap();
  return (n5, ...r8) => {
    const i9 = t6.get(n5);
    if (void 0 !== i9) return i9;
    const o6 = e11(n5, ...r8);
    return t6.set(n5, o6), o6;
  };
};
var Lt4 = BigInt(0);
var Dt3 = BigInt(1);
var $t4 = BigInt(2);
function Bt4(e11) {
  return e11 instanceof Uint8Array || null != e11 && "object" == typeof e11 && "Uint8Array" === e11.constructor.name;
}
function Kt4(e11) {
  if (!Bt4(e11)) throw new Error("Uint8Array expected");
}
var jt3 = Array.from({ length: 256 }, (e11, t6) => t6.toString(16).padStart(2, "0"));
function Ut3(e11) {
  Kt4(e11);
  let t6 = "";
  for (let n5 = 0; n5 < e11.length; n5++) t6 += jt3[e11[n5]];
  return t6;
}
function Ht4(e11) {
  const t6 = e11.toString(16);
  return 1 & t6.length ? `0${t6}` : t6;
}
function Ft2(e11) {
  if ("string" != typeof e11) throw new Error("hex string expected, got " + typeof e11);
  return BigInt("" === e11 ? "0" : `0x${e11}`);
}
var zt4 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function qt3(e11) {
  return e11 >= zt4._0 && e11 <= zt4._9 ? e11 - zt4._0 : e11 >= zt4._A && e11 <= zt4._F ? e11 - (zt4._A - 10) : e11 >= zt4._a && e11 <= zt4._f ? e11 - (zt4._a - 10) : void 0;
}
function Wt4(e11) {
  if ("string" != typeof e11) throw new Error("hex string expected, got " + typeof e11);
  const t6 = e11.length, n5 = t6 / 2;
  if (t6 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t6);
  const r8 = new Uint8Array(n5);
  for (let t7 = 0, i9 = 0; t7 < n5; t7++, i9 += 2) {
    const n6 = qt3(e11.charCodeAt(i9)), o6 = qt3(e11.charCodeAt(i9 + 1));
    if (void 0 === n6 || void 0 === o6) {
      const t8 = e11[i9] + e11[i9 + 1];
      throw new Error('hex string expected, got non-hex character "' + t8 + '" at index ' + i9);
    }
    r8[t7] = 16 * n6 + o6;
  }
  return r8;
}
function Vt4(e11, t6) {
  return Wt4(e11.toString(16).padStart(2 * t6, "0"));
}
function Gt4(...e11) {
  let t6 = 0;
  for (let n6 = 0; n6 < e11.length; n6++) {
    const r8 = e11[n6];
    Kt4(r8), t6 += r8.length;
  }
  const n5 = new Uint8Array(t6);
  for (let t7 = 0, r8 = 0; t7 < e11.length; t7++) {
    const i9 = e11[t7];
    n5.set(i9, r8), r8 += i9.length;
  }
  return n5;
}
var Yt4 = (e11) => "bigint" == typeof e11 && Lt4 <= e11;
function Zt4(e11, t6, n5) {
  return Yt4(e11) && Yt4(t6) && Yt4(n5) && t6 <= e11 && e11 < n5;
}
Nt4.bitMask = (e11) => ($t4 << BigInt(e11 - 1)) - Dt3;
var Jt4 = (e11) => new Uint8Array(e11);
var Qt4 = (e11) => Uint8Array.from(e11);
var Xt4 = { bigint: (e11) => "bigint" == typeof e11, function: (e11) => "function" == typeof e11, boolean: (e11) => "boolean" == typeof e11, string: (e11) => "string" == typeof e11, stringOrUint8Array: (e11) => "string" == typeof e11 || Bt4(e11), isSafeInteger: (e11) => Number.isSafeInteger(e11), array: (e11) => Array.isArray(e11), field: (e11, t6) => t6.Fp.isValid(e11), hash: (e11) => "function" == typeof e11 && Number.isSafeInteger(e11.outputLen) };
Nt4.notImplemented = () => {
  throw new Error("not implemented");
}, Object.defineProperty(Ot4, "__esModule", { value: true }), Ot4.isNegativeLE = void 0, Ot4.mod = ln3, Ot4.pow = dn3, Ot4.pow2 = function(e11, t6, n5) {
  let r8 = e11;
  for (; t6-- > tn3; ) r8 *= r8, r8 %= n5;
  return r8;
}, Ot4.invert = un3, Ot4.tonelliShanks = hn3, Ot4.FpSqrt = fn3, Ot4.validateField = function(e11) {
  const t6 = pn3.reduce((e12, t7) => (e12[t7] = "function", e12), { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" });
  return (0, en3.validateObject)(e11, t6);
}, Ot4.FpPow = gn3, Ot4.FpInvertBatch = mn3, Ot4.FpDiv = function(e11, t6, n5) {
  return e11.mul(t6, "bigint" == typeof n5 ? un3(n5, e11.ORDER) : e11.inv(n5));
}, Ot4.FpLegendre = yn3, Ot4.FpIsSquare = function(e11) {
  const t6 = yn3(e11.ORDER);
  return (n5) => {
    const r8 = t6(e11, n5);
    return e11.eql(r8, e11.ZERO) || e11.eql(r8, e11.ONE);
  };
}, Ot4.nLength = vn3, Ot4.Field = function(e11, t6, n5 = false, r8 = {}) {
  if (e11 <= tn3) throw new Error(`Expected Field ORDER > 0, got ${e11}`);
  const { nBitLength: i9, nByteLength: o6 } = vn3(e11, t6);
  if (o6 > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const s5 = fn3(e11), a6 = Object.freeze({ ORDER: e11, BITS: i9, BYTES: o6, MASK: (0, en3.bitMask)(i9), ZERO: tn3, ONE: nn3, create: (t7) => ln3(t7, e11), isValid: (t7) => {
    if ("bigint" != typeof t7) throw new Error("Invalid field element: expected bigint, got " + typeof t7);
    return tn3 <= t7 && t7 < e11;
  }, is0: (e12) => e12 === tn3, isOdd: (e12) => (e12 & nn3) === nn3, neg: (t7) => ln3(-t7, e11), eql: (e12, t7) => e12 === t7, sqr: (t7) => ln3(t7 * t7, e11), add: (t7, n6) => ln3(t7 + n6, e11), sub: (t7, n6) => ln3(t7 - n6, e11), mul: (t7, n6) => ln3(t7 * n6, e11), pow: (e12, t7) => gn3(a6, e12, t7), div: (t7, n6) => ln3(t7 * un3(n6, e11), e11), sqrN: (e12) => e12 * e12, addN: (e12, t7) => e12 + t7, subN: (e12, t7) => e12 - t7, mulN: (e12, t7) => e12 * t7, inv: (t7) => un3(t7, e11), sqrt: r8.sqrt || ((e12) => s5(a6, e12)), invertBatch: (e12) => mn3(a6, e12), cmov: (e12, t7, n6) => n6 ? t7 : e12, toBytes: (e12) => n5 ? (0, en3.numberToBytesLE)(e12, o6) : (0, en3.numberToBytesBE)(e12, o6), fromBytes: (e12) => {
    if (e12.length !== o6) throw new Error(`Fp.fromBytes: expected ${o6}, got ${e12.length}`);
    return n5 ? (0, en3.bytesToNumberLE)(e12) : (0, en3.bytesToNumberBE)(e12);
  } });
  return Object.freeze(a6);
}, Ot4.FpSqrtOdd = function(e11, t6) {
  if (!e11.isOdd) throw new Error("Field doesn't have isOdd");
  const n5 = e11.sqrt(t6);
  return e11.isOdd(n5) ? n5 : e11.neg(n5);
}, Ot4.FpSqrtEven = function(e11, t6) {
  if (!e11.isOdd) throw new Error("Field doesn't have isOdd");
  const n5 = e11.sqrt(t6);
  return e11.isOdd(n5) ? e11.neg(n5) : n5;
}, Ot4.hashToPrivateScalar = function(e11, t6, n5 = false) {
  e11 = (0, en3.ensureBytes)("privateHash", e11);
  const r8 = e11.length, i9 = vn3(t6).nByteLength + 8;
  if (i9 < 24 || r8 < i9 || r8 > 1024) throw new Error(`hashToPrivateScalar: expected ${i9}-1024 bytes of input, got ${r8}`);
  const o6 = n5 ? (0, en3.bytesToNumberLE)(e11) : (0, en3.bytesToNumberBE)(e11);
  return ln3(o6, t6 - nn3) + nn3;
}, Ot4.getFieldBytesLength = bn3, Ot4.getMinHashLength = wn3, Ot4.mapHashToField = function(e11, t6, n5 = false) {
  const r8 = e11.length, i9 = bn3(t6), o6 = wn3(t6);
  if (r8 < 16 || r8 < o6 || r8 > 1024) throw new Error(`expected ${o6}-1024 bytes of input, got ${r8}`);
  const s5 = ln3(n5 ? (0, en3.bytesToNumberBE)(e11) : (0, en3.bytesToNumberLE)(e11), t6 - nn3) + nn3;
  return n5 ? (0, en3.numberToBytesLE)(s5, i9) : (0, en3.numberToBytesBE)(s5, i9);
};
var en3 = Nt4;
var tn3 = BigInt(0);
var nn3 = BigInt(1);
var rn3 = BigInt(2);
var on4 = BigInt(3);
var sn4 = BigInt(4);
var an3 = BigInt(5);
var cn3 = BigInt(8);
function ln3(e11, t6) {
  const n5 = e11 % t6;
  return n5 >= tn3 ? n5 : t6 + n5;
}
function dn3(e11, t6, n5) {
  if (n5 <= tn3 || t6 < tn3) throw new Error("Expected power/modulo > 0");
  if (n5 === nn3) return tn3;
  let r8 = nn3;
  for (; t6 > tn3; ) t6 & nn3 && (r8 = r8 * e11 % n5), e11 = e11 * e11 % n5, t6 >>= nn3;
  return r8;
}
function un3(e11, t6) {
  if (e11 === tn3 || t6 <= tn3) throw new Error(`invert: expected positive integers, got n=${e11} mod=${t6}`);
  let n5 = ln3(e11, t6), r8 = t6, i9 = tn3, o6 = nn3;
  for (; n5 !== tn3; ) {
    const e12 = r8 % n5, t7 = i9 - o6 * (r8 / n5);
    r8 = n5, n5 = e12, i9 = o6, o6 = t7;
  }
  if (r8 !== nn3) throw new Error("invert: does not exist");
  return ln3(i9, t6);
}
function hn3(e11) {
  const t6 = (e11 - nn3) / rn3;
  let n5, r8, i9;
  for (n5 = e11 - nn3, r8 = 0; n5 % rn3 === tn3; n5 /= rn3, r8++) ;
  for (i9 = rn3; i9 < e11 && dn3(i9, t6, e11) !== e11 - nn3; i9++) ;
  if (1 === r8) {
    const t7 = (e11 + nn3) / sn4;
    return function(e12, n6) {
      const r9 = e12.pow(n6, t7);
      if (!e12.eql(e12.sqr(r9), n6)) throw new Error("Cannot find square root");
      return r9;
    };
  }
  const o6 = (n5 + nn3) / rn3;
  return function(e12, s5) {
    if (e12.pow(s5, t6) === e12.neg(e12.ONE)) throw new Error("Cannot find square root");
    let a6 = r8, c9 = e12.pow(e12.mul(e12.ONE, i9), n5), l9 = e12.pow(s5, o6), d7 = e12.pow(s5, n5);
    for (; !e12.eql(d7, e12.ONE); ) {
      if (e12.eql(d7, e12.ZERO)) return e12.ZERO;
      let t7 = 1;
      for (let n7 = e12.sqr(d7); t7 < a6 && !e12.eql(n7, e12.ONE); t7++) n7 = e12.sqr(n7);
      const n6 = e12.pow(c9, nn3 << BigInt(a6 - t7 - 1));
      c9 = e12.sqr(n6), l9 = e12.mul(l9, n6), d7 = e12.mul(d7, c9), a6 = t7;
    }
    return l9;
  };
}
function fn3(e11) {
  if (e11 % sn4 === on4) {
    const t6 = (e11 + nn3) / sn4;
    return function(e12, n5) {
      const r8 = e12.pow(n5, t6);
      if (!e12.eql(e12.sqr(r8), n5)) throw new Error("Cannot find square root");
      return r8;
    };
  }
  if (e11 % cn3 === an3) {
    const t6 = (e11 - an3) / cn3;
    return function(e12, n5) {
      const r8 = e12.mul(n5, rn3), i9 = e12.pow(r8, t6), o6 = e12.mul(n5, i9), s5 = e12.mul(e12.mul(o6, rn3), i9), a6 = e12.mul(o6, e12.sub(s5, e12.ONE));
      if (!e12.eql(e12.sqr(a6), n5)) throw new Error("Cannot find square root");
      return a6;
    };
  }
  return hn3(e11);
}
BigInt(9), BigInt(16);
Ot4.isNegativeLE = (e11, t6) => (ln3(e11, t6) & nn3) === nn3;
var pn3 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function gn3(e11, t6, n5) {
  if (n5 < tn3) throw new Error("Expected power > 0");
  if (n5 === tn3) return e11.ONE;
  if (n5 === nn3) return t6;
  let r8 = e11.ONE, i9 = t6;
  for (; n5 > tn3; ) n5 & nn3 && (r8 = e11.mul(r8, i9)), i9 = e11.sqr(i9), n5 >>= nn3;
  return r8;
}
function mn3(e11, t6) {
  const n5 = new Array(t6.length), r8 = t6.reduce((t7, r9, i10) => e11.is0(r9) ? t7 : (n5[i10] = t7, e11.mul(t7, r9)), e11.ONE), i9 = e11.inv(r8);
  return t6.reduceRight((t7, r9, i10) => e11.is0(r9) ? t7 : (n5[i10] = e11.mul(t7, n5[i10]), e11.mul(t7, r9)), i9), n5;
}
function yn3(e11) {
  const t6 = (e11 - nn3) / rn3;
  return (e12, n5) => e12.pow(n5, t6);
}
function vn3(e11, t6) {
  const n5 = void 0 !== t6 ? t6 : e11.toString(2).length;
  return { nBitLength: n5, nByteLength: Math.ceil(n5 / 8) };
}
function bn3(e11) {
  if ("bigint" != typeof e11) throw new Error("field order must be bigint");
  const t6 = e11.toString(2).length;
  return Math.ceil(t6 / 8);
}
function wn3(e11) {
  const t6 = bn3(e11);
  return t6 + Math.ceil(t6 / 2);
}
Object.defineProperty(Pt4, "__esModule", { value: true }), Pt4.wNAF = function(e11, t6) {
  const n5 = (e12, t7) => {
    const n6 = t7.negate();
    return e12 ? n6 : t7;
  }, r8 = (e12) => {
    if (!Number.isSafeInteger(e12) || e12 <= 0 || e12 > t6) throw new Error(`Wrong window size=${e12}, should be [1..${t6}]`);
  }, i9 = (e12) => {
    r8(e12);
    return { windows: Math.ceil(t6 / e12) + 1, windowSize: 2 ** (e12 - 1) };
  };
  return { constTimeNegate: n5, unsafeLadder(t7, n6) {
    let r9 = e11.ZERO, i10 = t7;
    for (; n6 > _n3; ) n6 & Cn3 && (r9 = r9.add(i10)), i10 = i10.double(), n6 >>= Cn3;
    return r9;
  }, precomputeWindow(e12, t7) {
    const { windows: n6, windowSize: r9 } = i9(t7), o6 = [];
    let s5 = e12, a6 = s5;
    for (let e13 = 0; e13 < n6; e13++) {
      a6 = s5, o6.push(a6);
      for (let e14 = 1; e14 < r9; e14++) a6 = a6.add(s5), o6.push(a6);
      s5 = a6.double();
    }
    return o6;
  }, wNAF(t7, r9, o6) {
    const { windows: s5, windowSize: a6 } = i9(t7);
    let c9 = e11.ZERO, l9 = e11.BASE;
    const d7 = BigInt(2 ** t7 - 1), u10 = 2 ** t7, h9 = BigInt(t7);
    for (let e12 = 0; e12 < s5; e12++) {
      const t8 = e12 * a6;
      let i10 = Number(o6 & d7);
      o6 >>= h9, i10 > a6 && (i10 -= u10, o6 += Cn3);
      const s6 = t8, f16 = t8 + Math.abs(i10) - 1, p9 = e12 % 2 != 0, g4 = i10 < 0;
      0 === i10 ? l9 = l9.add(n5(p9, r9[s6])) : c9 = c9.add(n5(g4, r9[f16]));
    }
    return { p: c9, f: l9 };
  }, wNAFCached(e12, t7, n6) {
    const r9 = An3.get(e12) || 1;
    let i10 = kn3.get(e12);
    return i10 || (i10 = this.precomputeWindow(e12, r9), 1 !== r9 && kn3.set(e12, n6(i10))), this.wNAF(r9, i10, t7);
  }, setWindowSize(e12, t7) {
    r8(t7), An3.set(e12, t7), kn3.delete(e12);
  } };
}, Pt4.pippenger = function(e11, t6, n5, r8) {
  if (!Array.isArray(n5) || !Array.isArray(r8) || r8.length !== n5.length) throw new Error("arrays of points and scalars must have equal length");
  r8.forEach((e12, n6) => {
    if (!t6.isValid(e12)) throw new Error(`wrong scalar at index ${n6}`);
  }), n5.forEach((t7, n6) => {
    if (!(t7 instanceof e11)) throw new Error(`wrong point at index ${n6}`);
  });
  const i9 = (0, Sn3.bitLen)(BigInt(n5.length)), o6 = i9 > 12 ? i9 - 3 : i9 > 4 ? i9 - 2 : i9 ? 2 : 1, s5 = (1 << o6) - 1, a6 = new Array(s5 + 1).fill(e11.ZERO), c9 = Math.floor((t6.BITS - 1) / o6) * o6;
  let l9 = e11.ZERO;
  for (let t7 = c9; t7 >= 0; t7 -= o6) {
    a6.fill(e11.ZERO);
    for (let e12 = 0; e12 < r8.length; e12++) {
      const i11 = r8[e12], o7 = Number(i11 >> BigInt(t7) & BigInt(s5));
      a6[o7] = a6[o7].add(n5[e12]);
    }
    let i10 = e11.ZERO;
    for (let t8 = a6.length - 1, n6 = e11.ZERO; t8 > 0; t8--) n6 = n6.add(a6[t8]), i10 = i10.add(n6);
    if (l9 = l9.add(i10), 0 !== t7) for (let e12 = 0; e12 < o6; e12++) l9 = l9.double();
  }
  return l9;
}, Pt4.validateBasic = function(e11) {
  return (0, En3.validateField)(e11.Fp), (0, Sn3.validateObject)(e11, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...(0, En3.nLength)(e11.n, e11.nBitLength), ...e11, p: e11.Fp.ORDER });
};
var En3 = Ot4;
var Sn3 = Nt4;
var _n3 = BigInt(0);
var Cn3 = BigInt(1);
var kn3 = /* @__PURE__ */ new WeakMap();
var An3 = /* @__PURE__ */ new WeakMap();
Object.defineProperty(Rt4, "__esModule", { value: true }), Rt4.twistedEdwards = function(e11) {
  const t6 = function(e12) {
    const t7 = (0, xn3.validateBasic)(e12);
    return In3.validateObject(e12, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...t7 });
  }(e11), { Fp: n5, n: r8, prehash: i9, hash: o6, randomBytes: s5, nByteLength: a6, h: c9 } = t6, l9 = On3 << BigInt(8 * a6) - Pn3, d7 = n5.create, u10 = (0, Mn3.Field)(t6.n, t6.nBitLength), h9 = t6.uvRatio || ((e12, t7) => {
    try {
      return { isValid: true, value: n5.sqrt(e12 * n5.inv(t7)) };
    } catch (e13) {
      return { isValid: false, value: Rn3 };
    }
  }), f16 = t6.adjustScalarBytes || ((e12) => e12), p9 = t6.domain || ((e12, t7, n6) => {
    if ((0, Tn3.abool)("phflag", n6), t7.length || n6) throw new Error("Contexts/pre-hash are not supported");
    return e12;
  });
  function g4(e12, t7) {
    In3.aInRange("coordinate " + e12, t7, Rn3, l9);
  }
  function m6(e12) {
    if (!(e12 instanceof b6)) throw new Error("ExtendedPoint expected");
  }
  const y11 = (0, Tn3.memoized)((e12, t7) => {
    const { ex: r9, ey: i10, ez: o7 } = e12, s6 = e12.is0();
    null == t7 && (t7 = s6 ? Nn3 : n5.inv(o7));
    const a7 = d7(r9 * t7), c10 = d7(i10 * t7), l10 = d7(o7 * t7);
    if (s6) return { x: Rn3, y: Pn3 };
    if (l10 !== Pn3) throw new Error("invZ was invalid");
    return { x: a7, y: c10 };
  }), v9 = (0, Tn3.memoized)((e12) => {
    const { a: n6, d: r9 } = t6;
    if (e12.is0()) throw new Error("bad point: ZERO");
    const { ex: i10, ey: o7, ez: s6, et: a7 } = e12, c10 = d7(i10 * i10), l10 = d7(o7 * o7), u11 = d7(s6 * s6), h10 = d7(u11 * u11), f17 = d7(c10 * n6);
    if (d7(u11 * d7(f17 + l10)) !== d7(h10 + d7(r9 * d7(c10 * l10)))) throw new Error("bad point: equation left != right (1)");
    if (d7(i10 * o7) !== d7(s6 * a7)) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class b6 {
    constructor(e12, t7, n6, r9) {
      this.ex = e12, this.ey = t7, this.ez = n6, this.et = r9, g4("x", e12), g4("y", t7), g4("z", n6), g4("t", r9), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(e12) {
      if (e12 instanceof b6) throw new Error("extended point not allowed");
      const { x: t7, y: n6 } = e12 || {};
      return g4("x", t7), g4("y", n6), new b6(t7, n6, Pn3, d7(t7 * n6));
    }
    static normalizeZ(e12) {
      const t7 = n5.invertBatch(e12.map((e13) => e13.ez));
      return e12.map((e13, n6) => e13.toAffine(t7[n6])).map(b6.fromAffine);
    }
    static msm(e12, t7) {
      return (0, xn3.pippenger)(b6, u10, e12, t7);
    }
    _setWindowSize(e12) {
      S8.setWindowSize(this, e12);
    }
    assertValidity() {
      v9(this);
    }
    equals(e12) {
      m6(e12);
      const { ex: t7, ey: n6, ez: r9 } = this, { ex: i10, ey: o7, ez: s6 } = e12, a7 = d7(t7 * s6), c10 = d7(i10 * r9), l10 = d7(n6 * s6), u11 = d7(o7 * r9);
      return a7 === c10 && l10 === u11;
    }
    is0() {
      return this.equals(b6.ZERO);
    }
    negate() {
      return new b6(d7(-this.ex), this.ey, this.ez, d7(-this.et));
    }
    double() {
      const { a: e12 } = t6, { ex: n6, ey: r9, ez: i10 } = this, o7 = d7(n6 * n6), s6 = d7(r9 * r9), a7 = d7(On3 * d7(i10 * i10)), c10 = d7(e12 * o7), l10 = n6 + r9, u11 = d7(d7(l10 * l10) - o7 - s6), h10 = c10 + s6, f17 = h10 - a7, p10 = c10 - s6, g5 = d7(u11 * f17), m7 = d7(h10 * p10), y12 = d7(u11 * p10), v10 = d7(f17 * h10);
      return new b6(g5, m7, v10, y12);
    }
    add(e12) {
      m6(e12);
      const { a: n6, d: r9 } = t6, { ex: i10, ey: o7, ez: s6, et: a7 } = this, { ex: c10, ey: l10, ez: u11, et: h10 } = e12;
      if (n6 === BigInt(-1)) {
        const e13 = d7((o7 - i10) * (l10 + c10)), t7 = d7((o7 + i10) * (l10 - c10)), n7 = d7(t7 - e13);
        if (n7 === Rn3) return this.double();
        const r10 = d7(s6 * On3 * h10), f18 = d7(a7 * On3 * u11), p11 = f18 + r10, g6 = t7 + e13, m7 = f18 - r10, y13 = d7(p11 * n7), v11 = d7(g6 * m7), w10 = d7(p11 * m7), E10 = d7(n7 * g6);
        return new b6(y13, v11, E10, w10);
      }
      const f17 = d7(i10 * c10), p10 = d7(o7 * l10), g5 = d7(a7 * r9 * h10), y12 = d7(s6 * u11), v10 = d7((i10 + o7) * (c10 + l10) - f17 - p10), w9 = y12 - g5, E9 = y12 + g5, S9 = d7(p10 - n6 * f17), _7 = d7(v10 * w9), C11 = d7(E9 * S9), k12 = d7(v10 * S9), A10 = d7(w9 * E9);
      return new b6(_7, C11, A10, k12);
    }
    subtract(e12) {
      return this.add(e12.negate());
    }
    wNAF(e12) {
      return S8.wNAFCached(this, e12, b6.normalizeZ);
    }
    multiply(e12) {
      const t7 = e12;
      In3.aInRange("scalar", t7, Pn3, r8);
      const { p: n6, f: i10 } = this.wNAF(t7);
      return b6.normalizeZ([n6, i10])[0];
    }
    multiplyUnsafe(e12) {
      const t7 = e12;
      return In3.aInRange("scalar", t7, Rn3, r8), t7 === Rn3 ? E8 : this.equals(E8) || t7 === Pn3 ? this : this.equals(w8) ? this.wNAF(t7).p : S8.unsafeLadder(this, t7);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(c9).is0();
    }
    isTorsionFree() {
      return S8.unsafeLadder(this, r8).is0();
    }
    toAffine(e12) {
      return y11(this, e12);
    }
    clearCofactor() {
      const { h: e12 } = t6;
      return e12 === Pn3 ? this : this.multiplyUnsafe(e12);
    }
    static fromHex(e12, r9 = false) {
      const { d: i10, a: o7 } = t6, s6 = n5.BYTES;
      e12 = (0, Tn3.ensureBytes)("pointHex", e12, s6), (0, Tn3.abool)("zip215", r9);
      const a7 = e12.slice(), c10 = e12[s6 - 1];
      a7[s6 - 1] = -129 & c10;
      const u11 = In3.bytesToNumberLE(a7), f17 = r9 ? l9 : n5.ORDER;
      In3.aInRange("pointHex.y", u11, Rn3, f17);
      const p10 = d7(u11 * u11), g5 = d7(p10 - Pn3), m7 = d7(i10 * p10 - o7);
      let { isValid: y12, value: v10 } = h9(g5, m7);
      if (!y12) throw new Error("Point.fromHex: invalid y coordinate");
      const w9 = (v10 & Pn3) === Pn3, E9 = 0 != (128 & c10);
      if (!r9 && v10 === Rn3 && E9) throw new Error("Point.fromHex: x=0 and x_0=1");
      return E9 !== w9 && (v10 = d7(-v10)), b6.fromAffine({ x: v10, y: u11 });
    }
    static fromPrivateKey(e12) {
      return k11(e12).point;
    }
    toRawBytes() {
      const { x: e12, y: t7 } = this.toAffine(), r9 = In3.numberToBytesLE(t7, n5.BYTES);
      return r9[r9.length - 1] |= e12 & Pn3 ? 128 : 0, r9;
    }
    toHex() {
      return In3.bytesToHex(this.toRawBytes());
    }
  }
  b6.BASE = new b6(t6.Gx, t6.Gy, Pn3, d7(t6.Gx * t6.Gy)), b6.ZERO = new b6(Rn3, Pn3, Pn3, Rn3);
  const { BASE: w8, ZERO: E8 } = b6, S8 = (0, xn3.wNAF)(b6, 8 * a6);
  function _6(e12) {
    return (0, Mn3.mod)(e12, r8);
  }
  function C10(e12) {
    return _6(In3.bytesToNumberLE(e12));
  }
  function k11(e12) {
    const t7 = a6;
    e12 = (0, Tn3.ensureBytes)("private key", e12, t7);
    const n6 = (0, Tn3.ensureBytes)("hashed private key", o6(e12), 2 * t7), r9 = f16(n6.slice(0, t7)), i10 = n6.slice(t7, 2 * t7), s6 = C10(r9), c10 = w8.multiply(s6), l10 = c10.toRawBytes();
    return { head: r9, prefix: i10, scalar: s6, point: c10, pointBytes: l10 };
  }
  function A9(e12 = new Uint8Array(), ...t7) {
    const n6 = In3.concatBytes(...t7);
    return C10(o6(p9(n6, (0, Tn3.ensureBytes)("context", e12), !!i9)));
  }
  const x7 = Ln3;
  w8._setWindowSize(8);
  const M8 = { getExtendedPublicKey: k11, randomPrivateKey: () => s5(n5.BYTES), precompute: (e12 = 8, t7 = b6.BASE) => (t7._setWindowSize(e12), t7.multiply(BigInt(3)), t7) };
  return { CURVE: t6, getPublicKey: function(e12) {
    return k11(e12).pointBytes;
  }, sign: function(e12, t7, o7 = {}) {
    e12 = (0, Tn3.ensureBytes)("message", e12), i9 && (e12 = i9(e12));
    const { prefix: s6, scalar: c10, pointBytes: l10 } = k11(t7), d8 = A9(o7.context, s6, e12), u11 = w8.multiply(d8).toRawBytes(), h10 = _6(d8 + A9(o7.context, u11, l10, e12) * c10);
    In3.aInRange("signature.s", h10, Rn3, r8);
    const f17 = In3.concatBytes(u11, In3.numberToBytesLE(h10, n5.BYTES));
    return (0, Tn3.ensureBytes)("result", f17, 2 * a6);
  }, verify: function(e12, t7, r9, o7 = x7) {
    const { context: s6, zip215: a7 } = o7, c10 = n5.BYTES;
    e12 = (0, Tn3.ensureBytes)("signature", e12, 2 * c10), t7 = (0, Tn3.ensureBytes)("message", t7), void 0 !== a7 && (0, Tn3.abool)("zip215", a7), i9 && (t7 = i9(t7));
    const l10 = In3.bytesToNumberLE(e12.slice(c10, 2 * c10));
    let d8, u11, h10;
    try {
      d8 = b6.fromHex(r9, a7), u11 = b6.fromHex(e12.slice(0, c10), a7), h10 = w8.multiplyUnsafe(l10);
    } catch (e13) {
      return false;
    }
    if (!a7 && d8.isSmallOrder()) return false;
    const f17 = A9(s6, u11.toRawBytes(), d8.toRawBytes(), t7);
    return u11.add(d8.multiplyUnsafe(f17)).subtract(h10).clearCofactor().equals(b6.ZERO);
  }, ExtendedPoint: b6, utils: M8 };
};
var xn3 = Pt4;
var Mn3 = Ot4;
var In3 = Nt4;
var Tn3 = Nt4;
var Rn3 = BigInt(0);
var Pn3 = BigInt(1);
var On3 = BigInt(2);
var Nn3 = BigInt(8);
var Ln3 = { zip215: true };
var Dn3 = {};
Object.defineProperty(Dn3, "__esModule", { value: true }), Dn3.expand_message_xmd = Fn3, Dn3.expand_message_xof = zn3, Dn3.hash_to_field = qn3, Dn3.isogenyMap = function(e11, t6) {
  const n5 = t6.map((e12) => Array.from(e12).reverse());
  return (t7, r8) => {
    const [i9, o6, s5, a6] = n5.map((n6) => n6.reduce((n7, r9) => e11.add(e11.mul(n7, t7), r9)));
    return t7 = e11.div(i9, o6), r8 = e11.mul(r8, e11.div(s5, a6)), { x: t7, y: r8 };
  };
}, Dn3.createHasher = function(e11, t6, n5) {
  if ("function" != typeof t6) throw new Error("mapToCurve() must be defined");
  return { hashToCurve(r8, i9) {
    const o6 = qn3(r8, 2, { ...n5, DST: n5.DST, ...i9 }), s5 = e11.fromAffine(t6(o6[0])), a6 = e11.fromAffine(t6(o6[1])), c9 = s5.add(a6).clearCofactor();
    return c9.assertValidity(), c9;
  }, encodeToCurve(r8, i9) {
    const o6 = qn3(r8, 1, { ...n5, DST: n5.encodeDST, ...i9 }), s5 = e11.fromAffine(t6(o6[0])).clearCofactor();
    return s5.assertValidity(), s5;
  }, mapToCurve(n6) {
    if (!Array.isArray(n6)) throw new Error("mapToCurve: expected array of bigints");
    for (const e12 of n6) if ("bigint" != typeof e12) throw new Error(`mapToCurve: expected array of bigints, got ${e12} in array`);
    const r8 = e11.fromAffine(t6(n6)).clearCofactor();
    return r8.assertValidity(), r8;
  } };
};
var $n3 = Ot4;
var Bn3 = Nt4;
var Kn3 = Bn3.bytesToNumberBE;
function jn3(e11, t6) {
  if (Hn3(e11), Hn3(t6), e11 < 0 || e11 >= 1 << 8 * t6) throw new Error(`bad I2OSP call: value=${e11} length=${t6}`);
  const n5 = Array.from({ length: t6 }).fill(0);
  for (let r8 = t6 - 1; r8 >= 0; r8--) n5[r8] = 255 & e11, e11 >>>= 8;
  return new Uint8Array(n5);
}
function Un3(e11, t6) {
  const n5 = new Uint8Array(e11.length);
  for (let r8 = 0; r8 < e11.length; r8++) n5[r8] = e11[r8] ^ t6[r8];
  return n5;
}
function Hn3(e11) {
  if (!Number.isSafeInteger(e11)) throw new Error("number expected");
}
function Fn3(e11, t6, n5, r8) {
  (0, Bn3.abytes)(e11), (0, Bn3.abytes)(t6), Hn3(n5), t6.length > 255 && (t6 = r8((0, Bn3.concatBytes)((0, Bn3.utf8ToBytes)("H2C-OVERSIZE-DST-"), t6)));
  const { outputLen: i9, blockLen: o6 } = r8, s5 = Math.ceil(n5 / i9);
  if (n5 > 65535 || s5 > 255) throw new Error("expand_message_xmd: invalid lenInBytes");
  const a6 = (0, Bn3.concatBytes)(t6, jn3(t6.length, 1)), c9 = jn3(0, o6), l9 = jn3(n5, 2), d7 = new Array(s5), u10 = r8((0, Bn3.concatBytes)(c9, e11, l9, jn3(0, 1), a6));
  d7[0] = r8((0, Bn3.concatBytes)(u10, jn3(1, 1), a6));
  for (let e12 = 1; e12 <= s5; e12++) {
    const t7 = [Un3(u10, d7[e12 - 1]), jn3(e12 + 1, 1), a6];
    d7[e12] = r8((0, Bn3.concatBytes)(...t7));
  }
  return (0, Bn3.concatBytes)(...d7).slice(0, n5);
}
function zn3(e11, t6, n5, r8, i9) {
  if ((0, Bn3.abytes)(e11), (0, Bn3.abytes)(t6), Hn3(n5), t6.length > 255) {
    const e12 = Math.ceil(2 * r8 / 8);
    t6 = i9.create({ dkLen: e12 }).update((0, Bn3.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t6).digest();
  }
  if (n5 > 65535 || t6.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
  return i9.create({ dkLen: n5 }).update(e11).update(jn3(n5, 2)).update(t6).update(jn3(t6.length, 1)).digest();
}
function qn3(e11, t6, n5) {
  (0, Bn3.validateObject)(n5, { DST: "stringOrUint8Array", p: "bigint", m: "isSafeInteger", k: "isSafeInteger", hash: "hash" });
  const { p: r8, k: i9, m: o6, hash: s5, expand: a6, DST: c9 } = n5;
  (0, Bn3.abytes)(e11), Hn3(t6);
  const l9 = "string" == typeof c9 ? (0, Bn3.utf8ToBytes)(c9) : c9, d7 = r8.toString(2).length, u10 = Math.ceil((d7 + i9) / 8), h9 = t6 * o6 * u10;
  let f16;
  if ("xmd" === a6) f16 = Fn3(e11, l9, h9, s5);
  else if ("xof" === a6) f16 = zn3(e11, l9, h9, i9, s5);
  else {
    if ("_internal_pass" !== a6) throw new Error('expand must be "xmd" or "xof"');
    f16 = e11;
  }
  const p9 = new Array(t6);
  for (let e12 = 0; e12 < t6; e12++) {
    const t7 = new Array(o6);
    for (let n6 = 0; n6 < o6; n6++) {
      const i10 = u10 * (n6 + e12 * o6), s6 = f16.subarray(i10, i10 + u10);
      t7[n6] = (0, $n3.mod)(Kn3(s6), r8);
    }
    p9[e12] = t7;
  }
  return p9;
}
var Wn2 = {};
Object.defineProperty(Wn2, "__esModule", { value: true }), Wn2.montgomery = function(e11) {
  const t6 = function(e12) {
    return (0, Gn2.validateObject)(e12, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...e12 });
  }(e11), { P: n5 } = t6, r8 = (e12) => (0, Vn3.mod)(e12, n5), i9 = t6.montgomeryBits, o6 = Math.ceil(i9 / 8), s5 = t6.nByteLength, a6 = t6.adjustScalarBytes || ((e12) => e12), c9 = t6.powPminus2 || ((e12) => (0, Vn3.pow)(e12, n5 - BigInt(2), n5));
  function l9(e12, t7, n6) {
    const i10 = r8(e12 * (t7 - n6));
    return [t7 = r8(t7 - i10), n6 = r8(n6 + i10)];
  }
  const d7 = (t6.a - BigInt(2)) / BigInt(4);
  function u10(e12) {
    return (0, Gn2.numberToBytesLE)(r8(e12), o6);
  }
  function h9(e12, t7) {
    const h10 = function(e13) {
      const t8 = (0, Gn2.ensureBytes)("u coordinate", e13, o6);
      return 32 === s5 && (t8[31] &= 127), (0, Gn2.bytesToNumberLE)(t8);
    }(t7), f17 = function(e13) {
      const t8 = (0, Gn2.ensureBytes)("scalar", e13), n6 = t8.length;
      if (n6 !== o6 && n6 !== s5) throw new Error(`Expected ${o6} or ${s5} bytes, got ${n6}`);
      return (0, Gn2.bytesToNumberLE)(a6(t8));
    }(e12), p10 = function(e13, t8) {
      (0, Gn2.aInRange)("u", e13, Yn2, n5), (0, Gn2.aInRange)("scalar", t8, Yn2, n5);
      const o7 = t8, s6 = e13;
      let a7, u11 = Zn2, h11 = Yn2, f18 = e13, p11 = Zn2, g4 = Yn2;
      for (let e14 = BigInt(i9 - 1); e14 >= Yn2; e14--) {
        const t9 = o7 >> e14 & Zn2;
        g4 ^= t9, a7 = l9(g4, u11, f18), u11 = a7[0], f18 = a7[1], a7 = l9(g4, h11, p11), h11 = a7[0], p11 = a7[1], g4 = t9;
        const n6 = u11 + h11, i10 = r8(n6 * n6), c10 = u11 - h11, m7 = r8(c10 * c10), y11 = i10 - m7, v9 = f18 + p11, b6 = r8((f18 - p11) * n6), w8 = r8(v9 * c10), E8 = b6 + w8, S8 = b6 - w8;
        f18 = r8(E8 * E8), p11 = r8(s6 * r8(S8 * S8)), u11 = r8(i10 * m7), h11 = r8(y11 * (i10 + r8(d7 * y11)));
      }
      a7 = l9(g4, u11, f18), u11 = a7[0], f18 = a7[1], a7 = l9(g4, h11, p11), h11 = a7[0], p11 = a7[1];
      const m6 = c9(h11);
      return r8(u11 * m6);
    }(h10, f17);
    if (p10 === Yn2) throw new Error("Invalid private or public key received");
    return u10(p10);
  }
  const f16 = u10(t6.Gu);
  function p9(e12) {
    return h9(e12, f16);
  }
  return { scalarMult: h9, scalarMultBase: p9, getSharedSecret: (e12, t7) => h9(e12, t7), getPublicKey: (e12) => p9(e12), utils: { randomPrivateKey: () => t6.randomBytes(t6.nByteLength) }, GuBytes: f16 };
};
var Vn3 = Ot4;
var Gn2 = Nt4;
var Yn2 = BigInt(0);
var Zn2 = BigInt(1);
!function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.hash_to_ristretto255 = e11.hashToRistretto255 = e11.RistrettoPoint = e11.encodeToCurve = e11.hashToCurve = e11.edwardsToMontgomery = e11.x25519 = e11.ed25519ph = e11.ed25519ctx = e11.ed25519 = e11.ED25519_TORSION_SUBGROUP = void 0, e11.edwardsToMontgomeryPub = S8, e11.edwardsToMontgomeryPriv = function(e12) {
    const t7 = w8.hash(e12.subarray(0, 32));
    return w8.adjustScalarBytes(t7).subarray(0, 32);
  };
  const t6 = Oe3, n5 = ze3, r8 = Rt4, i9 = Dn3, o6 = Ot4, s5 = Wn2, a6 = Nt4, c9 = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), l9 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), d7 = BigInt(0), u10 = BigInt(1), h9 = BigInt(2), f16 = BigInt(3), p9 = BigInt(5), g4 = BigInt(8);
  function m6(e12) {
    const t7 = BigInt(10), n6 = BigInt(20), r9 = BigInt(40), i10 = BigInt(80), s6 = c9, a7 = e12 * e12 % s6 * e12 % s6, l10 = (0, o6.pow2)(a7, h9, s6) * a7 % s6, d8 = (0, o6.pow2)(l10, u10, s6) * e12 % s6, f17 = (0, o6.pow2)(d8, p9, s6) * d8 % s6, g5 = (0, o6.pow2)(f17, t7, s6) * f17 % s6, m7 = (0, o6.pow2)(g5, n6, s6) * g5 % s6, y12 = (0, o6.pow2)(m7, r9, s6) * m7 % s6, v10 = (0, o6.pow2)(y12, i10, s6) * y12 % s6, b7 = (0, o6.pow2)(v10, i10, s6) * y12 % s6, w9 = (0, o6.pow2)(b7, t7, s6) * f17 % s6;
    return { pow_p_5_8: (0, o6.pow2)(w9, h9, s6) * e12 % s6, b2: a7 };
  }
  function y11(e12) {
    return e12[0] &= 248, e12[31] &= 127, e12[31] |= 64, e12;
  }
  function v9(e12, t7) {
    const n6 = c9, r9 = (0, o6.mod)(t7 * t7 * t7, n6), i10 = m6(e12 * (0, o6.mod)(r9 * r9 * t7, n6)).pow_p_5_8;
    let s6 = (0, o6.mod)(e12 * r9 * i10, n6);
    const a7 = (0, o6.mod)(t7 * s6 * s6, n6), d8 = s6, u11 = (0, o6.mod)(s6 * l9, n6), h10 = a7 === e12, f17 = a7 === (0, o6.mod)(-e12, n6), p10 = a7 === (0, o6.mod)(-e12 * l9, n6);
    return h10 && (s6 = d8), (f17 || p10) && (s6 = u11), (0, o6.isNegativeLE)(s6, n6) && (s6 = (0, o6.mod)(-s6, n6)), { isValid: h10 || f17, value: s6 };
  }
  e11.ED25519_TORSION_SUBGROUP = ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];
  const b6 = (() => (0, o6.Field)(c9, void 0, true))(), w8 = (() => ({ a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: b6, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: g4, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: t6.sha512, randomBytes: n5.randomBytes, adjustScalarBytes: y11, uvRatio: v9 }))();
  function E8(e12, t7, r9) {
    if (t7.length > 255) throw new Error("Context is too big");
    return (0, n5.concatBytes)((0, n5.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([r9 ? 1 : 0, t7.length]), t7, e12);
  }
  function S8(t7) {
    const { y: n6 } = e11.ed25519.ExtendedPoint.fromHex(t7), r9 = BigInt(1);
    return b6.toBytes(b6.create((r9 + n6) * b6.inv(r9 - n6)));
  }
  e11.ed25519 = (0, r8.twistedEdwards)(w8), e11.ed25519ctx = (0, r8.twistedEdwards)({ ...w8, domain: E8 }), e11.ed25519ph = (0, r8.twistedEdwards)(Object.assign({}, w8, { domain: E8, prehash: t6.sha512 })), e11.x25519 = (0, s5.montgomery)({ P: c9, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (e12) => {
    const t7 = c9, { pow_p_5_8: n6, b2: r9 } = m6(e12);
    return (0, o6.mod)((0, o6.pow2)(n6, f16, t7) * r9, t7);
  }, adjustScalarBytes: y11, randomBytes: n5.randomBytes }), e11.edwardsToMontgomery = S8;
  const _6 = (() => (b6.ORDER + f16) / g4)(), C10 = (() => b6.pow(h9, _6))(), k11 = (() => b6.sqrt(b6.neg(b6.ONE)))();
  const A9 = (() => (0, o6.FpSqrtEven)(b6, b6.neg(BigInt(486664))))();
  function x7(e12) {
    const { xMn: t7, xMd: n6, yMn: r9, yMd: i10 } = function(e13) {
      const t8 = (b6.ORDER - p9) / g4, n7 = BigInt(486662);
      let r10 = b6.sqr(e13);
      r10 = b6.mul(r10, h9);
      let i11 = b6.add(r10, b6.ONE), o8 = b6.neg(n7), s7 = b6.sqr(i11), a8 = b6.mul(s7, i11), c11 = b6.mul(r10, n7);
      c11 = b6.mul(c11, o8), c11 = b6.add(c11, s7), c11 = b6.mul(c11, o8);
      let l11 = b6.sqr(a8);
      s7 = b6.sqr(l11), l11 = b6.mul(l11, a8), l11 = b6.mul(l11, c11), s7 = b6.mul(s7, l11);
      let d9 = b6.pow(s7, t8);
      d9 = b6.mul(d9, l11);
      let f18 = b6.mul(d9, k11);
      s7 = b6.sqr(d9), s7 = b6.mul(s7, a8);
      let m7 = b6.eql(s7, c11), y12 = b6.cmov(f18, d9, m7), v10 = b6.mul(o8, r10), w9 = b6.mul(d9, e13);
      w9 = b6.mul(w9, C10);
      let E9 = b6.mul(w9, k11), S9 = b6.mul(c11, r10);
      s7 = b6.sqr(w9), s7 = b6.mul(s7, a8);
      let _7 = b6.eql(s7, S9), A10 = b6.cmov(E9, w9, _7);
      s7 = b6.sqr(y12), s7 = b6.mul(s7, a8);
      let x8 = b6.eql(s7, c11), M9 = b6.cmov(v10, o8, x8), I9 = b6.cmov(A10, y12, x8), T9 = b6.isOdd(I9);
      return I9 = b6.cmov(I9, b6.neg(I9), x8 !== T9), { xMn: M9, xMd: i11, yMn: I9, yMd: u10 };
    }(e12);
    let o7 = b6.mul(t7, i10);
    o7 = b6.mul(o7, A9);
    let s6 = b6.mul(n6, r9), a7 = b6.sub(t7, n6), c10 = b6.add(t7, n6), l10 = b6.mul(s6, c10), d8 = b6.eql(l10, b6.ZERO);
    o7 = b6.cmov(o7, b6.ZERO, d8), s6 = b6.cmov(s6, b6.ONE, d8), a7 = b6.cmov(a7, b6.ONE, d8), c10 = b6.cmov(c10, b6.ONE, d8);
    const f17 = b6.invertBatch([s6, c10]);
    return { x: b6.mul(o7, f17[0]), y: b6.mul(a7, f17[1]) };
  }
  const M8 = (() => (0, i9.createHasher)(e11.ed25519.ExtendedPoint, (e12) => x7(e12[0]), { DST: "edwards25519_XMD:SHA-512_ELL2_RO_", encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_", p: b6.ORDER, m: 1, k: 128, expand: "xmd", hash: t6.sha512 }))();
  function I8(e12) {
    if (!(e12 instanceof K5)) throw new Error("RistrettoPoint expected");
  }
  e11.hashToCurve = M8.hashToCurve, e11.encodeToCurve = M8.encodeToCurve;
  const T8 = l9, R6 = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), P7 = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), O8 = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), N9 = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), L7 = (e12) => v9(u10, e12), D9 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), $8 = (t7) => e11.ed25519.CURVE.Fp.create((0, a6.bytesToNumberLE)(t7) & D9);
  function B9(t7) {
    const { d: n6 } = e11.ed25519.CURVE, r9 = e11.ed25519.CURVE.Fp.ORDER, i10 = e11.ed25519.CURVE.Fp.create, s6 = i10(T8 * t7 * t7), a7 = i10((s6 + u10) * O8);
    let c10 = BigInt(-1);
    const l10 = i10((c10 - n6 * s6) * i10(s6 + n6));
    let { isValid: d8, value: h10 } = v9(a7, l10), f17 = i10(h10 * t7);
    (0, o6.isNegativeLE)(f17, r9) || (f17 = i10(-f17)), d8 || (h10 = f17), d8 || (c10 = s6);
    const p10 = i10(c10 * (s6 - u10) * N9 - l10), g5 = h10 * h10, m7 = i10((h10 + h10) * l10), y12 = i10(p10 * R6), b7 = i10(u10 - g5), w9 = i10(u10 + g5);
    return new e11.ed25519.ExtendedPoint(i10(m7 * w9), i10(b7 * y12), i10(y12 * w9), i10(m7 * b7));
  }
  class K5 {
    constructor(e12) {
      this.ep = e12;
    }
    static fromAffine(t7) {
      return new K5(e11.ed25519.ExtendedPoint.fromAffine(t7));
    }
    static hashToCurve(e12) {
      e12 = (0, a6.ensureBytes)("ristrettoHash", e12, 64);
      const t7 = B9($8(e12.slice(0, 32))), n6 = B9($8(e12.slice(32, 64)));
      return new K5(t7.add(n6));
    }
    static fromHex(t7) {
      t7 = (0, a6.ensureBytes)("ristrettoHex", t7, 32);
      const { a: n6, d: r9 } = e11.ed25519.CURVE, i10 = e11.ed25519.CURVE.Fp.ORDER, s6 = e11.ed25519.CURVE.Fp.create, c10 = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", l10 = $8(t7);
      if (!(0, a6.equalBytes)((0, a6.numberToBytesLE)(l10, 32), t7) || (0, o6.isNegativeLE)(l10, i10)) throw new Error(c10);
      const h10 = s6(l10 * l10), f17 = s6(u10 + n6 * h10), p10 = s6(u10 - n6 * h10), g5 = s6(f17 * f17), m7 = s6(p10 * p10), y12 = s6(n6 * r9 * g5 - m7), { isValid: v10, value: b7 } = L7(s6(y12 * m7)), w9 = s6(b7 * p10), E9 = s6(b7 * w9 * y12);
      let S9 = s6((l10 + l10) * w9);
      (0, o6.isNegativeLE)(S9, i10) && (S9 = s6(-S9));
      const _7 = s6(f17 * E9), C11 = s6(S9 * _7);
      if (!v10 || (0, o6.isNegativeLE)(C11, i10) || _7 === d7) throw new Error(c10);
      return new K5(new e11.ed25519.ExtendedPoint(S9, _7, u10, C11));
    }
    toRawBytes() {
      let { ex: t7, ey: n6, ez: r9, et: i10 } = this.ep;
      const s6 = e11.ed25519.CURVE.Fp.ORDER, c10 = e11.ed25519.CURVE.Fp.create, l10 = c10(c10(r9 + n6) * c10(r9 - n6)), d8 = c10(t7 * n6), u11 = c10(d8 * d8), { value: h10 } = L7(c10(l10 * u11)), f17 = c10(h10 * l10), p10 = c10(h10 * d8), g5 = c10(f17 * p10 * i10);
      let m7;
      if ((0, o6.isNegativeLE)(i10 * g5, s6)) {
        let e12 = c10(n6 * T8), r10 = c10(t7 * T8);
        t7 = e12, n6 = r10, m7 = c10(f17 * P7);
      } else m7 = p10;
      (0, o6.isNegativeLE)(t7 * g5, s6) && (n6 = c10(-n6));
      let y12 = c10((r9 - n6) * m7);
      return (0, o6.isNegativeLE)(y12, s6) && (y12 = c10(-y12)), (0, a6.numberToBytesLE)(y12, 32);
    }
    toHex() {
      return (0, a6.bytesToHex)(this.toRawBytes());
    }
    toString() {
      return this.toHex();
    }
    equals(t7) {
      I8(t7);
      const { ex: n6, ey: r9 } = this.ep, { ex: i10, ey: o7 } = t7.ep, s6 = e11.ed25519.CURVE.Fp.create, a7 = s6(n6 * o7) === s6(r9 * i10), c10 = s6(r9 * o7) === s6(n6 * i10);
      return a7 || c10;
    }
    add(e12) {
      return I8(e12), new K5(this.ep.add(e12.ep));
    }
    subtract(e12) {
      return I8(e12), new K5(this.ep.subtract(e12.ep));
    }
    multiply(e12) {
      return new K5(this.ep.multiply(e12));
    }
    multiplyUnsafe(e12) {
      return new K5(this.ep.multiplyUnsafe(e12));
    }
    double() {
      return new K5(this.ep.double());
    }
    negate() {
      return new K5(this.ep.negate());
    }
  }
  e11.RistrettoPoint = (K5.BASE || (K5.BASE = new K5(e11.ed25519.ExtendedPoint.BASE)), K5.ZERO || (K5.ZERO = new K5(e11.ed25519.ExtendedPoint.ZERO)), K5);
  e11.hashToRistretto255 = (e12, r9) => {
    const o7 = r9.DST, s6 = "string" == typeof o7 ? (0, n5.utf8ToBytes)(o7) : o7, a7 = (0, i9.expand_message_xmd)(e12, s6, 64, t6.sha512);
    return K5.hashToCurve(a7);
  }, e11.hash_to_ristretto255 = e11.hashToRistretto255;
}(Pe4);
var Jn3 = {};
var Qn3 = {};
Object.defineProperty(Qn3, "__esModule", { value: true }), Qn3.sha224 = Qn3.sha256 = Qn3.SHA256 = void 0;
var Xn2 = Ne3;
var er2 = ze3;
var tr3 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var nr2 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var rr3 = new Uint32Array(64);
var ir3 = class extends Xn2.HashMD {
  constructor() {
    super(64, 32, 8, false), this.A = 0 | nr2[0], this.B = 0 | nr2[1], this.C = 0 | nr2[2], this.D = 0 | nr2[3], this.E = 0 | nr2[4], this.F = 0 | nr2[5], this.G = 0 | nr2[6], this.H = 0 | nr2[7];
  }
  get() {
    const { A: e11, B: t6, C: n5, D: r8, E: i9, F: o6, G: s5, H: a6 } = this;
    return [e11, t6, n5, r8, i9, o6, s5, a6];
  }
  set(e11, t6, n5, r8, i9, o6, s5, a6) {
    this.A = 0 | e11, this.B = 0 | t6, this.C = 0 | n5, this.D = 0 | r8, this.E = 0 | i9, this.F = 0 | o6, this.G = 0 | s5, this.H = 0 | a6;
  }
  process(e11, t6) {
    for (let n6 = 0; n6 < 16; n6++, t6 += 4) rr3[n6] = e11.getUint32(t6, false);
    for (let e12 = 16; e12 < 64; e12++) {
      const t7 = rr3[e12 - 15], n6 = rr3[e12 - 2], r9 = (0, er2.rotr)(t7, 7) ^ (0, er2.rotr)(t7, 18) ^ t7 >>> 3, i10 = (0, er2.rotr)(n6, 17) ^ (0, er2.rotr)(n6, 19) ^ n6 >>> 10;
      rr3[e12] = i10 + rr3[e12 - 7] + r9 + rr3[e12 - 16] | 0;
    }
    let { A: n5, B: r8, C: i9, D: o6, E: s5, F: a6, G: c9, H: l9 } = this;
    for (let e12 = 0; e12 < 64; e12++) {
      const t7 = l9 + ((0, er2.rotr)(s5, 6) ^ (0, er2.rotr)(s5, 11) ^ (0, er2.rotr)(s5, 25)) + (0, Xn2.Chi)(s5, a6, c9) + tr3[e12] + rr3[e12] | 0, d7 = ((0, er2.rotr)(n5, 2) ^ (0, er2.rotr)(n5, 13) ^ (0, er2.rotr)(n5, 22)) + (0, Xn2.Maj)(n5, r8, i9) | 0;
      l9 = c9, c9 = a6, a6 = s5, s5 = o6 + t7 | 0, o6 = i9, i9 = r8, r8 = n5, n5 = t7 + d7 | 0;
    }
    n5 = n5 + this.A | 0, r8 = r8 + this.B | 0, i9 = i9 + this.C | 0, o6 = o6 + this.D | 0, s5 = s5 + this.E | 0, a6 = a6 + this.F | 0, c9 = c9 + this.G | 0, l9 = l9 + this.H | 0, this.set(n5, r8, i9, o6, s5, a6, c9, l9);
  }
  roundClean() {
    rr3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
Qn3.SHA256 = ir3;
var or3 = class extends ir3 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
Qn3.sha256 = (0, er2.wrapConstructor)(() => new ir3()), Qn3.sha224 = (0, er2.wrapConstructor)(() => new or3());
var sr3 = {};
var ar2 = {};
!function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.hmac = e11.HMAC = void 0;
  const t6 = Le5, n5 = ze3;
  class r8 extends n5.Hash {
    constructor(e12, r9) {
      super(), this.finished = false, this.destroyed = false, (0, t6.hash)(e12);
      const i9 = (0, n5.toBytes)(r9);
      if (this.iHash = e12.create(), "function" != typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const o6 = this.blockLen, s5 = new Uint8Array(o6);
      s5.set(i9.length > o6 ? e12.create().update(i9).digest() : i9);
      for (let e13 = 0; e13 < s5.length; e13++) s5[e13] ^= 54;
      this.iHash.update(s5), this.oHash = e12.create();
      for (let e13 = 0; e13 < s5.length; e13++) s5[e13] ^= 106;
      this.oHash.update(s5), s5.fill(0);
    }
    update(e12) {
      return (0, t6.exists)(this), this.iHash.update(e12), this;
    }
    digestInto(e12) {
      (0, t6.exists)(this), (0, t6.bytes)(e12, this.outputLen), this.finished = true, this.iHash.digestInto(e12), this.oHash.update(e12), this.oHash.digestInto(e12), this.destroy();
    }
    digest() {
      const e12 = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(e12), e12;
    }
    _cloneInto(e12) {
      e12 || (e12 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: t7, iHash: n6, finished: r9, destroyed: i9, blockLen: o6, outputLen: s5 } = this;
      return e12.finished = r9, e12.destroyed = i9, e12.blockLen = o6, e12.outputLen = s5, e12.oHash = t7._cloneInto(e12.oHash), e12.iHash = n6._cloneInto(e12.iHash), e12;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e11.HMAC = r8;
  e11.hmac = (e12, t7, n6) => new r8(e12, t7).update(n6).digest(), e11.hmac.create = (e12, t7) => new r8(e12, t7);
}(ar2);
var cr3 = {};
!function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.DER = void 0, e11.weierstrassPoints = f16, e11.weierstrass = function(s6) {
    const a7 = function(e12) {
      const n6 = (0, t6.validateBasic)(e12);
      return r8.validateObject(n6, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...n6 });
    }(s6), { Fp: d8, n: u11 } = a7, h10 = d8.BYTES + 1, p10 = 2 * d8.BYTES + 1;
    function g4(e12) {
      return n5.mod(e12, u11);
    }
    function m6(e12) {
      return n5.invert(e12, u11);
    }
    const { ProjectivePoint: y11, normPrivateKeyToScalar: v9, weierstrassEquation: b6, isWithinCurveOrder: w8 } = f16({ ...a7, toBytes(e12, t7, n6) {
      const o7 = t7.toAffine(), s7 = d8.toBytes(o7.x), a8 = r8.concatBytes;
      return (0, i9.abool)("isCompressed", n6), n6 ? a8(Uint8Array.from([t7.hasEvenY() ? 2 : 3]), s7) : a8(Uint8Array.from([4]), s7, d8.toBytes(o7.y));
    }, fromBytes(e12) {
      const t7 = e12.length, n6 = e12[0], i10 = e12.subarray(1);
      if (t7 !== h10 || 2 !== n6 && 3 !== n6) {
        if (t7 === p10 && 4 === n6) {
          return { x: d8.fromBytes(i10.subarray(0, d8.BYTES)), y: d8.fromBytes(i10.subarray(d8.BYTES, 2 * d8.BYTES)) };
        }
        throw new Error(`Point of length ${t7} was invalid. Expected ${h10} compressed bytes or ${p10} uncompressed bytes`);
      }
      {
        const e13 = r8.bytesToNumberBE(i10);
        if (!r8.inRange(e13, l9, d8.ORDER)) throw new Error("Point is not on curve");
        const t8 = b6(e13);
        let o7;
        try {
          o7 = d8.sqrt(t8);
        } catch (e14) {
          const t9 = e14 instanceof Error ? ": " + e14.message : "";
          throw new Error("Point is not on curve" + t9);
        }
        return 1 == (1 & n6) !== ((o7 & l9) === l9) && (o7 = d8.neg(o7)), { x: e13, y: o7 };
      }
    } }), E8 = (e12) => r8.bytesToHex(r8.numberToBytesBE(e12, a7.nByteLength));
    function S8(e12) {
      return e12 > u11 >> l9;
    }
    const _6 = (e12, t7, n6) => r8.bytesToNumberBE(e12.slice(t7, n6));
    class C10 {
      constructor(e12, t7, n6) {
        this.r = e12, this.s = t7, this.recovery = n6, this.assertValidity();
      }
      static fromCompact(e12) {
        const t7 = a7.nByteLength;
        return e12 = (0, i9.ensureBytes)("compactSignature", e12, 2 * t7), new C10(_6(e12, 0, t7), _6(e12, t7, 2 * t7));
      }
      static fromDER(t7) {
        const { r: n6, s: r9 } = e11.DER.toSig((0, i9.ensureBytes)("DER", t7));
        return new C10(n6, r9);
      }
      assertValidity() {
        r8.aInRange("r", this.r, l9, u11), r8.aInRange("s", this.s, l9, u11);
      }
      addRecoveryBit(e12) {
        return new C10(this.r, this.s, e12);
      }
      recoverPublicKey(e12) {
        const { r: t7, s: n6, recovery: r9 } = this, o7 = M8((0, i9.ensureBytes)("msgHash", e12));
        if (null == r9 || ![0, 1, 2, 3].includes(r9)) throw new Error("recovery id invalid");
        const s7 = 2 === r9 || 3 === r9 ? t7 + a7.n : t7;
        if (s7 >= d8.ORDER) throw new Error("recovery id 2 or 3 invalid");
        const c10 = 0 == (1 & r9) ? "02" : "03", l10 = y11.fromHex(c10 + E8(s7)), u12 = m6(s7), h11 = g4(-o7 * u12), f17 = g4(n6 * u12), p11 = y11.BASE.multiplyAndAddUnsafe(l10, h11, f17);
        if (!p11) throw new Error("point at infinify");
        return p11.assertValidity(), p11;
      }
      hasHighS() {
        return S8(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new C10(this.r, g4(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return r8.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e11.DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return r8.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return E8(this.r) + E8(this.s);
      }
    }
    const k11 = { isValidPrivateKey(e12) {
      try {
        return v9(e12), true;
      } catch (e13) {
        return false;
      }
    }, normPrivateKeyToScalar: v9, randomPrivateKey: () => {
      const e12 = n5.getMinHashLength(a7.n);
      return n5.mapHashToField(a7.randomBytes(e12), a7.n);
    }, precompute: (e12 = 8, t7 = y11.BASE) => (t7._setWindowSize(e12), t7.multiply(BigInt(3)), t7) };
    function A9(e12) {
      const t7 = r8.isBytes(e12), n6 = "string" == typeof e12, i10 = (t7 || n6) && e12.length;
      return t7 ? i10 === h10 || i10 === p10 : n6 ? i10 === 2 * h10 || i10 === 2 * p10 : e12 instanceof y11;
    }
    const x7 = a7.bits2int || function(e12) {
      const t7 = r8.bytesToNumberBE(e12), n6 = 8 * e12.length - a7.nBitLength;
      return n6 > 0 ? t7 >> BigInt(n6) : t7;
    }, M8 = a7.bits2int_modN || function(e12) {
      return g4(x7(e12));
    }, I8 = r8.bitMask(a7.nBitLength);
    function T8(e12) {
      return r8.aInRange(`num < 2^${a7.nBitLength}`, e12, c9, I8), r8.numberToBytesBE(e12, a7.nByteLength);
    }
    function R6(e12, t7, n6 = P7) {
      if (["recovered", "canonical"].some((e13) => e13 in n6)) throw new Error("sign() legacy options not supported");
      const { hash: s7, randomBytes: u12 } = a7;
      let { lowS: h11, prehash: f17, extraEntropy: p11 } = n6;
      null == h11 && (h11 = true), e12 = (0, i9.ensureBytes)("msgHash", e12), o6(n6), f17 && (e12 = (0, i9.ensureBytes)("prehashed msgHash", s7(e12)));
      const b7 = M8(e12), E9 = v9(t7), _7 = [T8(E9), T8(b7)];
      if (null != p11 && false !== p11) {
        const e13 = true === p11 ? u12(d8.BYTES) : p11;
        _7.push((0, i9.ensureBytes)("extraEntropy", e13));
      }
      const k12 = r8.concatBytes(..._7), A10 = b7;
      return { seed: k12, k2sig: function(e13) {
        const t8 = x7(e13);
        if (!w8(t8)) return;
        const n7 = m6(t8), r9 = y11.BASE.multiply(t8).toAffine(), i10 = g4(r9.x);
        if (i10 === c9) return;
        const o7 = g4(n7 * g4(A10 + i10 * E9));
        if (o7 === c9) return;
        let s8 = (r9.x === i10 ? 0 : 2) | Number(r9.y & l9), a8 = o7;
        return h11 && S8(o7) && (a8 = function(e14) {
          return S8(e14) ? g4(-e14) : e14;
        }(o7), s8 ^= 1), new C10(i10, a8, s8);
      } };
    }
    const P7 = { lowS: a7.lowS, prehash: false }, O8 = { lowS: a7.lowS, prehash: false };
    return y11.BASE._setWindowSize(8), { CURVE: a7, getPublicKey: function(e12, t7 = true) {
      return y11.fromPrivateKey(e12).toRawBytes(t7);
    }, getSharedSecret: function(e12, t7, n6 = true) {
      if (A9(e12)) throw new Error("first arg must be private key");
      if (!A9(t7)) throw new Error("second arg must be public key");
      const r9 = y11.fromHex(t7);
      return r9.multiply(v9(e12)).toRawBytes(n6);
    }, sign: function(e12, t7, n6 = P7) {
      const { seed: i10, k2sig: o7 } = R6(e12, t7, n6), s7 = a7, c10 = r8.createHmacDrbg(s7.hash.outputLen, s7.nByteLength, s7.hmac);
      return c10(i10, o7);
    }, verify: function(t7, n6, s7, c10 = O8) {
      var _a14;
      const l10 = t7;
      if (n6 = (0, i9.ensureBytes)("msgHash", n6), s7 = (0, i9.ensureBytes)("publicKey", s7), "strict" in c10) throw new Error("options.strict was renamed to lowS");
      o6(c10);
      const { lowS: d9, prehash: u12 } = c10;
      let h11, f17;
      try {
        if ("string" == typeof l10 || r8.isBytes(l10)) try {
          h11 = C10.fromDER(l10);
        } catch (t8) {
          if (!(t8 instanceof e11.DER.Err)) throw t8;
          h11 = C10.fromCompact(l10);
        }
        else {
          if ("object" != typeof l10 || "bigint" != typeof l10.r || "bigint" != typeof l10.s) throw new Error("PARSE");
          {
            const { r: e12, s: t8 } = l10;
            h11 = new C10(e12, t8);
          }
        }
        f17 = y11.fromHex(s7);
      } catch (e12) {
        if ("PARSE" === e12.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return false;
      }
      if (d9 && h11.hasHighS()) return false;
      u12 && (n6 = a7.hash(n6));
      const { r: p11, s: v10 } = h11, b7 = M8(n6), w9 = m6(v10), E9 = g4(b7 * w9), S9 = g4(p11 * w9), _7 = (_a14 = y11.BASE.multiplyAndAddUnsafe(f17, E9, S9)) == null ? void 0 : _a14.toAffine();
      if (!_7) return false;
      const k12 = g4(_7.x);
      return k12 === p11;
    }, ProjectivePoint: y11, Signature: C10, utils: k11 };
  }, e11.SWUFpSqrtRatio = p9, e11.mapToCurveSimpleSWU = function(e12, t7) {
    if (n5.validateField(e12), !e12.isValid(t7.A) || !e12.isValid(t7.B) || !e12.isValid(t7.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const r9 = p9(e12, t7.Z);
    if (!e12.isOdd) throw new Error("Fp.isOdd is not implemented!");
    return (n6) => {
      let i10, o7, s6, a7, c10, l10, d8, u11;
      i10 = e12.sqr(n6), i10 = e12.mul(i10, t7.Z), o7 = e12.sqr(i10), o7 = e12.add(o7, i10), s6 = e12.add(o7, e12.ONE), s6 = e12.mul(s6, t7.B), a7 = e12.cmov(t7.Z, e12.neg(o7), !e12.eql(o7, e12.ZERO)), a7 = e12.mul(a7, t7.A), o7 = e12.sqr(s6), l10 = e12.sqr(a7), c10 = e12.mul(l10, t7.A), o7 = e12.add(o7, c10), o7 = e12.mul(o7, s6), l10 = e12.mul(l10, a7), c10 = e12.mul(l10, t7.B), o7 = e12.add(o7, c10), d8 = e12.mul(i10, s6);
      const { isValid: h10, value: f17 } = r9(o7, l10);
      u11 = e12.mul(i10, n6), u11 = e12.mul(u11, f17), d8 = e12.cmov(d8, s6, h10), u11 = e12.cmov(u11, f17, h10);
      const p10 = e12.isOdd(n6) === e12.isOdd(u11);
      return u11 = e12.cmov(e12.neg(u11), u11, p10), d8 = e12.div(d8, a7), { x: d8, y: u11 };
    };
  };
  const t6 = Pt4, n5 = Ot4, r8 = Nt4, i9 = Nt4;
  function o6(e12) {
    void 0 !== e12.lowS && (0, i9.abool)("lowS", e12.lowS), void 0 !== e12.prehash && (0, i9.abool)("prehash", e12.prehash);
  }
  const { bytesToNumberBE: s5, hexToBytes: a6 } = r8;
  e11.DER = { Err: class extends Error {
    constructor(e12 = "") {
      super(e12);
    }
  }, _tlv: { encode: (t7, n6) => {
    const { Err: i10 } = e11.DER;
    if (t7 < 0 || t7 > 256) throw new i10("tlv.encode: wrong tag");
    if (1 & n6.length) throw new i10("tlv.encode: unpadded data");
    const o7 = n6.length / 2, s6 = r8.numberToHexUnpadded(o7);
    if (s6.length / 2 & 128) throw new i10("tlv.encode: long form length too big");
    const a7 = o7 > 127 ? r8.numberToHexUnpadded(s6.length / 2 | 128) : "";
    return `${r8.numberToHexUnpadded(t7)}${a7}${s6}${n6}`;
  }, decode(t7, n6) {
    const { Err: r9 } = e11.DER;
    let i10 = 0;
    if (t7 < 0 || t7 > 256) throw new r9("tlv.encode: wrong tag");
    if (n6.length < 2 || n6[i10++] !== t7) throw new r9("tlv.decode: wrong tlv");
    const o7 = n6[i10++];
    let s6 = 0;
    if (!!(128 & o7)) {
      const e12 = 127 & o7;
      if (!e12) throw new r9("tlv.decode(long): indefinite length not supported");
      if (e12 > 4) throw new r9("tlv.decode(long): byte length is too big");
      const t8 = n6.subarray(i10, i10 + e12);
      if (t8.length !== e12) throw new r9("tlv.decode: length bytes not complete");
      if (0 === t8[0]) throw new r9("tlv.decode(long): zero leftmost byte");
      for (const e13 of t8) s6 = s6 << 8 | e13;
      if (i10 += e12, s6 < 128) throw new r9("tlv.decode(long): not minimal encoding");
    } else s6 = o7;
    const a7 = n6.subarray(i10, i10 + s6);
    if (a7.length !== s6) throw new r9("tlv.decode: wrong value length");
    return { v: a7, l: n6.subarray(i10 + s6) };
  } }, _int: { encode(t7) {
    const { Err: n6 } = e11.DER;
    if (t7 < c9) throw new n6("integer: negative integers are not allowed");
    let i10 = r8.numberToHexUnpadded(t7);
    if (8 & Number.parseInt(i10[0], 16) && (i10 = "00" + i10), 1 & i10.length) throw new n6("unexpected assertion");
    return i10;
  }, decode(t7) {
    const { Err: n6 } = e11.DER;
    if (128 & t7[0]) throw new n6("Invalid signature integer: negative");
    if (0 === t7[0] && !(128 & t7[1])) throw new n6("Invalid signature integer: unnecessary leading zero");
    return s5(t7);
  } }, toSig(t7) {
    const { Err: n6, _int: i10, _tlv: o7 } = e11.DER, s6 = "string" == typeof t7 ? a6(t7) : t7;
    r8.abytes(s6);
    const { v: c10, l: l10 } = o7.decode(48, s6);
    if (l10.length) throw new n6("Invalid signature: left bytes after parsing");
    const { v: d8, l: u11 } = o7.decode(2, c10), { v: h10, l: f17 } = o7.decode(2, u11);
    if (f17.length) throw new n6("Invalid signature: left bytes after parsing");
    return { r: i10.decode(d8), s: i10.decode(h10) };
  }, hexFromSig(t7) {
    const { _tlv: n6, _int: r9 } = e11.DER, i10 = `${n6.encode(2, r9.encode(t7.r))}${n6.encode(2, r9.encode(t7.s))}`;
    return n6.encode(48, i10);
  } };
  const c9 = BigInt(0), l9 = BigInt(1), d7 = BigInt(2), u10 = BigInt(3), h9 = BigInt(4);
  function f16(e12) {
    const o7 = function(e13) {
      const n6 = (0, t6.validateBasic)(e13);
      r8.validateObject(n6, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
      const { endo: i10, Fp: o8, a: s7 } = n6;
      if (i10) {
        if (!o8.eql(s7, o8.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if ("object" != typeof i10 || "bigint" != typeof i10.beta || "function" != typeof i10.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
      return Object.freeze({ ...n6 });
    }(e12), { Fp: s6 } = o7, a7 = n5.Field(o7.n, o7.nBitLength), d8 = o7.toBytes || ((e13, t7, n6) => {
      const i10 = t7.toAffine();
      return r8.concatBytes(Uint8Array.from([4]), s6.toBytes(i10.x), s6.toBytes(i10.y));
    }), h10 = o7.fromBytes || ((e13) => {
      const t7 = e13.subarray(1);
      return { x: s6.fromBytes(t7.subarray(0, s6.BYTES)), y: s6.fromBytes(t7.subarray(s6.BYTES, 2 * s6.BYTES)) };
    });
    function f17(e13) {
      const { a: t7, b: n6 } = o7, r9 = s6.sqr(e13), i10 = s6.mul(r9, e13);
      return s6.add(s6.add(i10, s6.mul(e13, t7)), n6);
    }
    if (!s6.eql(s6.sqr(o7.Gy), f17(o7.Gx))) throw new Error("bad generator point: equation left != right");
    function p10(e13) {
      const { allowedPrivateKeyLengths: t7, nByteLength: s7, wrapPrivateKey: a8, n: c10 } = o7;
      if (t7 && "bigint" != typeof e13) {
        if (r8.isBytes(e13) && (e13 = r8.bytesToHex(e13)), "string" != typeof e13 || !t7.includes(e13.length)) throw new Error("Invalid key");
        e13 = e13.padStart(2 * s7, "0");
      }
      let d9;
      try {
        d9 = "bigint" == typeof e13 ? e13 : r8.bytesToNumberBE((0, i9.ensureBytes)("private key", e13, s7));
      } catch (t8) {
        throw new Error(`private key must be ${s7} bytes, hex or bigint, not ${typeof e13}`);
      }
      return a8 && (d9 = n5.mod(d9, c10)), r8.aInRange("private key", d9, l9, c10), d9;
    }
    function g4(e13) {
      if (!(e13 instanceof v9)) throw new Error("ProjectivePoint expected");
    }
    const m6 = (0, i9.memoized)((e13, t7) => {
      const { px: n6, py: r9, pz: i10 } = e13;
      if (s6.eql(i10, s6.ONE)) return { x: n6, y: r9 };
      const o8 = e13.is0();
      null == t7 && (t7 = o8 ? s6.ONE : s6.inv(i10));
      const a8 = s6.mul(n6, t7), c10 = s6.mul(r9, t7), l10 = s6.mul(i10, t7);
      if (o8) return { x: s6.ZERO, y: s6.ZERO };
      if (!s6.eql(l10, s6.ONE)) throw new Error("invZ was invalid");
      return { x: a8, y: c10 };
    }), y11 = (0, i9.memoized)((e13) => {
      if (e13.is0()) {
        if (o7.allowInfinityPoint && !s6.is0(e13.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: t7, y: n6 } = e13.toAffine();
      if (!s6.isValid(t7) || !s6.isValid(n6)) throw new Error("bad point: x or y not FE");
      const r9 = s6.sqr(n6), i10 = f17(t7);
      if (!s6.eql(r9, i10)) throw new Error("bad point: equation left != right");
      if (!e13.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class v9 {
      constructor(e13, t7, n6) {
        if (this.px = e13, this.py = t7, this.pz = n6, null == e13 || !s6.isValid(e13)) throw new Error("x required");
        if (null == t7 || !s6.isValid(t7)) throw new Error("y required");
        if (null == n6 || !s6.isValid(n6)) throw new Error("z required");
        Object.freeze(this);
      }
      static fromAffine(e13) {
        const { x: t7, y: n6 } = e13 || {};
        if (!e13 || !s6.isValid(t7) || !s6.isValid(n6)) throw new Error("invalid affine point");
        if (e13 instanceof v9) throw new Error("projective point not allowed");
        const r9 = (e14) => s6.eql(e14, s6.ZERO);
        return r9(t7) && r9(n6) ? v9.ZERO : new v9(t7, n6, s6.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(e13) {
        const t7 = s6.invertBatch(e13.map((e14) => e14.pz));
        return e13.map((e14, n6) => e14.toAffine(t7[n6])).map(v9.fromAffine);
      }
      static fromHex(e13) {
        const t7 = v9.fromAffine(h10((0, i9.ensureBytes)("pointHex", e13)));
        return t7.assertValidity(), t7;
      }
      static fromPrivateKey(e13) {
        return v9.BASE.multiply(p10(e13));
      }
      static msm(e13, n6) {
        return (0, t6.pippenger)(v9, a7, e13, n6);
      }
      _setWindowSize(e13) {
        w8.setWindowSize(this, e13);
      }
      assertValidity() {
        y11(this);
      }
      hasEvenY() {
        const { y: e13 } = this.toAffine();
        if (s6.isOdd) return !s6.isOdd(e13);
        throw new Error("Field doesn't support isOdd");
      }
      equals(e13) {
        g4(e13);
        const { px: t7, py: n6, pz: r9 } = this, { px: i10, py: o8, pz: a8 } = e13, c10 = s6.eql(s6.mul(t7, a8), s6.mul(i10, r9)), l10 = s6.eql(s6.mul(n6, a8), s6.mul(o8, r9));
        return c10 && l10;
      }
      negate() {
        return new v9(this.px, s6.neg(this.py), this.pz);
      }
      double() {
        const { a: e13, b: t7 } = o7, n6 = s6.mul(t7, u10), { px: r9, py: i10, pz: a8 } = this;
        let c10 = s6.ZERO, l10 = s6.ZERO, d9 = s6.ZERO, h11 = s6.mul(r9, r9), f18 = s6.mul(i10, i10), p11 = s6.mul(a8, a8), g5 = s6.mul(r9, i10);
        return g5 = s6.add(g5, g5), d9 = s6.mul(r9, a8), d9 = s6.add(d9, d9), c10 = s6.mul(e13, d9), l10 = s6.mul(n6, p11), l10 = s6.add(c10, l10), c10 = s6.sub(f18, l10), l10 = s6.add(f18, l10), l10 = s6.mul(c10, l10), c10 = s6.mul(g5, c10), d9 = s6.mul(n6, d9), p11 = s6.mul(e13, p11), g5 = s6.sub(h11, p11), g5 = s6.mul(e13, g5), g5 = s6.add(g5, d9), d9 = s6.add(h11, h11), h11 = s6.add(d9, h11), h11 = s6.add(h11, p11), h11 = s6.mul(h11, g5), l10 = s6.add(l10, h11), p11 = s6.mul(i10, a8), p11 = s6.add(p11, p11), h11 = s6.mul(p11, g5), c10 = s6.sub(c10, h11), d9 = s6.mul(p11, f18), d9 = s6.add(d9, d9), d9 = s6.add(d9, d9), new v9(c10, l10, d9);
      }
      add(e13) {
        g4(e13);
        const { px: t7, py: n6, pz: r9 } = this, { px: i10, py: a8, pz: c10 } = e13;
        let l10 = s6.ZERO, d9 = s6.ZERO, h11 = s6.ZERO;
        const f18 = o7.a, p11 = s6.mul(o7.b, u10);
        let m7 = s6.mul(t7, i10), y12 = s6.mul(n6, a8), b7 = s6.mul(r9, c10), w9 = s6.add(t7, n6), E8 = s6.add(i10, a8);
        w9 = s6.mul(w9, E8), E8 = s6.add(m7, y12), w9 = s6.sub(w9, E8), E8 = s6.add(t7, r9);
        let S8 = s6.add(i10, c10);
        return E8 = s6.mul(E8, S8), S8 = s6.add(m7, b7), E8 = s6.sub(E8, S8), S8 = s6.add(n6, r9), l10 = s6.add(a8, c10), S8 = s6.mul(S8, l10), l10 = s6.add(y12, b7), S8 = s6.sub(S8, l10), h11 = s6.mul(f18, E8), l10 = s6.mul(p11, b7), h11 = s6.add(l10, h11), l10 = s6.sub(y12, h11), h11 = s6.add(y12, h11), d9 = s6.mul(l10, h11), y12 = s6.add(m7, m7), y12 = s6.add(y12, m7), b7 = s6.mul(f18, b7), E8 = s6.mul(p11, E8), y12 = s6.add(y12, b7), b7 = s6.sub(m7, b7), b7 = s6.mul(f18, b7), E8 = s6.add(E8, b7), m7 = s6.mul(y12, E8), d9 = s6.add(d9, m7), m7 = s6.mul(S8, E8), l10 = s6.mul(w9, l10), l10 = s6.sub(l10, m7), m7 = s6.mul(w9, y12), h11 = s6.mul(S8, h11), h11 = s6.add(h11, m7), new v9(l10, d9, h11);
      }
      subtract(e13) {
        return this.add(e13.negate());
      }
      is0() {
        return this.equals(v9.ZERO);
      }
      wNAF(e13) {
        return w8.wNAFCached(this, e13, v9.normalizeZ);
      }
      multiplyUnsafe(e13) {
        r8.aInRange("scalar", e13, c9, o7.n);
        const t7 = v9.ZERO;
        if (e13 === c9) return t7;
        if (e13 === l9) return this;
        const { endo: n6 } = o7;
        if (!n6) return w8.unsafeLadder(this, e13);
        let { k1neg: i10, k1: a8, k2neg: d9, k2: u11 } = n6.splitScalar(e13), h11 = t7, f18 = t7, p11 = this;
        for (; a8 > c9 || u11 > c9; ) a8 & l9 && (h11 = h11.add(p11)), u11 & l9 && (f18 = f18.add(p11)), p11 = p11.double(), a8 >>= l9, u11 >>= l9;
        return i10 && (h11 = h11.negate()), d9 && (f18 = f18.negate()), f18 = new v9(s6.mul(f18.px, n6.beta), f18.py, f18.pz), h11.add(f18);
      }
      multiply(e13) {
        const { endo: t7, n: n6 } = o7;
        let i10, a8;
        if (r8.aInRange("scalar", e13, l9, n6), t7) {
          const { k1neg: n7, k1: r9, k2neg: o8, k2: c10 } = t7.splitScalar(e13);
          let { p: l10, f: d9 } = this.wNAF(r9), { p: u11, f: h11 } = this.wNAF(c10);
          l10 = w8.constTimeNegate(n7, l10), u11 = w8.constTimeNegate(o8, u11), u11 = new v9(s6.mul(u11.px, t7.beta), u11.py, u11.pz), i10 = l10.add(u11), a8 = d9.add(h11);
        } else {
          const { p: t8, f: n7 } = this.wNAF(e13);
          i10 = t8, a8 = n7;
        }
        return v9.normalizeZ([i10, a8])[0];
      }
      multiplyAndAddUnsafe(e13, t7, n6) {
        const r9 = v9.BASE, i10 = (e14, t8) => t8 !== c9 && t8 !== l9 && e14.equals(r9) ? e14.multiply(t8) : e14.multiplyUnsafe(t8), o8 = i10(this, t7).add(i10(e13, n6));
        return o8.is0() ? void 0 : o8;
      }
      toAffine(e13) {
        return m6(this, e13);
      }
      isTorsionFree() {
        const { h: e13, isTorsionFree: t7 } = o7;
        if (e13 === l9) return true;
        if (t7) return t7(v9, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: e13, clearCofactor: t7 } = o7;
        return e13 === l9 ? this : t7 ? t7(v9, this) : this.multiplyUnsafe(o7.h);
      }
      toRawBytes(e13 = true) {
        return (0, i9.abool)("isCompressed", e13), this.assertValidity(), d8(v9, this, e13);
      }
      toHex(e13 = true) {
        return (0, i9.abool)("isCompressed", e13), r8.bytesToHex(this.toRawBytes(e13));
      }
    }
    v9.BASE = new v9(o7.Gx, o7.Gy, s6.ONE), v9.ZERO = new v9(s6.ZERO, s6.ONE, s6.ZERO);
    const b6 = o7.nBitLength, w8 = (0, t6.wNAF)(v9, o7.endo ? Math.ceil(b6 / 2) : b6);
    return { CURVE: o7, ProjectivePoint: v9, normPrivateKeyToScalar: p10, weierstrassEquation: f17, isWithinCurveOrder: function(e13) {
      return r8.inRange(e13, l9, o7.n);
    } };
  }
  function p9(e12, t7) {
    const n6 = e12.ORDER;
    let r9 = c9;
    for (let e13 = n6 - l9; e13 % d7 === c9; e13 /= d7) r9 += l9;
    const i10 = r9, o7 = d7 << i10 - l9 - l9, s6 = o7 * d7, a7 = (n6 - l9) / s6, f17 = (a7 - l9) / d7, p10 = s6 - l9, g4 = o7, m6 = e12.pow(t7, a7), y11 = e12.pow(t7, (a7 + l9) / d7);
    let v9 = (t8, n7) => {
      let r10 = m6, o8 = e12.pow(n7, p10), s7 = e12.sqr(o8);
      s7 = e12.mul(s7, n7);
      let a8 = e12.mul(t8, s7);
      a8 = e12.pow(a8, f17), a8 = e12.mul(a8, o8), o8 = e12.mul(a8, n7), s7 = e12.mul(a8, t8);
      let c10 = e12.mul(s7, o8);
      a8 = e12.pow(c10, g4);
      let u11 = e12.eql(a8, e12.ONE);
      o8 = e12.mul(s7, y11), a8 = e12.mul(c10, r10), s7 = e12.cmov(o8, s7, u11), c10 = e12.cmov(a8, c10, u11);
      for (let t9 = i10; t9 > l9; t9--) {
        let n8 = t9 - d7;
        n8 = d7 << n8 - l9;
        let i11 = e12.pow(c10, n8);
        const a9 = e12.eql(i11, e12.ONE);
        o8 = e12.mul(s7, r10), r10 = e12.mul(r10, r10), i11 = e12.mul(c10, r10), s7 = e12.cmov(o8, s7, a9), c10 = e12.cmov(i11, c10, a9);
      }
      return { isValid: u11, value: s7 };
    };
    if (e12.ORDER % h9 === u10) {
      const n7 = (e12.ORDER - u10) / h9, r10 = e12.sqrt(e12.neg(t7));
      v9 = (t8, i11) => {
        let o8 = e12.sqr(i11);
        const s7 = e12.mul(t8, i11);
        o8 = e12.mul(o8, s7);
        let a8 = e12.pow(o8, n7);
        a8 = e12.mul(a8, s7);
        const c10 = e12.mul(a8, r10), l10 = e12.mul(e12.sqr(a8), i11), d8 = e12.eql(l10, t8);
        return { isValid: d8, value: e12.cmov(c10, a8, d8) };
      };
    }
    return v9;
  }
}(cr3), Object.defineProperty(sr3, "__esModule", { value: true }), sr3.getHash = hr3, sr3.createCurve = function(e11, t6) {
  const n5 = (t7) => (0, ur2.weierstrass)({ ...e11, ...hr3(t7) });
  return Object.freeze({ ...n5(t6), create: n5 });
};
var lr2 = ar2;
var dr3 = ze3;
var ur2 = cr3;
function hr3(e11) {
  return { hash: e11, hmac: (t6, ...n5) => (0, lr2.hmac)(e11, t6, (0, dr3.concatBytes)(...n5)), randomBytes: dr3.randomBytes };
}
!function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.encodeToCurve = e11.hashToCurve = e11.schnorr = e11.secp256k1 = void 0;
  const t6 = Qn3, n5 = ze3, r8 = sr3, i9 = Dn3, o6 = Ot4, s5 = Nt4, a6 = cr3, c9 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), l9 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), d7 = BigInt(1), u10 = BigInt(2), h9 = (e12, t7) => (e12 + t7 / u10) / t7;
  function f16(e12) {
    const t7 = c9, n6 = BigInt(3), r9 = BigInt(6), i10 = BigInt(11), s6 = BigInt(22), a7 = BigInt(23), l10 = BigInt(44), d8 = BigInt(88), h10 = e12 * e12 * e12 % t7, f17 = h10 * h10 * e12 % t7, g5 = (0, o6.pow2)(f17, n6, t7) * f17 % t7, m7 = (0, o6.pow2)(g5, n6, t7) * f17 % t7, y12 = (0, o6.pow2)(m7, u10, t7) * h10 % t7, v10 = (0, o6.pow2)(y12, i10, t7) * y12 % t7, b7 = (0, o6.pow2)(v10, s6, t7) * v10 % t7, w9 = (0, o6.pow2)(b7, l10, t7) * b7 % t7, E9 = (0, o6.pow2)(w9, d8, t7) * w9 % t7, S9 = (0, o6.pow2)(E9, l10, t7) * b7 % t7, _7 = (0, o6.pow2)(S9, n6, t7) * f17 % t7, C11 = (0, o6.pow2)(_7, a7, t7) * v10 % t7, k12 = (0, o6.pow2)(C11, r9, t7) * h10 % t7, A10 = (0, o6.pow2)(k12, u10, t7);
    if (!p9.eql(p9.sqr(A10), e12)) throw new Error("Cannot find square root");
    return A10;
  }
  const p9 = (0, o6.Field)(c9, void 0, void 0, { sqrt: f16 });
  e11.secp256k1 = (0, r8.createCurve)({ a: BigInt(0), b: BigInt(7), Fp: p9, n: l9, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: true, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (e12) => {
    const t7 = l9, n6 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r9 = -d7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i10 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s6 = n6, a7 = BigInt("0x100000000000000000000000000000000"), c10 = h9(s6 * e12, t7), u11 = h9(-r9 * e12, t7);
    let f17 = (0, o6.mod)(e12 - c10 * n6 - u11 * i10, t7), p10 = (0, o6.mod)(-c10 * r9 - u11 * s6, t7);
    const g5 = f17 > a7, m7 = p10 > a7;
    if (g5 && (f17 = t7 - f17), m7 && (p10 = t7 - p10), f17 > a7 || p10 > a7) throw new Error("splitScalar: Endomorphism failed, k=" + e12);
    return { k1neg: g5, k1: f17, k2neg: m7, k2: p10 };
  } } }, t6.sha256);
  const g4 = BigInt(0), m6 = {};
  function y11(e12, ...n6) {
    let r9 = m6[e12];
    if (void 0 === r9) {
      const n7 = (0, t6.sha256)(Uint8Array.from(e12, (e13) => e13.charCodeAt(0)));
      r9 = (0, s5.concatBytes)(n7, n7), m6[e12] = r9;
    }
    return (0, t6.sha256)((0, s5.concatBytes)(r9, ...n6));
  }
  const v9 = (e12) => e12.toRawBytes(true).slice(1), b6 = (e12) => (0, s5.numberToBytesBE)(e12, 32), w8 = (e12) => (0, o6.mod)(e12, c9), E8 = (e12) => (0, o6.mod)(e12, l9), S8 = e11.secp256k1.ProjectivePoint, _6 = (e12, t7, n6) => S8.BASE.multiplyAndAddUnsafe(e12, t7, n6);
  function C10(t7) {
    let n6 = e11.secp256k1.utils.normPrivateKeyToScalar(t7), r9 = S8.fromPrivateKey(n6);
    return { scalar: r9.hasEvenY() ? n6 : E8(-n6), bytes: v9(r9) };
  }
  function k11(e12) {
    (0, s5.aInRange)("x", e12, d7, c9);
    const t7 = w8(e12 * e12);
    let n6 = f16(w8(t7 * e12 + BigInt(7)));
    n6 % u10 !== g4 && (n6 = w8(-n6));
    const r9 = new S8(e12, n6, d7);
    return r9.assertValidity(), r9;
  }
  const A9 = s5.bytesToNumberBE;
  function x7(...e12) {
    return E8(A9(y11("BIP0340/challenge", ...e12)));
  }
  function M8(e12) {
    return C10(e12).bytes;
  }
  function I8(e12, t7, r9 = (0, n5.randomBytes)(32)) {
    const i10 = (0, s5.ensureBytes)("message", e12), { bytes: o7, scalar: a7 } = C10(t7), c10 = (0, s5.ensureBytes)("auxRand", r9, 32), l10 = b6(a7 ^ A9(y11("BIP0340/aux", c10))), d8 = y11("BIP0340/nonce", l10, o7, i10), u11 = E8(A9(d8));
    if (u11 === g4) throw new Error("sign failed: k is zero");
    const { bytes: h10, scalar: f17 } = C10(u11), p10 = x7(h10, o7, i10), m7 = new Uint8Array(64);
    if (m7.set(h10, 0), m7.set(b6(E8(f17 + p10 * a7)), 32), !T8(m7, i10, o7)) throw new Error("sign: Invalid signature produced");
    return m7;
  }
  function T8(e12, t7, n6) {
    const r9 = (0, s5.ensureBytes)("signature", e12, 64), i10 = (0, s5.ensureBytes)("message", t7), o7 = (0, s5.ensureBytes)("publicKey", n6, 32);
    try {
      const e13 = k11(A9(o7)), t8 = A9(r9.subarray(0, 32));
      if (!(0, s5.inRange)(t8, d7, c9)) return false;
      const n7 = A9(r9.subarray(32, 64));
      if (!(0, s5.inRange)(n7, d7, l9)) return false;
      const a7 = x7(b6(t8), v9(e13), i10), u11 = _6(e13, n7, E8(-a7));
      return !(!u11 || !u11.hasEvenY() || u11.toAffine().x !== t8);
    } catch (e13) {
      return false;
    }
  }
  e11.schnorr = { getPublicKey: M8, sign: I8, verify: T8, utils: { randomPrivateKey: e11.secp256k1.utils.randomPrivateKey, lift_x: k11, pointToBytes: v9, numberToBytesBE: s5.numberToBytesBE, bytesToNumberBE: s5.bytesToNumberBE, taggedHash: y11, mod: o6.mod } };
  const R6 = (() => (0, i9.isogenyMap)(p9, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e12) => e12.map((e13) => BigInt(e13)))))(), P7 = (() => (0, a6.mapToCurveSimpleSWU)(p9, { A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"), B: BigInt("1771"), Z: p9.create(BigInt("-11")) }))(), O8 = (() => (0, i9.createHasher)(e11.secp256k1.ProjectivePoint, (e12) => {
    const { x: t7, y: n6 } = P7(p9.create(e12[0]));
    return R6(t7, n6);
  }, { DST: "secp256k1_XMD:SHA-256_SSWU_RO_", encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_", p: p9.ORDER, m: 1, k: 128, expand: "xmd", hash: t6.sha256 }))();
  e11.hashToCurve = O8.hashToCurve, e11.encodeToCurve = O8.encodeToCurve;
}(Jn3);
var fr3 = {};
!function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.decodeHex = e11.remove0x = void 0;
  var t6 = pe4;
  e11.remove0x = function(e12) {
    return e12.startsWith("0x") || e12.startsWith("0X") ? e12.slice(2) : e12;
  };
  e11.decodeHex = function(n5) {
    return (0, t6.hexToBytes)((0, e11.remove0x)(n5));
  };
}(fr3), function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.hexToPublicKey = e11.convertPublicKeyFormat = e11.getSharedPoint = e11.getPublicKey = e11.isValidPrivateKey = e11.getValidSecret = void 0;
  var t6 = Te4, n5 = Pe4, r8 = Jn3, i9 = Ce5, o6 = ke5, s5 = fr3;
  e11.getValidSecret = function() {
    var n6;
    do {
      n6 = (0, t6.randomBytes)(o6.SECRET_KEY_LENGTH);
    } while (!(0, e11.isValidPrivateKey)(n6));
    return n6;
  };
  e11.isValidPrivateKey = function(e12) {
    return a6((0, i9.ellipticCurve)(), function(t7) {
      return t7.utils.isValidPrivateKey(e12);
    }, function() {
      return true;
    }, function() {
      return true;
    });
  };
  e11.getPublicKey = function(e12) {
    return a6((0, i9.ellipticCurve)(), function(t7) {
      return t7.getPublicKey(e12);
    }, function(t7) {
      return t7.getPublicKey(e12);
    }, function(t7) {
      return t7.getPublicKey(e12);
    });
  };
  e11.getSharedPoint = function(e12, t7, n6) {
    return a6((0, i9.ellipticCurve)(), function(r9) {
      return r9.getSharedSecret(e12, t7, n6);
    }, function(n7) {
      return n7.getSharedSecret(e12, t7);
    }, function(n7) {
      return l9(n7, e12, t7);
    });
  };
  e11.convertPublicKeyFormat = function(e12, t7) {
    return a6((0, i9.ellipticCurve)(), function(n6) {
      return n6.getSharedSecret(BigInt(1), e12, t7);
    }, function() {
      return e12;
    }, function() {
      return e12;
    });
  };
  function a6(e12, t7, i10, o7) {
    if ("secp256k1" === e12) return t7(r8.secp256k1);
    if ("x25519" === e12) return i10(n5.x25519);
    if ("ed25519" === e12) return o7(n5.ed25519);
    throw new Error("Not implemented");
  }
  e11.hexToPublicKey = function(e12) {
    var t7 = (0, s5.decodeHex)(e12);
    return a6((0, i9.ellipticCurve)(), function() {
      return c9(t7);
    }, function() {
      return t7;
    }, function() {
      return t7;
    });
  };
  var c9 = function(e12) {
    if (e12.length === o6.ETH_PUBLIC_KEY_SIZE) {
      var t7 = new Uint8Array(1 + e12.length);
      return t7.set([4]), t7.set(e12, 1), t7;
    }
    return e12;
  }, l9 = function(e12, t7, n6) {
    var r9 = e12.utils.getExtendedPublicKey(t7).scalar;
    return e12.ExtendedPoint.fromHex(n6).multiply(r9).toRawBytes();
  };
}(Ie4);
var pr3 = {};
var gr3 = {};
Object.defineProperty(gr3, "__esModule", { value: true }), gr3.hkdf = void 0, gr3.extract = br3, gr3.expand = Sr3;
var mr3 = Le5;
var yr3 = ze3;
var vr3 = ar2;
function br3(e11, t6, n5) {
  return (0, mr3.hash)(e11), void 0 === n5 && (n5 = new Uint8Array(e11.outputLen)), (0, vr3.hmac)(e11, (0, yr3.toBytes)(n5), (0, yr3.toBytes)(t6));
}
var wr3 = new Uint8Array([0]);
var Er3 = new Uint8Array();
function Sr3(e11, t6, n5, r8 = 32) {
  if ((0, mr3.hash)(e11), (0, mr3.number)(r8), r8 > 255 * e11.outputLen) throw new Error("Length should be <= 255*HashLen");
  const i9 = Math.ceil(r8 / e11.outputLen);
  void 0 === n5 && (n5 = Er3);
  const o6 = new Uint8Array(i9 * e11.outputLen), s5 = vr3.hmac.create(e11, t6), a6 = s5._cloneInto(), c9 = new Uint8Array(s5.outputLen);
  for (let t7 = 0; t7 < i9; t7++) wr3[0] = t7 + 1, a6.update(0 === t7 ? Er3 : c9).update(n5).update(wr3).digestInto(c9), o6.set(c9, e11.outputLen * t7), s5._cloneInto(a6);
  return s5.destroy(), a6.destroy(), c9.fill(0), wr3.fill(0), o6.slice(0, r8);
}
gr3.hkdf = (e11, t6, n5, r8, i9) => Sr3(e11, br3(e11, t6, n5), r8, i9), function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.getSharedKey = e11.deriveKey = void 0;
  var t6 = pe4, n5 = gr3, r8 = Qn3;
  e11.deriveKey = function(e12, t7, i9) {
    return (0, n5.hkdf)(r8.sha256, e12, t7, i9, 32);
  };
  e11.getSharedKey = function() {
    for (var n6 = [], r9 = 0; r9 < arguments.length; r9++) n6[r9] = arguments[r9];
    return (0, e11.deriveKey)(t6.concatBytes.apply(void 0, n6));
  };
}(pr3);
var _r3 = {};
var Cr3 = {};
var kr3 = {};
var Ar3 = {};
Object.defineProperty(Ar3, "__esModule", { value: true }), Ar3.polyval = Ar3.ghash = void 0, Ar3._toGHASHKey = Or3;
var xr3 = ge4;
var Mr3 = pe4;
var Ir3 = 16;
var Tr3 = new Uint8Array(16);
var Rr3 = (0, Mr3.u32)(Tr3);
var Pr3 = (e11) => (e11 >>> 0 & 255) << 24 | (e11 >>> 8 & 255) << 16 | (e11 >>> 16 & 255) << 8 | e11 >>> 24 & 255 | 0;
function Or3(e11) {
  e11.reverse();
  const t6 = 1 & e11[15];
  let n5 = 0;
  for (let t7 = 0; t7 < e11.length; t7++) {
    const r8 = e11[t7];
    e11[t7] = r8 >>> 1 | n5, n5 = (1 & r8) << 7;
  }
  return e11[0] ^= 225 & -t6, e11;
}
var Nr3 = class {
  constructor(e11, t6) {
    this.blockLen = Ir3, this.outputLen = Ir3, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = false, e11 = (0, Mr3.toBytes)(e11), (0, xr3.bytes)(e11, 16);
    const n5 = (0, Mr3.createView)(e11);
    let r8 = n5.getUint32(0, false), i9 = n5.getUint32(4, false), o6 = n5.getUint32(8, false), s5 = n5.getUint32(12, false);
    const a6 = [];
    for (let e12 = 0; e12 < 128; e12++) a6.push({ s0: Pr3(r8), s1: Pr3(i9), s2: Pr3(o6), s3: Pr3(s5) }), { s0: r8, s1: i9, s2: o6, s3: s5 } = { s3: (d7 = o6) << 31 | (u10 = s5) >>> 1, s2: (l9 = i9) << 31 | d7 >>> 1, s1: (c9 = r8) << 31 | l9 >>> 1, s0: c9 >>> 1 ^ 225 << 24 & -(1 & u10) };
    var c9, l9, d7, u10;
    const h9 = ((e12) => e12 > 65536 ? 8 : e12 > 1024 ? 4 : 2)(t6 || 1024);
    if (![1, 2, 4, 8].includes(h9)) throw new Error(`ghash: wrong window size=${h9}, should be 2, 4 or 8`);
    this.W = h9;
    const f16 = 128 / h9, p9 = this.windowSize = 2 ** h9, g4 = [];
    for (let e12 = 0; e12 < f16; e12++) for (let t7 = 0; t7 < p9; t7++) {
      let n6 = 0, r9 = 0, i10 = 0, o7 = 0;
      for (let s6 = 0; s6 < h9; s6++) {
        if (!(t7 >>> h9 - s6 - 1 & 1)) continue;
        const { s0: c10, s1: l10, s2: d8, s3: u11 } = a6[h9 * e12 + s6];
        n6 ^= c10, r9 ^= l10, i10 ^= d8, o7 ^= u11;
      }
      g4.push({ s0: n6, s1: r9, s2: i10, s3: o7 });
    }
    this.t = g4;
  }
  _updateBlock(e11, t6, n5, r8) {
    e11 ^= this.s0, t6 ^= this.s1, n5 ^= this.s2, r8 ^= this.s3;
    const { W: i9, t: o6, windowSize: s5 } = this;
    let a6 = 0, c9 = 0, l9 = 0, d7 = 0;
    const u10 = (1 << i9) - 1;
    let h9 = 0;
    for (const f16 of [e11, t6, n5, r8]) for (let e12 = 0; e12 < 4; e12++) {
      const t7 = f16 >>> 8 * e12 & 255;
      for (let e13 = 8 / i9 - 1; e13 >= 0; e13--) {
        const n6 = t7 >>> i9 * e13 & u10, { s0: r9, s1: f17, s2: p9, s3: g4 } = o6[h9 * s5 + n6];
        a6 ^= r9, c9 ^= f17, l9 ^= p9, d7 ^= g4, h9 += 1;
      }
    }
    this.s0 = a6, this.s1 = c9, this.s2 = l9, this.s3 = d7;
  }
  update(e11) {
    e11 = (0, Mr3.toBytes)(e11), (0, xr3.exists)(this);
    const t6 = (0, Mr3.u32)(e11), n5 = Math.floor(e11.length / Ir3), r8 = e11.length % Ir3;
    for (let e12 = 0; e12 < n5; e12++) this._updateBlock(t6[4 * e12 + 0], t6[4 * e12 + 1], t6[4 * e12 + 2], t6[4 * e12 + 3]);
    return r8 && (Tr3.set(e11.subarray(n5 * Ir3)), this._updateBlock(Rr3[0], Rr3[1], Rr3[2], Rr3[3]), (0, Mr3.clean)(Rr3)), this;
  }
  destroy() {
    const { t: e11 } = this;
    for (const t6 of e11) t6.s0 = 0, t6.s1 = 0, t6.s2 = 0, t6.s3 = 0;
  }
  digestInto(e11) {
    (0, xr3.exists)(this), (0, xr3.output)(e11, this), this.finished = true;
    const { s0: t6, s1: n5, s2: r8, s3: i9 } = this, o6 = (0, Mr3.u32)(e11);
    return o6[0] = t6, o6[1] = n5, o6[2] = r8, o6[3] = i9, e11;
  }
  digest() {
    const e11 = new Uint8Array(Ir3);
    return this.digestInto(e11), this.destroy(), e11;
  }
};
var Lr3 = class extends Nr3 {
  constructor(e11, t6) {
    e11 = (0, Mr3.toBytes)(e11);
    const n5 = Or3((0, Mr3.copyBytes)(e11));
    super(n5, t6), (0, Mr3.clean)(n5);
  }
  update(e11) {
    e11 = (0, Mr3.toBytes)(e11), (0, xr3.exists)(this);
    const t6 = (0, Mr3.u32)(e11), n5 = e11.length % Ir3, r8 = Math.floor(e11.length / Ir3);
    for (let e12 = 0; e12 < r8; e12++) this._updateBlock(Pr3(t6[4 * e12 + 3]), Pr3(t6[4 * e12 + 2]), Pr3(t6[4 * e12 + 1]), Pr3(t6[4 * e12 + 0]));
    return n5 && (Tr3.set(e11.subarray(r8 * Ir3)), this._updateBlock(Pr3(Rr3[3]), Pr3(Rr3[2]), Pr3(Rr3[1]), Pr3(Rr3[0])), (0, Mr3.clean)(Rr3)), this;
  }
  digestInto(e11) {
    (0, xr3.exists)(this), (0, xr3.output)(e11, this), this.finished = true;
    const { s0: t6, s1: n5, s2: r8, s3: i9 } = this, o6 = (0, Mr3.u32)(e11);
    return o6[0] = t6, o6[1] = n5, o6[2] = r8, o6[3] = i9, e11.reverse();
  }
};
function Dr3(e11) {
  const t6 = (t7, n6) => e11(n6, t7.length).update((0, Mr3.toBytes)(t7)).digest(), n5 = e11(new Uint8Array(16), 0);
  return t6.outputLen = n5.outputLen, t6.blockLen = n5.blockLen, t6.create = (t7, n6) => e11(t7, n6), t6;
}
Ar3.ghash = Dr3((e11, t6) => new Nr3(e11, t6)), Ar3.polyval = Dr3((e11, t6) => new Lr3(e11, t6)), Object.defineProperty(kr3, "__esModule", { value: true }), kr3.unsafe = kr3.aeskwp = kr3.aeskw = kr3.siv = kr3.gcm = kr3.cfb = kr3.cbc = kr3.ecb = kr3.ctr = void 0, kr3.expandKeyLE = ei4, kr3.expandKeyDecLE = ti3;
var $r3 = ge4;
var Br3 = Ar3;
var Kr2 = pe4;
var jr3 = 16;
var Ur3 = new Uint8Array(jr3);
var Hr3 = 283;
function Fr2(e11) {
  return e11 << 1 ^ Hr3 & -(e11 >> 7);
}
function zr2(e11, t6) {
  let n5 = 0;
  for (; t6 > 0; t6 >>= 1) n5 ^= e11 & -(1 & t6), e11 = Fr2(e11);
  return n5;
}
var qr3 = (() => {
  const e11 = new Uint8Array(256);
  for (let t7 = 0, n5 = 1; t7 < 256; t7++, n5 ^= Fr2(n5)) e11[t7] = n5;
  const t6 = new Uint8Array(256);
  t6[0] = 99;
  for (let n5 = 0; n5 < 255; n5++) {
    let r8 = e11[255 - n5];
    r8 |= r8 << 8, t6[e11[n5]] = 255 & (r8 ^ r8 >> 4 ^ r8 >> 5 ^ r8 >> 6 ^ r8 >> 7 ^ 99);
  }
  return (0, Kr2.clean)(e11), t6;
})();
var Wr3 = qr3.map((e11, t6) => qr3.indexOf(t6));
var Vr3 = (e11) => e11 << 24 | e11 >>> 8;
var Gr3 = (e11) => e11 << 8 | e11 >>> 24;
var Yr2 = (e11) => e11 << 24 & 4278190080 | e11 << 8 & 16711680 | e11 >>> 8 & 65280 | e11 >>> 24 & 255;
function Zr3(e11, t6) {
  if (256 !== e11.length) throw new Error("Wrong sbox length");
  const n5 = new Uint32Array(256).map((n6, r9) => t6(e11[r9])), r8 = n5.map(Gr3), i9 = r8.map(Gr3), o6 = i9.map(Gr3), s5 = new Uint32Array(65536), a6 = new Uint32Array(65536), c9 = new Uint16Array(65536);
  for (let t7 = 0; t7 < 256; t7++) for (let l9 = 0; l9 < 256; l9++) {
    const d7 = 256 * t7 + l9;
    s5[d7] = n5[t7] ^ r8[l9], a6[d7] = i9[t7] ^ o6[l9], c9[d7] = e11[t7] << 8 | e11[l9];
  }
  return { sbox: e11, sbox2: c9, T0: n5, T1: r8, T2: i9, T3: o6, T01: s5, T23: a6 };
}
var Jr2 = Zr3(qr3, (e11) => zr2(e11, 3) << 24 | e11 << 16 | e11 << 8 | zr2(e11, 2));
var Qr3 = Zr3(Wr3, (e11) => zr2(e11, 11) << 24 | zr2(e11, 13) << 16 | zr2(e11, 9) << 8 | zr2(e11, 14));
var Xr3 = (() => {
  const e11 = new Uint8Array(16);
  for (let t6 = 0, n5 = 1; t6 < 16; t6++, n5 = Fr2(n5)) e11[t6] = n5;
  return e11;
})();
function ei4(e11) {
  (0, $r3.bytes)(e11);
  const t6 = e11.length;
  if (![16, 24, 32].includes(t6)) throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t6}`);
  const { sbox2: n5 } = Jr2, r8 = [];
  (0, Kr2.isAligned32)(e11) || r8.push(e11 = (0, Kr2.copyBytes)(e11));
  const i9 = (0, Kr2.u32)(e11), o6 = i9.length, s5 = (e12) => ri4(n5, e12, e12, e12, e12), a6 = new Uint32Array(t6 + 28);
  a6.set(i9);
  for (let e12 = o6; e12 < a6.length; e12++) {
    let t7 = a6[e12 - 1];
    e12 % o6 == 0 ? t7 = s5(Vr3(t7)) ^ Xr3[e12 / o6 - 1] : o6 > 6 && e12 % o6 == 4 && (t7 = s5(t7)), a6[e12] = a6[e12 - o6] ^ t7;
  }
  return (0, Kr2.clean)(...r8), a6;
}
function ti3(e11) {
  const t6 = ei4(e11), n5 = t6.slice(), r8 = t6.length, { sbox2: i9 } = Jr2, { T0: o6, T1: s5, T2: a6, T3: c9 } = Qr3;
  for (let e12 = 0; e12 < r8; e12 += 4) for (let i10 = 0; i10 < 4; i10++) n5[e12 + i10] = t6[r8 - e12 - 4 + i10];
  (0, Kr2.clean)(t6);
  for (let e12 = 4; e12 < r8 - 4; e12++) {
    const t7 = n5[e12], r9 = ri4(i9, t7, t7, t7, t7);
    n5[e12] = o6[255 & r9] ^ s5[r9 >>> 8 & 255] ^ a6[r9 >>> 16 & 255] ^ c9[r9 >>> 24];
  }
  return n5;
}
function ni4(e11, t6, n5, r8, i9, o6) {
  return e11[n5 << 8 & 65280 | r8 >>> 8 & 255] ^ t6[i9 >>> 8 & 65280 | o6 >>> 24 & 255];
}
function ri4(e11, t6, n5, r8, i9) {
  return e11[255 & t6 | 65280 & n5] | e11[r8 >>> 16 & 255 | i9 >>> 16 & 65280] << 16;
}
function ii4(e11, t6, n5, r8, i9) {
  const { sbox2: o6, T01: s5, T23: a6 } = Jr2;
  let c9 = 0;
  t6 ^= e11[c9++], n5 ^= e11[c9++], r8 ^= e11[c9++], i9 ^= e11[c9++];
  const l9 = e11.length / 4 - 2;
  for (let o7 = 0; o7 < l9; o7++) {
    const o8 = e11[c9++] ^ ni4(s5, a6, t6, n5, r8, i9), l10 = e11[c9++] ^ ni4(s5, a6, n5, r8, i9, t6), d7 = e11[c9++] ^ ni4(s5, a6, r8, i9, t6, n5), u10 = e11[c9++] ^ ni4(s5, a6, i9, t6, n5, r8);
    t6 = o8, n5 = l10, r8 = d7, i9 = u10;
  }
  return { s0: e11[c9++] ^ ri4(o6, t6, n5, r8, i9), s1: e11[c9++] ^ ri4(o6, n5, r8, i9, t6), s2: e11[c9++] ^ ri4(o6, r8, i9, t6, n5), s3: e11[c9++] ^ ri4(o6, i9, t6, n5, r8) };
}
function oi4(e11, t6, n5, r8, i9) {
  const { sbox2: o6, T01: s5, T23: a6 } = Qr3;
  let c9 = 0;
  t6 ^= e11[c9++], n5 ^= e11[c9++], r8 ^= e11[c9++], i9 ^= e11[c9++];
  const l9 = e11.length / 4 - 2;
  for (let o7 = 0; o7 < l9; o7++) {
    const o8 = e11[c9++] ^ ni4(s5, a6, t6, i9, r8, n5), l10 = e11[c9++] ^ ni4(s5, a6, n5, t6, i9, r8), d7 = e11[c9++] ^ ni4(s5, a6, r8, n5, t6, i9), u10 = e11[c9++] ^ ni4(s5, a6, i9, r8, n5, t6);
    t6 = o8, n5 = l10, r8 = d7, i9 = u10;
  }
  return { s0: e11[c9++] ^ ri4(o6, t6, i9, r8, n5), s1: e11[c9++] ^ ri4(o6, n5, t6, i9, r8), s2: e11[c9++] ^ ri4(o6, r8, n5, t6, i9), s3: e11[c9++] ^ ri4(o6, i9, r8, n5, t6) };
}
function si4(e11, t6) {
  if (void 0 === t6) return new Uint8Array(e11);
  if ((0, $r3.bytes)(t6), t6.length < e11) throw new Error(`aes: wrong destination length, expected at least ${e11}, got: ${t6.length}`);
  if (!(0, Kr2.isAligned32)(t6)) throw new Error("unaligned dst");
  return t6;
}
function ai4(e11, t6, n5, r8) {
  (0, $r3.bytes)(t6, jr3), (0, $r3.bytes)(n5);
  const i9 = n5.length;
  r8 = si4(i9, r8);
  const o6 = t6, s5 = (0, Kr2.u32)(o6);
  let { s0: a6, s1: c9, s2: l9, s3: d7 } = ii4(e11, s5[0], s5[1], s5[2], s5[3]);
  const u10 = (0, Kr2.u32)(n5), h9 = (0, Kr2.u32)(r8);
  for (let t7 = 0; t7 + 4 <= u10.length; t7 += 4) {
    h9[t7 + 0] = u10[t7 + 0] ^ a6, h9[t7 + 1] = u10[t7 + 1] ^ c9, h9[t7 + 2] = u10[t7 + 2] ^ l9, h9[t7 + 3] = u10[t7 + 3] ^ d7;
    let n6 = 1;
    for (let e12 = o6.length - 1; e12 >= 0; e12--) n6 = n6 + (255 & o6[e12]) | 0, o6[e12] = 255 & n6, n6 >>>= 8;
    ({ s0: a6, s1: c9, s2: l9, s3: d7 } = ii4(e11, s5[0], s5[1], s5[2], s5[3]));
  }
  const f16 = jr3 * Math.floor(u10.length / 4);
  if (f16 < i9) {
    const e12 = new Uint32Array([a6, c9, l9, d7]), t7 = (0, Kr2.u8)(e12);
    for (let e13 = f16, o7 = 0; e13 < i9; e13++, o7++) r8[e13] = n5[e13] ^ t7[o7];
    (0, Kr2.clean)(e12);
  }
  return r8;
}
function ci4(e11, t6, n5, r8, i9) {
  (0, $r3.bytes)(n5, jr3), (0, $r3.bytes)(r8), i9 = si4(r8.length, i9);
  const o6 = n5, s5 = (0, Kr2.u32)(o6), a6 = (0, Kr2.createView)(o6), c9 = (0, Kr2.u32)(r8), l9 = (0, Kr2.u32)(i9), d7 = t6 ? 0 : 12, u10 = r8.length;
  let h9 = a6.getUint32(d7, t6), { s0: f16, s1: p9, s2: g4, s3: m6 } = ii4(e11, s5[0], s5[1], s5[2], s5[3]);
  for (let n6 = 0; n6 + 4 <= c9.length; n6 += 4) l9[n6 + 0] = c9[n6 + 0] ^ f16, l9[n6 + 1] = c9[n6 + 1] ^ p9, l9[n6 + 2] = c9[n6 + 2] ^ g4, l9[n6 + 3] = c9[n6 + 3] ^ m6, h9 = h9 + 1 >>> 0, a6.setUint32(d7, h9, t6), { s0: f16, s1: p9, s2: g4, s3: m6 } = ii4(e11, s5[0], s5[1], s5[2], s5[3]);
  const y11 = jr3 * Math.floor(c9.length / 4);
  if (y11 < u10) {
    const e12 = new Uint32Array([f16, p9, g4, m6]), t7 = (0, Kr2.u8)(e12);
    for (let e13 = y11, n6 = 0; e13 < u10; e13++, n6++) i9[e13] = r8[e13] ^ t7[n6];
    (0, Kr2.clean)(e12);
  }
  return i9;
}
function li4(e11) {
  if ((0, $r3.bytes)(e11), e11.length % jr3 != 0) throw new Error("aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16");
}
function di4(e11, t6, n5) {
  (0, $r3.bytes)(e11);
  let r8 = e11.length;
  const i9 = r8 % jr3;
  if (!t6 && 0 !== i9) throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  (0, Kr2.isAligned32)(e11) || (e11 = (0, Kr2.copyBytes)(e11));
  const o6 = (0, Kr2.u32)(e11);
  if (t6) {
    let e12 = jr3 - i9;
    e12 || (e12 = jr3), r8 += e12;
  }
  const s5 = si4(r8, n5);
  return { b: o6, o: (0, Kr2.u32)(s5), out: s5 };
}
function ui4(e11, t6) {
  if (!t6) return e11;
  const n5 = e11.length;
  if (!n5) throw new Error("aes/pcks5: empty ciphertext not allowed");
  const r8 = e11[n5 - 1];
  if (r8 <= 0 || r8 > 16) throw new Error("aes/pcks5: wrong padding");
  const i9 = e11.subarray(0, -r8);
  for (let t7 = 0; t7 < r8; t7++) if (e11[n5 - t7 - 1] !== r8) throw new Error("aes/pcks5: wrong padding");
  return i9;
}
function hi4(e11) {
  const t6 = new Uint8Array(16), n5 = (0, Kr2.u32)(t6);
  t6.set(e11);
  const r8 = jr3 - e11.length;
  for (let e12 = jr3 - r8; e12 < jr3; e12++) t6[e12] = r8;
  return n5;
}
function fi4(e11, t6, n5, r8, i9) {
  const o6 = null == i9 ? 0 : i9.length, s5 = e11.create(n5, r8.length + o6);
  i9 && s5.update(i9), s5.update(r8);
  const a6 = new Uint8Array(16), c9 = (0, Kr2.createView)(a6);
  i9 && (0, Kr2.setBigUint64)(c9, 0, BigInt(8 * o6), t6), (0, Kr2.setBigUint64)(c9, 8, BigInt(8 * r8.length), t6), s5.update(a6);
  const l9 = s5.digest();
  return (0, Kr2.clean)(a6), l9;
}
kr3.ctr = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e11, t6) {
  function n5(n6, r8) {
    if ((0, $r3.bytes)(n6), void 0 !== r8 && ((0, $r3.bytes)(r8), !(0, Kr2.isAligned32)(r8))) throw new Error("unaligned destination");
    const i9 = ei4(e11), o6 = (0, Kr2.copyBytes)(t6), s5 = [i9, o6];
    (0, Kr2.isAligned32)(n6) || s5.push(n6 = (0, Kr2.copyBytes)(n6));
    const a6 = ai4(i9, o6, n6, r8);
    return (0, Kr2.clean)(...s5), a6;
  }
  return (0, $r3.bytes)(e11), (0, $r3.bytes)(t6, jr3), { encrypt: (e12, t7) => n5(e12, t7), decrypt: (e12, t7) => n5(e12, t7) };
}), kr3.ecb = (0, Kr2.wrapCipher)({ blockSize: 16 }, function(e11, t6 = {}) {
  (0, $r3.bytes)(e11);
  const n5 = !t6.disablePadding;
  return { encrypt(t7, r8) {
    const { b: i9, o: o6, out: s5 } = di4(t7, n5, r8), a6 = ei4(e11);
    let c9 = 0;
    for (; c9 + 4 <= i9.length; ) {
      const { s0: e12, s1: t8, s2: n6, s3: r9 } = ii4(a6, i9[c9 + 0], i9[c9 + 1], i9[c9 + 2], i9[c9 + 3]);
      o6[c9++] = e12, o6[c9++] = t8, o6[c9++] = n6, o6[c9++] = r9;
    }
    if (n5) {
      const e12 = hi4(t7.subarray(4 * c9)), { s0: n6, s1: r9, s2: i10, s3: s6 } = ii4(a6, e12[0], e12[1], e12[2], e12[3]);
      o6[c9++] = n6, o6[c9++] = r9, o6[c9++] = i10, o6[c9++] = s6;
    }
    return (0, Kr2.clean)(a6), s5;
  }, decrypt(t7, r8) {
    li4(t7);
    const i9 = ti3(e11), o6 = si4(t7.length, r8), s5 = [i9];
    (0, Kr2.isAligned32)(t7) || s5.push(t7 = (0, Kr2.copyBytes)(t7));
    const a6 = (0, Kr2.u32)(t7), c9 = (0, Kr2.u32)(o6);
    for (let e12 = 0; e12 + 4 <= a6.length; ) {
      const { s0: t8, s1: n6, s2: r9, s3: o7 } = oi4(i9, a6[e12 + 0], a6[e12 + 1], a6[e12 + 2], a6[e12 + 3]);
      c9[e12++] = t8, c9[e12++] = n6, c9[e12++] = r9, c9[e12++] = o7;
    }
    return (0, Kr2.clean)(...s5), ui4(o6, n5);
  } };
}), kr3.cbc = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e11, t6, n5 = {}) {
  (0, $r3.bytes)(e11), (0, $r3.bytes)(t6, 16);
  const r8 = !n5.disablePadding;
  return { encrypt(n6, i9) {
    const o6 = ei4(e11), { b: s5, o: a6, out: c9 } = di4(n6, r8, i9);
    let l9 = t6;
    const d7 = [o6];
    (0, Kr2.isAligned32)(l9) || d7.push(l9 = (0, Kr2.copyBytes)(l9));
    const u10 = (0, Kr2.u32)(l9);
    let h9 = u10[0], f16 = u10[1], p9 = u10[2], g4 = u10[3], m6 = 0;
    for (; m6 + 4 <= s5.length; ) h9 ^= s5[m6 + 0], f16 ^= s5[m6 + 1], p9 ^= s5[m6 + 2], g4 ^= s5[m6 + 3], { s0: h9, s1: f16, s2: p9, s3: g4 } = ii4(o6, h9, f16, p9, g4), a6[m6++] = h9, a6[m6++] = f16, a6[m6++] = p9, a6[m6++] = g4;
    if (r8) {
      const e12 = hi4(n6.subarray(4 * m6));
      h9 ^= e12[0], f16 ^= e12[1], p9 ^= e12[2], g4 ^= e12[3], { s0: h9, s1: f16, s2: p9, s3: g4 } = ii4(o6, h9, f16, p9, g4), a6[m6++] = h9, a6[m6++] = f16, a6[m6++] = p9, a6[m6++] = g4;
    }
    return (0, Kr2.clean)(...d7), c9;
  }, decrypt(n6, i9) {
    li4(n6);
    const o6 = ti3(e11);
    let s5 = t6;
    const a6 = [o6];
    (0, Kr2.isAligned32)(s5) || a6.push(s5 = (0, Kr2.copyBytes)(s5));
    const c9 = (0, Kr2.u32)(s5), l9 = si4(n6.length, i9);
    (0, Kr2.isAligned32)(n6) || a6.push(n6 = (0, Kr2.copyBytes)(n6));
    const d7 = (0, Kr2.u32)(n6), u10 = (0, Kr2.u32)(l9);
    let h9 = c9[0], f16 = c9[1], p9 = c9[2], g4 = c9[3];
    for (let e12 = 0; e12 + 4 <= d7.length; ) {
      const t7 = h9, n7 = f16, r9 = p9, i10 = g4;
      h9 = d7[e12 + 0], f16 = d7[e12 + 1], p9 = d7[e12 + 2], g4 = d7[e12 + 3];
      const { s0: s6, s1: a7, s2: c10, s3: l10 } = oi4(o6, h9, f16, p9, g4);
      u10[e12++] = s6 ^ t7, u10[e12++] = a7 ^ n7, u10[e12++] = c10 ^ r9, u10[e12++] = l10 ^ i10;
    }
    return (0, Kr2.clean)(...a6), ui4(l9, r8);
  } };
}), kr3.cfb = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function(e11, t6) {
  function n5(n6, r8, i9) {
    (0, $r3.bytes)(n6);
    const o6 = n6.length;
    i9 = si4(o6, i9);
    const s5 = ei4(e11);
    let a6 = t6;
    const c9 = [s5];
    (0, Kr2.isAligned32)(a6) || c9.push(a6 = (0, Kr2.copyBytes)(a6)), (0, Kr2.isAligned32)(n6) || c9.push(n6 = (0, Kr2.copyBytes)(n6));
    const l9 = (0, Kr2.u32)(n6), d7 = (0, Kr2.u32)(i9), u10 = r8 ? d7 : l9, h9 = (0, Kr2.u32)(a6);
    let f16 = h9[0], p9 = h9[1], g4 = h9[2], m6 = h9[3];
    for (let e12 = 0; e12 + 4 <= l9.length; ) {
      const { s0: t7, s1: n7, s2: r9, s3: i10 } = ii4(s5, f16, p9, g4, m6);
      d7[e12 + 0] = l9[e12 + 0] ^ t7, d7[e12 + 1] = l9[e12 + 1] ^ n7, d7[e12 + 2] = l9[e12 + 2] ^ r9, d7[e12 + 3] = l9[e12 + 3] ^ i10, f16 = u10[e12++], p9 = u10[e12++], g4 = u10[e12++], m6 = u10[e12++];
    }
    const y11 = jr3 * Math.floor(l9.length / 4);
    if (y11 < o6) {
      ({ s0: f16, s1: p9, s2: g4, s3: m6 } = ii4(s5, f16, p9, g4, m6));
      const e12 = (0, Kr2.u8)(new Uint32Array([f16, p9, g4, m6]));
      for (let t7 = y11, r9 = 0; t7 < o6; t7++, r9++) i9[t7] = n6[t7] ^ e12[r9];
      (0, Kr2.clean)(e12);
    }
    return (0, Kr2.clean)(...c9), i9;
  }
  return (0, $r3.bytes)(e11), (0, $r3.bytes)(t6, 16), { encrypt: (e12, t7) => n5(e12, true, t7), decrypt: (e12, t7) => n5(e12, false, t7) };
}), kr3.gcm = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(e11, t6, n5) {
  if ((0, $r3.bytes)(e11), (0, $r3.bytes)(t6), void 0 !== n5 && (0, $r3.bytes)(n5), t6.length < 8) throw new Error("aes/gcm: invalid nonce length");
  const r8 = 16;
  function i9(e12, t7, r9) {
    const i10 = fi4(Br3.ghash, false, e12, r9, n5);
    for (let e13 = 0; e13 < t7.length; e13++) i10[e13] ^= t7[e13];
    return i10;
  }
  function o6() {
    const n6 = ei4(e11), r9 = Ur3.slice(), i10 = Ur3.slice();
    if (ci4(n6, false, i10, i10, r9), 12 === t6.length) i10.set(t6);
    else {
      const e12 = Ur3.slice(), n7 = (0, Kr2.createView)(e12);
      (0, Kr2.setBigUint64)(n7, 8, BigInt(8 * t6.length), false);
      const o7 = Br3.ghash.create(r9).update(t6).update(e12);
      o7.digestInto(i10), o7.destroy();
    }
    return { xk: n6, authKey: r9, counter: i10, tagMask: ci4(n6, false, i10, Ur3) };
  }
  return { encrypt(e12) {
    (0, $r3.bytes)(e12);
    const { xk: t7, authKey: n6, counter: s5, tagMask: a6 } = o6(), c9 = new Uint8Array(e12.length + r8), l9 = [t7, n6, s5, a6];
    (0, Kr2.isAligned32)(e12) || l9.push(e12 = (0, Kr2.copyBytes)(e12)), ci4(t7, false, s5, e12, c9);
    const d7 = i9(n6, a6, c9.subarray(0, c9.length - r8));
    return l9.push(d7), c9.set(d7, e12.length), (0, Kr2.clean)(...l9), c9;
  }, decrypt(e12) {
    if ((0, $r3.bytes)(e12), e12.length < r8) throw new Error("aes/gcm: ciphertext less than tagLen (16)");
    const { xk: t7, authKey: n6, counter: s5, tagMask: a6 } = o6(), c9 = [t7, n6, a6, s5];
    (0, Kr2.isAligned32)(e12) || c9.push(e12 = (0, Kr2.copyBytes)(e12));
    const l9 = e12.subarray(0, -16), d7 = e12.subarray(-16), u10 = i9(n6, a6, l9);
    if (c9.push(u10), !(0, Kr2.equalBytes)(u10, d7)) throw new Error("aes/gcm: invalid ghash tag");
    const h9 = ci4(t7, false, s5, l9);
    return (0, Kr2.clean)(...c9), h9;
  } };
});
var pi4 = (e11, t6, n5) => (r8) => {
  if (!Number.isSafeInteger(r8) || t6 > r8 || r8 > n5) throw new Error(`${e11}: invalid value=${r8}, must be [${t6}..${n5}]`);
};
function gi3(e11) {
  return null != e11 && "object" == typeof e11 && (e11 instanceof Uint32Array || "Uint32Array" === e11.constructor.name);
}
function mi4(e11, t6) {
  if ((0, $r3.bytes)(t6, 16), !gi3(e11)) throw new Error("_encryptBlock accepts result of expandKeyLE");
  const n5 = (0, Kr2.u32)(t6);
  let { s0: r8, s1: i9, s2: o6, s3: s5 } = ii4(e11, n5[0], n5[1], n5[2], n5[3]);
  return n5[0] = r8, n5[1] = i9, n5[2] = o6, n5[3] = s5, t6;
}
function yi3(e11, t6) {
  if ((0, $r3.bytes)(t6, 16), !gi3(e11)) throw new Error("_decryptBlock accepts result of expandKeyLE");
  const n5 = (0, Kr2.u32)(t6);
  let { s0: r8, s1: i9, s2: o6, s3: s5 } = oi4(e11, n5[0], n5[1], n5[2], n5[3]);
  return n5[0] = r8, n5[1] = i9, n5[2] = o6, n5[3] = s5, t6;
}
kr3.siv = (0, Kr2.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function(e11, t6, n5) {
  const r8 = pi4("AAD", 0, 2 ** 36), i9 = pi4("plaintext", 0, 2 ** 36), o6 = pi4("nonce", 12, 12), s5 = pi4("ciphertext", 16, 2 ** 36 + 16);
  function a6() {
    const n6 = ei4(e11), r9 = new Uint8Array(e11.length), i10 = new Uint8Array(16), o7 = [n6, r9];
    let s6 = t6;
    (0, Kr2.isAligned32)(s6) || o7.push(s6 = (0, Kr2.copyBytes)(s6));
    const a7 = (0, Kr2.u32)(s6);
    let c10 = 0, l10 = a7[0], d7 = a7[1], u10 = a7[2], h9 = 0;
    for (const e12 of [i10, r9].map(Kr2.u32)) {
      const t7 = (0, Kr2.u32)(e12);
      for (let e13 = 0; e13 < t7.length; e13 += 2) {
        const { s0: r10, s1: i11 } = ii4(n6, c10, l10, d7, u10);
        t7[e13 + 0] = r10, t7[e13 + 1] = i11, c10 = ++h9;
      }
    }
    const f16 = { authKey: i10, encKey: ei4(r9) };
    return (0, Kr2.clean)(...o7), f16;
  }
  function c9(e12, r9, i10) {
    const o7 = fi4(Br3.polyval, true, r9, i10, n5);
    for (let e13 = 0; e13 < 12; e13++) o7[e13] ^= t6[e13];
    o7[15] &= 127;
    const s6 = (0, Kr2.u32)(o7);
    let a7 = s6[0], c10 = s6[1], l10 = s6[2], d7 = s6[3];
    return { s0: a7, s1: c10, s2: l10, s3: d7 } = ii4(e12, a7, c10, l10, d7), s6[0] = a7, s6[1] = c10, s6[2] = l10, s6[3] = d7, o7;
  }
  function l9(e12, t7, n6) {
    let r9 = (0, Kr2.copyBytes)(t7);
    r9[15] |= 128;
    const i10 = ci4(e12, true, r9, n6);
    return (0, Kr2.clean)(r9), i10;
  }
  return (0, $r3.bytes)(e11, 16, 24, 32), (0, $r3.bytes)(t6), o6(t6.length), void 0 !== n5 && ((0, $r3.bytes)(n5), r8(n5.length)), { encrypt(e12) {
    (0, $r3.bytes)(e12), i9(e12.length);
    const { encKey: t7, authKey: n6 } = a6(), r9 = c9(t7, n6, e12), o7 = [t7, n6, r9];
    (0, Kr2.isAligned32)(e12) || o7.push(e12 = (0, Kr2.copyBytes)(e12));
    const s6 = new Uint8Array(e12.length + 16);
    return s6.set(r9, e12.length), s6.set(l9(t7, r9, e12)), (0, Kr2.clean)(...o7), s6;
  }, decrypt(e12) {
    (0, $r3.bytes)(e12), s5(e12.length);
    const t7 = e12.subarray(-16), { encKey: n6, authKey: r9 } = a6(), i10 = [n6, r9];
    (0, Kr2.isAligned32)(e12) || i10.push(e12 = (0, Kr2.copyBytes)(e12));
    const o7 = l9(n6, t7, e12.subarray(0, -16)), d7 = c9(n6, r9, o7);
    if (i10.push(d7), !(0, Kr2.equalBytes)(t7, d7)) throw (0, Kr2.clean)(...i10), new Error("invalid polyval tag");
    return (0, Kr2.clean)(...i10), o7;
  } };
});
var vi4 = { encrypt(e11, t6) {
  if (t6.length >= 2 ** 32) throw new Error("plaintext should be less than 4gb");
  const n5 = ei4(e11);
  if (16 === t6.length) mi4(n5, t6);
  else {
    const e12 = (0, Kr2.u32)(t6);
    let r8 = e12[0], i9 = e12[1];
    for (let t7 = 0, o6 = 1; t7 < 6; t7++) for (let t8 = 2; t8 < e12.length; t8 += 2, o6++) {
      const { s0: s5, s1: a6, s2: c9, s3: l9 } = ii4(n5, r8, i9, e12[t8], e12[t8 + 1]);
      r8 = s5, i9 = a6 ^ Yr2(o6), e12[t8] = c9, e12[t8 + 1] = l9;
    }
    e12[0] = r8, e12[1] = i9;
  }
  n5.fill(0);
}, decrypt(e11, t6) {
  if (t6.length - 8 >= 2 ** 32) throw new Error("ciphertext should be less than 4gb");
  const n5 = ti3(e11), r8 = t6.length / 8 - 1;
  if (1 === r8) yi3(n5, t6);
  else {
    const e12 = (0, Kr2.u32)(t6);
    let i9 = e12[0], o6 = e12[1];
    for (let t7 = 0, s5 = 6 * r8; t7 < 6; t7++) for (let t8 = 2 * r8; t8 >= 1; t8 -= 2, s5--) {
      o6 ^= Yr2(s5);
      const { s0: r9, s1: a6, s2: c9, s3: l9 } = oi4(n5, i9, o6, e12[t8], e12[t8 + 1]);
      i9 = r9, o6 = a6, e12[t8] = c9, e12[t8 + 1] = l9;
    }
    e12[0] = i9, e12[1] = o6;
  }
  n5.fill(0);
} };
var bi3 = new Uint8Array(8).fill(166);
kr3.aeskw = (0, Kr2.wrapCipher)({ blockSize: 8 }, (e11) => ({ encrypt(t6) {
  if ((0, $r3.bytes)(t6), !t6.length || t6.length % 8 != 0) throw new Error("invalid plaintext length");
  if (8 === t6.length) throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
  const n5 = (0, Kr2.concatBytes)(bi3, t6);
  return vi4.encrypt(e11, n5), n5;
}, decrypt(t6) {
  if ((0, $r3.bytes)(t6), t6.length % 8 != 0 || t6.length < 24) throw new Error("invalid ciphertext length");
  const n5 = (0, Kr2.copyBytes)(t6);
  if (vi4.decrypt(e11, n5), !(0, Kr2.equalBytes)(n5.subarray(0, 8), bi3)) throw new Error("integrity check failed");
  return n5.subarray(0, 8).fill(0), n5.subarray(8);
} }));
var wi3 = 2790873510;
kr3.aeskwp = (0, Kr2.wrapCipher)({ blockSize: 8 }, (e11) => ({ encrypt(t6) {
  if ((0, $r3.bytes)(t6), !t6.length) throw new Error("invalid plaintext length");
  const n5 = 8 * Math.ceil(t6.length / 8), r8 = new Uint8Array(8 + n5);
  r8.set(t6, 8);
  const i9 = (0, Kr2.u32)(r8);
  return i9[0] = wi3, i9[1] = Yr2(t6.length), vi4.encrypt(e11, r8), r8;
}, decrypt(t6) {
  if ((0, $r3.bytes)(t6), t6.length < 16) throw new Error("invalid ciphertext length");
  const n5 = (0, Kr2.copyBytes)(t6), r8 = (0, Kr2.u32)(n5);
  vi4.decrypt(e11, n5);
  const i9 = Yr2(r8[1]) >>> 0, o6 = 8 * Math.ceil(i9 / 8);
  if (r8[0] !== wi3 || n5.length - 8 !== o6) throw new Error("integrity check failed");
  for (let e12 = i9; e12 < o6; e12++) if (0 !== n5[8 + e12]) throw new Error("integrity check failed");
  return n5.subarray(0, 8).fill(0), n5.subarray(8, 8 + i9);
} })), kr3.unsafe = { expandKeyLE: ei4, expandKeyDecLE: ti3, encrypt: ii4, decrypt: oi4, encryptBlock: mi4, decryptBlock: yi3, ctrCounter: ai4, ctr32: ci4 }, Object.defineProperty(Cr3, "__esModule", { value: true }), Cr3.aes256cbc = Cr3.aes256gcm = void 0;
var Ei3 = kr3;
Cr3.aes256gcm = function(e11, t6, n5) {
  return (0, Ei3.gcm)(e11, t6, n5);
};
Cr3.aes256cbc = function(e11, t6, n5) {
  return (0, Ei3.cbc)(e11, t6);
};
var Si3 = {};
var _i3 = {};
var Ci3 = {};
Object.defineProperty(Ci3, "__esModule", { value: true }), Ci3.sigma = void 0, Ci3.rotl = function(e11, t6) {
  return e11 << t6 | e11 >>> 32 - t6;
}, Ci3.createCipher = function(e11, t6) {
  const { allowShortKeys: n5, extendNonceFn: r8, counterLength: i9, counterRight: o6, rounds: s5 } = (0, Ai3.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, t6);
  if ("function" != typeof e11) throw new Error("core must be a function");
  return (0, ki3.number)(i9), (0, ki3.number)(s5), (0, ki3.bool)(o6), (0, ki3.bool)(n5), (t7, a6, c9, l9, d7 = 0) => {
    (0, ki3.bytes)(t7), (0, ki3.bytes)(a6), (0, ki3.bytes)(c9);
    const u10 = c9.length;
    if (void 0 === l9 && (l9 = new Uint8Array(u10)), (0, ki3.bytes)(l9), (0, ki3.number)(d7), d7 < 0 || d7 >= Li3) throw new Error("arx: counter overflow");
    if (l9.length < u10) throw new Error(`arx: output (${l9.length}) is shorter than data (${u10})`);
    const h9 = [];
    let f16, p9, g4 = t7.length;
    if (32 === g4) h9.push(f16 = (0, Ai3.copyBytes)(t7)), p9 = Ri3;
    else {
      if (16 !== g4 || !n5) throw new Error(`arx: invalid 32-byte key, got length=${g4}`);
      f16 = new Uint8Array(32), f16.set(t7), f16.set(t7, 16), p9 = Ti3, h9.push(f16);
    }
    Pi3(a6) || h9.push(a6 = (0, Ai3.copyBytes)(a6));
    const m6 = (0, Ai3.u32)(f16);
    if (r8) {
      if (24 !== a6.length) throw new Error("arx: extended nonce must be 24 bytes");
      r8(p9, m6, (0, Ai3.u32)(a6.subarray(0, 16)), m6), a6 = a6.subarray(16);
    }
    const y11 = 16 - i9;
    if (y11 !== a6.length) throw new Error(`arx: nonce must be ${y11} or 16 bytes`);
    if (12 !== y11) {
      const e12 = new Uint8Array(12);
      e12.set(a6, o6 ? 0 : 12 - a6.length), a6 = e12, h9.push(a6);
    }
    const v9 = (0, Ai3.u32)(a6);
    return function(e12, t8, n6, r9, i10, o7, s6, a7) {
      const c10 = i10.length, l10 = new Uint8Array(Oi3), d8 = (0, Ai3.u32)(l10), u11 = Pi3(i10) && Pi3(o7), h10 = u11 ? (0, Ai3.u32)(i10) : Di3, f17 = u11 ? (0, Ai3.u32)(o7) : Di3;
      for (let p10 = 0; p10 < c10; s6++) {
        if (e12(t8, n6, r9, d8, s6, a7), s6 >= Li3) throw new Error("arx: counter overflow");
        const g5 = Math.min(Oi3, c10 - p10);
        if (u11 && g5 === Oi3) {
          const e13 = p10 / 4;
          if (p10 % 4 != 0) throw new Error("arx: invalid block position");
          for (let t9, n7 = 0; n7 < Ni3; n7++) t9 = e13 + n7, f17[t9] = h10[t9] ^ d8[n7];
          p10 += Oi3;
        } else {
          for (let e13, t9 = 0; t9 < g5; t9++) e13 = p10 + t9, o7[e13] = i10[e13] ^ l10[t9];
          p10 += g5;
        }
      }
    }(e11, p9, m6, v9, c9, l9, d7, s5), (0, Ai3.clean)(...h9), l9;
  };
};
var ki3 = ge4;
var Ai3 = pe4;
var xi3 = (e11) => Uint8Array.from(e11.split("").map((e12) => e12.charCodeAt(0)));
var Mi3 = xi3("expand 16-byte k");
var Ii3 = xi3("expand 32-byte k");
var Ti3 = (0, Ai3.u32)(Mi3);
var Ri3 = (0, Ai3.u32)(Ii3);
function Pi3(e11) {
  return e11.byteOffset % 4 == 0;
}
Ci3.sigma = Ri3.slice();
var Oi3 = 64;
var Ni3 = 16;
var Li3 = 2 ** 32 - 1;
var Di3 = new Uint32Array();
var $i3 = {};
Object.defineProperty($i3, "__esModule", { value: true }), $i3.poly1305 = void 0, $i3.wrapConstructorWithKey = Hi2;
var Bi3 = ge4;
var Ki3 = pe4;
var ji3 = (e11, t6) => 255 & e11[t6++] | (255 & e11[t6++]) << 8;
var Ui3 = class {
  constructor(e11) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e11 = (0, Ki3.toBytes)(e11), (0, Bi3.bytes)(e11, 32);
    const t6 = ji3(e11, 0), n5 = ji3(e11, 2), r8 = ji3(e11, 4), i9 = ji3(e11, 6), o6 = ji3(e11, 8), s5 = ji3(e11, 10), a6 = ji3(e11, 12), c9 = ji3(e11, 14);
    this.r[0] = 8191 & t6, this.r[1] = 8191 & (t6 >>> 13 | n5 << 3), this.r[2] = 7939 & (n5 >>> 10 | r8 << 6), this.r[3] = 8191 & (r8 >>> 7 | i9 << 9), this.r[4] = 255 & (i9 >>> 4 | o6 << 12), this.r[5] = o6 >>> 1 & 8190, this.r[6] = 8191 & (o6 >>> 14 | s5 << 2), this.r[7] = 8065 & (s5 >>> 11 | a6 << 5), this.r[8] = 8191 & (a6 >>> 8 | c9 << 8), this.r[9] = c9 >>> 5 & 127;
    for (let t7 = 0; t7 < 8; t7++) this.pad[t7] = ji3(e11, 16 + 2 * t7);
  }
  process(e11, t6, n5 = false) {
    const r8 = n5 ? 0 : 2048, { h: i9, r: o6 } = this, s5 = o6[0], a6 = o6[1], c9 = o6[2], l9 = o6[3], d7 = o6[4], u10 = o6[5], h9 = o6[6], f16 = o6[7], p9 = o6[8], g4 = o6[9], m6 = ji3(e11, t6 + 0), y11 = ji3(e11, t6 + 2), v9 = ji3(e11, t6 + 4), b6 = ji3(e11, t6 + 6), w8 = ji3(e11, t6 + 8), E8 = ji3(e11, t6 + 10), S8 = ji3(e11, t6 + 12), _6 = ji3(e11, t6 + 14);
    let C10 = i9[0] + (8191 & m6), k11 = i9[1] + (8191 & (m6 >>> 13 | y11 << 3)), A9 = i9[2] + (8191 & (y11 >>> 10 | v9 << 6)), x7 = i9[3] + (8191 & (v9 >>> 7 | b6 << 9)), M8 = i9[4] + (8191 & (b6 >>> 4 | w8 << 12)), I8 = i9[5] + (w8 >>> 1 & 8191), T8 = i9[6] + (8191 & (w8 >>> 14 | E8 << 2)), R6 = i9[7] + (8191 & (E8 >>> 11 | S8 << 5)), P7 = i9[8] + (8191 & (S8 >>> 8 | _6 << 8)), O8 = i9[9] + (_6 >>> 5 | r8), N9 = 0, L7 = N9 + C10 * s5 + k11 * (5 * g4) + A9 * (5 * p9) + x7 * (5 * f16) + M8 * (5 * h9);
    N9 = L7 >>> 13, L7 &= 8191, L7 += I8 * (5 * u10) + T8 * (5 * d7) + R6 * (5 * l9) + P7 * (5 * c9) + O8 * (5 * a6), N9 += L7 >>> 13, L7 &= 8191;
    let D9 = N9 + C10 * a6 + k11 * s5 + A9 * (5 * g4) + x7 * (5 * p9) + M8 * (5 * f16);
    N9 = D9 >>> 13, D9 &= 8191, D9 += I8 * (5 * h9) + T8 * (5 * u10) + R6 * (5 * d7) + P7 * (5 * l9) + O8 * (5 * c9), N9 += D9 >>> 13, D9 &= 8191;
    let $8 = N9 + C10 * c9 + k11 * a6 + A9 * s5 + x7 * (5 * g4) + M8 * (5 * p9);
    N9 = $8 >>> 13, $8 &= 8191, $8 += I8 * (5 * f16) + T8 * (5 * h9) + R6 * (5 * u10) + P7 * (5 * d7) + O8 * (5 * l9), N9 += $8 >>> 13, $8 &= 8191;
    let B9 = N9 + C10 * l9 + k11 * c9 + A9 * a6 + x7 * s5 + M8 * (5 * g4);
    N9 = B9 >>> 13, B9 &= 8191, B9 += I8 * (5 * p9) + T8 * (5 * f16) + R6 * (5 * h9) + P7 * (5 * u10) + O8 * (5 * d7), N9 += B9 >>> 13, B9 &= 8191;
    let K5 = N9 + C10 * d7 + k11 * l9 + A9 * c9 + x7 * a6 + M8 * s5;
    N9 = K5 >>> 13, K5 &= 8191, K5 += I8 * (5 * g4) + T8 * (5 * p9) + R6 * (5 * f16) + P7 * (5 * h9) + O8 * (5 * u10), N9 += K5 >>> 13, K5 &= 8191;
    let j9 = N9 + C10 * u10 + k11 * d7 + A9 * l9 + x7 * c9 + M8 * a6;
    N9 = j9 >>> 13, j9 &= 8191, j9 += I8 * s5 + T8 * (5 * g4) + R6 * (5 * p9) + P7 * (5 * f16) + O8 * (5 * h9), N9 += j9 >>> 13, j9 &= 8191;
    let U6 = N9 + C10 * h9 + k11 * u10 + A9 * d7 + x7 * l9 + M8 * c9;
    N9 = U6 >>> 13, U6 &= 8191, U6 += I8 * a6 + T8 * s5 + R6 * (5 * g4) + P7 * (5 * p9) + O8 * (5 * f16), N9 += U6 >>> 13, U6 &= 8191;
    let H4 = N9 + C10 * f16 + k11 * h9 + A9 * u10 + x7 * d7 + M8 * l9;
    N9 = H4 >>> 13, H4 &= 8191, H4 += I8 * c9 + T8 * a6 + R6 * s5 + P7 * (5 * g4) + O8 * (5 * p9), N9 += H4 >>> 13, H4 &= 8191;
    let F8 = N9 + C10 * p9 + k11 * f16 + A9 * h9 + x7 * u10 + M8 * d7;
    N9 = F8 >>> 13, F8 &= 8191, F8 += I8 * l9 + T8 * c9 + R6 * a6 + P7 * s5 + O8 * (5 * g4), N9 += F8 >>> 13, F8 &= 8191;
    let z9 = N9 + C10 * g4 + k11 * p9 + A9 * f16 + x7 * h9 + M8 * u10;
    N9 = z9 >>> 13, z9 &= 8191, z9 += I8 * d7 + T8 * l9 + R6 * c9 + P7 * a6 + O8 * s5, N9 += z9 >>> 13, z9 &= 8191, N9 = (N9 << 2) + N9 | 0, N9 = N9 + L7 | 0, L7 = 8191 & N9, N9 >>>= 13, D9 += N9, i9[0] = L7, i9[1] = D9, i9[2] = $8, i9[3] = B9, i9[4] = K5, i9[5] = j9, i9[6] = U6, i9[7] = H4, i9[8] = F8, i9[9] = z9;
  }
  finalize() {
    const { h: e11, pad: t6 } = this, n5 = new Uint16Array(10);
    let r8 = e11[1] >>> 13;
    e11[1] &= 8191;
    for (let t7 = 2; t7 < 10; t7++) e11[t7] += r8, r8 = e11[t7] >>> 13, e11[t7] &= 8191;
    e11[0] += 5 * r8, r8 = e11[0] >>> 13, e11[0] &= 8191, e11[1] += r8, r8 = e11[1] >>> 13, e11[1] &= 8191, e11[2] += r8, n5[0] = e11[0] + 5, r8 = n5[0] >>> 13, n5[0] &= 8191;
    for (let t7 = 1; t7 < 10; t7++) n5[t7] = e11[t7] + r8, r8 = n5[t7] >>> 13, n5[t7] &= 8191;
    n5[9] -= 8192;
    let i9 = (1 ^ r8) - 1;
    for (let e12 = 0; e12 < 10; e12++) n5[e12] &= i9;
    i9 = ~i9;
    for (let t7 = 0; t7 < 10; t7++) e11[t7] = e11[t7] & i9 | n5[t7];
    e11[0] = 65535 & (e11[0] | e11[1] << 13), e11[1] = 65535 & (e11[1] >>> 3 | e11[2] << 10), e11[2] = 65535 & (e11[2] >>> 6 | e11[3] << 7), e11[3] = 65535 & (e11[3] >>> 9 | e11[4] << 4), e11[4] = 65535 & (e11[4] >>> 12 | e11[5] << 1 | e11[6] << 14), e11[5] = 65535 & (e11[6] >>> 2 | e11[7] << 11), e11[6] = 65535 & (e11[7] >>> 5 | e11[8] << 8), e11[7] = 65535 & (e11[8] >>> 8 | e11[9] << 5);
    let o6 = e11[0] + t6[0];
    e11[0] = 65535 & o6;
    for (let n6 = 1; n6 < 8; n6++) o6 = (e11[n6] + t6[n6] | 0) + (o6 >>> 16) | 0, e11[n6] = 65535 & o6;
    (0, Ki3.clean)(n5);
  }
  update(e11) {
    (0, Bi3.exists)(this);
    const { buffer: t6, blockLen: n5 } = this, r8 = (e11 = (0, Ki3.toBytes)(e11)).length;
    for (let i9 = 0; i9 < r8; ) {
      const o6 = Math.min(n5 - this.pos, r8 - i9);
      if (o6 !== n5) t6.set(e11.subarray(i9, i9 + o6), this.pos), this.pos += o6, i9 += o6, this.pos === n5 && (this.process(t6, 0, false), this.pos = 0);
      else for (; n5 <= r8 - i9; i9 += n5) this.process(e11, i9);
    }
    return this;
  }
  destroy() {
    (0, Ki3.clean)(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e11) {
    (0, Bi3.exists)(this), (0, Bi3.output)(e11, this), this.finished = true;
    const { buffer: t6, h: n5 } = this;
    let { pos: r8 } = this;
    if (r8) {
      for (t6[r8++] = 1; r8 < 16; r8++) t6[r8] = 0;
      this.process(t6, 0, true);
    }
    this.finalize();
    let i9 = 0;
    for (let t7 = 0; t7 < 8; t7++) e11[i9++] = n5[t7] >>> 0, e11[i9++] = n5[t7] >>> 8;
    return e11;
  }
  digest() {
    const { buffer: e11, outputLen: t6 } = this;
    this.digestInto(e11);
    const n5 = e11.slice(0, t6);
    return this.destroy(), n5;
  }
};
function Hi2(e11) {
  const t6 = (t7, n6) => e11(n6).update((0, Ki3.toBytes)(t7)).digest(), n5 = e11(new Uint8Array(32));
  return t6.outputLen = n5.outputLen, t6.blockLen = n5.blockLen, t6.create = (t7) => e11(t7), t6;
}
$i3.poly1305 = Hi2((e11) => new Ui3(e11)), function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.xchacha20poly1305 = e11.chacha20poly1305 = e11._poly1305_aead = e11.chacha12 = e11.chacha8 = e11.xchacha20 = e11.chacha20 = e11.chacha20orig = void 0, e11.hchacha = s5;
  const t6 = Ci3, n5 = ge4, r8 = $i3, i9 = pe4;
  function o6(e12, n6, r9, i10, o7, s6 = 20) {
    let a7 = e12[0], c10 = e12[1], l10 = e12[2], d8 = e12[3], u10 = n6[0], h9 = n6[1], f16 = n6[2], p9 = n6[3], g4 = n6[4], m6 = n6[5], y11 = n6[6], v9 = n6[7], b6 = o7, w8 = r9[0], E8 = r9[1], S8 = r9[2], _6 = a7, C10 = c10, k11 = l10, A9 = d8, x7 = u10, M8 = h9, I8 = f16, T8 = p9, R6 = g4, P7 = m6, O8 = y11, N9 = v9, L7 = b6, D9 = w8, $8 = E8, B9 = S8;
    for (let e13 = 0; e13 < s6; e13 += 2) _6 = _6 + x7 | 0, L7 = (0, t6.rotl)(L7 ^ _6, 16), R6 = R6 + L7 | 0, x7 = (0, t6.rotl)(x7 ^ R6, 12), _6 = _6 + x7 | 0, L7 = (0, t6.rotl)(L7 ^ _6, 8), R6 = R6 + L7 | 0, x7 = (0, t6.rotl)(x7 ^ R6, 7), C10 = C10 + M8 | 0, D9 = (0, t6.rotl)(D9 ^ C10, 16), P7 = P7 + D9 | 0, M8 = (0, t6.rotl)(M8 ^ P7, 12), C10 = C10 + M8 | 0, D9 = (0, t6.rotl)(D9 ^ C10, 8), P7 = P7 + D9 | 0, M8 = (0, t6.rotl)(M8 ^ P7, 7), k11 = k11 + I8 | 0, $8 = (0, t6.rotl)($8 ^ k11, 16), O8 = O8 + $8 | 0, I8 = (0, t6.rotl)(I8 ^ O8, 12), k11 = k11 + I8 | 0, $8 = (0, t6.rotl)($8 ^ k11, 8), O8 = O8 + $8 | 0, I8 = (0, t6.rotl)(I8 ^ O8, 7), A9 = A9 + T8 | 0, B9 = (0, t6.rotl)(B9 ^ A9, 16), N9 = N9 + B9 | 0, T8 = (0, t6.rotl)(T8 ^ N9, 12), A9 = A9 + T8 | 0, B9 = (0, t6.rotl)(B9 ^ A9, 8), N9 = N9 + B9 | 0, T8 = (0, t6.rotl)(T8 ^ N9, 7), _6 = _6 + M8 | 0, B9 = (0, t6.rotl)(B9 ^ _6, 16), O8 = O8 + B9 | 0, M8 = (0, t6.rotl)(M8 ^ O8, 12), _6 = _6 + M8 | 0, B9 = (0, t6.rotl)(B9 ^ _6, 8), O8 = O8 + B9 | 0, M8 = (0, t6.rotl)(M8 ^ O8, 7), C10 = C10 + I8 | 0, L7 = (0, t6.rotl)(L7 ^ C10, 16), N9 = N9 + L7 | 0, I8 = (0, t6.rotl)(I8 ^ N9, 12), C10 = C10 + I8 | 0, L7 = (0, t6.rotl)(L7 ^ C10, 8), N9 = N9 + L7 | 0, I8 = (0, t6.rotl)(I8 ^ N9, 7), k11 = k11 + T8 | 0, D9 = (0, t6.rotl)(D9 ^ k11, 16), R6 = R6 + D9 | 0, T8 = (0, t6.rotl)(T8 ^ R6, 12), k11 = k11 + T8 | 0, D9 = (0, t6.rotl)(D9 ^ k11, 8), R6 = R6 + D9 | 0, T8 = (0, t6.rotl)(T8 ^ R6, 7), A9 = A9 + x7 | 0, $8 = (0, t6.rotl)($8 ^ A9, 16), P7 = P7 + $8 | 0, x7 = (0, t6.rotl)(x7 ^ P7, 12), A9 = A9 + x7 | 0, $8 = (0, t6.rotl)($8 ^ A9, 8), P7 = P7 + $8 | 0, x7 = (0, t6.rotl)(x7 ^ P7, 7);
    let K5 = 0;
    i10[K5++] = a7 + _6 | 0, i10[K5++] = c10 + C10 | 0, i10[K5++] = l10 + k11 | 0, i10[K5++] = d8 + A9 | 0, i10[K5++] = u10 + x7 | 0, i10[K5++] = h9 + M8 | 0, i10[K5++] = f16 + I8 | 0, i10[K5++] = p9 + T8 | 0, i10[K5++] = g4 + R6 | 0, i10[K5++] = m6 + P7 | 0, i10[K5++] = y11 + O8 | 0, i10[K5++] = v9 + N9 | 0, i10[K5++] = b6 + L7 | 0, i10[K5++] = w8 + D9 | 0, i10[K5++] = E8 + $8 | 0, i10[K5++] = S8 + B9 | 0;
  }
  function s5(e12, n6, r9, i10) {
    let o7 = e12[0], s6 = e12[1], a7 = e12[2], c10 = e12[3], l10 = n6[0], d8 = n6[1], u10 = n6[2], h9 = n6[3], f16 = n6[4], p9 = n6[5], g4 = n6[6], m6 = n6[7], y11 = r9[0], v9 = r9[1], b6 = r9[2], w8 = r9[3];
    for (let e13 = 0; e13 < 20; e13 += 2) o7 = o7 + l10 | 0, y11 = (0, t6.rotl)(y11 ^ o7, 16), f16 = f16 + y11 | 0, l10 = (0, t6.rotl)(l10 ^ f16, 12), o7 = o7 + l10 | 0, y11 = (0, t6.rotl)(y11 ^ o7, 8), f16 = f16 + y11 | 0, l10 = (0, t6.rotl)(l10 ^ f16, 7), s6 = s6 + d8 | 0, v9 = (0, t6.rotl)(v9 ^ s6, 16), p9 = p9 + v9 | 0, d8 = (0, t6.rotl)(d8 ^ p9, 12), s6 = s6 + d8 | 0, v9 = (0, t6.rotl)(v9 ^ s6, 8), p9 = p9 + v9 | 0, d8 = (0, t6.rotl)(d8 ^ p9, 7), a7 = a7 + u10 | 0, b6 = (0, t6.rotl)(b6 ^ a7, 16), g4 = g4 + b6 | 0, u10 = (0, t6.rotl)(u10 ^ g4, 12), a7 = a7 + u10 | 0, b6 = (0, t6.rotl)(b6 ^ a7, 8), g4 = g4 + b6 | 0, u10 = (0, t6.rotl)(u10 ^ g4, 7), c10 = c10 + h9 | 0, w8 = (0, t6.rotl)(w8 ^ c10, 16), m6 = m6 + w8 | 0, h9 = (0, t6.rotl)(h9 ^ m6, 12), c10 = c10 + h9 | 0, w8 = (0, t6.rotl)(w8 ^ c10, 8), m6 = m6 + w8 | 0, h9 = (0, t6.rotl)(h9 ^ m6, 7), o7 = o7 + d8 | 0, w8 = (0, t6.rotl)(w8 ^ o7, 16), g4 = g4 + w8 | 0, d8 = (0, t6.rotl)(d8 ^ g4, 12), o7 = o7 + d8 | 0, w8 = (0, t6.rotl)(w8 ^ o7, 8), g4 = g4 + w8 | 0, d8 = (0, t6.rotl)(d8 ^ g4, 7), s6 = s6 + u10 | 0, y11 = (0, t6.rotl)(y11 ^ s6, 16), m6 = m6 + y11 | 0, u10 = (0, t6.rotl)(u10 ^ m6, 12), s6 = s6 + u10 | 0, y11 = (0, t6.rotl)(y11 ^ s6, 8), m6 = m6 + y11 | 0, u10 = (0, t6.rotl)(u10 ^ m6, 7), a7 = a7 + h9 | 0, v9 = (0, t6.rotl)(v9 ^ a7, 16), f16 = f16 + v9 | 0, h9 = (0, t6.rotl)(h9 ^ f16, 12), a7 = a7 + h9 | 0, v9 = (0, t6.rotl)(v9 ^ a7, 8), f16 = f16 + v9 | 0, h9 = (0, t6.rotl)(h9 ^ f16, 7), c10 = c10 + l10 | 0, b6 = (0, t6.rotl)(b6 ^ c10, 16), p9 = p9 + b6 | 0, l10 = (0, t6.rotl)(l10 ^ p9, 12), c10 = c10 + l10 | 0, b6 = (0, t6.rotl)(b6 ^ c10, 8), p9 = p9 + b6 | 0, l10 = (0, t6.rotl)(l10 ^ p9, 7);
    let E8 = 0;
    i10[E8++] = o7, i10[E8++] = s6, i10[E8++] = a7, i10[E8++] = c10, i10[E8++] = y11, i10[E8++] = v9, i10[E8++] = b6, i10[E8++] = w8;
  }
  e11.chacha20orig = (0, t6.createCipher)(o6, { counterRight: false, counterLength: 8, allowShortKeys: true }), e11.chacha20 = (0, t6.createCipher)(o6, { counterRight: false, counterLength: 4, allowShortKeys: false }), e11.xchacha20 = (0, t6.createCipher)(o6, { counterRight: false, counterLength: 8, extendNonceFn: s5, allowShortKeys: false }), e11.chacha8 = (0, t6.createCipher)(o6, { counterRight: false, counterLength: 4, rounds: 8 }), e11.chacha12 = (0, t6.createCipher)(o6, { counterRight: false, counterLength: 4, rounds: 12 });
  const a6 = new Uint8Array(16), c9 = (e12, t7) => {
    e12.update(t7);
    const n6 = t7.length % 16;
    n6 && e12.update(a6.subarray(n6));
  }, l9 = new Uint8Array(32);
  function d7(e12, t7, n6, o7, s6) {
    const a7 = e12(t7, n6, l9), d8 = r8.poly1305.create(a7);
    s6 && c9(d8, s6), c9(d8, o7);
    const u10 = new Uint8Array(16), h9 = (0, i9.createView)(u10);
    (0, i9.setBigUint64)(h9, 0, BigInt(s6 ? s6.length : 0), true), (0, i9.setBigUint64)(h9, 8, BigInt(o7.length), true), d8.update(u10);
    const f16 = d8.digest();
    return (0, i9.clean)(a7, u10), f16;
  }
  e11._poly1305_aead = (e12) => (t7, r9, o7) => {
    const s6 = 16;
    return (0, n5.bytes)(t7, 32), (0, n5.bytes)(r9), { encrypt(a7, c10) {
      const l10 = a7.length, u10 = l10 + s6;
      c10 ? (0, n5.bytes)(c10, u10) : c10 = new Uint8Array(u10), e12(t7, r9, a7, c10, 1);
      const h9 = d7(e12, t7, r9, c10.subarray(0, -16), o7);
      return c10.set(h9, l10), (0, i9.clean)(h9), c10;
    }, decrypt(a7, c10) {
      const l10 = a7.length, u10 = l10 - s6;
      if (l10 < s6) throw new Error("encrypted data must be at least 16 bytes");
      c10 ? (0, n5.bytes)(c10, u10) : c10 = new Uint8Array(u10);
      const h9 = a7.subarray(0, -16), f16 = a7.subarray(-16), p9 = d7(e12, t7, r9, h9, o7);
      if (!(0, i9.equalBytes)(f16, p9)) throw new Error("invalid tag");
      return e12(t7, r9, h9, c10, 1), (0, i9.clean)(p9), c10;
    } };
  }, e11.chacha20poly1305 = (0, i9.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, e11._poly1305_aead)(e11.chacha20)), e11.xchacha20poly1305 = (0, i9.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, e11._poly1305_aead)(e11.xchacha20));
}(_i3), Object.defineProperty(Si3, "__esModule", { value: true }), Si3.xchacha20 = void 0;
var Fi3;
var zi3;
var qi3;
var Wi3 = _i3;
Si3.xchacha20 = function(e11, t6, n5) {
  return (0, Wi3.xchacha20poly1305)(e11, t6, n5);
}, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.aesDecrypt = e11.aesEncrypt = e11.symDecrypt = e11.symEncrypt = void 0;
  var t6 = pe4, n5 = Te4, r8 = Cr3, i9 = Si3, o6 = Ce5, s5 = ke5;
  e11.symEncrypt = function(e12, t7, n6) {
    return a6(c9, e12, t7, n6);
  };
  function a6(e12, t7, n6, a7) {
    var c10 = (0, o6.symmetricAlgorithm)();
    if ("aes-256-gcm" === c10) return e12(r8.aes256gcm, t7, n6, (0, o6.symmetricNonceLength)(), s5.AEAD_TAG_LENGTH, a7);
    if ("xchacha20" === c10) return e12(i9.xchacha20, t7, n6, s5.XCHACHA20_NONCE_LENGTH, s5.AEAD_TAG_LENGTH, a7);
    if ("aes-256-cbc" === c10) return e12(r8.aes256cbc, t7, n6, 16, 0);
    throw new Error("Not implemented");
  }
  function c9(e12, r9, i10, o7, s6, a7) {
    var c10 = (0, n5.randomBytes)(o7), l10 = e12(r9, c10, a7).encrypt(i10);
    if (0 === s6) return (0, t6.concatBytes)(c10, l10);
    var d7 = l10.length - s6, u10 = l10.subarray(0, d7), h9 = l10.subarray(d7);
    return (0, t6.concatBytes)(c10, h9, u10);
  }
  function l9(e12, n6, r9, i10, o7, s6) {
    var a7 = r9.subarray(0, i10), c10 = e12(n6, Uint8Array.from(a7), s6), l10 = r9.subarray(i10);
    if (0 === o7) return c10.decrypt(l10);
    var d7 = l10.subarray(0, o7), u10 = l10.subarray(o7);
    return c10.decrypt((0, t6.concatBytes)(u10, d7));
  }
  e11.symDecrypt = function(e12, t7, n6) {
    return a6(l9, e12, t7, n6);
  }, e11.aesEncrypt = e11.symEncrypt, e11.aesDecrypt = e11.symDecrypt;
}(_r3), Fi3 = Me5, zi3 = de4 && de4.__createBinding || (Object.create ? function(e11, t6, n5, r8) {
  void 0 === r8 && (r8 = n5);
  var i9 = Object.getOwnPropertyDescriptor(t6, n5);
  i9 && !("get" in i9 ? !t6.__esModule : i9.writable || i9.configurable) || (i9 = { enumerable: true, get: function() {
    return t6[n5];
  } }), Object.defineProperty(e11, r8, i9);
} : function(e11, t6, n5, r8) {
  void 0 === r8 && (r8 = n5), e11[r8] = t6[n5];
}), qi3 = de4 && de4.__exportStar || function(e11, t6) {
  for (var n5 in e11) "default" === n5 || Object.prototype.hasOwnProperty.call(t6, n5) || zi3(t6, e11, n5);
}, Object.defineProperty(Fi3, "__esModule", { value: true }), qi3(Ie4, Fi3), qi3(pr3, Fi3), qi3(fr3, Fi3), qi3(_r3, Fi3);
var Vi3 = {};
Object.defineProperty(Vi3, "__esModule", { value: true }), Vi3.PublicKey = void 0;
var Gi3 = pe4;
var Yi2 = Me5;
var Zi2 = function() {
  function e11(e12) {
    this.data = (0, Yi2.convertPublicKeyFormat)(e12, true);
  }
  return e11.fromHex = function(t6) {
    return new e11((0, Yi2.hexToPublicKey)(t6));
  }, Object.defineProperty(e11.prototype, "uncompressed", { get: function() {
    return C9.from((0, Yi2.convertPublicKeyFormat)(this.data, false));
  }, enumerable: false, configurable: true }), Object.defineProperty(e11.prototype, "compressed", { get: function() {
    return C9.from(this.data);
  }, enumerable: false, configurable: true }), e11.prototype.toHex = function(e12) {
    return void 0 === e12 && (e12 = true), (0, Gi3.bytesToHex)(e12 ? this.data : this.uncompressed);
  }, e11.prototype.decapsulate = function(e12, t6) {
    void 0 === t6 && (t6 = false);
    var n5 = t6 ? this.data : this.uncompressed, r8 = e12.multiply(this, t6);
    return (0, Yi2.getSharedKey)(n5, r8);
  }, e11.prototype.equals = function(e12) {
    return (0, Gi3.equalBytes)(this.data, e12.data);
  }, e11;
}();
Vi3.PublicKey = Zi2, Object.defineProperty(xe3, "__esModule", { value: true }), xe3.PrivateKey = void 0;
var Ji2 = pe4;
var Qi2 = Me5;
var Xi2 = Vi3;
var eo3 = function() {
  function e11(e12) {
    if (void 0 === e12) this.data = (0, Qi2.getValidSecret)();
    else {
      if (!(0, Qi2.isValidPrivateKey)(e12)) throw new Error("Invalid private key");
      this.data = e12;
    }
    this.publicKey = new Xi2.PublicKey((0, Qi2.getPublicKey)(this.data));
  }
  return e11.fromHex = function(t6) {
    return new e11((0, Qi2.decodeHex)(t6));
  }, Object.defineProperty(e11.prototype, "secret", { get: function() {
    return C9.from(this.data);
  }, enumerable: false, configurable: true }), e11.prototype.toHex = function() {
    return (0, Ji2.bytesToHex)(this.data);
  }, e11.prototype.encapsulate = function(e12, t6) {
    void 0 === t6 && (t6 = false);
    var n5 = t6 ? this.publicKey.compressed : this.publicKey.uncompressed, r8 = this.multiply(e12, t6);
    return (0, Qi2.getSharedKey)(n5, r8);
  }, e11.prototype.multiply = function(e12, t6) {
    return void 0 === t6 && (t6 = false), (0, Qi2.getSharedPoint)(this.data, e12.compressed, t6);
  }, e11.prototype.equals = function(e12) {
    return (0, Ji2.equalBytes)(this.data, e12.data);
  }, e11;
}();
xe3.PrivateKey = eo3, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.PublicKey = e11.PrivateKey = void 0;
  var t6 = xe3;
  Object.defineProperty(e11, "PrivateKey", { enumerable: true, get: function() {
    return t6.PrivateKey;
  } });
  var n5 = Vi3;
  Object.defineProperty(e11, "PublicKey", { enumerable: true, get: function() {
    return n5.PublicKey;
  } });
}(Ae3), function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.utils = e11.PublicKey = e11.PrivateKey = e11.ECIES_CONFIG = void 0, e11.encrypt = function(e12, o7) {
    var s6 = new r8.PrivateKey(), a6 = e12 instanceof Uint8Array ? new r8.PublicKey(e12) : r8.PublicKey.fromHex(e12), c9 = s6.encapsulate(a6, (0, n5.isHkdfKeyCompressed)()), l9 = (0, n5.isEphemeralKeyCompressed)() ? s6.publicKey.compressed : s6.publicKey.uncompressed, d7 = (0, i9.symEncrypt)(c9, o7);
    return C9.from((0, t6.concatBytes)(l9, d7));
  }, e11.decrypt = function(e12, t7) {
    var o7 = e12 instanceof Uint8Array ? new r8.PrivateKey(e12) : r8.PrivateKey.fromHex(e12), s6 = (0, n5.ephemeralKeySize)(), a6 = new r8.PublicKey(t7.subarray(0, s6)), c9 = t7.subarray(s6), l9 = a6.decapsulate(o7, (0, n5.isHkdfKeyCompressed)());
    return C9.from((0, i9.symDecrypt)(l9, c9));
  };
  var t6 = pe4, n5 = Ce5, r8 = Ae3, i9 = Me5;
  var o6 = Ce5;
  Object.defineProperty(e11, "ECIES_CONFIG", { enumerable: true, get: function() {
    return o6.ECIES_CONFIG;
  } });
  var s5 = Ae3;
  Object.defineProperty(e11, "PrivateKey", { enumerable: true, get: function() {
    return s5.PrivateKey;
  } }), Object.defineProperty(e11, "PublicKey", { enumerable: true, get: function() {
    return s5.PublicKey;
  } }), e11.utils = { aesEncrypt: i9.aesEncrypt, aesDecrypt: i9.aesDecrypt, symEncrypt: i9.symEncrypt, symDecrypt: i9.symDecrypt, decodeHex: i9.decodeHex, getValidSecret: i9.getValidSecret, remove0x: i9.remove0x };
}(fe4);
var to5 = (0, import_debug4.default)("KeyExchange:Layer");
var no3 = (0, import_debug4.default)("SocketService:Layer");
var ro3 = (0, import_debug4.default)("Ecies:Layer");
var io3 = (0, import_debug4.default)("RemoteCommunication:Layer");
to5.color = "##95c44e", no3.color = "#f638d7", ro3.color = "#465b9c", io3.color = "#47a2be";
var oo3 = { KeyExchange: to5, SocketService: no3, Ecies: ro3, RemoteCommunication: io3 };
var so3;
var ao3 = [];
var co3 = [];
var lo3 = (t6, n5) => c8(void 0, void 0, void 0, function* () {
  so3 = n5, co3.push(t6), function(t7) {
    return c8(this, void 0, void 0, function* () {
      if (!so3 || !t7) return;
      !function() {
        const e11 = co3;
        co3 = ao3, ao3 = e11;
      }();
      const n6 = so3.endsWith("/") ? `${so3}evt` : `${so3}/evt`, r8 = Object.assign({}, t7);
      if (delete r8.params, t7.params) for (const [e11, n7] of Object.entries(t7.params)) r8[e11] = n7;
      const i9 = JSON.stringify(r8);
      oo3.RemoteCommunication(`[sendBufferedEvents] Sending ${ao3.length} analytics events to ${n6}`);
      try {
        const t8 = yield (0, import_cross_fetch2.default)(n6, { method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" }, body: i9 }), r9 = yield t8.text();
        oo3.RemoteCommunication(`[sendBufferedEvents] Response: ${r9}`), ao3.length = 0;
      } catch (n7) {
      }
    });
  }(t6).catch(() => {
  });
});
var uo3 = class {
  constructor(e11) {
    this.enabled = true, (null == e11 ? void 0 : e11.debug) && import_debug4.default.enable("Ecies:Layer"), this.ecies = (null == e11 ? void 0 : e11.privateKey) ? fe4.PrivateKey.fromHex(e11.privateKey) : new fe4.PrivateKey(), oo3.Ecies("[ECIES constructor()] initialized secret: ", this.ecies.toHex()), oo3.Ecies("[ECIES constructor()] initialized public: ", this.ecies.publicKey.toHex()), oo3.Ecies("[ECIES constructor()] init with", this);
  }
  generateECIES() {
    this.ecies = new fe4.PrivateKey();
  }
  getPublicKey() {
    return this.ecies.publicKey.toHex();
  }
  encrypt(e11, t6) {
    let n5 = e11;
    if (this.enabled) try {
      oo3.Ecies("[ECIES: encrypt()] using otherPublicKey", t6);
      const r8 = C9.from(e11), i9 = fe4.encrypt(t6, r8);
      n5 = C9.from(i9).toString("base64");
    } catch (n6) {
      throw oo3.Ecies("[ECIES: encrypt()] error encrypt:", n6), oo3.Ecies("[ECIES: encrypt()] private: ", this.ecies.toHex()), oo3.Ecies("[ECIES: encrypt()] data: ", e11), oo3.Ecies("[ECIES: encrypt()] otherkey: ", t6), n6;
    }
    return n5;
  }
  decrypt(e11) {
    let t6 = e11;
    if (this.enabled) try {
      oo3.Ecies("[ECIES: decrypt()] using privateKey", this.ecies.toHex());
      const n5 = C9.from(e11.toString(), "base64");
      t6 = fe4.decrypt(this.ecies.toHex(), n5).toString();
    } catch (t7) {
      throw oo3.Ecies("[ECIES: decrypt()] error decrypt", t7), oo3.Ecies("[ECIES: decrypt()] private: ", this.ecies.toHex()), oo3.Ecies("[ECIES: decrypt()] encryptedData: ", e11), t7;
    }
    return t6;
  }
  getKeyInfo() {
    return { private: this.ecies.toHex(), public: this.ecies.publicKey.toHex() };
  }
  toString() {
    oo3.Ecies("[ECIES: toString()]", this.getKeyInfo());
  }
};
var ho3 = { name: "@metamask/sdk-communication-layer", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk.git", directory: "packages/sdk-communication-layer" }, main: "dist/node/cjs/metamask-sdk-communication-layer.js", unpkg: "dist/browser/umd/metamask-sdk-communication-layer.js", module: "dist/node/es/metamask-sdk-communication-layer.js", browser: "dist/browser/es/metamask-sdk-communication-layer.js", "react-native": "dist/react-native/es/metamask-sdk-communication-layer.js", types: "dist/types/src/index.d.ts", files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", "build:clean": "yarn clean && yarn build", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs", dev: 'concurrently "tsc --watch" "rollup -c --bundleConfigAsCjs -w"', "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", size: "size-limit", clean: "rimraf ./dist", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk-communication-layer", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", "publish:preview": "yarn npm publish --tag preview", prepack: "../../scripts/prepack.sh", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:coverage": "jest --coverage", "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": "jest", watch: "rollup -c --bundleConfigAsCjs -w" }, dependencies: { "@metamask/sdk-analytics": "workspace:*", bufferutil: "^4.0.8", "date-fns": "^2.29.3", debug: "^4.3.4", "utf-8-validate": "^5.0.2", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@rollup/plugin-commonjs": "^25.0.0", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.4", "@size-limit/preset-big-lib": "^11.0.2", "@types/jest": "^29.2.4", "@types/node": "^20.1.3", "@types/uuid": "^9.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", concurrently: "^9.1.2", "cross-fetch": "^4.0.0", eciesjs: "^0.4.11", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", eventemitter2: "^6.4.9", jest: "^29.3.1", prettier: "^2.3.0", rimraf: "^3.0.2", rollup: "^4.26.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-node-globals": "^1.4.0", "rollup-plugin-peer-deps-external": "^2.2.4", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.1.6", "socket.io-client": "^4.5.1", "stream-browserify": "^3.0.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^5.6.3" }, peerDependencies: { "cross-fetch": "^4.0.0", eciesjs: "*", eventemitter2: "^6.4.9", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "@lavamoat/preinstall-always-fail": false, canvas: true, "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, bufferutil: false, "utf-8-validate": false } } };
var fo3 = "https://metamask-sdk.api.cx.metamask.io/";
var po3 = ["websocket"];
var go3 = 6048e5;
var mo3 = 3e3;
var yo3 = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_SWITCHETHEREUMCHAIN: "wallet_switchEthereumChain", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var vo3 = [yo3.METAMASK_CONNECTSIGN, yo3.METAMASK_CONNECTWITH, yo3.METAMASK_OPEN, yo3.METAMASK_BATCH, yo3.PERSONAL_SIGN, yo3.WALLET_REQUESTPERMISSIONS, yo3.WALLET_REVOKEPERMISSIONS, yo3.WALLET_WATCHASSET, yo3.ETH_SENDTRANSACTION, yo3.ETH_SIGNTYPEDDATA, yo3.ETH_SIGNTYPEDDATA_V3, yo3.ETH_SIGNTYPEDDATA_V4, yo3.ETH_SIGNTRANSACTION, yo3.ETH_SIGN, yo3.PERSONAL_EC_RECOVER];
function bo3(e11) {
  return vo3.includes(e11);
}
function wo3(e11) {
  const { context: t6 } = e11;
  oo3.RemoteCommunication(`[RemoteCommunication: clean()] context=${t6}`), e11.channelConfig = void 0, e11.ready = false, e11.originatorConnectStarted = false;
}
var Eo3;
var So3;
var _o3;
var Co3;
var ko3;
var Ao3;
var xo3;
(xo3 = Eo3 || (Eo3 = {})).DISCONNECTED = "disconnected", xo3.WAITING = "waiting", xo3.TIMEOUT = "timeout", xo3.LINKED = "linked", xo3.PAUSED = "paused", xo3.TERMINATED = "terminated", function(e11) {
  e11.KEY_INFO = "key_info", e11.SERVICE_STATUS = "service_status", e11.PROVIDER_UPDATE = "provider_update", e11.RPC_UPDATE = "rpc_update", e11.KEYS_EXCHANGED = "keys_exchanged", e11.JOIN_CHANNEL = "join_channel", e11.PUBLIC_KEY = "public_key", e11.CHANNEL_CREATED = "channel_created", e11.CLIENTS_CONNECTED = "clients_connected", e11.CLIENTS_DISCONNECTED = "clients_disconnected", e11.CLIENTS_WAITING = "clients_waiting", e11.CLIENTS_READY = "clients_ready", e11.REJECTED = "rejected", e11.WALLET_INIT = "wallet_init", e11.CHANNEL_PERSISTENCE = "channel_persistence", e11.CONFIG = "config", e11.MESSAGE_ACK = "ack", e11.SOCKET_DISCONNECTED = "socket_disconnected", e11.SOCKET_RECONNECT = "socket_reconnect", e11.OTP = "otp", e11.SDK_RPC_CALL = "sdk_rpc_call", e11.AUTHORIZED = "authorized", e11.CONNECTION_STATUS = "connection_status", e11.MESSAGE = "message", e11.TERMINATE = "terminate";
}(So3 || (So3 = {})), (_o3 || (_o3 = {})).KEY_EXCHANGE = "key_exchange", function(e11) {
  e11.KEY_HANDSHAKE_START = "key_handshake_start", e11.KEY_HANDSHAKE_CHECK = "key_handshake_check", e11.KEY_HANDSHAKE_SYN = "key_handshake_SYN", e11.KEY_HANDSHAKE_SYNACK = "key_handshake_SYNACK", e11.KEY_HANDSHAKE_ACK = "key_handshake_ACK", e11.KEY_HANDSHAKE_WALLET = "key_handshake_wallet", e11.KEY_HANDSHAKE_NONE = "none";
}(Co3 || (Co3 = {}));
var Mo3 = class extends import_eventemitter2.EventEmitter2 {
  constructor({ communicationLayer: e11, otherPublicKey: t6, context: n5, ecies: r8, logging: i9 }) {
    super(), this.keysExchanged = false, this.step = Co3.KEY_HANDSHAKE_NONE, this.debug = false, this.context = n5, this.communicationLayer = e11, (null == r8 ? void 0 : r8.privateKey) && t6 && (oo3.KeyExchange(`[KeyExchange: constructor()] otherPubKey=${t6} set keysExchanged to true!`, r8), this.keysExchanged = true), this.myECIES = new uo3(Object.assign(Object.assign({}, r8), { debug: null == i9 ? void 0 : i9.eciesLayer })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = true === (null == i9 ? void 0 : i9.keyExchangeLayer), t6 && this.setOtherPublicKey(t6), this.communicationLayer.on(_o3.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));
  }
  onKeyExchangeMessage(e11) {
    const { relayPersistence: t6 } = this.communicationLayer.remote.state;
    if (oo3.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged} relayPersistence=${t6}`, e11), t6) return void oo3.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated");
    const { message: n5 } = e11;
    this.keysExchanged && oo3.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`), this.emit(So3.KEY_INFO, n5.type), n5.type === Co3.KEY_HANDSHAKE_SYN ? (this.checkStep([Co3.KEY_HANDSHAKE_NONE, Co3.KEY_HANDSHAKE_ACK]), oo3.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN", n5), n5.pubkey && this.setOtherPublicKey(n5.pubkey), this.communicationLayer.sendMessage({ type: Co3.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey }).catch((e12) => {
      oo3.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK", e12);
    }), this.setStep(Co3.KEY_HANDSHAKE_ACK)) : n5.type === Co3.KEY_HANDSHAKE_SYNACK ? (this.checkStep([Co3.KEY_HANDSHAKE_SYNACK, Co3.KEY_HANDSHAKE_ACK, Co3.KEY_HANDSHAKE_NONE]), oo3.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"), n5.pubkey && this.setOtherPublicKey(n5.pubkey), this.communicationLayer.sendMessage({ type: Co3.KEY_HANDSHAKE_ACK }).catch((e12) => {
      oo3.KeyExchange("[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK", e12);
    }), this.keysExchanged = true, this.setStep(Co3.KEY_HANDSHAKE_ACK), this.emit(So3.KEYS_EXCHANGED)) : n5.type === Co3.KEY_HANDSHAKE_ACK && (oo3.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"), this.checkStep([Co3.KEY_HANDSHAKE_ACK, Co3.KEY_HANDSHAKE_NONE]), this.keysExchanged = true, this.setStep(Co3.KEY_HANDSHAKE_ACK), this.emit(So3.KEYS_EXCHANGED));
  }
  resetKeys(e11) {
    this.clean(), this.myECIES = new uo3(e11);
  }
  clean() {
    oo3.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`), this.setStep(Co3.KEY_HANDSHAKE_NONE), this.emit(So3.KEY_INFO, this.step), this.keysExchanged = false;
  }
  start({ isOriginator: e11, force: t6 }) {
    const { relayPersistence: n5, protocolVersion: r8 } = this.communicationLayer.remote.state, i9 = r8 >= 2;
    n5 ? oo3.KeyExchange("[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated") : (oo3.KeyExchange(`[KeyExchange: start()] context=${this.context} protocolVersion=${r8} isOriginator=${e11} step=${this.step} force=${t6} relayPersistence=${n5} keysExchanged=${this.keysExchanged}`), e11 ? !(this.keysExchanged || this.step !== Co3.KEY_HANDSHAKE_NONE && this.step !== Co3.KEY_HANDSHAKE_SYNACK) || t6 ? (oo3.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t6}) -- step=${this.step}`, this.step), this.clean(), this.setStep(Co3.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({ type: Co3.KEY_HANDSHAKE_SYN, pubkey: this.myPublicKey, v: 2 }).catch((e12) => {
      oo3.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN", e12);
    })) : oo3.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged ? "done" : "in progress"} -- aborted.`, this.step) : this.keysExchanged && true !== t6 ? oo3.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.") : i9 ? this.communicationLayer.sendMessage({ type: Co3.KEY_HANDSHAKE_SYNACK, pubkey: this.myPublicKey, v: 2 }).catch((e12) => {
      oo3.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK", e12);
    }) : (this.communicationLayer.sendMessage({ type: Co3.KEY_HANDSHAKE_START }).catch((e12) => {
      oo3.KeyExchange("[KeyExchange: start()] Error sending KEY_HANDSHAKE_START", e12);
    }), this.clean()));
  }
  setStep(e11) {
    this.step = e11, this.emit(So3.KEY_INFO, e11);
  }
  checkStep(e11) {
    e11.length > 0 && e11.indexOf(this.step.toString());
  }
  setRelayPersistence({ localKey: e11, otherKey: t6 }) {
    this.otherPublicKey = t6, this.myECIES = new uo3({ privateKey: e11, debug: this.debug }), this.keysExchanged = true;
  }
  setKeysExchanged(e11) {
    this.keysExchanged = e11;
  }
  areKeysExchanged() {
    return this.keysExchanged;
  }
  getMyPublicKey() {
    return this.myPublicKey;
  }
  getOtherPublicKey() {
    return this.otherPublicKey;
  }
  setOtherPublicKey(e11) {
    oo3.KeyExchange("[KeyExchange: setOtherPubKey()]", e11), this.otherPublicKey = e11;
  }
  encryptMessage(e11) {
    if (!this.otherPublicKey) throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.encrypt(e11, this.otherPublicKey);
  }
  decryptMessage(e11) {
    if (!this.otherPublicKey) throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");
    return this.myECIES.decrypt(e11);
  }
  getKeyInfo() {
    return { ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), { otherPubKey: this.otherPublicKey }), step: this.step, keysExchanged: this.areKeysExchanged() };
  }
  toString() {
    const e11 = { keyInfo: this.getKeyInfo(), keysExchanged: this.keysExchanged, step: this.step };
    return JSON.stringify(e11);
  }
};
!function(e11) {
  e11.TERMINATE = "terminate", e11.ANSWER = "answer", e11.OFFER = "offer", e11.CANDIDATE = "candidate", e11.JSONRPC = "jsonrpc", e11.WALLET_INFO = "wallet_info", e11.WALLET_INIT = "wallet_init", e11.ORIGINATOR_INFO = "originator_info", e11.PAUSE = "pause", e11.OTP = "otp", e11.AUTHORIZED = "authorized", e11.PING = "ping", e11.READY = "ready";
}(ko3 || (ko3 = {})), function(e11) {
  e11.REQUEST = "sdk_connect_request_started", e11.REQUEST_MOBILE = "sdk_connect_request_started_mobile", e11.RECONNECT = "sdk_reconnect_request_started", e11.CONNECTED = "sdk_connection_established", e11.CONNECTED_MOBILE = "sdk_connection_established_mobile", e11.AUTHORIZED = "sdk_connection_authorized", e11.REJECTED = "sdk_connection_rejected", e11.TERMINATED = "sdk_connection_terminated", e11.DISCONNECTED = "sdk_disconnected", e11.SDK_USE_EXTENSION = "sdk_use_extension", e11.SDK_RPC_REQUEST = "sdk_rpc_request", e11.SDK_RPC_REQUEST_RECEIVED = "sdk_rpc_request_received", e11.SDK_RPC_REQUEST_DONE = "sdk_rpc_request_done", e11.SDK_EXTENSION_UTILIZED = "sdk_extension_utilized", e11.SDK_USE_INAPP_BROWSER = "sdk_use_inapp_browser";
}(Ao3 || (Ao3 = {}));
var Io3 = (e11, t6, n5) => c8(void 0, void 0, void 0, function* () {
  var r8, i9, o6, s5, a6, c9;
  const { remote: l9, state: d7 } = e11, { channelId: u10, isOriginator: h9 } = d7;
  if ("error_terminated" === t6) return oo3.SocketService(`handleJoinChannelResults: Channel ${u10} terminated`), void e11.emit(So3.TERMINATE);
  if (!n5) return void oo3.SocketService(`handleJoinChannelResults: No result for channel ${u10}`);
  const { persistence: f16, walletKey: p9, rejected: g4 } = n5;
  if (oo3.SocketService(`handleJoinChannelResults: Channel ${u10} persistence=${f16} walletKey=${p9} rejected=${g4}`), g4) return oo3.SocketService(`handleJoinChannelResults: Channel ${u10} rejected`), yield e11.remote.disconnect({ terminate: true }), e11.remote.emit(So3.REJECTED, { channelId: u10 }), void e11.remote.emitServiceStatusEvent();
  if (p9 && !(null === (r8 = l9.state.channelConfig) || void 0 === r8 ? void 0 : r8.otherKey)) {
    e11.getKeyExchange().setOtherPublicKey(p9), null === (i9 = e11.state.keyExchange) || void 0 === i9 || i9.setKeysExchanged(true), l9.state.ready = true, l9.state.authorized = true, l9.emit(So3.AUTHORIZED);
    const { communicationLayer: t7, storageManager: n6 } = l9.state, r9 = Object.assign(Object.assign({}, l9.state.channelConfig), { channelId: null !== (o6 = l9.state.channelId) && void 0 !== o6 ? o6 : "", validUntil: Date.now() + go3, localKey: null == t7 ? void 0 : t7.getKeyInfo().ecies.private, otherKey: p9 });
    e11.sendMessage({ type: Co3.KEY_HANDSHAKE_ACK }).catch((e12) => {
    }), null === (s5 = e11.state.socket) || void 0 === s5 || s5.emit(ko3.PING, { id: u10, clientType: h9 ? "dapp" : "wallet", context: "on_channel_reconnect", message: "" }), yield null == n6 ? void 0 : n6.persistChannelConfig(r9), l9.emitServiceStatusEvent(), l9.setConnectionStatus(Eo3.LINKED);
  }
  f16 && (e11.emit(So3.CHANNEL_PERSISTENCE), null === (a6 = e11.state.keyExchange) || void 0 === a6 || a6.setKeysExchanged(true), l9.state.ready = true, l9.state.authorized = true, l9.emit(So3.AUTHORIZED), lo3(Object.assign(Object.assign({ id: null != u10 ? u10 : "", event: h9 ? Ao3.CONNECTED : Ao3.CONNECTED_MOBILE }, e11.remote.state.originatorInfo), { sdkVersion: e11.remote.state.sdkVersion, commLayer: e11.state.communicationLayerPreference, commLayerVersion: ho3.version, walletVersion: null === (c9 = e11.remote.state.walletInfo) || void 0 === c9 ? void 0 : c9.version }), d7.communicationServerUrl).catch((e12) => {
  }));
});
var To3 = (e11) => new Promise((t6) => {
  setTimeout(t6, e11);
});
var Ro3 = (e11, t6, ...n5) => c8(void 0, [e11, t6, ...n5], void 0, function* (e12, t7, n6 = 200) {
  let r8;
  const i9 = Date.now();
  let o6 = false;
  for (; !o6; ) {
    if (o6 = Date.now() - i9 > 3e5, r8 = t7[e12], void 0 !== r8.elapsedTime) return r8;
    yield To3(n6);
  }
  throw new Error(`RPC ${e12} timed out`);
});
var Po4 = (e11) => c8(void 0, void 0, void 0, function* () {
  const { state: t6 } = e11, { socket: n5, channelId: r8, context: i9, isOriginator: o6, isReconnecting: s5 } = t6;
  if (s5) return oo3.SocketService("[SocketService: reconnectSocket()] Reconnection already in progress, skipping", e11), false;
  if (!n5) return oo3.SocketService("[SocketService: reconnectSocket()] socket is not defined", e11), false;
  if (!r8) return false;
  const { connected: a6 } = n5;
  t6.isReconnecting = true, t6.reconnectionAttempts = 0, oo3.SocketService(`[SocketService: reconnectSocket()] connected=${a6} trying to reconnect after socketio disconnection`, e11);
  try {
    for (; 3 > t6.reconnectionAttempts; ) {
      if (oo3.SocketService(`[SocketService: reconnectSocket()] Attempt ${t6.reconnectionAttempts + 1} of 3`, e11), yield To3(200), n5.connected) return oo3.SocketService("Socket already connected --- ping to retrieve messages"), n5.emit(ko3.PING, { id: r8, clientType: o6 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), true;
      t6.resumed = true, n5.connect(), e11.emit(So3.SOCKET_RECONNECT);
      try {
        if (yield new Promise((t7, s6) => {
          n5.emit(So3.JOIN_CHANNEL, { channelId: r8, context: `${i9}connect_again`, clientType: o6 ? "dapp" : "wallet" }, (n6, r9) => c8(void 0, void 0, void 0, function* () {
            try {
              yield Io3(e11, n6, r9), t7();
            } catch (e12) {
              s6(e12);
            }
          }));
        }), yield To3(100), n5.connected) return oo3.SocketService(`Reconnection successful on attempt ${t6.reconnectionAttempts + 1}`), true;
      } catch (e12) {
        oo3.SocketService(`Error during reconnection attempt ${t6.reconnectionAttempts + 1}:`, e12);
      }
      t6.reconnectionAttempts += 1, 3 > t6.reconnectionAttempts && (yield To3(200));
    }
    return oo3.SocketService("Failed to reconnect after 3 attempts"), false;
  } finally {
    t6.isReconnecting = false, t6.reconnectionAttempts = 0;
  }
});
function Oo3(e11, t6) {
  return c8(this, void 0, void 0, function* () {
    var n5;
    const r8 = null === (n5 = e11.state.keyExchange) || void 0 === n5 ? void 0 : n5.encryptMessage(JSON.stringify(t6)), i9 = { id: e11.state.channelId, context: e11.state.context, clientType: e11.state.isOriginator ? "dapp" : "wallet", message: r8, plaintext: e11.state.hasPlaintext ? JSON.stringify(t6) : void 0 };
    return oo3.SocketService(`[SocketService: encryptAndSendMessage()] context=${e11.state.context}`, i9), t6.type === ko3.TERMINATE && (e11.state.manualDisconnect = true), new Promise((t7, n6) => {
      var r9;
      null === (r9 = e11.state.socket) || void 0 === r9 || r9.emit(So3.MESSAGE, i9, (e12, r10) => {
        var i10;
        e12 && (oo3.SocketService(`[SocketService: encryptAndSendMessage()] error=${e12}`), n6(e12)), oo3.SocketService("[encryptAndSendMessage] response", r10), t7(null !== (i10 = null == r10 ? void 0 : r10.success) && void 0 !== i10 && i10);
      });
    });
  });
}
var No3;
!function(e11) {
  e11.RPC_CHECK = "rpcCheck", e11.SKIPPED_RPC = "skippedRpc";
}(No3 || (No3 = {}));
var Lo3 = ["eth_sendTransaction", "eth_signTypedData", "eth_signTransaction", "personal_sign", "wallet_requestPermissions", "wallet_switchEthereumChain", "eth_signTypedData_v3", "eth_signTypedData_v4", "metamask_connectSign", "metamask_connectWith", "metamask_batch"].map((e11) => e11.toLowerCase());
var Do22 = [{ event: So3.CLIENTS_CONNECTED, handler: function(e11, t6) {
  return (n5) => c8(this, void 0, void 0, function* () {
    var n6, r8, i9, o6, s5, a6, c9, l9, d7, u10, h9;
    const f16 = null !== (r8 = null === (n6 = e11.remote.state.channelConfig) || void 0 === n6 ? void 0 : n6.relayPersistence) && void 0 !== r8 && r8;
    if (oo3.SocketService(`[SocketService: handleClientsConnected()] context=${e11.state.context} on 'clients_connected-${t6}' relayPersistence=${f16} resumed=${e11.state.resumed}  clientsPaused=${e11.state.clientsPaused} keysExchanged=${null === (i9 = e11.state.keyExchange) || void 0 === i9 ? void 0 : i9.areKeysExchanged()} isOriginator=${e11.state.isOriginator}`), e11.emit(So3.CLIENTS_CONNECTED, { isOriginator: e11.state.isOriginator, keysExchanged: null === (o6 = e11.state.keyExchange) || void 0 === o6 ? void 0 : o6.areKeysExchanged(), context: e11.state.context }), e11.state.resumed) e11.state.isOriginator || (oo3.SocketService(`[SocketService: handleClientsConnected()] context=${e11.state.context} 'clients_connected' / keysExchanged=${null === (s5 = e11.state.keyExchange) || void 0 === s5 ? void 0 : s5.areKeysExchanged()} -- backward compatibility`), null === (a6 = e11.state.keyExchange) || void 0 === a6 || a6.start({ isOriginator: null !== (c9 = e11.state.isOriginator) && void 0 !== c9 && c9 })), e11.state.resumed = false;
    else if (e11.state.clientsPaused) oo3.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause");
    else if (!e11.state.isOriginator) {
      const t7 = !f16;
      oo3.SocketService(`[SocketService: handleClientsConnected()] context=${e11.state.context} on 'clients_connected' / keysExchanged=${null === (l9 = e11.state.keyExchange) || void 0 === l9 ? void 0 : l9.areKeysExchanged()} -- force=${t7} -- backward compatibility`), oo3.SocketService(`[SocketService: handleClientsConnected()] context=${e11.state.context} on 'clients_connected' / keysExchanged=${null === (d7 = e11.state.keyExchange) || void 0 === d7 ? void 0 : d7.areKeysExchanged()} -- force=${t7} -- backward compatibility`), null === (u10 = e11.state.keyExchange) || void 0 === u10 || u10.start({ isOriginator: null !== (h9 = e11.state.isOriginator) && void 0 !== h9 && h9, force: t7 });
    }
    e11.state.clientsConnected = true, e11.state.clientsPaused = false;
  });
} }, { event: So3.CHANNEL_CREATED, handler: function(e11, t6) {
  return (n5) => {
    oo3.SocketService(`[SocketService: handleChannelCreated()] context=${e11.state.context} on 'channel_created-${t6}'`, n5), e11.emit(So3.CHANNEL_CREATED, n5);
  };
} }, { event: So3.CLIENTS_DISCONNECTED, handler: function(e11, t6) {
  return () => {
    var n5;
    e11.state.clientsConnected = false, oo3.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e11.state.context} on 'clients_disconnected-${t6}'`), e11.remote.state.relayPersistence ? oo3.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e11.state.context} on 'clients_disconnected-${t6}' - relayPersistence enabled, skipping key exchange cleanup.`) : (e11.state.isOriginator && !e11.state.clientsPaused && (null === (n5 = e11.state.keyExchange) || void 0 === n5 || n5.clean()), e11.emit(So3.CLIENTS_DISCONNECTED, t6));
  };
} }, { event: So3.CONFIG, handler: function(e11, t6) {
  return (n5) => c8(this, void 0, void 0, function* () {
    var r8, i9, o6;
    oo3.SocketService(`[SocketService: handleChannelConfig()] update relayPersistence on 'config-${t6}'`, n5);
    const { persistence: s5, walletKey: a6 } = n5;
    e11.state.isOriginator && e11.remote.state.channelConfig ? (n5.walletKey && !e11.remote.state.channelConfig.otherKey && (oo3.SocketService(`Setting wallet key ${a6}`), e11.remote.state.channelConfig.otherKey = a6, e11.getKeyExchange().setOtherPublicKey(n5.walletKey), null === (r8 = e11.state.keyExchange) || void 0 === r8 || r8.setKeysExchanged(true), yield e11.remote.sendMessage({ type: Co3.KEY_HANDSHAKE_ACK }), yield e11.remote.sendMessage({ type: ko3.PING }), yield null === (i9 = e11.remote.state.storageManager) || void 0 === i9 ? void 0 : i9.persistChannelConfig(e11.remote.state.channelConfig)), true !== s5 || e11.remote.state.channelConfig.relayPersistence || (oo3.SocketService(`Setting relay persistence ${s5}`), e11.remote.state.channelConfig.relayPersistence = s5, e11.remote.state.relayPersistence = true, e11.remote.emit(So3.CHANNEL_PERSISTENCE), e11.remote.state.authorized = true, e11.remote.state.ready = true, e11.remote.emit(So3.AUTHORIZED), yield null === (o6 = e11.remote.state.storageManager) || void 0 === o6 ? void 0 : o6.persistChannelConfig(e11.remote.state.channelConfig))) : e11.state.isOriginator || n5.persistence && (e11.remote.state.relayPersistence = true, e11.remote.emit(So3.CHANNEL_PERSISTENCE));
  });
} }, { event: So3.MESSAGE, handler: function(e11, t6) {
  return (r8) => {
    var i9, o6, s5, a6, c9, l9, d7, u10, h9, f16, p9, g4, m6, y11, v9, b6, w8, E8;
    const { ackId: S8, message: _6, error: C10 } = r8, k11 = null !== (i9 = e11.remote.state.relayPersistence) && void 0 !== i9 && i9;
    if (oo3.SocketService(`[SocketService handleMessage()]  relayPersistence=${k11}  context=${e11.state.context} on 'message' ${t6} keysExchanged=${null === (o6 = e11.state.keyExchange) || void 0 === o6 ? void 0 : o6.areKeysExchanged()}`, r8), C10) throw oo3.SocketService(`
      [SocketService handleMessage()] context=${e11.state.context}::on 'message' error=${C10}`), new Error(C10);
    const A9 = "string" == typeof _6;
    if (!A9 && (null == _6 ? void 0 : _6.type) === Co3.KEY_HANDSHAKE_START) {
      if (k11) return;
      return oo3.SocketService(`[SocketService handleMessage()] context=${e11.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e11.state.isOriginator}`, _6), void (null === (s5 = e11.state.keyExchange) || void 0 === s5 || s5.start({ isOriginator: null !== (a6 = e11.state.isOriginator) && void 0 !== a6 && a6, force: true }));
    }
    if (!A9 && (null === (c9 = null == _6 ? void 0 : _6.type) || void 0 === c9 ? void 0 : c9.startsWith("key_handshake"))) {
      if (k11) return;
      return oo3.SocketService(`[SocketService handleMessage()] context=${e11.state.context}::on 'message' emit KEY_EXCHANGE`, _6), void e11.emit(_o3.KEY_EXCHANGE, { message: _6, context: e11.state.context });
    }
    if (A9 && !(null === (l9 = e11.state.keyExchange) || void 0 === l9 ? void 0 : l9.areKeysExchanged())) {
      let t7 = false;
      try {
        oo3.SocketService(`[SocketService handleMessage()] context=${e11.state.context}::on 'message' trying to decrypt message`), null === (d7 = e11.state.keyExchange) || void 0 === d7 || d7.decryptMessage(_6), t7 = true;
      } catch (t8) {
        oo3.SocketService(`[SocketService handleMessage()] context=${e11.state.context}::on 'message' error`, t8);
      }
      if (!t7) return e11.state.isOriginator ? null === (h9 = e11.state.keyExchange) || void 0 === h9 || h9.start({ isOriginator: null !== (f16 = e11.state.isOriginator) && void 0 !== f16 && f16 }) : e11.sendMessage({ type: Co3.KEY_HANDSHAKE_START }).catch((e12) => {
      }), void oo3.SocketService(`Message ignored because invalid key exchange status. step=${null === (p9 = e11.state.keyExchange) || void 0 === p9 ? void 0 : p9.getKeyInfo().step}`, null === (g4 = e11.state.keyExchange) || void 0 === g4 ? void 0 : g4.getKeyInfo(), _6);
      oo3.SocketService("Invalid key exchange status detected --- updating it."), null === (u10 = e11.state.keyExchange) || void 0 === u10 || u10.setKeysExchanged(true);
    } else if (!A9 && (null == _6 ? void 0 : _6.type)) return void e11.emit(So3.MESSAGE, _6);
    if (!A9) return void e11.emit(So3.MESSAGE, _6);
    const x7 = null === (m6 = e11.state.keyExchange) || void 0 === m6 ? void 0 : m6.decryptMessage(_6), M8 = JSON.parse(null != x7 ? x7 : "{}");
    if (S8 && (null == S8 ? void 0 : S8.length) > 0 && (oo3.SocketService(`[SocketService handleMessage()] context=${e11.state.context}::on 'message' ackid=${S8} channelId=${t6}`), null === (y11 = e11.state.socket) || void 0 === y11 || y11.emit(So3.MESSAGE_ACK, { ackId: S8, channelId: t6, clientType: e11.state.isOriginator ? "dapp" : "wallet" })), e11.state.clientsPaused = (null == M8 ? void 0 : M8.type) === ko3.PAUSE, e11.state.isOriginator && M8.data) {
      const t7 = M8.data, r9 = e11.state.rpcMethodTracker[t7.id];
      if (r9) {
        const i10 = Date.now() - r9.timestamp;
        oo3.SocketService(`[SocketService handleMessage()] context=${e11.state.context}::on 'message' received answer for id=${t7.id} method=${r9.method} responseTime=${i10}`, M8), e11.remote.state.analytics && Lo3.includes(r9.method.toLowerCase()) && lo3(Object.assign(Object.assign({ id: null !== (v9 = e11.remote.state.channelId) && void 0 !== v9 ? v9 : "", event: Ao3.SDK_RPC_REQUEST_DONE, sdkVersion: e11.remote.state.sdkVersion, commLayerVersion: ho3.version }, e11.remote.state.originatorInfo), { walletVersion: null === (b6 = e11.remote.state.walletInfo) || void 0 === b6 ? void 0 : b6.version, params: { method: r9.method, from: "mobile" } }), e11.remote.state.communicationServerUrl).catch((e12) => {
        }), bo3(r9.method) && import_sdk_analytics.analytics.track(t7.error ? 4001 === t7.error.code ? "sdk_action_rejected" : "sdk_action_failed" : "sdk_action_succeeded", { action: r9.method });
        const o7 = Object.assign(Object.assign({}, r9), { result: t7.result, error: t7.error ? { code: null === (w8 = t7.error) || void 0 === w8 ? void 0 : w8.code, message: null === (E8 = t7.error) || void 0 === E8 ? void 0 : E8.message } : void 0, elapsedTime: i10 });
        e11.state.rpcMethodTracker[t7.id] = o7, e11.emit(So3.RPC_UPDATE, o7);
      }
    }
    e11.emit(So3.MESSAGE, { message: M8 });
  };
} }, { event: So3.REJECTED, handler: function(e11, t6) {
  return (r8) => c8(this, void 0, void 0, function* () {
    var r9;
    e11.state.isOriginator && !e11.remote.state.ready ? (oo3.SocketService(`[SocketService: handleChannelRejected()] context=${e11.state.context} channelId=${t6} isOriginator=${e11.state.isOriginator} ready=${e11.remote.state.ready}`, e11.remote.state.originatorInfo), lo3(Object.assign(Object.assign({ id: t6, event: Ao3.REJECTED }, e11.remote.state.originatorInfo), { sdkVersion: e11.remote.state.sdkVersion, commLayer: e11.state.communicationLayerPreference, commLayerVersion: ho3.version, walletVersion: null === (r9 = e11.remote.state.walletInfo) || void 0 === r9 ? void 0 : r9.version }), e11.remote.state.communicationServerUrl).catch((e12) => {
    }), import_sdk_analytics.analytics.track("sdk_connection_rejected", { transport_type: "websocket" }), yield e11.remote.disconnect({ terminate: true }), e11.remote.emit(So3.REJECTED, { channelId: t6 }), e11.remote.setConnectionStatus(Eo3.DISCONNECTED)) : oo3.SocketService(`[SocketService: handleChannelRejected()] SKIP -- channelId=${t6} isOriginator=${e11.state.isOriginator} ready=${e11.remote.state.ready}`);
  });
} }, { event: "clients_waiting_to_join", handler: function(e11, t6) {
  return (n5) => {
    oo3.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e11.state.context} on 'clients_waiting_to_join-${t6}'`, n5), e11.emit(So3.CLIENTS_WAITING, n5);
  };
} }];
var $o3 = [{ event: So3.KEY_INFO, handler: function(e11) {
  return (t6) => {
    oo3.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'", t6), e11.emit(So3.KEY_INFO, t6);
  };
} }, { event: So3.KEYS_EXCHANGED, handler: function(e11) {
  return () => {
    var t6, n5, r8;
    oo3.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null === (t6 = e11.state.keyExchange) || void 0 === t6 ? void 0 : t6.areKeysExchanged()}`);
    const { channelConfig: i9 } = e11.remote.state;
    if (i9) {
      const t7 = e11.getKeyExchange().getKeyInfo().ecies;
      i9.localKey = t7.private, i9.otherKey = t7.otherPubKey, e11.remote.state.channelConfig = i9, null === (n5 = e11.remote.state.storageManager) || void 0 === n5 || n5.persistChannelConfig(i9).catch((e12) => {
      });
    }
    e11.emit(So3.KEYS_EXCHANGED, { keysExchanged: null === (r8 = e11.state.keyExchange) || void 0 === r8 ? void 0 : r8.areKeysExchanged(), isOriginator: e11.state.isOriginator });
    const o6 = { keyInfo: e11.getKeyInfo() };
    e11.emit(So3.SERVICE_STATUS, o6);
  };
} }];
function Bo3(e11, t6) {
  oo3.SocketService(`[SocketService: setupChannelListener()] context=${e11.state.context} setting socket listeners for channel ${t6}...`);
  const { socket: n5 } = e11.state, { keyExchange: r8 } = e11.state;
  n5 && e11.state.isOriginator && (e11.state.debug && (null == n5 || n5.io.on("error", (t7) => {
    oo3.SocketService(`[SocketService: setupChannelListener()] context=${e11.state.context} socket event=error`, t7);
  }), null == n5 || n5.io.on("reconnect", (t7) => {
    oo3.SocketService(`[SocketService: setupChannelListener()] context=${e11.state.context} socket event=reconnect`, t7), Po4(e11).catch((e12) => {
    });
  }), null == n5 || n5.io.on("reconnect_error", (t7) => {
    oo3.SocketService(`[SocketService: setupChannelListener()] context=${e11.state.context} socket event=reconnect_error`, t7);
  }), null == n5 || n5.io.on("reconnect_failed", () => {
    oo3.SocketService(`[SocketService: setupChannelListener()] context=${e11.state.context} socket event=reconnect_failed`);
  })), null == n5 || n5.on("disconnect", (t7) => (oo3.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t7}' begin recovery...`), (/* @__PURE__ */ function(e12) {
    return (t8) => {
      oo3.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e12.state.manualDisconnect}`, t8), e12.state.manualDisconnect || (e12.emit(So3.SOCKET_DISCONNECTED), Po4(e12).catch((e13) => {
      }));
    };
  }(e11))(t7)))), Do22.forEach(({ event: r9, handler: i9 }) => {
    null == n5 || n5.on(`${r9}-${t6}`, i9(e11, t6));
  }), $o3.forEach(({ event: t7, handler: n6 }) => {
    null == r8 || r8.on(t7, n6(e11));
  }), e11.state.setupChannelListeners = true;
}
var Ko3 = class extends import_eventemitter2.EventEmitter2 {
  constructor(e11) {
    super(), this.state = { clientsConnected: false, clientsPaused: false, manualDisconnect: false, lastRpcId: void 0, rpcMethodTracker: {}, hasPlaintext: false, communicationServerUrl: "", focusListenerAdded: false, removeFocusListener: void 0, isReconnecting: false, reconnectionAttempts: 0 }, this.options = e11;
    const { reconnect: n5, communicationLayerPreference: r8, communicationServerUrl: i9, context: o6, remote: s5, logging: a6 } = e11;
    this.state.resumed = n5, this.state.context = o6, this.state.isOriginator = s5.state.isOriginator, this.state.communicationLayerPreference = r8, this.state.debug = true === (null == a6 ? void 0 : a6.serviceLayer), this.remote = s5, true === (null == a6 ? void 0 : a6.serviceLayer) && import_debug4.default.enable("SocketService:Layer"), this.state.communicationServerUrl = i9, this.state.hasPlaintext = this.state.communicationServerUrl !== fo3 && true === (null == a6 ? void 0 : a6.plaintext), oo3.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`), this.initSocket();
  }
  initSocket() {
    var e11;
    const { otherPublicKey: t6, ecies: n5, logging: r8 } = this.options, i9 = { autoConnect: false, transports: po3, withCredentials: true }, o6 = this.state.communicationServerUrl;
    oo3.SocketService(`[SocketService: initSocket()] Socket IO url: ${o6}`), this.state.socket = lookup5(o6, i9), function(e12) {
      if ("undefined" != typeof window && "undefined" != typeof document && (oo3.SocketService(`[SocketService: setupSocketFocusListener()] hasFocus=${document.hasFocus()}`, e12), !e12.state.focusListenerAdded)) {
        const t7 = () => {
          oo3.SocketService("Document has focus --- reconnecting socket"), Po4(e12).catch((e13) => {
          });
        };
        window.addEventListener("focus", t7), e12.state.focusListenerAdded = true, e12.state.removeFocusListener = () => {
          window.removeEventListener("focus", t7), e12.state.focusListenerAdded = false;
        };
      }
    }(this);
    const s5 = { communicationLayer: this, otherPublicKey: t6, sendPublicKey: false, context: null !== (e11 = this.state.context) && void 0 !== e11 ? e11 : "", ecies: n5, logging: r8 };
    this.state.keyExchange = new Mo3(s5);
  }
  resetKeys() {
    return oo3.SocketService("[SocketService: resetKeys()] Resetting keys."), void (null === (e11 = this.state.keyExchange) || void 0 === e11 || e11.resetKeys());
    var e11;
  }
  createChannel() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        return c8(this, void 0, void 0, function* () {
          var t6, n5, r8;
          if (oo3.SocketService(`[SocketService: createChannel()] context=${e11.state.context}`), e11.state.socket || e11.initSocket(), null === (t6 = e11.state.socket) || void 0 === t6 ? void 0 : t6.connected) throw new Error("socket already connected");
          null === (n5 = e11.state.socket) || void 0 === n5 || n5.connect(), e11.state.manualDisconnect = false, e11.state.isOriginator = true;
          const i9 = v4_default2();
          e11.state.channelId = i9, Bo3(e11, i9), yield new Promise((t7, n6) => {
            var r9;
            null === (r9 = e11.state.socket) || void 0 === r9 || r9.emit(So3.JOIN_CHANNEL, { channelId: i9, context: `${e11.state.context}createChannel`, clientType: "dapp" }, (r10, i10) => c8(this, void 0, void 0, function* () {
              try {
                yield Io3(e11, r10, i10), t7();
              } catch (e12) {
                n6(e12);
              }
            }));
          });
          const o6 = null === (r8 = e11.state.keyExchange) || void 0 === r8 ? void 0 : r8.getKeyInfo();
          return { channelId: i9, pubKey: (null == o6 ? void 0 : o6.ecies.public) || "", privKey: (null == o6 ? void 0 : o6.ecies.private) || "" };
        });
      }(this);
    });
  }
  connectToChannel({ channelId: e11, withKeyExchange: t6 = false, authorized: n5 }) {
    return function(e12) {
      return c8(this, arguments, void 0, function* ({ options: e13, instance: t7 }) {
        const { channelId: n6, authorized: r8, withKeyExchange: i9 } = e13, { state: o6, remote: s5 } = t7, { isOriginator: a6 = false, socket: l9, keyExchange: d7 } = o6, { channelConfig: u10 } = s5.state;
        if (null == l9 ? void 0 : l9.connected) throw new Error("socket already connected");
        if (a6 && (null == u10 ? void 0 : u10.relayPersistence)) {
          const { localKey: e14, otherKey: t8 } = u10;
          e14 && t8 && (null == d7 || d7.setRelayPersistence({ localKey: e14, otherKey: t8 }));
        }
        return Object.assign(o6, { manualDisconnect: false, withKeyExchange: i9, isOriginator: a6, channelId: n6 }), null == l9 || l9.connect(), Bo3(t7, n6), !a6 && r8 && (null == d7 || d7.setKeysExchanged(true), Object.assign(s5.state, { ready: true, authorized: true })), new Promise((e14) => {
          var i10;
          const s6 = null === (i10 = null == d7 ? void 0 : d7.getKeyInfo()) || void 0 === i10 ? void 0 : i10.ecies.public;
          null == l9 || l9.emit(So3.JOIN_CHANNEL, { channelId: n6, context: `${o6.context}_connectToChannel`, clientType: a6 ? "dapp" : "wallet", publicKey: r8 && !a6 ? s6 : void 0 }, (n7, r9) => c8(this, void 0, void 0, function* () {
            yield Io3(t7, n7, r9), e14();
          }));
        });
      });
    }({ options: { channelId: e11, withKeyExchange: t6, authorized: n5 }, instance: this });
  }
  getKeyInfo() {
    return this.state.keyExchange.getKeyInfo();
  }
  keyCheck() {
    var e11, t6;
    null === (t6 = (e11 = this).state.socket) || void 0 === t6 || t6.emit(So3.MESSAGE, { id: e11.state.channelId, context: e11.state.context, message: { type: Co3.KEY_HANDSHAKE_CHECK, pubkey: e11.getKeyInfo().ecies.otherPubKey } });
  }
  getKeyExchange() {
    return this.state.keyExchange;
  }
  sendMessage(e11) {
    return c8(this, void 0, void 0, function* () {
      return function(e12, t6) {
        return c8(this, void 0, void 0, function* () {
          var r8, i9, o6;
          if (!e12.state.channelId) throw oo3.SocketService("handleSendMessage: no channelId - Create a channel first"), new Error("Create a channel first");
          if (oo3.SocketService(`[SocketService: handleSendMessage()] context=${e12.state.context} areKeysExchanged=${null === (r8 = e12.state.keyExchange) || void 0 === r8 ? void 0 : r8.areKeysExchanged()}`, t6), null === (i9 = null == t6 ? void 0 : t6.type) || void 0 === i9 ? void 0 : i9.startsWith("key_handshake")) return function(e13, t7) {
            var n5;
            oo3.SocketService(`[SocketService: handleKeyHandshake()] context=${e13.state.context}`, t7), null === (n5 = e13.state.socket) || void 0 === n5 || n5.emit(So3.MESSAGE, { id: e13.state.channelId, context: e13.state.context, clientType: e13.state.isOriginator ? "dapp" : "wallet", message: t7 });
          }(e12, t6), true;
          !function(e13, t7) {
            var n5;
            if (!(null === (n5 = e13.state.keyExchange) || void 0 === n5 ? void 0 : n5.areKeysExchanged()) && !e13.remote.state.relayPersistence) throw oo3.SocketService(`[SocketService: validateKeyExchange()] context=${e13.state.context} ERROR keys not exchanged`, t7), new Error("Keys not exchanged BBB");
          }(e12, t6), function(e13, t7) {
            var n5;
            const r9 = null !== (n5 = null == t7 ? void 0 : t7.method) && void 0 !== n5 ? n5 : "", i10 = null == t7 ? void 0 : t7.id;
            e13.state.isOriginator && i10 && (e13.state.rpcMethodTracker[i10] = { id: i10, timestamp: Date.now(), method: r9 }, e13.emit(So3.RPC_UPDATE, e13.state.rpcMethodTracker[i10]));
          }(e12, t6);
          const s5 = yield Oo3(e12, t6);
          return e12.remote.state.analytics && e12.remote.state.isOriginator && t6.method && Lo3.includes(t6.method.toLowerCase()) && lo3({ id: null !== (o6 = e12.remote.state.channelId) && void 0 !== o6 ? o6 : "", event: Ao3.SDK_RPC_REQUEST, params: { method: t6.method, from: "mobile" } }, e12.remote.state.communicationServerUrl).catch((e13) => {
          }), e12.remote.state.isOriginator && t6.method && bo3(t6.method) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: t6.method }), function(e13, t7) {
            return c8(this, void 0, void 0, function* () {
              var n5;
              const r9 = null == t7 ? void 0 : t7.id, i10 = null !== (n5 = null == t7 ? void 0 : t7.method) && void 0 !== n5 ? n5 : "";
              if (e13.state.isOriginator && r9) try {
                const n6 = Ro3(r9, e13.state.rpcMethodTracker, 200).then((e14) => ({ type: No3.RPC_CHECK, result: e14 })), o7 = (() => c8(this, void 0, void 0, function* () {
                  const t8 = yield ((e14) => c8(void 0, [e14], void 0, function* ({ rpcId: e15, instance: t9 }) {
                    for (; t9.state.lastRpcId === e15 || void 0 === t9.state.lastRpcId; ) yield To3(200);
                    return t9.state.lastRpcId;
                  }))({ instance: e13, rpcId: r9 }), n7 = yield Ro3(t8, e13.state.rpcMethodTracker, 200);
                  return { type: No3.SKIPPED_RPC, result: n7 };
                }))(), s6 = yield Promise.race([n6, o7]);
                if (s6.type === No3.RPC_CHECK) {
                  const e14 = s6.result;
                  oo3.SocketService(`[SocketService:handleRpcReplies()] id=${t7.id} ${i10} ( ${e14.elapsedTime} ms)`, e14.result);
                } else {
                  if (s6.type !== No3.SKIPPED_RPC) throw new Error(`Error handling RPC replies for ${r9}`);
                  {
                    const t8 = Object.assign(Object.assign({}, e13.state.rpcMethodTracker[r9]), { error: new Error("SDK_CONNECTION_ISSUE") });
                    e13.emit(So3.RPC_UPDATE, t8);
                    const n7 = { data: Object.assign(Object.assign({}, t8), { jsonrpc: "2.0" }), name: "metamask-provider" };
                    e13.emit(So3.MESSAGE, { message: n7 });
                  }
                }
              } catch (e14) {
                throw e14;
              }
            });
          }(e12, t6).catch((e13) => {
          }), s5;
        });
      }(this, e11);
    });
  }
  ping() {
    return function(e11) {
      return c8(this, void 0, void 0, function* () {
        var t6, n5;
        oo3.SocketService(`[SocketService: ping()] context=${e11.state.context} originator=${e11.state.isOriginator} keysExchanged=${null === (t6 = e11.state.keyExchange) || void 0 === t6 ? void 0 : t6.areKeysExchanged()}`), null === (n5 = e11.state.socket) || void 0 === n5 || n5.emit(ko3.PING, { id: e11.state.channelId, context: "ping", clientType: e11.remote.state.isOriginator ? "dapp" : "wallet", message: "" });
      });
    }(this);
  }
  pause() {
    return function(e11) {
      return c8(this, void 0, void 0, function* () {
        var t6, n5;
        oo3.SocketService(`[SocketService: pause()] context=${e11.state.context}`), e11.state.manualDisconnect = true, (null === (t6 = e11.state.keyExchange) || void 0 === t6 ? void 0 : t6.areKeysExchanged()) && (yield e11.sendMessage({ type: ko3.PAUSE })), null === (n5 = e11.state.socket) || void 0 === n5 || n5.disconnect();
      });
    }(this);
  }
  isConnected() {
    var e11;
    return null === (e11 = this.state.socket) || void 0 === e11 ? void 0 : e11.connected;
  }
  resume() {
    return function(e11) {
      return c8(this, void 0, void 0, function* () {
        const { state: t6, remote: n5 } = e11, { socket: r8, channelId: i9, context: o6, keyExchange: s5, isOriginator: a6 } = t6, { isOriginator: l9 } = n5.state;
        if (oo3.SocketService(`[SocketService: resume()] channelId=${i9} context=${o6} connected=${null == r8 ? void 0 : r8.connected} manualDisconnect=${t6.manualDisconnect} resumed=${t6.resumed} keysExchanged=${null == s5 ? void 0 : s5.areKeysExchanged()}`), !i9) throw oo3.SocketService("[SocketService: resume()] channelId is not defined"), new Error("ChannelId is not defined");
        (null == r8 ? void 0 : r8.connected) ? (oo3.SocketService("[SocketService: resume()] already connected."), r8.emit(ko3.PING, { id: i9, clientType: l9 ? "dapp" : "wallet", context: "on_channel_config", message: "" }), n5.hasRelayPersistence() || (null == s5 ? void 0 : s5.areKeysExchanged()) || (a6 ? yield e11.sendMessage({ type: ko3.READY }) : null == s5 || s5.start({ isOriginator: false }))) : (null == r8 || r8.connect(), oo3.SocketService(`[SocketService: resume()] after connecting socket --> connected=${null == r8 ? void 0 : r8.connected}`), null == r8 || r8.emit(So3.JOIN_CHANNEL, { channelId: i9, context: `${o6}_resume`, clientType: l9 ? "dapp" : "wallet" }, (t7, n6) => c8(this, void 0, void 0, function* () {
          try {
            yield Io3(e11, t7, n6);
          } catch (e12) {
          }
        }))), t6.manualDisconnect = false, t6.resumed = true;
      });
    }(this);
  }
  getRPCMethodTracker() {
    return this.state.rpcMethodTracker;
  }
  disconnect(e11) {
    return function(e12, t6) {
      var n5, r8, i9, o6, s5;
      oo3.SocketService(`[SocketService: disconnect()] context=${e12.state.context}`, t6), (null == t6 ? void 0 : t6.terminate) && (null === (r8 = (n5 = e12.state).removeFocusListener) || void 0 === r8 || r8.call(n5), e12.state.channelId = t6.channelId, null === (i9 = e12.state.socket) || void 0 === i9 || i9.removeAllListeners(), null === (o6 = e12.state.keyExchange) || void 0 === o6 || o6.clean(), e12.remote.state.ready = false, e12.state.socket = void 0, e12.state.rpcMethodTracker = {}), e12.state.manualDisconnect = true, null === (s5 = e12.state.socket) || void 0 === s5 || s5.disconnect();
    }(this, e11);
  }
};
var jo3;
var Uo3;
var Ho3;
function Fo3(e11) {
  return () => c8(this, void 0, void 0, function* () {
    var t6, n5, r8;
    const { state: i9 } = e11;
    if (i9.authorized) return;
    yield (() => c8(this, void 0, void 0, function* () {
      for (; !i9.walletInfo; ) yield To3(500);
    }))();
    const o6 = "7.3".localeCompare((null === (t6 = i9.walletInfo) || void 0 === t6 ? void 0 : t6.version) || "");
    if (oo3.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null === (n5 = i9.walletInfo) || void 0 === n5 ? void 0 : n5.version} compareValue=${o6}`), 1 !== o6) return;
    const s5 = i9.platformType === Uo3.MobileWeb || i9.platformType === Uo3.ReactNative || i9.platformType === Uo3.MetaMaskMobileWebview;
    oo3.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i9.platformType} secure=${s5} channel=${i9.channelId} walletVersion=${null === (r8 = i9.walletInfo) || void 0 === r8 ? void 0 : r8.version}`), s5 && (i9.authorized = true, e11.emit(So3.AUTHORIZED));
  });
}
function zo3(e11) {
  return (t6) => {
    const { state: n5 } = e11;
    oo3.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n5.context} on 'channel_created' channelId=${t6}`), e11.emit(So3.CHANNEL_CREATED, t6);
  };
}
function qo3(e11, t6) {
  return () => {
    var r8, i9, o6, s5;
    const { state: a6 } = e11;
    oo3.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${a6.channelId} keysExchanged=${null === (i9 = null === (r8 = a6.communicationLayer) || void 0 === r8 ? void 0 : r8.getKeyInfo()) || void 0 === i9 ? void 0 : i9.keysExchanged}`), a6.analytics && lo3(Object.assign(Object.assign({ id: null !== (o6 = a6.channelId) && void 0 !== o6 ? o6 : "", event: a6.reconnection ? Ao3.RECONNECT : a6.isOriginator ? Ao3.REQUEST : Ao3.REQUEST_MOBILE }, a6.originatorInfo), { commLayer: t6, sdkVersion: a6.sdkVersion, walletVersion: null === (s5 = a6.walletInfo) || void 0 === s5 ? void 0 : s5.version, commLayerVersion: ho3.version }), a6.communicationServerUrl).catch((e12) => {
    }), a6.isOriginator && !a6.reconnection && import_sdk_analytics.analytics.track("sdk_connection_established", { transport_type: "websocket" }), a6.clientsConnected = true, a6.originatorInfoSent = false, e11.emit(So3.CLIENTS_CONNECTED);
  };
}
function Wo3(e11) {
  return (t6) => {
    const { state: n5 } = e11;
    oo3.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${n5.context} on 'clients_disconnected' channelId=${t6}`), n5.relayPersistence || (n5.clientsConnected = false, n5.ready = false, n5.authorized = false), e11.emit(So3.CLIENTS_DISCONNECTED, n5.channelId), e11.setConnectionStatus(Eo3.DISCONNECTED);
  };
}
function Vo3(e11) {
  return (t6) => {
    var n5;
    const { state: r8 } = e11;
    if (oo3.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${r8.context} on 'clients_waiting' numberUsers=${t6} ready=${r8.ready} autoStarted=${r8.originatorConnectStarted}`), e11.setConnectionStatus(Eo3.WAITING), e11.emit(So3.CLIENTS_WAITING, t6), r8.originatorConnectStarted) {
      oo3.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${r8.originatorConnectStarted} timeout`, r8.autoConnectOptions);
      const t7 = (null === (n5 = r8.autoConnectOptions) || void 0 === n5 ? void 0 : n5.timeout) || 3e3, i9 = setTimeout(() => {
        oo3.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t7}) terminate channelConfig`, r8.autoConnectOptions), r8.originatorConnectStarted = false, r8.ready || e11.setConnectionStatus(Eo3.TIMEOUT), clearTimeout(i9);
      }, t7);
    }
  };
}
function Go3(e11, t6) {
  return (n5) => {
    var r8, i9, o6, s5, a6, c9, l9, d7;
    const { state: u10 } = e11;
    if (oo3.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${u10.context} on commLayer.'keys_exchanged' channel=${u10.channelId}`, n5), null === (i9 = null === (r8 = u10.communicationLayer) || void 0 === r8 ? void 0 : r8.getKeyInfo()) || void 0 === i9 ? void 0 : i9.keysExchanged) {
      const t7 = Object.assign(Object.assign({}, u10.channelConfig), { channelId: null !== (o6 = u10.channelId) && void 0 !== o6 ? o6 : "", validUntil: (null === (s5 = u10.channelConfig) || void 0 === s5 ? void 0 : s5.validUntil) || go3, localKey: u10.communicationLayer.getKeyInfo().ecies.private, otherKey: u10.communicationLayer.getKeyInfo().ecies.otherPubKey });
      null === (a6 = u10.storageManager) || void 0 === a6 || a6.persistChannelConfig(t7).catch((e12) => {
      }), e11.setConnectionStatus(Eo3.LINKED);
    }
    !function(e12, t7) {
      var n6, r9, i10, o7, s6, a7, c10, l10;
      const { state: d8 } = e12;
      oo3.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${d8.channelId}`, t7);
      const u11 = Object.assign(Object.assign({}, d8.channelConfig), { channelId: null !== (n6 = d8.channelId) && void 0 !== n6 ? n6 : "", validUntil: null !== (i10 = null === (r9 = d8.channelConfig) || void 0 === r9 ? void 0 : r9.validUntil) && void 0 !== i10 ? i10 : 0, relayPersistence: d8.relayPersistence, localKey: null === (s6 = null === (o7 = d8.communicationLayer) || void 0 === o7 ? void 0 : o7.state.keyExchange) || void 0 === s6 ? void 0 : s6.getKeyInfo().ecies.private, otherKey: null === (c10 = null === (a7 = d8.communicationLayer) || void 0 === a7 ? void 0 : a7.state.keyExchange) || void 0 === c10 ? void 0 : c10.getKeyInfo().ecies.otherPubKey, lastActive: t7.getTime() });
      null === (l10 = d8.storageManager) || void 0 === l10 || l10.persistChannelConfig(u11);
    }(e11, /* @__PURE__ */ new Date()), u10.analytics && u10.channelId && lo3(Object.assign(Object.assign({ id: u10.channelId, event: n5.isOriginator ? Ao3.CONNECTED : Ao3.CONNECTED_MOBILE }, u10.originatorInfo), { sdkVersion: u10.sdkVersion, commLayer: t6, commLayerVersion: ho3.version, walletVersion: null === (c9 = u10.walletInfo) || void 0 === c9 ? void 0 : c9.version }), u10.communicationServerUrl).catch((e12) => {
    }), u10.isOriginator = n5.isOriginator, n5.isOriginator || (null === (l9 = u10.communicationLayer) || void 0 === l9 || l9.sendMessage({ type: ko3.READY }), u10.ready = true, u10.paused = false), n5.isOriginator && !u10.originatorInfoSent && (null === (d7 = u10.communicationLayer) || void 0 === d7 || d7.sendMessage({ type: ko3.ORIGINATOR_INFO, originatorInfo: u10.originatorInfo, originator: u10.originatorInfo }), u10.originatorInfoSent = true);
  };
}
function Yo3(e11) {
  return (t6) => {
    let n5 = t6;
    t6.message && (n5 = n5.message), function(e12, t7) {
      const { state: n6 } = t7;
      if (oo3.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n6.context} on 'message' typeof=${typeof e12}`, e12), t7.state.ready = true, n6.isOriginator || e12.type !== ko3.ORIGINATOR_INFO) if (n6.isOriginator && e12.type === ko3.WALLET_INFO) !function(e13, t8) {
        const { state: n7 } = e13;
        n7.walletInfo = t8.walletInfo, n7.paused = false;
      }(t7, e12);
      else {
        if (n6.isOriginator && e12.type === ko3.WALLET_INIT) (function(e13, t8) {
          return c8(this, void 0, void 0, function* () {
            var n7, r8, i9;
            const { state: o6 } = e13;
            if (o6.isOriginator) {
              const o7 = t8.data || {};
              if ("object" == typeof o7 && "accounts" in o7 && "chainId" in o7 && "walletKey" in o7) try {
                const { channelConfig: t9 } = e13.state;
                if (oo3.RemoteCommunication("WALLET_INIT: channelConfig", JSON.stringify(t9, null, 2)), t9) {
                  const s5 = o7.accounts, a6 = o7.chainId, c9 = o7.walletKey;
                  let l9, d7 = false;
                  "deeplinkProtocol" in o7 && (d7 = Boolean(o7.deeplinkProtocol), e13.state.deeplinkProtocolAvailable = d7), "walletVersion" in o7 && (l9 = o7.walletVersion), yield null === (n7 = e13.state.storageManager) || void 0 === n7 ? void 0 : n7.persistChannelConfig(Object.assign(Object.assign({}, t9), { otherKey: c9, walletVersion: l9, deeplinkProtocolAvailable: d7, relayPersistence: true })), yield null === (r8 = e13.state.storageManager) || void 0 === r8 ? void 0 : r8.persistAccounts(s5), yield null === (i9 = e13.state.storageManager) || void 0 === i9 ? void 0 : i9.persistChainId(a6);
                }
                e13.emit(So3.WALLET_INIT, { accounts: o7.accounts, chainId: o7.chainId });
              } catch (n8) {
              }
            }
          });
        })(t7, e12).catch((e13) => {
          oo3.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e13}`);
        });
        else if (e12.type === ko3.TERMINATE) (function(e13) {
          return c8(this, void 0, void 0, function* () {
            const { state: t8 } = e13;
            t8.isOriginator && (yield es2({ options: { terminate: true, sendMessage: false }, instance: e13 }), e13.emit(So3.TERMINATE));
          });
        })(t7).catch((e13) => {
          oo3.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] error=${e13}`);
        });
        else if (e12.type === ko3.PAUSE) !function(e13) {
          const { state: t8 } = e13;
          t8.paused = true, e13.setConnectionStatus(Eo3.PAUSED);
        }(t7);
        else if (e12.type === ko3.READY && n6.isOriginator) !function(e13) {
          const { state: t8 } = e13;
          e13.setConnectionStatus(Eo3.LINKED);
          const n7 = t8.paused;
          t8.paused = false, e13.emit(So3.CLIENTS_READY, { isOriginator: t8.isOriginator, walletInfo: t8.walletInfo }), n7 && (t8.authorized = true, e13.emit(So3.AUTHORIZED));
        }(t7);
        else {
          if (e12.type === ko3.OTP && n6.isOriginator) return void function(e13, t8) {
            var n7;
            const { state: r8 } = e13;
            e13.emit(So3.OTP, t8.otpAnswer), 1 === "6.6".localeCompare((null === (n7 = r8.walletInfo) || void 0 === n7 ? void 0 : n7.version) || "") && e13.emit(So3.SDK_RPC_CALL, { method: yo3.ETH_REQUESTACCOUNTS, params: [] });
          }(t7, e12);
          e12.type === ko3.AUTHORIZED && n6.isOriginator && function(e13) {
            const { state: t8 } = e13;
            t8.authorized = true, e13.emit(So3.AUTHORIZED);
          }(t7);
        }
        t7.emit(So3.MESSAGE, e12);
      }
      else !function(e13, t8) {
        var n7;
        const { state: r8 } = e13;
        null === (n7 = r8.communicationLayer) || void 0 === n7 || n7.sendMessage({ type: ko3.WALLET_INFO, walletInfo: r8.walletInfo }), r8.originatorInfo = t8.originatorInfo || t8.originator, e13.emit(So3.CLIENTS_READY, { isOriginator: r8.isOriginator, originatorInfo: r8.originatorInfo }), r8.paused = false;
      }(t7, e12);
    }(n5, e11);
  };
}
function Zo3(e11) {
  return () => {
    const { state: t6 } = e11;
    oo3.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"), t6.ready = false, t6.authorized = false, wo3(t6), e11.emitServiceStatusEvent({ context: "socket_reconnect" });
  };
}
function Jo3(e11) {
  return () => {
    const { state: t6 } = e11;
    oo3.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"), t6.ready = false;
  };
}
function Qo3(e11) {
  return () => c8(this, void 0, void 0, function* () {
    var t6, n5, r8, i9, o6, s5, a6;
    const { state: c9 } = e11;
    oo3.RemoteCommunication(`[RemoteCommunication: handleFullPersistenceEvent()] context=${c9.context}`), e11.state.ready = true, e11.state.clientsConnected = true, e11.state.authorized = true, e11.state.relayPersistence = true, null === (t6 = e11.state.communicationLayer) || void 0 === t6 || t6.getKeyExchange().setKeysExchanged(true), e11.emit(So3.KEYS_EXCHANGED, { keysExchanged: true, isOriginator: true }), e11.emit(So3.AUTHORIZED), e11.emit(So3.CLIENTS_READY), e11.emit(So3.CHANNEL_PERSISTENCE);
    try {
      c9.channelConfig = Object.assign(Object.assign({}, c9.channelConfig), { localKey: null === (n5 = c9.communicationLayer) || void 0 === n5 ? void 0 : n5.getKeyExchange().getKeyInfo().ecies.private, otherKey: null === (r8 = c9.communicationLayer) || void 0 === r8 ? void 0 : r8.getKeyExchange().getOtherPublicKey(), channelId: null !== (i9 = c9.channelId) && void 0 !== i9 ? i9 : "", validUntil: null !== (s5 = null === (o6 = c9.channelConfig) || void 0 === o6 ? void 0 : o6.validUntil) && void 0 !== s5 ? s5 : go3, relayPersistence: true }), yield null === (a6 = c9.storageManager) || void 0 === a6 ? void 0 : a6.persistChannelConfig(c9.channelConfig);
    } catch (t7) {
    }
  });
}
function Xo3({ communicationLayerPreference: e11, otherPublicKey: t6, reconnect: n5, ecies: r8, communicationServerUrl: i9 = fo3, instance: o6 }) {
  var s5, a6, c9, l9, d7, u10, h9, f16, p9, g4, m6;
  const { state: y11 } = o6;
  if (oo3.RemoteCommunication("[initCommunicationLayer()] ", JSON.stringify(y11, null, 2)), e11 !== jo3.SOCKET) throw new Error("Invalid communication protocol");
  y11.communicationLayer = new Ko3({ communicationLayerPreference: e11, otherPublicKey: t6, reconnect: n5, transports: y11.transports, communicationServerUrl: i9, context: y11.context, ecies: r8, logging: y11.logging, remote: o6 });
  let v9 = "undefined" != typeof document && document.URL || "", b6 = "undefined" != typeof document && document.title || "";
  (null === (s5 = y11.dappMetadata) || void 0 === s5 ? void 0 : s5.url) && (v9 = y11.dappMetadata.url), (null === (a6 = y11.dappMetadata) || void 0 === a6 ? void 0 : a6.name) && (b6 = y11.dappMetadata.name);
  const w8 = null !== (u10 = null !== (l9 = null === (c9 = y11.dappMetadata) || void 0 === c9 ? void 0 : c9.name) && void 0 !== l9 ? l9 : null === (d7 = y11.dappMetadata) || void 0 === d7 ? void 0 : d7.url) && void 0 !== u10 ? u10 : "N/A", E8 = "undefined" != typeof window && void 0 !== window.location && null !== (h9 = window.location.hostname) && void 0 !== h9 ? h9 : w8, S8 = { url: v9, title: b6, source: null === (f16 = y11.dappMetadata) || void 0 === f16 ? void 0 : f16.source, dappId: E8, anonId: y11.anonId, icon: (null === (p9 = y11.dappMetadata) || void 0 === p9 ? void 0 : p9.iconUrl) || (null === (g4 = y11.dappMetadata) || void 0 === g4 ? void 0 : g4.base64Icon), platform: y11.platformType, apiVersion: ho3.version, connector: null === (m6 = y11.dappMetadata) || void 0 === m6 ? void 0 : m6.connector };
  y11.originatorInfo = S8;
  const _6 = { [So3.AUTHORIZED]: Fo3(o6), [So3.MESSAGE]: Yo3(o6), [So3.CHANNEL_PERSISTENCE]: Qo3(o6), [So3.CLIENTS_CONNECTED]: qo3(o6, e11), [So3.KEYS_EXCHANGED]: Go3(o6, e11), [So3.SOCKET_DISCONNECTED]: Jo3(o6), [So3.SOCKET_RECONNECT]: Zo3(o6), [So3.CLIENTS_DISCONNECTED]: Wo3(o6), [So3.KEY_INFO]: () => {
  }, [So3.CHANNEL_CREATED]: zo3(o6), [So3.CLIENTS_WAITING]: Vo3(o6), [So3.RPC_UPDATE]: (e12) => {
    o6.emit(So3.RPC_UPDATE, e12);
  } };
  for (const [t7, n6] of Object.entries(_6)) try {
    y11.communicationLayer.on(t7, n6);
  } catch (e12) {
  }
}
function es2(e11) {
  return c8(this, arguments, void 0, function* ({ options: e12, instance: t6 }) {
    const { state: n5 } = t6;
    return oo3.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${n5.channelId}`, e12), new Promise((r8, i9) => {
      var o6, a6, c9, l9, d7, u10;
      (null == e12 ? void 0 : e12.terminate) ? (t6.state.ready && lo3({ id: null !== (o6 = t6.state.channelId) && void 0 !== o6 ? o6 : "", event: Ao3.TERMINATED }, t6.state.communicationServerUrl).catch((e13) => {
      }), n5.ready = false, n5.paused = false, null === (a6 = n5.storageManager) || void 0 === a6 || a6.terminate(null !== (c9 = n5.channelId) && void 0 !== c9 ? c9 : ""), t6.state.terminated = true, e12.sendMessage ? (null === (l9 = n5.communicationLayer) || void 0 === l9 ? void 0 : l9.getKeyInfo().keysExchanged) && t6.state.communicationLayer && Oo3(t6.state.communicationLayer, { type: ko3.TERMINATE }).then(() => {
        r8(true);
      }).catch((e13) => {
        i9(e13);
      }) : r8(true), n5.authorized = false, n5.relayPersistence = false, n5.channelId = v4_default2(), e12.channelId = n5.channelId, n5.channelConfig = void 0, n5.originatorConnectStarted = false, null === (d7 = n5.communicationLayer) || void 0 === d7 || d7.disconnect(e12), t6.setConnectionStatus(Eo3.TERMINATED)) : (null === (u10 = n5.communicationLayer) || void 0 === u10 || u10.disconnect(e12), t6.setConnectionStatus(Eo3.DISCONNECTED), r8(true));
    });
  });
}
(jo3 || (jo3 = {})).SOCKET = "socket", function(e11) {
  e11.NonBrowser = "nodejs", e11.MetaMaskMobileWebview = "in-app-browser", e11.DesktopWeb = "web-desktop", e11.MobileWeb = "web-mobile", e11.ReactNative = "react-native";
}(Uo3 || (Uo3 = {}));
var ts2 = class extends import_eventemitter2.EventEmitter2 {
  constructor(e11) {
    super(), this.state = { ready: false, anonId: "", authorized: false, isOriginator: false, terminated: false, protocolVersion: 1, paused: false, deeplinkProtocolAvailable: false, platformType: "metamask-mobile", analytics: false, reconnection: false, originatorInfoSent: false, communicationServerUrl: fo3, context: "", persist: false, clientsConnected: false, sessionDuration: go3, originatorConnectStarted: false, debug: false, _connectionStatus: Eo3.DISCONNECTED }, this._options = e11;
    const { anonId: n5, platformType: r8, communicationLayerPreference: i9, otherPublicKey: o6, reconnect: s5, walletInfo: a6, dappMetadata: c9, protocolVersion: l9, transports: d7, context: u10, relayPersistence: h9, ecies: f16, analytics: p9 = false, storage: g4, sdkVersion: m6, communicationServerUrl: y11 = fo3, logging: v9, autoConnect: b6 = { timeout: mo3 } } = e11;
    this.state.anonId = n5, this.state.otherPublicKey = o6, this.state.dappMetadata = c9, this.state.walletInfo = a6, this.state.transports = d7, this.state.platformType = r8, this.state.analytics = p9, this.state.protocolVersion = null != l9 ? l9 : 1, this.state.isOriginator = !o6, this.state.relayPersistence = h9, this.state.communicationServerUrl = y11, this.state.context = u10, this.state.terminated = false, this.state.sdkVersion = m6, this.setMaxListeners(50), this.setConnectionStatus(Eo3.DISCONNECTED), (null == g4 ? void 0 : g4.duration) && (this.state.sessionDuration = go3), this.state.storageOptions = g4, this.state.autoConnectOptions = b6, this.state.debug = true === (null == v9 ? void 0 : v9.remoteLayer), true === (null == v9 ? void 0 : v9.remoteLayer) && import_debug4.default.enable("RemoteCommunication:Layer"), true === (null == v9 ? void 0 : v9.serviceLayer) && import_debug4.default.enable("SocketService:Layer"), true === (null == v9 ? void 0 : v9.eciesLayer) && import_debug4.default.enable("ECIES:Layer"), true === (null == v9 ? void 0 : v9.keyExchangeLayer) && import_debug4.default.enable("KeyExchange:Layer"), this.state.logging = v9, (null == g4 ? void 0 : g4.storageManager) && (this.state.storageManager = g4.storageManager), oo3.RemoteCommunication(`[RemoteCommunication: constructor()] protocolVersion=${l9} relayPersistence=${h9} isOriginator=${this.state.isOriginator} communicationLayerPreference=${i9} otherPublicKey=${o6} reconnect=${s5}`), this.state.isOriginator || Xo3({ communicationLayerPreference: i9, otherPublicKey: o6, reconnect: s5, ecies: f16, communicationServerUrl: y11, instance: this }), this.emitServiceStatusEvent({ context: "constructor" });
  }
  initFromDappStorage() {
    return c8(this, void 0, void 0, function* () {
      var e11;
      if (this.state.storageManager) {
        const t6 = yield this.state.storageManager.getPersistedChannelConfig({});
        t6 && (this.state.channelConfig = t6, this.state.channelId = t6.channelId, this.state.deeplinkProtocolAvailable = null !== (e11 = t6.deeplinkProtocolAvailable) && void 0 !== e11 && e11, t6.relayPersistence && (this.state.authorized = true, this.state.ready = true, this.setConnectionStatus(Eo3.LINKED), yield this.connectToChannel({ channelId: t6.channelId })));
      }
      Xo3({ communicationLayerPreference: jo3.SOCKET, otherPublicKey: this.state.otherPublicKey, reconnect: this._options.reconnect, ecies: this._options.ecies, communicationServerUrl: this.state.communicationServerUrl, instance: this });
    });
  }
  originatorSessionConnect() {
    return c8(this, void 0, void 0, function* () {
      return yield function(e11) {
        return c8(this, void 0, void 0, function* () {
          var t6;
          const { state: n5 } = e11;
          if (!n5.storageManager) return void oo3.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");
          const r8 = yield n5.storageManager.getPersistedChannelConfig({});
          if (oo3.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${n5.originatorConnectStarted} channelConfig`, r8), null === (t6 = n5.communicationLayer) || void 0 === t6 ? void 0 : t6.isConnected()) return oo3.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"), r8;
          if (r8) {
            if (r8.validUntil > Date.now()) return n5.channelConfig = r8, n5.originatorConnectStarted = true, n5.channelId = null == r8 ? void 0 : r8.channelId, n5.reconnection = true, r8;
            oo3.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired");
          }
          n5.originatorConnectStarted = false;
        });
      }(this);
    });
  }
  generateChannelIdConnect() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        return c8(this, void 0, void 0, function* () {
          var t6, n5, r8, i9, o6, s5;
          if (!e11.communicationLayer) throw new Error("communication layer not initialized");
          if (e11.ready) throw new Error("Channel already connected");
          if (e11.channelId && (null === (t6 = e11.communicationLayer) || void 0 === t6 ? void 0 : t6.isConnected())) return e11.channelConfig = Object.assign(Object.assign({}, e11.channelConfig), { channelId: e11.channelId, validUntil: Date.now() + e11.sessionDuration }), null === (n5 = e11.storageManager) || void 0 === n5 || n5.persistChannelConfig(e11.channelConfig), { channelId: e11.channelId, privKey: null === (i9 = null === (r8 = e11.communicationLayer) || void 0 === r8 ? void 0 : r8.getKeyInfo()) || void 0 === i9 ? void 0 : i9.ecies.private, pubKey: null === (s5 = null === (o6 = e11.communicationLayer) || void 0 === o6 ? void 0 : o6.getKeyInfo()) || void 0 === s5 ? void 0 : s5.ecies.public };
          oo3.RemoteCommunication("[RemoteCommunication: generateChannelId()]");
          const a6 = yield e11.communicationLayer.createChannel();
          oo3.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created", a6);
          const c9 = Object.assign(Object.assign({}, e11.channelConfig), { channelId: a6.channelId, localKey: a6.privKey, validUntil: Date.now() + e11.sessionDuration });
          return e11.channelId = a6.channelId, e11.channelConfig = c9, { channelId: e11.channelId, pubKey: a6.pubKey, privKey: a6.privKey };
        });
      }(this.state);
    });
  }
  clean() {
    return wo3(this.state);
  }
  connectToChannel({ channelId: e11, withKeyExchange: t6, authorized: n5 }) {
    return function(e12) {
      return c8(this, arguments, void 0, function* ({ channelId: e13, withKeyExchange: t7, authorized: n6, state: r8 }) {
        var i9, s5, a6;
        if (!validate_default2(e13)) throw oo3.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r8.context} invalid channel channelId=${e13}`), new Error(`Invalid channel ${e13}`);
        if (oo3.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r8.context} channelId=${e13} withKeyExchange=${t7}`), null === (i9 = r8.communicationLayer) || void 0 === i9 ? void 0 : i9.isConnected()) return void oo3.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${r8.context} already connected - interrupt connection.`);
        r8.channelId = e13, yield null === (s5 = r8.communicationLayer) || void 0 === s5 ? void 0 : s5.connectToChannel({ channelId: e13, authorized: n6, withKeyExchange: t7 });
        const c9 = Object.assign(Object.assign({}, r8.channelConfig), { channelId: e13, validUntil: Date.now() + r8.sessionDuration });
        r8.channelConfig = c9, null === (a6 = r8.storageManager) || void 0 === a6 || a6.persistChannelConfig(c9);
      });
    }({ channelId: e11, authorized: n5, withKeyExchange: t6, state: this.state });
  }
  sendMessage(e11) {
    return c8(this, void 0, void 0, function* () {
      const t6 = this.state.isOriginator && e11.method && bo3(e11.method);
      t6 && import_sdk_analytics.analytics.track("sdk_action_requested", { action: e11.method });
      try {
        return yield function(e12, t7) {
          return c8(this, void 0, void 0, function* () {
            var n5, r8;
            const { state: i9 } = e12;
            oo3.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i9.context} paused=${i9.paused} ready=${i9.ready} relayPersistence=${i9.relayPersistence} authorized=${i9.authorized} socket=${null === (n5 = i9.communicationLayer) || void 0 === n5 ? void 0 : n5.isConnected()} clientsConnected=${i9.clientsConnected} status=${i9._connectionStatus}`, t7), i9.relayPersistence || i9.ready && (null === (r8 = i9.communicationLayer) || void 0 === r8 ? void 0 : r8.isConnected()) && i9.clientsConnected || (oo3.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i9.context}  SKIP message waiting for MM mobile readiness.`), yield new Promise((t8) => {
              e12.once(So3.CLIENTS_READY, t8);
            }), oo3.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i9.context}  AFTER SKIP / READY -- sending pending message`));
            try {
              const n6 = yield function(e13, t8) {
                return c8(this, void 0, void 0, function* () {
                  return new Promise((n7) => {
                    var r9;
                    const { state: i10 } = e13;
                    oo3.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i10.context} ready=${i10.ready} authorized=${i10.authorized} method=${t8.method}`), !i10.isOriginator || i10.authorized || i10.relayPersistence ? null === (r9 = i10.communicationLayer) || void 0 === r9 || r9.sendMessage(t8).then((e14) => {
                      n7(e14);
                    }).catch((e14) => {
                      n7(false);
                    }) : e13.once(So3.AUTHORIZED, () => {
                      var e14;
                      oo3.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${i10.context}  AFTER SKIP / AUTHORIZED -- sending pending message`), null === (e14 = i10.communicationLayer) || void 0 === e14 || e14.sendMessage(t8).then((e15) => {
                        n7(e15);
                      }).catch((e15) => {
                        n7(false);
                      });
                    });
                  });
                });
              }(e12, t7);
              return n6;
            } catch (e13) {
              throw e13;
            }
          });
        }(this, e11);
      } catch (r8) {
        throw t6 && import_sdk_analytics.analytics.track("sdk_action_failed", { action: e11.method }), r8;
      }
    });
  }
  testStorage() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        return c8(this, void 0, void 0, function* () {
          var t6;
          const n5 = yield null === (t6 = e11.storageManager) || void 0 === t6 ? void 0 : t6.getPersistedChannelConfig();
          oo3.RemoteCommunication("[RemoteCommunication: testStorage()] res", n5);
        });
      }(this.state);
    });
  }
  hasDeeplinkProtocol() {
    return this.state.deeplinkProtocolAvailable;
  }
  getChannelConfig() {
    return this.state.channelConfig;
  }
  isReady() {
    return this.state.ready;
  }
  isConnected() {
    var e11;
    return null === (e11 = this.state.communicationLayer) || void 0 === e11 ? void 0 : e11.isConnected();
  }
  isAuthorized() {
    return this.state.authorized;
  }
  isPaused() {
    return this.state.paused;
  }
  getCommunicationLayer() {
    return this.state.communicationLayer;
  }
  ping() {
    return c8(this, void 0, void 0, function* () {
      var e11;
      oo3.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`), yield null === (e11 = this.state.communicationLayer) || void 0 === e11 ? void 0 : e11.ping();
    });
  }
  testLogger() {
    oo3.RemoteCommunication(`testLogger() channel=${this.state.channelId}`), oo3.SocketService(`testLogger() channel=${this.state.channelId}`), oo3.Ecies(`testLogger() channel=${this.state.channelId}`), oo3.KeyExchange(`testLogger() channel=${this.state.channelId}`);
  }
  keyCheck() {
    var e11;
    oo3.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`), null === (e11 = this.state.communicationLayer) || void 0 === e11 || e11.keyCheck();
  }
  setConnectionStatus(e11) {
    this.state._connectionStatus !== e11 && (this.state._connectionStatus = e11, this.emit(So3.CONNECTION_STATUS, e11), this.emitServiceStatusEvent({ context: "setConnectionStatus" }));
  }
  emitServiceStatusEvent(e11 = {}) {
    this.emit(So3.SERVICE_STATUS, this.getServiceStatus());
  }
  getConnectionStatus() {
    return this.state._connectionStatus;
  }
  getServiceStatus() {
    return { originatorInfo: this.state.originatorInfo, keyInfo: this.getKeyInfo(), connectionStatus: this.state._connectionStatus, channelConfig: this.state.channelConfig, channelId: this.state.channelId };
  }
  getKeyInfo() {
    var e11;
    return null === (e11 = this.state.communicationLayer) || void 0 === e11 ? void 0 : e11.getKeyInfo();
  }
  resetKeys() {
    var e11;
    null === (e11 = this.state.communicationLayer) || void 0 === e11 || e11.resetKeys();
  }
  setOtherPublicKey(e11) {
    var t6;
    const n5 = null === (t6 = this.state.communicationLayer) || void 0 === t6 ? void 0 : t6.getKeyExchange();
    if (!n5) throw new Error("KeyExchange is not initialized.");
    n5.getOtherPublicKey() !== e11 && n5.setOtherPublicKey(e11);
  }
  pause() {
    return c8(this, void 0, void 0, function* () {
      var e11;
      oo3.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`), yield null === (e11 = this.state.communicationLayer) || void 0 === e11 ? void 0 : e11.pause(), this.setConnectionStatus(Eo3.PAUSED);
    });
  }
  getVersion() {
    return ho3.version;
  }
  hasRelayPersistence() {
    var e11;
    return null !== (e11 = this.state.relayPersistence) && void 0 !== e11 && e11;
  }
  resume() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        return c8(this, void 0, void 0, function* () {
          var t6;
          const { state: n5 } = e11;
          oo3.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n5.channelId}`), yield null === (t6 = n5.communicationLayer) || void 0 === t6 ? void 0 : t6.resume(), e11.setConnectionStatus(Eo3.LINKED);
        });
      }(this);
    });
  }
  encrypt(e11) {
    var t6, n5, r8;
    const i9 = null === (t6 = this.state.communicationLayer) || void 0 === t6 ? void 0 : t6.getKeyExchange(), o6 = null == i9 ? void 0 : i9.getOtherPublicKey();
    if (!o6) throw new Error("KeyExchange not completed");
    return null === (r8 = null === (n5 = this.state.communicationLayer) || void 0 === n5 ? void 0 : n5.state.eciesInstance) || void 0 === r8 ? void 0 : r8.encrypt(e11, o6);
  }
  decrypt(e11) {
    var t6, n5, r8;
    if (!(null === (t6 = this.state.communicationLayer) || void 0 === t6 ? void 0 : t6.state.eciesInstance)) throw new Error("ECIES instance is not initialized");
    return null === (r8 = null === (n5 = this.state.communicationLayer) || void 0 === n5 ? void 0 : n5.state.eciesInstance) || void 0 === r8 ? void 0 : r8.decrypt(e11);
  }
  getChannelId() {
    return this.state.channelId;
  }
  getRPCMethodTracker() {
    var e11;
    return null === (e11 = this.state.communicationLayer) || void 0 === e11 ? void 0 : e11.getRPCMethodTracker();
  }
  reject({ channelId: e11 }) {
    return function(e12) {
      return c8(this, arguments, void 0, function* ({ channelId: e13, state: t6 }) {
        var n5, r8, i9;
        if (!validate_default2(e13)) throw oo3.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${t6.context} invalid channel channelId=${e13}`), new Error(`Invalid channel ${e13}`);
        if (t6.isOriginator) return void oo3.RemoteCommunication(`[RemoteCommunication: reject()] context=${t6.context} isOriginator=${t6.isOriginator} channelId=${e13}`);
        const { socket: s5 } = null !== (r8 = null === (n5 = t6.communicationLayer) || void 0 === n5 ? void 0 : n5.state) && void 0 !== r8 ? r8 : {};
        (null == s5 ? void 0 : s5.connected) || (oo3.RemoteCommunication(`[RemoteCommunication: reject()] context=${t6.context} socket already connected`), null == s5 || s5.connect()), lo3(Object.assign(Object.assign({ id: e13, event: Ao3.REJECTED }, t6.originatorInfo), { sdkVersion: t6.sdkVersion, commLayerVersion: ho3.version, walletVersion: null === (i9 = t6.walletInfo) || void 0 === i9 ? void 0 : i9.version }), t6.communicationServerUrl).catch((e14) => {
        }), yield new Promise((n6, r9) => {
          null == s5 || s5.emit(So3.REJECTED, { channelId: e13 }, (e14, i10) => {
            oo3.RemoteCommunication(`[RemoteCommunication: reject()] context=${t6.context} socket=${null == s5 ? void 0 : s5.id}`, { error: e14, response: i10 }), e14 ? r9(e14) : n6(i10);
          });
        });
      });
    }({ channelId: e11, state: this.state });
  }
  disconnect(e11) {
    return c8(this, void 0, void 0, function* () {
      return es2({ options: e11, instance: this });
    });
  }
};
!function(e11) {
  e11.RENEW = "renew", e11.LINK = "link";
}(Ho3 || (Ho3 = {}));
var ns2 = "ERC721";
var rs2 = "ERC1155";
var is2 = { errors: { disconnected: () => "MetaMask: Disconnected from chain. Attempting to connect.", permanentlyDisconnected: () => "MetaMask: Disconnected from MetaMask background. Page reload required.", sendSiteMetadata: () => "MetaMask: Failed to send site metadata. This is an internal error, please report this bug.", unsupportedSync: (e11) => `MetaMask: The MetaMask Ethereum provider does not support synchronous methods like ${e11} without a callback parameter.`, invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.", invalidNetworkParams: () => "MetaMask: Received invalid network parameters. Please report this bug.", invalidRequestArgs: () => "Expected a single, non-array, object argument.", invalidRequestMethod: () => "'args.method' must be a non-empty string.", invalidRequestParams: () => "'args.params' must be an object or array if provided.", invalidLoggerObject: () => "'args.logger' must be an object if provided.", invalidLoggerMethod: (e11) => `'args.logger' must include required method '${e11}'.` }, info: { connected: (e11) => `MetaMask: Connected to chain with ID "${e11}".` }, warnings: { chainIdDeprecation: "MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", networkVersionDeprecation: "MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", selectedAddressDeprecation: "MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23", enableDeprecation: "MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102", sendDeprecation: "MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193", events: { close: "MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect", data: "MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message", networkChanged: "MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged", notification: "MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message" }, rpc: { ethDecryptDeprecation: "MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", ethGetEncryptionPublicKeyDeprecation: "MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686", walletWatchAssetNFTExperimental: "MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle" }, experimentalMethods: "MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning." } };
function os2(e11) {
  const t6 = { ethDecryptDeprecation: false, ethGetEncryptionPublicKeyDeprecation: false, walletWatchAssetNFTExperimental: false };
  return (n5, r8, i9) => {
    var _a14;
    t6.ethDecryptDeprecation || "eth_decrypt" !== n5.method ? t6.ethGetEncryptionPublicKeyDeprecation || "eth_getEncryptionPublicKey" !== n5.method ? !t6.walletWatchAssetNFTExperimental && "wallet_watchAsset" === n5.method && [ns2, rs2].includes(((_a14 = n5.params) == null ? void 0 : _a14.type) || "") && (e11.warn(is2.warnings.rpc.walletWatchAssetNFTExperimental), t6.walletWatchAssetNFTExperimental = true) : (e11.warn(is2.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), t6.ethGetEncryptionPublicKeyDeprecation = true) : (e11.warn(is2.warnings.rpc.ethDecryptDeprecation), t6.ethDecryptDeprecation = true), i9();
  };
}
var ss2 = 4294967295;
var as16 = Math.floor(Math.random() * ss2);
function cs2() {
  return (e11, t6, n5, r8) => {
    const i9 = e11.id, o6 = as16 = (as16 + 1) % ss2;
    e11.id = o6, t6.id = o6, n5((n6) => {
      e11.id = i9, t6.id = i9, n6();
    });
  };
}
var ls2 = (e11, t6, n5) => {
  if (!t6.has(e11)) throw TypeError("Cannot " + n5);
};
var ds2 = (e11, t6, n5) => (ls2(e11, t6, "read from private field"), n5 ? n5.call(e11) : t6.get(e11));
var us2 = (e11, t6, n5) => {
  if (t6.has(e11)) throw TypeError("Cannot add the same private member more than once");
  t6 instanceof WeakSet ? t6.add(e11) : t6.set(e11, n5);
};
var hs3 = (e11, t6, n5, r8) => (ls2(e11, t6, "write to private field"), t6.set(e11, n5), n5);
var fs2 = (e11, t6, n5) => (ls2(e11, t6, "access private method"), n5);
var ps2 = { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 };
var gs3 = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } };
function ms2(e11) {
  return Boolean(e11) && "object" == typeof e11 && !Array.isArray(e11);
}
var ys3 = (e11, t6) => Object.hasOwnProperty.call(e11, t6);
var vs = class extends TypeError {
  constructor(e11, t6) {
    let n5;
    const { message: r8, explanation: i9, ...o6 } = e11, { path: s5 } = e11, a6 = 0 === s5.length ? r8 : `At path: ${s5.join(".")} -- ${r8}`;
    super(i9 ?? a6), null != i9 && (this.cause = a6), Object.assign(this, o6), this.name = this.constructor.name, this.failures = () => n5 ?? (n5 = [e11, ...t6()]);
  }
};
function bs3(e11) {
  return "object" == typeof e11 && null != e11;
}
function ws4(e11) {
  return "symbol" == typeof e11 ? e11.toString() : "string" == typeof e11 ? JSON.stringify(e11) : `${e11}`;
}
function Es(e11, t6, n5, r8) {
  if (true === e11) return;
  false === e11 ? e11 = {} : "string" == typeof e11 && (e11 = { message: e11 });
  const { path: i9, branch: o6 } = t6, { type: s5 } = n5, { refinement: a6, message: c9 = `Expected a value of type \`${s5}\`${a6 ? ` with refinement \`${a6}\`` : ""}, but received: \`${ws4(r8)}\`` } = e11;
  return { value: r8, type: s5, refinement: a6, key: i9[i9.length - 1], path: i9, branch: o6, ...e11, message: c9 };
}
function* Ss(e11, t6, n5, r8) {
  (function(e12) {
    return bs3(e12) && "function" == typeof e12[Symbol.iterator];
  })(e11) || (e11 = [e11]);
  for (const i9 of e11) {
    const e12 = Es(i9, t6, n5, r8);
    e12 && (yield e12);
  }
}
function* _s2(e11, t6, n5 = {}) {
  const { path: r8 = [], branch: i9 = [e11], coerce: o6 = false, mask: s5 = false } = n5, a6 = { path: r8, branch: i9 };
  if (o6 && (e11 = t6.coercer(e11, a6), s5 && "type" !== t6.type && bs3(t6.schema) && bs3(e11) && !Array.isArray(e11))) for (const n6 in e11) void 0 === t6.schema[n6] && delete e11[n6];
  let c9 = "valid";
  for (const r9 of t6.validator(e11, a6)) r9.explanation = n5.message, c9 = "not_valid", yield [r9, void 0];
  for (let [l9, d7, u10] of t6.entries(e11, a6)) {
    const t7 = _s2(d7, u10, { path: void 0 === l9 ? r8 : [...r8, l9], branch: void 0 === l9 ? i9 : [...i9, d7], coerce: o6, mask: s5, message: n5.message });
    for (const n6 of t7) n6[0] ? (c9 = null != n6[0].refinement ? "not_refined" : "not_valid", yield [n6[0], void 0]) : o6 && (d7 = n6[1], void 0 === l9 ? e11 = d7 : e11 instanceof Map ? e11.set(l9, d7) : e11 instanceof Set ? e11.add(d7) : bs3(e11) && (void 0 !== d7 || l9 in e11) && (e11[l9] = d7));
  }
  if ("not_valid" !== c9) for (const r9 of t6.refiner(e11, a6)) r9.explanation = n5.message, c9 = "not_refined", yield [r9, void 0];
  "valid" === c9 && (yield [void 0, e11]);
}
var Cs3 = class {
  constructor(e11) {
    const { type: t6, schema: n5, validator: r8, refiner: i9, coercer: o6 = (e12) => e12, entries: s5 = function* () {
    } } = e11;
    this.type = t6, this.schema = n5, this.entries = s5, this.coercer = o6, this.validator = r8 ? (e12, t7) => Ss(r8(e12, t7), t7, this, e12) : () => [], this.refiner = i9 ? (e12, t7) => Ss(i9(e12, t7), t7, this, e12) : () => [];
  }
  assert(e11, t6) {
    return ks3(e11, this, t6);
  }
  create(e11, t6) {
    return As2(e11, this, t6);
  }
  is(e11) {
    return xs3(e11, this);
  }
  mask(e11, t6) {
    return function(e12, t7, n5) {
      const r8 = Ms3(e12, t7, { coerce: true, mask: true, message: n5 });
      if (r8[0]) throw r8[0];
      return r8[1];
    }(e11, this, t6);
  }
  validate(e11, t6 = {}) {
    return Ms3(e11, this, t6);
  }
};
function ks3(e11, t6, n5) {
  const r8 = Ms3(e11, t6, { message: n5 });
  if (r8[0]) throw r8[0];
}
function As2(e11, t6, n5) {
  const r8 = Ms3(e11, t6, { coerce: true, message: n5 });
  if (r8[0]) throw r8[0];
  return r8[1];
}
function xs3(e11, t6) {
  return !Ms3(e11, t6)[0];
}
function Ms3(e11, t6, n5 = {}) {
  const r8 = _s2(e11, t6, n5), i9 = function(e12) {
    const { done: t7, value: n6 } = e12.next();
    return t7 ? void 0 : n6;
  }(r8);
  if (i9[0]) {
    const e12 = new vs(i9[0], function* () {
      for (const e13 of r8) e13[0] && (yield e13[0]);
    });
    return [e12, void 0];
  }
  return [void 0, i9[1]];
}
function Is(e11, t6) {
  return new Cs3({ type: e11, schema: null, validator: t6 });
}
function Ts(e11) {
  let t6;
  return new Cs3({ type: "lazy", schema: null, *entries(n5, r8) {
    t6 ?? (t6 = e11()), yield* t6.entries(n5, r8);
  }, validator: (n5, r8) => (t6 ?? (t6 = e11()), t6.validator(n5, r8)), coercer: (n5, r8) => (t6 ?? (t6 = e11()), t6.coercer(n5, r8)), refiner: (n5, r8) => (t6 ?? (t6 = e11()), t6.refiner(n5, r8)) });
}
function Rs(e11) {
  return new Cs3({ type: "array", schema: e11, *entries(t6) {
    if (e11 && Array.isArray(t6)) for (const [n5, r8] of t6.entries()) yield [n5, r8, e11];
  }, coercer: (e12) => Array.isArray(e12) ? e12.slice() : e12, validator: (e12) => Array.isArray(e12) || `Expected an array value, but received: ${ws4(e12)}` });
}
function Ps2(e11) {
  const t6 = ws4(e11), n5 = typeof e11;
  return new Cs3({ type: "literal", schema: "string" === n5 || "number" === n5 || "boolean" === n5 ? e11 : null, validator: (n6) => n6 === e11 || `Expected the literal \`${t6}\`, but received: ${ws4(n6)}` });
}
function Os2() {
  return Is("number", (e11) => "number" == typeof e11 && !isNaN(e11) || `Expected a number, but received: ${ws4(e11)}`);
}
function Ns2(e11) {
  const t6 = e11 ? Object.keys(e11) : [], n5 = Is("never", () => false);
  return new Cs3({ type: "object", schema: e11 || null, *entries(r8) {
    if (e11 && bs3(r8)) {
      const i9 = new Set(Object.keys(r8));
      for (const n6 of t6) i9.delete(n6), yield [n6, r8[n6], e11[n6]];
      for (const e12 of i9) yield [e12, r8[e12], n5];
    }
  }, validator: (e12) => bs3(e12) || `Expected an object, but received: ${ws4(e12)}`, coercer: (e12) => bs3(e12) ? { ...e12 } : e12 });
}
function Ls3(e11) {
  return new Cs3({ ...e11, validator: (t6, n5) => void 0 === t6 || e11.validator(t6, n5), refiner: (t6, n5) => void 0 === t6 || e11.refiner(t6, n5) });
}
function Ds2(e11, t6) {
  return new Cs3({ type: "record", schema: null, *entries(n5) {
    if (bs3(n5)) for (const r8 in n5) {
      const i9 = n5[r8];
      yield [r8, r8, e11], yield [r8, i9, t6];
    }
  }, validator: (e12) => bs3(e12) || `Expected an object, but received: ${ws4(e12)}` });
}
function $s3() {
  return Is("string", (e11) => "string" == typeof e11 || `Expected a string, but received: ${ws4(e11)}`);
}
function Bs(e11) {
  const t6 = e11.map((e12) => e12.type).join(" | ");
  return new Cs3({ type: "union", schema: null, coercer(t7) {
    for (const n5 of e11) {
      const [e12, r8] = n5.validate(t7, { coerce: true });
      if (!e12) return r8;
    }
    return t7;
  }, validator(n5, r8) {
    const i9 = [];
    for (const t7 of e11) {
      const [...e12] = _s2(n5, t7, r8), [o6] = e12;
      if (!o6[0]) return [];
      for (const [t8] of e12) t8 && i9.push(t8);
    }
    return [`Expected the value to satisfy a union of \`${t6}\`, but received: ${ws4(n5)}`, ...i9];
  } });
}
function Ks3(e11) {
  return function(e12) {
    return function(e13) {
      return "object" == typeof e13 && null !== e13 && "message" in e13;
    }(e12) && "string" == typeof e12.message ? e12.message : null == e12 ? "" : String(e12);
  }(e11).replace(/\.$/u, "");
}
function js3(e11, t6) {
  var _a14, _b;
  return n5 = e11, Boolean("string" == typeof ((_b = (_a14 = n5 == null ? void 0 : n5.prototype) == null ? void 0 : _a14.constructor) == null ? void 0 : _b.name)) ? new e11({ message: t6 }) : e11({ message: t6 });
  var n5;
}
var Us2 = class extends Error {
  constructor(e11) {
    super(e11.message), this.code = "ERR_ASSERTION";
  }
};
function Hs() {
  throw new Error("setTimeout has not been defined");
}
function Fs2() {
  throw new Error("clearTimeout has not been defined");
}
var zs2 = Hs;
var qs2 = Fs2;
function Ws(e11) {
  if (zs2 === setTimeout) return setTimeout(e11, 0);
  if ((zs2 === Hs || !zs2) && setTimeout) return zs2 = setTimeout, setTimeout(e11, 0);
  try {
    return zs2(e11, 0);
  } catch (t6) {
    try {
      return zs2.call(null, e11, 0);
    } catch (t7) {
      return zs2.call(this, e11, 0);
    }
  }
}
"function" == typeof l8.setTimeout && (zs2 = setTimeout), "function" == typeof l8.clearTimeout && (qs2 = clearTimeout);
var Vs3;
var Gs3 = [];
var Ys2 = false;
var Zs = -1;
function Js2() {
  Ys2 && Vs3 && (Ys2 = false, Vs3.length ? Gs3 = Vs3.concat(Gs3) : Zs = -1, Gs3.length && Qs2());
}
function Qs2() {
  if (!Ys2) {
    var e11 = Ws(Js2);
    Ys2 = true;
    for (var t6 = Gs3.length; t6; ) {
      for (Vs3 = Gs3, Gs3 = []; ++Zs < t6; ) Vs3 && Vs3[Zs].run();
      Zs = -1, t6 = Gs3.length;
    }
    Vs3 = null, Ys2 = false, function(e12) {
      if (qs2 === clearTimeout) return clearTimeout(e12);
      if ((qs2 === Fs2 || !qs2) && clearTimeout) return qs2 = clearTimeout, clearTimeout(e12);
      try {
        return qs2(e12);
      } catch (t7) {
        try {
          return qs2.call(null, e12);
        } catch (t8) {
          return qs2.call(this, e12);
        }
      }
    }(e11);
  }
}
function Xs2(e11, t6) {
  this.fun = e11, this.array = t6;
}
Xs2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function ea2() {
}
var ta2 = ea2;
var na2 = ea2;
var ra2 = ea2;
var ia2 = ea2;
var oa2 = ea2;
var sa2 = ea2;
var aa2 = ea2;
var ca2 = l8.performance || {};
var la2 = ca2.now || ca2.mozNow || ca2.msNow || ca2.oNow || ca2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var da2 = /* @__PURE__ */ new Date();
var ua2 = { nextTick: function(e11) {
  var t6 = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n5 = 1; n5 < arguments.length; n5++) t6[n5 - 1] = arguments[n5];
  Gs3.push(new Xs2(e11, t6)), 1 !== Gs3.length || Ys2 || Ws(Qs2);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: ta2, addListener: na2, once: ra2, off: ia2, removeListener: oa2, removeAllListeners: sa2, emit: aa2, binding: function(e11) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e11) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e11) {
  var t6 = 1e-3 * la2.call(ca2), n5 = Math.floor(t6), r8 = Math.floor(t6 % 1 * 1e9);
  return e11 && (n5 -= e11[0], (r8 -= e11[1]) < 0 && (n5--, r8 += 1e9)), [n5, r8];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (/* @__PURE__ */ new Date() - da2) / 1e3;
} };
var ha = (e11) => Ns2(e11);
function fa2({ path: e11, branch: t6 }) {
  const n5 = e11[e11.length - 1];
  return ys3(t6[t6.length - 2], n5);
}
function pa(e11) {
  return new Cs3({ ...e11, type: `optional ${e11.type}`, validator: (t6, n5) => !fa2(n5) || e11.validator(t6, n5), refiner: (t6, n5) => !fa2(n5) || e11.refiner(t6, n5) });
}
var ga2;
var ma2;
var ya2;
var va2 = Bs([Ps2(null), Is("boolean", (e11) => "boolean" == typeof e11), Is("finite number", (e11) => xs3(e11, Os2()) && Number.isFinite(e11)), $s3(), Rs(Ts(() => va2)), Ds2($s3(), Ts(() => va2))]);
var ba2 = (ga2 = va2, ma2 = Is("any", () => true), ya2 = (e11) => (function(e12, t6, n5 = "Assertion failed", r8 = Us2) {
  try {
    ks3(e12, t6);
  } catch (e13) {
    throw js3(r8, `${n5}: ${Ks3(e13)}.`);
  }
}(e11, va2), JSON.parse(JSON.stringify(e11, (e12, t6) => {
  if ("__proto__" !== e12 && "constructor" !== e12) return t6;
}))), new Cs3({ ...ga2, coercer: (e11, t6) => xs3(e11, ma2) ? ga2.coercer(ya2(e11, t6), t6) : ga2.coercer(e11, t6) }));
function wa2(e11) {
  try {
    return function(e12) {
      As2(e12, ba2);
    }(e11), true;
  } catch {
    return false;
  }
}
var Ea2 = Ps2("2.0");
var Sa2 = function(e11) {
  return new Cs3({ ...e11, validator: (t6, n5) => null === t6 || e11.validator(t6, n5), refiner: (t6, n5) => null === t6 || e11.refiner(t6, n5) });
}(Bs([Os2(), $s3()]));
var _a13 = ha({ code: Is("integer", (e11) => "number" == typeof e11 && !isNaN(e11) && Number.isInteger(e11) || `Expected an integer, but received: ${ws4(e11)}`), message: $s3(), data: pa(ba2), stack: pa($s3()) });
var Ca2 = Bs([Ds2($s3(), ba2), Rs(ba2)]);
var ka2 = ha({ id: Sa2, jsonrpc: Ea2, method: $s3(), params: pa(Ca2) });
var Aa2 = ha({ jsonrpc: Ea2, method: $s3(), params: pa(Ca2) });
function xa2(e11) {
  return xs3(e11, ka2);
}
function Ma2(e11) {
  return xs3(e11, _a13);
}
Ns2({ id: Sa2, jsonrpc: Ea2, result: Ls3(Is("unknown", () => true)), error: Ls3(_a13) }), Bs([ha({ id: Sa2, jsonrpc: Ea2, result: ba2 }), ha({ id: Sa2, jsonrpc: Ea2, error: _a13 })]);
var Ia2 = ps2.internal;
var Ta2 = "Unspecified error message. This is a bug, please report it.";
var Ra2 = { code: Ia2, message: Oa2(Ia2) };
var Pa2 = "Unspecified server error.";
function Oa2(e11, t6 = Ta2) {
  if (function(e12) {
    return Number.isInteger(e12);
  }(e11)) {
    const t7 = e11.toString();
    if (ys3(gs3, t7)) return gs3[t7].message;
    if (function(e12) {
      return e12 >= -32099 && e12 <= -32e3;
    }(e11)) return Pa2;
  }
  return t6;
}
function Na2(e11, { fallbackError: t6 = Ra2, shouldIncludeStack: n5 = true } = {}) {
  if (!Ma2(t6)) throw new Error("Must provide fallback error with integer number code and string message.");
  const r8 = function(e12, t7) {
    if (e12 && "object" == typeof e12 && "serialize" in e12 && "function" == typeof e12.serialize) return e12.serialize();
    if (Ma2(e12)) return e12;
    const n6 = La2(e12), r9 = { ...t7, data: { cause: n6 } };
    return r9;
  }(e11, t6);
  return n5 || delete r8.stack, r8;
}
function La2(e11) {
  return Array.isArray(e11) ? e11.map((e12) => wa2(e12) ? e12 : ms2(e12) ? Da2(e12) : null) : ms2(e11) ? Da2(e11) : wa2(e11) ? e11 : null;
}
function Da2(e11) {
  return Object.getOwnPropertyNames(e11).reduce((t6, n5) => {
    const r8 = e11[n5];
    return wa2(r8) && (t6[n5] = r8), t6;
  }, {});
}
var $a2 = Fa;
Fa.default = Fa, Fa.stable = Va2, Fa.stableStringify = Va2;
var Ba2 = "[...]";
var Ka2 = "[Circular]";
var ja2 = [];
var Ua2 = [];
function Ha2() {
  return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
}
function Fa(e11, t6, n5, r8) {
  var i9;
  void 0 === r8 && (r8 = Ha2()), qa2(e11, "", 0, [], void 0, 0, r8);
  try {
    i9 = 0 === Ua2.length ? JSON.stringify(e11, t6, n5) : JSON.stringify(e11, Ya(t6), n5);
  } catch (e12) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja2.length; ) {
      var o6 = ja2.pop();
      4 === o6.length ? Object.defineProperty(o6[0], o6[1], o6[3]) : o6[0][o6[1]] = o6[2];
    }
  }
  return i9;
}
function za(e11, t6, n5, r8) {
  var i9 = Object.getOwnPropertyDescriptor(r8, n5);
  void 0 !== i9.get ? i9.configurable ? (Object.defineProperty(r8, n5, { value: e11 }), ja2.push([r8, n5, t6, i9])) : Ua2.push([t6, n5, e11]) : (r8[n5] = e11, ja2.push([r8, n5, t6]));
}
function qa2(e11, t6, n5, r8, i9, o6, s5) {
  var a6;
  if (o6 += 1, "object" == typeof e11 && null !== e11) {
    for (a6 = 0; a6 < r8.length; a6++) if (r8[a6] === e11) return void za(Ka2, e11, t6, i9);
    if (void 0 !== s5.depthLimit && o6 > s5.depthLimit) return void za(Ba2, e11, t6, i9);
    if (void 0 !== s5.edgesLimit && n5 + 1 > s5.edgesLimit) return void za(Ba2, e11, t6, i9);
    if (r8.push(e11), Array.isArray(e11)) for (a6 = 0; a6 < e11.length; a6++) qa2(e11[a6], a6, a6, r8, e11, o6, s5);
    else {
      var c9 = Object.keys(e11);
      for (a6 = 0; a6 < c9.length; a6++) {
        var l9 = c9[a6];
        qa2(e11[l9], l9, a6, r8, e11, o6, s5);
      }
    }
    r8.pop();
  }
}
function Wa(e11, t6) {
  return e11 < t6 ? -1 : e11 > t6 ? 1 : 0;
}
function Va2(e11, t6, n5, r8) {
  void 0 === r8 && (r8 = Ha2());
  var i9, o6 = Ga(e11, "", 0, [], void 0, 0, r8) || e11;
  try {
    i9 = 0 === Ua2.length ? JSON.stringify(o6, t6, n5) : JSON.stringify(o6, Ya(t6), n5);
  } catch (e12) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; 0 !== ja2.length; ) {
      var s5 = ja2.pop();
      4 === s5.length ? Object.defineProperty(s5[0], s5[1], s5[3]) : s5[0][s5[1]] = s5[2];
    }
  }
  return i9;
}
function Ga(e11, t6, n5, r8, i9, o6, s5) {
  var a6;
  if (o6 += 1, "object" == typeof e11 && null !== e11) {
    for (a6 = 0; a6 < r8.length; a6++) if (r8[a6] === e11) return void za(Ka2, e11, t6, i9);
    try {
      if ("function" == typeof e11.toJSON) return;
    } catch (e12) {
      return;
    }
    if (void 0 !== s5.depthLimit && o6 > s5.depthLimit) return void za(Ba2, e11, t6, i9);
    if (void 0 !== s5.edgesLimit && n5 + 1 > s5.edgesLimit) return void za(Ba2, e11, t6, i9);
    if (r8.push(e11), Array.isArray(e11)) for (a6 = 0; a6 < e11.length; a6++) Ga(e11[a6], a6, a6, r8, e11, o6, s5);
    else {
      var c9 = {}, l9 = Object.keys(e11).sort(Wa);
      for (a6 = 0; a6 < l9.length; a6++) {
        var d7 = l9[a6];
        Ga(e11[d7], d7, a6, r8, e11, o6, s5), c9[d7] = e11[d7];
      }
      if (void 0 === i9) return c9;
      ja2.push([i9, t6, e11]), i9[t6] = c9;
    }
    r8.pop();
  }
}
function Ya(e11) {
  return e11 = void 0 !== e11 ? e11 : function(e12, t6) {
    return t6;
  }, function(t6, n5) {
    if (Ua2.length > 0) for (var r8 = 0; r8 < Ua2.length; r8++) {
      var i9 = Ua2[r8];
      if (i9[1] === t6 && i9[0] === n5) {
        n5 = i9[2], Ua2.splice(r8, 1);
        break;
      }
    }
    return e11.call(this, t6, n5);
  };
}
var Za = ue4($a2);
var Ja = class extends Error {
  constructor(e11, t6, n5) {
    if (!Number.isInteger(e11)) throw new Error('"code" must be an integer.');
    if (!t6 || "string" != typeof t6) throw new Error('"message" must be a non-empty string.');
    super(t6), this.code = e11, void 0 !== n5 && (this.data = n5);
  }
  serialize() {
    const e11 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e11.data = this.data, function(e12) {
      if ("object" != typeof e12 || null === e12) return false;
      try {
        let t6 = e12;
        for (; null !== Object.getPrototypeOf(t6); ) t6 = Object.getPrototypeOf(t6);
        return Object.getPrototypeOf(e12) === t6;
      } catch (e13) {
        return false;
      }
    }(this.data) && (e11.data.cause = La2(this.data.cause))), this.stack && (e11.stack = this.stack), e11;
  }
  toString() {
    return Za(this.serialize(), Qa, 2);
  }
};
function Qa(e11, t6) {
  if ("[Circular]" !== t6) return t6;
}
var Xa = (e11) => ec2(ps2.invalidRequest, e11);
function ec2(e11, t6) {
  const [n5, r8] = function(e12) {
    if (e12) {
      if ("string" == typeof e12) return [e12];
      if ("object" == typeof e12 && !Array.isArray(e12)) {
        const { message: t7, data: n6 } = e12;
        if (t7 && "string" != typeof t7) throw new Error("Must specify string message.");
        return [t7 ?? void 0, n6];
      }
    }
    return [];
  }(t6);
  return new Ja(e11, n5 ?? Oa2(e11), r8);
}
var tc2 = {};
function nc2() {
}
function rc2() {
  rc2.init.call(this);
}
function ic2(e11) {
  return void 0 === e11._maxListeners ? rc2.defaultMaxListeners : e11._maxListeners;
}
function oc2(e11, t6, n5, r8) {
  var i9, o6, s5;
  if ("function" != typeof n5) throw new TypeError('"listener" argument must be a function');
  if ((o6 = e11._events) ? (o6.newListener && (e11.emit("newListener", t6, n5.listener ? n5.listener : n5), o6 = e11._events), s5 = o6[t6]) : (o6 = e11._events = new nc2(), e11._eventsCount = 0), s5) {
    if ("function" == typeof s5 ? s5 = o6[t6] = r8 ? [n5, s5] : [s5, n5] : r8 ? s5.unshift(n5) : s5.push(n5), !s5.warned && (i9 = ic2(e11)) && i9 > 0 && s5.length > i9) {
      s5.warned = true;
      var a6 = new Error("Possible EventEmitter memory leak detected. " + s5.length + " " + t6 + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a6.name = "MaxListenersExceededWarning", a6.emitter = e11, a6.type = t6, a6.count = s5.length, function(e12) {
        "function" == typeof console.warn ? console.warn(e12) : console.log(e12);
      }(a6);
    }
  } else s5 = o6[t6] = n5, ++e11._eventsCount;
  return e11;
}
function sc2(e11, t6, n5) {
  var r8 = false;
  function i9() {
    e11.removeListener(t6, i9), r8 || (r8 = true, n5.apply(e11, arguments));
  }
  return i9.listener = n5, i9;
}
function ac2(e11) {
  var t6 = this._events;
  if (t6) {
    var n5 = t6[e11];
    if ("function" == typeof n5) return 1;
    if (n5) return n5.length;
  }
  return 0;
}
function cc2(e11, t6) {
  for (var n5 = new Array(t6); t6--; ) n5[t6] = e11[t6];
  return n5;
}
nc2.prototype = /* @__PURE__ */ Object.create(null), rc2.EventEmitter = rc2, rc2.usingDomains = false, rc2.prototype.domain = void 0, rc2.prototype._events = void 0, rc2.prototype._maxListeners = void 0, rc2.defaultMaxListeners = 10, rc2.init = function() {
  this.domain = null, rc2.usingDomains && (void 0).active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new nc2(), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, rc2.prototype.setMaxListeners = function(e11) {
  if ("number" != typeof e11 || e11 < 0 || isNaN(e11)) throw new TypeError('"n" argument must be a positive number');
  return this._maxListeners = e11, this;
}, rc2.prototype.getMaxListeners = function() {
  return ic2(this);
}, rc2.prototype.emit = function(e11) {
  var t6, n5, r8, i9, o6, s5, a6, c9 = "error" === e11;
  if (s5 = this._events) c9 = c9 && null == s5.error;
  else if (!c9) return false;
  if (a6 = this.domain, c9) {
    if (t6 = arguments[1], !a6) {
      if (t6 instanceof Error) throw t6;
      var l9 = new Error('Uncaught, unspecified "error" event. (' + t6 + ")");
      throw l9.context = t6, l9;
    }
    return t6 || (t6 = new Error('Uncaught, unspecified "error" event')), t6.domainEmitter = this, t6.domain = a6, t6.domainThrown = false, a6.emit("error", t6), false;
  }
  if (!(n5 = s5[e11])) return false;
  var d7 = "function" == typeof n5;
  switch (r8 = arguments.length) {
    case 1:
      !function(e12, t7, n6) {
        if (t7) e12.call(n6);
        else for (var r9 = e12.length, i10 = cc2(e12, r9), o7 = 0; o7 < r9; ++o7) i10[o7].call(n6);
      }(n5, d7, this);
      break;
    case 2:
      !function(e12, t7, n6, r9) {
        if (t7) e12.call(n6, r9);
        else for (var i10 = e12.length, o7 = cc2(e12, i10), s6 = 0; s6 < i10; ++s6) o7[s6].call(n6, r9);
      }(n5, d7, this, arguments[1]);
      break;
    case 3:
      !function(e12, t7, n6, r9, i10) {
        if (t7) e12.call(n6, r9, i10);
        else for (var o7 = e12.length, s6 = cc2(e12, o7), a7 = 0; a7 < o7; ++a7) s6[a7].call(n6, r9, i10);
      }(n5, d7, this, arguments[1], arguments[2]);
      break;
    case 4:
      !function(e12, t7, n6, r9, i10, o7) {
        if (t7) e12.call(n6, r9, i10, o7);
        else for (var s6 = e12.length, a7 = cc2(e12, s6), c10 = 0; c10 < s6; ++c10) a7[c10].call(n6, r9, i10, o7);
      }(n5, d7, this, arguments[1], arguments[2], arguments[3]);
      break;
    default:
      for (i9 = new Array(r8 - 1), o6 = 1; o6 < r8; o6++) i9[o6 - 1] = arguments[o6];
      !function(e12, t7, n6, r9) {
        if (t7) e12.apply(n6, r9);
        else for (var i10 = e12.length, o7 = cc2(e12, i10), s6 = 0; s6 < i10; ++s6) o7[s6].apply(n6, r9);
      }(n5, d7, this, i9);
  }
  return true;
}, rc2.prototype.addListener = function(e11, t6) {
  return oc2(this, e11, t6, false);
}, rc2.prototype.on = rc2.prototype.addListener, rc2.prototype.prependListener = function(e11, t6) {
  return oc2(this, e11, t6, true);
}, rc2.prototype.once = function(e11, t6) {
  if ("function" != typeof t6) throw new TypeError('"listener" argument must be a function');
  return this.on(e11, sc2(this, e11, t6)), this;
}, rc2.prototype.prependOnceListener = function(e11, t6) {
  if ("function" != typeof t6) throw new TypeError('"listener" argument must be a function');
  return this.prependListener(e11, sc2(this, e11, t6)), this;
}, rc2.prototype.removeListener = function(e11, t6) {
  var n5, r8, i9, o6, s5;
  if ("function" != typeof t6) throw new TypeError('"listener" argument must be a function');
  if (!(r8 = this._events)) return this;
  if (!(n5 = r8[e11])) return this;
  if (n5 === t6 || n5.listener && n5.listener === t6) 0 == --this._eventsCount ? this._events = new nc2() : (delete r8[e11], r8.removeListener && this.emit("removeListener", e11, n5.listener || t6));
  else if ("function" != typeof n5) {
    for (i9 = -1, o6 = n5.length; o6-- > 0; ) if (n5[o6] === t6 || n5[o6].listener && n5[o6].listener === t6) {
      s5 = n5[o6].listener, i9 = o6;
      break;
    }
    if (i9 < 0) return this;
    if (1 === n5.length) {
      if (n5[0] = void 0, 0 == --this._eventsCount) return this._events = new nc2(), this;
      delete r8[e11];
    } else !function(e12, t7) {
      for (var n6 = t7, r9 = n6 + 1, i10 = e12.length; r9 < i10; n6 += 1, r9 += 1) e12[n6] = e12[r9];
      e12.pop();
    }(n5, i9);
    r8.removeListener && this.emit("removeListener", e11, s5 || t6);
  }
  return this;
}, rc2.prototype.off = function(e11, t6) {
  return this.removeListener(e11, t6);
}, rc2.prototype.removeAllListeners = function(e11) {
  var t6, n5;
  if (!(n5 = this._events)) return this;
  if (!n5.removeListener) return 0 === arguments.length ? (this._events = new nc2(), this._eventsCount = 0) : n5[e11] && (0 == --this._eventsCount ? this._events = new nc2() : delete n5[e11]), this;
  if (0 === arguments.length) {
    for (var r8, i9 = Object.keys(n5), o6 = 0; o6 < i9.length; ++o6) "removeListener" !== (r8 = i9[o6]) && this.removeAllListeners(r8);
    return this.removeAllListeners("removeListener"), this._events = new nc2(), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t6 = n5[e11])) this.removeListener(e11, t6);
  else if (t6) do {
    this.removeListener(e11, t6[t6.length - 1]);
  } while (t6[0]);
  return this;
}, rc2.prototype.listeners = function(e11) {
  var t6, n5, r8 = this._events;
  return n5 = r8 && (t6 = r8[e11]) ? "function" == typeof t6 ? [t6.listener || t6] : function(e12) {
    for (var t7 = new Array(e12.length), n6 = 0; n6 < t7.length; ++n6) t7[n6] = e12[n6].listener || e12[n6];
    return t7;
  }(t6) : [], n5;
}, rc2.listenerCount = function(e11, t6) {
  return "function" == typeof e11.listenerCount ? e11.listenerCount(t6) : ac2.call(e11, t6);
}, rc2.prototype.listenerCount = ac2, rc2.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
var lc2 = he4(Object.freeze({ __proto__: null, EventEmitter: rc2, default: rc2 }));
Object.defineProperty(tc2, "__esModule", { value: true });
var dc2 = lc2;
function uc2(e11, t6, n5) {
  try {
    Reflect.apply(e11, t6, n5);
  } catch (e12) {
    setTimeout(() => {
      throw e12;
    });
  }
}
var hc2 = class extends dc2.EventEmitter {
  emit(e11, ...t6) {
    let n5 = "error" === e11;
    const r8 = this._events;
    if (void 0 !== r8) n5 = n5 && void 0 === r8.error;
    else if (!n5) return false;
    if (n5) {
      let e12;
      if (t6.length > 0 && ([e12] = t6), e12 instanceof Error) throw e12;
      const n6 = new Error("Unhandled error." + (e12 ? ` (${e12.message})` : ""));
      throw n6.context = e12, n6;
    }
    const i9 = r8[e11];
    if (void 0 === i9) return false;
    if ("function" == typeof i9) uc2(i9, this, t6);
    else {
      const e12 = i9.length, n6 = function(e13) {
        const t7 = e13.length, n7 = new Array(t7);
        for (let r9 = 0; r9 < t7; r9 += 1) n7[r9] = e13[r9];
        return n7;
      }(i9);
      for (let r9 = 0; r9 < e12; r9 += 1) uc2(n6[r9], this, t6);
    }
    return true;
  }
};
var fc2;
var pc2;
var gc2;
var mc2;
var yc2;
var vc2;
var bc2;
var wc2;
var Ec2;
var Sc2;
var _c2;
var Cc2;
var kc2;
var Ac2;
var xc2;
var Mc2;
var Ic2;
var Tc2;
var Rc2;
var Pc2 = tc2.default = hc2;
var Oc2 = class e6 extends Pc2 {
  constructor({ notificationHandler: e11 } = {}) {
    super(), us2(this, mc2), us2(this, vc2), us2(this, wc2), us2(this, fc2, false), us2(this, pc2, void 0), us2(this, gc2, void 0), hs3(this, pc2, []), hs3(this, gc2, e11);
  }
  destroy() {
    ds2(this, pc2).forEach((e11) => {
      "destroy" in e11 && "function" == typeof e11.destroy && e11.destroy();
    }), hs3(this, pc2, []), hs3(this, fc2, true);
  }
  push(e11) {
    fs2(this, mc2, yc2).call(this), ds2(this, pc2).push(e11);
  }
  handle(e11, t6) {
    if (fs2(this, mc2, yc2).call(this), t6 && "function" != typeof t6) throw new Error('"callback" must be a function if provided.');
    return Array.isArray(e11) ? t6 ? fs2(this, vc2, bc2).call(this, e11, t6) : fs2(this, vc2, bc2).call(this, e11) : t6 ? fs2(this, wc2, Ec2).call(this, e11, t6) : this._promiseHandle(e11);
  }
  asMiddleware() {
    return fs2(this, mc2, yc2).call(this), async (t6, n5, r8, i9) => {
      var o6, s5;
      try {
        const [a6, c9, l9] = await fs2(o6 = e6, Cc2, kc2).call(o6, t6, n5, ds2(this, pc2));
        return c9 ? (await fs2(s5 = e6, Mc2, Ic2).call(s5, l9), i9(a6)) : r8(async (t7) => {
          var n6;
          try {
            await fs2(n6 = e6, Mc2, Ic2).call(n6, l9);
          } catch (e11) {
            return t7(e11);
          }
          return t7();
        });
      } catch (e11) {
        return i9(e11);
      }
    };
  }
  async _promiseHandle(e11) {
    return new Promise((t6, n5) => {
      fs2(this, wc2, Ec2).call(this, e11, (e12, r8) => {
        e12 && void 0 === r8 ? n5(e12) : t6(r8);
      }).catch(n5);
    });
  }
};
fc2 = /* @__PURE__ */ new WeakMap(), pc2 = /* @__PURE__ */ new WeakMap(), gc2 = /* @__PURE__ */ new WeakMap(), mc2 = /* @__PURE__ */ new WeakSet(), yc2 = function() {
  if (ds2(this, fc2)) throw new Error("This engine is destroyed and can no longer be used.");
}, vc2 = /* @__PURE__ */ new WeakSet(), bc2 = async function(e11, t6) {
  try {
    if (0 === e11.length) {
      const e12 = [{ id: null, jsonrpc: "2.0", error: new Ja(ps2.invalidRequest, "Request batch must contain plain objects. Received an empty array") }];
      return t6 ? t6(null, e12) : e12;
    }
    const n5 = (await Promise.all(e11.map(this._promiseHandle.bind(this)))).filter((e12) => void 0 !== e12);
    return t6 ? t6(null, n5) : n5;
  } catch (e12) {
    if (t6) return t6(e12);
    throw e12;
  }
}, wc2 = /* @__PURE__ */ new WeakSet(), Ec2 = async function(e11, t6) {
  var n5;
  if (!e11 || Array.isArray(e11) || "object" != typeof e11) {
    const n6 = new Ja(ps2.invalidRequest, "Requests must be plain objects. Received: " + typeof e11, { request: e11 });
    return t6(n6, { id: null, jsonrpc: "2.0", error: n6 });
  }
  if ("string" != typeof e11.method) {
    const n6 = new Ja(ps2.invalidRequest, "Must specify a string method. Received: " + typeof e11.method, { request: e11 });
    return ds2(this, gc2) && !xa2(e11) ? t6(null) : t6(n6, { id: e11.id ?? null, jsonrpc: "2.0", error: n6 });
  }
  if (ds2(this, gc2) && xs3(e11, Aa2) && !xa2(e11)) {
    try {
      await ds2(this, gc2).call(this, e11);
    } catch (e12) {
      return t6(e12);
    }
    return t6(null);
  }
  let r8 = null;
  const i9 = { ...e11 }, o6 = { id: i9.id, jsonrpc: i9.jsonrpc };
  try {
    await fs2(n5 = Oc2, Sc2, _c2).call(n5, i9, o6, ds2(this, pc2));
  } catch (e12) {
    r8 = e12;
  }
  return r8 && (delete o6.result, o6.error || (o6.error = Na2(r8))), t6(r8, o6);
}, Sc2 = /* @__PURE__ */ new WeakSet(), _c2 = async function(e11, t6, n5) {
  var r8, i9, o6;
  const [s5, a6, c9] = await fs2(r8 = Oc2, Cc2, kc2).call(r8, e11, t6, n5);
  if (fs2(i9 = Oc2, Tc2, Rc2).call(i9, e11, t6, a6), await fs2(o6 = Oc2, Mc2, Ic2).call(o6, c9), s5) throw s5;
}, Cc2 = /* @__PURE__ */ new WeakSet(), kc2 = async function(e11, t6, n5) {
  var r8;
  const i9 = [];
  let o6 = null, s5 = false;
  for (const a6 of n5) if ([o6, s5] = await fs2(r8 = Oc2, Ac2, xc2).call(r8, e11, t6, a6, i9), s5) break;
  return [o6, s5, i9.reverse()];
}, Ac2 = /* @__PURE__ */ new WeakSet(), xc2 = async function(e11, t6, n5, r8) {
  return new Promise((i9) => {
    const o6 = (e12) => {
      const n6 = e12 || t6.error;
      n6 && (t6.error = Na2(n6)), i9([n6, true]);
    }, s5 = (n6) => {
      t6.error ? o6(t6.error) : (n6 && ("function" != typeof n6 && o6(new Ja(ps2.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof n6}" for request:
${Lc2(e11)}`, { request: e11 })), r8.push(n6)), i9([null, false]));
    };
    try {
      n5(e11, t6, s5, o6);
    } catch (e12) {
      o6(e12);
    }
  });
}, Mc2 = /* @__PURE__ */ new WeakSet(), Ic2 = async function(e11) {
  for (const t6 of e11) await new Promise((e12, n5) => {
    t6((t7) => t7 ? n5(t7) : e12());
  });
}, Tc2 = /* @__PURE__ */ new WeakSet(), Rc2 = function(e11, t6, n5) {
  if (!ys3(t6, "result") && !ys3(t6, "error")) throw new Ja(ps2.internal, `JsonRpcEngine: Response has no error or result for request:
${Lc2(e11)}`, { request: e11 });
  if (!n5) throw new Ja(ps2.internal, `JsonRpcEngine: Nothing ended request:
${Lc2(e11)}`, { request: e11 });
}, us2(Oc2, Sc2), us2(Oc2, Cc2), us2(Oc2, Ac2), us2(Oc2, Mc2), us2(Oc2, Tc2);
var Nc2 = Oc2;
function Lc2(e11) {
  return JSON.stringify(e11, null, 2);
}
var Dc2 = Object.freeze(["eth_subscription"]);
var $c2 = (e11 = console) => [cs2(), Bc2(e11), os2(e11)];
function Bc2(e11) {
  return (t6, n5, r8) => {
    "string" == typeof t6.method && t6.method || (n5.error = Xa({ message: "The request 'method' must be a non-empty string.", data: t6 })), r8((t7) => {
      const { error: r9 } = n5;
      return r9 ? (e11.error(`MetaMask - RPC Error: ${r9.message}`, r9), t7()) : t7();
    });
  };
}
var Kc2 = (e11, t6, n5 = true) => (r8, i9) => {
  r8 || i9.error ? t6(r8 || i9.error) : !n5 || Array.isArray(i9) ? e11(i9) : e11(i9.result);
};
var jc2 = (e11) => Boolean(e11) && "string" == typeof e11 && e11.startsWith("0x");
var Uc2 = () => {
};
async function Hc2(e11, t6) {
  try {
    const t7 = await async function() {
      return { name: Fc2(window), icon: await zc2(window) };
    }();
    e11.handle({ jsonrpc: "2.0", id: 1, method: "metamask_sendDomainMetadata", params: t7 }, Uc2);
  } catch (e12) {
    t6.error({ message: is2.errors.sendSiteMetadata(), originalError: e12 });
  }
}
function Fc2(e11) {
  const { document: t6 } = e11, n5 = t6.querySelector('head > meta[property="og:site_name"]');
  if (n5) return n5.content;
  const r8 = t6.querySelector('head > meta[name="title"]');
  return r8 ? r8.content : t6.title && t6.title.length > 0 ? t6.title : window.location.hostname;
}
async function zc2(e11) {
  const { document: t6 } = e11, n5 = t6.querySelectorAll('head > link[rel~="icon"]');
  for (const e12 of Array.from(n5)) if (e12 && await qc2(e12.href)) return e12.href;
  return null;
}
async function qc2(e11) {
  return new Promise((t6, n5) => {
    try {
      const n6 = document.createElement("img");
      n6.onload = () => t6(true), n6.onerror = () => t6(false), n6.src = e11;
    } catch (e12) {
      n5(e12);
    }
  });
}
var Wc2 = (e11, t6, n5) => {
  if (!t6.has(e11)) throw TypeError("Cannot " + n5);
};
var Vc2 = (e11, t6, n5) => (Wc2(e11, t6, "read from private field"), n5 ? n5.call(e11) : t6.get(e11));
var Gc2 = (e11, t6, n5) => {
  if (t6.has(e11)) throw TypeError("Cannot add the same private member more than once");
  t6 instanceof WeakSet ? t6.add(e11) : t6.set(e11, n5);
};
var Yc2 = (e11, t6, n5, r8) => (Wc2(e11, t6, "write to private field"), t6.set(e11, n5), n5);
function Zc2(e11, t6, n5) {
  try {
    Reflect.apply(e11, t6, n5);
  } catch (e12) {
    setTimeout(() => {
      throw e12;
    });
  }
}
var Jc2 = class extends rc2 {
  emit(e11, ...t6) {
    let n5 = "error" === e11;
    const r8 = this._events;
    if (void 0 !== r8) n5 = n5 && void 0 === r8.error;
    else if (!n5) return false;
    if (n5) {
      let e12;
      if (t6.length > 0 && ([e12] = t6), e12 instanceof Error) throw e12;
      const n6 = new Error("Unhandled error." + (e12 ? ` (${e12.message})` : ""));
      throw n6.context = e12, n6;
    }
    const i9 = r8[e11];
    if (void 0 === i9) return false;
    if ("function" == typeof i9) Zc2(i9, this, t6);
    else {
      const e12 = i9.length, n6 = function(e13) {
        const t7 = e13.length, n7 = new Array(t7);
        for (let r9 = 0; r9 < t7; r9 += 1) n7[r9] = e13[r9];
        return n7;
      }(i9);
      for (let r9 = 0; r9 < e12; r9 += 1) Zc2(n6[r9], this, t6);
    }
    return true;
  }
};
var Qc2;
var Xc2;
var el = function e7(t6, n5) {
  if (t6 === n5) return true;
  if (t6 && n5 && "object" == typeof t6 && "object" == typeof n5) {
    if (t6.constructor !== n5.constructor) return false;
    var r8, i9, o6;
    if (Array.isArray(t6)) {
      if ((r8 = t6.length) != n5.length) return false;
      for (i9 = r8; 0 != i9--; ) if (!e7(t6[i9], n5[i9])) return false;
      return true;
    }
    if (t6.constructor === RegExp) return t6.source === n5.source && t6.flags === n5.flags;
    if (t6.valueOf !== Object.prototype.valueOf) return t6.valueOf() === n5.valueOf();
    if (t6.toString !== Object.prototype.toString) return t6.toString() === n5.toString();
    if ((r8 = (o6 = Object.keys(t6)).length) !== Object.keys(n5).length) return false;
    for (i9 = r8; 0 != i9--; ) if (!Object.prototype.hasOwnProperty.call(n5, o6[i9])) return false;
    for (i9 = r8; 0 != i9--; ) {
      var s5 = o6[i9];
      if (!e7(t6[s5], n5[s5])) return false;
    }
    return true;
  }
  return t6 != t6 && n5 != n5;
};
var tl = ue4(el);
var nl = class e8 extends Jc2 {
  constructor({ logger: t6 = console, maxEventListeners: n5 = 100, rpcMiddleware: r8 = [] } = {}) {
    super(), Gc2(this, Qc2, void 0), Gc2(this, Xc2, void 0), this._log = t6, this.setMaxListeners(n5), this._state = { ...e8._defaultState }, Yc2(this, Xc2, null), Yc2(this, Qc2, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const i9 = new Nc2();
    r8.forEach((e11) => i9.push(e11)), this._rpcEngine = i9;
  }
  get chainId() {
    return Vc2(this, Qc2);
  }
  get selectedAddress() {
    return Vc2(this, Xc2);
  }
  isConnected() {
    return this._state.isConnected;
  }
  async request(e11) {
    if (!e11 || "object" != typeof e11 || Array.isArray(e11)) throw Xa({ message: is2.errors.invalidRequestArgs(), data: e11 });
    const { method: t6, params: n5 } = e11;
    if ("string" != typeof t6 || 0 === t6.length) throw Xa({ message: is2.errors.invalidRequestMethod(), data: e11 });
    if (void 0 !== n5 && !Array.isArray(n5) && ("object" != typeof n5 || null === n5)) throw Xa({ message: is2.errors.invalidRequestParams(), data: e11 });
    const r8 = null == n5 ? { method: t6 } : { method: t6, params: n5 };
    return new Promise((e12, t7) => {
      this._rpcRequest(r8, Kc2(e12, t7));
    });
  }
  _initializeState(e11) {
    if (this._state.initialized) throw new Error("Provider already initialized.");
    if (e11) {
      const { accounts: t6, chainId: n5, isUnlocked: r8, networkVersion: i9 } = e11;
      this._handleConnect(n5), this._handleChainChanged({ chainId: n5, networkVersion: i9 }), this._handleUnlockStateChanged({ accounts: t6, isUnlocked: r8 }), this._handleAccountsChanged(t6);
    }
    this._state.initialized = true, this.emit("_initialized");
  }
  _rpcRequest(e11, t6) {
    let n5 = t6;
    return Array.isArray(e11) || (e11.jsonrpc || (e11.jsonrpc = "2.0"), "eth_accounts" !== e11.method && "eth_requestAccounts" !== e11.method || (n5 = (n6, r8) => {
      this._handleAccountsChanged(r8.result ?? [], "eth_accounts" === e11.method), t6(n6, r8);
    })), this._rpcEngine.handle(e11, n5);
  }
  _handleConnect(e11) {
    this._state.isConnected || (this._state.isConnected = true, this.emit("connect", { chainId: e11 }), this._log.debug(is2.info.connected(e11)));
  }
  _handleDisconnect(e11, t6) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e11) {
      let n5;
      this._state.isConnected = false, e11 ? (n5 = new Ja(1013, t6 ?? is2.errors.disconnected()), this._log.debug(n5)) : (n5 = new Ja(1011, t6 ?? is2.errors.permanentlyDisconnected()), this._log.error(n5), Yc2(this, Qc2, null), this._state.accounts = null, Yc2(this, Xc2, null), this._state.isUnlocked = false, this._state.isPermanentlyDisconnected = true), this.emit("disconnect", n5);
    }
  }
  _handleChainChanged({ chainId: e11 } = {}) {
    jc2(e11) ? (this._handleConnect(e11), e11 !== Vc2(this, Qc2) && (Yc2(this, Qc2, e11), this._state.initialized && this.emit("chainChanged", Vc2(this, Qc2)))) : this._log.error(is2.errors.invalidNetworkParams(), { chainId: e11 });
  }
  _handleAccountsChanged(e11, t6 = false) {
    let n5 = e11;
    Array.isArray(e11) || (this._log.error("MetaMask: Received invalid accounts parameter. Please report this bug.", e11), n5 = []);
    for (const t7 of e11) if ("string" != typeof t7) {
      this._log.error("MetaMask: Received non-string account. Please report this bug.", e11), n5 = [];
      break;
    }
    if (!tl(this._state.accounts, n5) && (t6 && null !== this._state.accounts && this._log.error("MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.", n5), this._state.accounts = n5, Vc2(this, Xc2) !== n5[0] && Yc2(this, Xc2, n5[0] || null), this._state.initialized)) {
      const e12 = [...n5];
      this.emit("accountsChanged", e12);
    }
  }
  _handleUnlockStateChanged({ accounts: e11, isUnlocked: t6 } = {}) {
    "boolean" == typeof t6 ? t6 !== this._state.isUnlocked && (this._state.isUnlocked = t6, this._handleAccountsChanged(e11 ?? [])) : this._log.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.");
  }
};
Qc2 = /* @__PURE__ */ new WeakMap(), Xc2 = /* @__PURE__ */ new WeakMap(), nl._defaultState = { accounts: null, isConnected: false, isUnlocked: false, initialized: false, isPermanentlyDisconnected: false };
var rl;
var il;
var ol = nl;
var sl = { exports: {} };
function al() {
  return il ? rl : (il = 1, rl = lc2.EventEmitter);
}
var cl;
var ll = he4(le4);
cl = "function" == typeof Object.create ? function(e11, t6) {
  e11.super_ = t6, e11.prototype = Object.create(t6.prototype, { constructor: { value: e11, enumerable: false, writable: true, configurable: true } });
} : function(e11, t6) {
  e11.super_ = t6;
  var n5 = function() {
  };
  n5.prototype = t6.prototype, e11.prototype = new n5(), e11.prototype.constructor = e11;
};
var dl = Object.getOwnPropertyDescriptors || function(e11) {
  for (var t6 = Object.keys(e11), n5 = {}, r8 = 0; r8 < t6.length; r8++) n5[t6[r8]] = Object.getOwnPropertyDescriptor(e11, t6[r8]);
  return n5;
};
var ul = /%[sdj%]/g;
function hl(e11) {
  if (!Ml(e11)) {
    for (var t6 = [], n5 = 0; n5 < arguments.length; n5++) t6.push(yl(arguments[n5]));
    return t6.join(" ");
  }
  n5 = 1;
  for (var r8 = arguments, i9 = r8.length, o6 = String(e11).replace(ul, function(e12) {
    if ("%%" === e12) return "%";
    if (n5 >= i9) return e12;
    switch (e12) {
      case "%s":
        return String(r8[n5++]);
      case "%d":
        return Number(r8[n5++]);
      case "%j":
        try {
          return JSON.stringify(r8[n5++]);
        } catch (e13) {
          return "[Circular]";
        }
      default:
        return e12;
    }
  }), s5 = r8[n5]; n5 < i9; s5 = r8[++n5]) kl(s5) || !Pl(s5) ? o6 += " " + s5 : o6 += " " + yl(s5);
  return o6;
}
function fl(e11, t6) {
  if (Tl(l8.process)) return function() {
    return fl(e11, t6).apply(this, arguments);
  };
  if (true === ua2.noDeprecation) return e11;
  var n5 = false;
  return function() {
    if (!n5) {
      if (ua2.throwDeprecation) throw new Error(t6);
      ua2.traceDeprecation ? console.trace(t6) : console.error(t6), n5 = true;
    }
    return e11.apply(this, arguments);
  };
}
var pl;
var gl = {};
function ml(e11) {
  if (Tl(pl) && (pl = ua2.env.NODE_DEBUG || ""), e11 = e11.toUpperCase(), !gl[e11]) if (new RegExp("\\b" + e11 + "\\b", "i").test(pl)) {
    gl[e11] = function() {
      var t6 = hl.apply(null, arguments);
      console.error("%s %d: %s", e11, 0, t6);
    };
  } else gl[e11] = function() {
  };
  return gl[e11];
}
function yl(e11, t6) {
  var n5 = { seen: [], stylize: bl };
  return arguments.length >= 3 && (n5.depth = arguments[2]), arguments.length >= 4 && (n5.colors = arguments[3]), Cl(t6) ? n5.showHidden = t6 : t6 && Hl(n5, t6), Tl(n5.showHidden) && (n5.showHidden = false), Tl(n5.depth) && (n5.depth = 2), Tl(n5.colors) && (n5.colors = false), Tl(n5.customInspect) && (n5.customInspect = true), n5.colors && (n5.stylize = vl), wl(n5, e11, n5.depth);
}
function vl(e11, t6) {
  var n5 = yl.styles[t6];
  return n5 ? "\x1B[" + yl.colors[n5][0] + "m" + e11 + "\x1B[" + yl.colors[n5][1] + "m" : e11;
}
function bl(e11, t6) {
  return e11;
}
function wl(e11, t6, n5) {
  if (e11.customInspect && t6 && Ll(t6.inspect) && t6.inspect !== yl && (!t6.constructor || t6.constructor.prototype !== t6)) {
    var r8 = t6.inspect(n5, e11);
    return Ml(r8) || (r8 = wl(e11, r8, n5)), r8;
  }
  var i9 = function(e12, t7) {
    if (Tl(t7)) return e12.stylize("undefined", "undefined");
    if (Ml(t7)) {
      var n6 = "'" + JSON.stringify(t7).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e12.stylize(n6, "string");
    }
    if (xl(t7)) return e12.stylize("" + t7, "number");
    if (Cl(t7)) return e12.stylize("" + t7, "boolean");
    if (kl(t7)) return e12.stylize("null", "null");
  }(e11, t6);
  if (i9) return i9;
  var o6 = Object.keys(t6), s5 = function(e12) {
    var t7 = {};
    return e12.forEach(function(e13, n6) {
      t7[e13] = true;
    }), t7;
  }(o6);
  if (e11.showHidden && (o6 = Object.getOwnPropertyNames(t6)), Nl(t6) && (o6.indexOf("message") >= 0 || o6.indexOf("description") >= 0)) return El(t6);
  if (0 === o6.length) {
    if (Ll(t6)) {
      var a6 = t6.name ? ": " + t6.name : "";
      return e11.stylize("[Function" + a6 + "]", "special");
    }
    if (Rl(t6)) return e11.stylize(RegExp.prototype.toString.call(t6), "regexp");
    if (Ol(t6)) return e11.stylize(Date.prototype.toString.call(t6), "date");
    if (Nl(t6)) return El(t6);
  }
  var c9, l9 = "", d7 = false, u10 = ["{", "}"];
  (_l(t6) && (d7 = true, u10 = ["[", "]"]), Ll(t6)) && (l9 = " [Function" + (t6.name ? ": " + t6.name : "") + "]");
  return Rl(t6) && (l9 = " " + RegExp.prototype.toString.call(t6)), Ol(t6) && (l9 = " " + Date.prototype.toUTCString.call(t6)), Nl(t6) && (l9 = " " + El(t6)), 0 !== o6.length || d7 && 0 != t6.length ? n5 < 0 ? Rl(t6) ? e11.stylize(RegExp.prototype.toString.call(t6), "regexp") : e11.stylize("[Object]", "special") : (e11.seen.push(t6), c9 = d7 ? function(e12, t7, n6, r9, i10) {
    for (var o7 = [], s6 = 0, a7 = t7.length; s6 < a7; ++s6) Fl(t7, String(s6)) ? o7.push(Sl(e12, t7, n6, r9, String(s6), true)) : o7.push("");
    return i10.forEach(function(i11) {
      i11.match(/^\d+$/) || o7.push(Sl(e12, t7, n6, r9, i11, true));
    }), o7;
  }(e11, t6, n5, s5, o6) : o6.map(function(r9) {
    return Sl(e11, t6, n5, s5, r9, d7);
  }), e11.seen.pop(), function(e12, t7, n6) {
    var r9 = e12.reduce(function(e13, t8) {
      return t8.indexOf("\n"), e13 + t8.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (r9 > 60) return n6[0] + ("" === t7 ? "" : t7 + "\n ") + " " + e12.join(",\n  ") + " " + n6[1];
    return n6[0] + t7 + " " + e12.join(", ") + " " + n6[1];
  }(c9, l9, u10)) : u10[0] + l9 + u10[1];
}
function El(e11) {
  return "[" + Error.prototype.toString.call(e11) + "]";
}
function Sl(e11, t6, n5, r8, i9, o6) {
  var s5, a6, c9;
  if ((c9 = Object.getOwnPropertyDescriptor(t6, i9) || { value: t6[i9] }).get ? a6 = c9.set ? e11.stylize("[Getter/Setter]", "special") : e11.stylize("[Getter]", "special") : c9.set && (a6 = e11.stylize("[Setter]", "special")), Fl(r8, i9) || (s5 = "[" + i9 + "]"), a6 || (e11.seen.indexOf(c9.value) < 0 ? (a6 = kl(n5) ? wl(e11, c9.value, null) : wl(e11, c9.value, n5 - 1)).indexOf("\n") > -1 && (a6 = o6 ? a6.split("\n").map(function(e12) {
    return "  " + e12;
  }).join("\n").substr(2) : "\n" + a6.split("\n").map(function(e12) {
    return "   " + e12;
  }).join("\n")) : a6 = e11.stylize("[Circular]", "special")), Tl(s5)) {
    if (o6 && i9.match(/^\d+$/)) return a6;
    (s5 = JSON.stringify("" + i9)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s5 = s5.substr(1, s5.length - 2), s5 = e11.stylize(s5, "name")) : (s5 = s5.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s5 = e11.stylize(s5, "string"));
  }
  return s5 + ": " + a6;
}
function _l(e11) {
  return Array.isArray(e11);
}
function Cl(e11) {
  return "boolean" == typeof e11;
}
function kl(e11) {
  return null === e11;
}
function Al(e11) {
  return null == e11;
}
function xl(e11) {
  return "number" == typeof e11;
}
function Ml(e11) {
  return "string" == typeof e11;
}
function Il(e11) {
  return "symbol" == typeof e11;
}
function Tl(e11) {
  return void 0 === e11;
}
function Rl(e11) {
  return Pl(e11) && "[object RegExp]" === Bl(e11);
}
function Pl(e11) {
  return "object" == typeof e11 && null !== e11;
}
function Ol(e11) {
  return Pl(e11) && "[object Date]" === Bl(e11);
}
function Nl(e11) {
  return Pl(e11) && ("[object Error]" === Bl(e11) || e11 instanceof Error);
}
function Ll(e11) {
  return "function" == typeof e11;
}
function Dl(e11) {
  return null === e11 || "boolean" == typeof e11 || "number" == typeof e11 || "string" == typeof e11 || "symbol" == typeof e11 || void 0 === e11;
}
function $l(e11) {
  return C9.isBuffer(e11);
}
function Bl(e11) {
  return Object.prototype.toString.call(e11);
}
function Kl(e11) {
  return e11 < 10 ? "0" + e11.toString(10) : e11.toString(10);
}
yl.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, yl.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
var jl = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Ul() {
  var e11, t6;
  console.log("%s - %s", (e11 = /* @__PURE__ */ new Date(), t6 = [Kl(e11.getHours()), Kl(e11.getMinutes()), Kl(e11.getSeconds())].join(":"), [e11.getDate(), jl[e11.getMonth()], t6].join(" ")), hl.apply(null, arguments));
}
function Hl(e11, t6) {
  if (!t6 || !Pl(t6)) return e11;
  for (var n5 = Object.keys(t6), r8 = n5.length; r8--; ) e11[n5[r8]] = t6[n5[r8]];
  return e11;
}
function Fl(e11, t6) {
  return Object.prototype.hasOwnProperty.call(e11, t6);
}
var zl = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function ql(e11) {
  if ("function" != typeof e11) throw new TypeError('The "original" argument must be of type Function');
  if (zl && e11[zl]) {
    var t6;
    if ("function" != typeof (t6 = e11[zl])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t6, zl, { value: t6, enumerable: false, writable: false, configurable: true }), t6;
  }
  function t6() {
    for (var t7, n5, r8 = new Promise(function(e12, r9) {
      t7 = e12, n5 = r9;
    }), i9 = [], o6 = 0; o6 < arguments.length; o6++) i9.push(arguments[o6]);
    i9.push(function(e12, r9) {
      e12 ? n5(e12) : t7(r9);
    });
    try {
      e11.apply(this, i9);
    } catch (e12) {
      n5(e12);
    }
    return r8;
  }
  return Object.setPrototypeOf(t6, Object.getPrototypeOf(e11)), zl && Object.defineProperty(t6, zl, { value: t6, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t6, dl(e11));
}
function Wl(e11, t6) {
  if (!e11) {
    var n5 = new Error("Promise was rejected with a falsy value");
    n5.reason = e11, e11 = n5;
  }
  return t6(e11);
}
function Vl(e11) {
  if ("function" != typeof e11) throw new TypeError('The "original" argument must be of type Function');
  function t6() {
    for (var t7 = [], n5 = 0; n5 < arguments.length; n5++) t7.push(arguments[n5]);
    var r8 = t7.pop();
    if ("function" != typeof r8) throw new TypeError("The last argument must be of type Function");
    var i9 = this, o6 = function() {
      return r8.apply(i9, arguments);
    };
    e11.apply(this, t7).then(function(e12) {
      ua2.nextTick(o6.bind(null, null, e12));
    }, function(e12) {
      ua2.nextTick(Wl.bind(null, e12, o6));
    });
  }
  return Object.setPrototypeOf(t6, Object.getPrototypeOf(e11)), Object.defineProperties(t6, dl(e11)), t6;
}
ql.custom = zl;
var Gl;
var Yl;
var Zl;
var Jl;
var Ql = { inherits: cl, _extend: Hl, log: Ul, isBuffer: $l, isPrimitive: Dl, isFunction: Ll, isError: Nl, isDate: Ol, isObject: Pl, isRegExp: Rl, isUndefined: Tl, isSymbol: Il, isString: Ml, isNumber: xl, isNullOrUndefined: Al, isNull: kl, isBoolean: Cl, isArray: _l, inspect: yl, deprecate: fl, format: hl, debuglog: ml, promisify: ql, callbackify: Vl };
var Xl = he4(Object.freeze({ __proto__: null, _extend: Hl, callbackify: Vl, debuglog: ml, default: Ql, deprecate: fl, format: hl, inherits: cl, inspect: yl, isArray: _l, isBoolean: Cl, isBuffer: $l, isDate: Ol, isError: Nl, isFunction: Ll, isNull: kl, isNullOrUndefined: Al, isNumber: xl, isObject: Pl, isPrimitive: Dl, isRegExp: Rl, isString: Ml, isSymbol: Il, isUndefined: Tl, log: Ul, promisify: ql }));
function ed() {
  if (Yl) return Gl;
  function e11(e12, t7) {
    var n6 = Object.keys(e12);
    if (Object.getOwnPropertySymbols) {
      var r9 = Object.getOwnPropertySymbols(e12);
      t7 && (r9 = r9.filter(function(t8) {
        return Object.getOwnPropertyDescriptor(e12, t8).enumerable;
      })), n6.push.apply(n6, r9);
    }
    return n6;
  }
  function t6(t7) {
    for (var r9 = 1; r9 < arguments.length; r9++) {
      var i10 = null != arguments[r9] ? arguments[r9] : {};
      r9 % 2 ? e11(Object(i10), true).forEach(function(e12) {
        n5(t7, e12, i10[e12]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t7, Object.getOwnPropertyDescriptors(i10)) : e11(Object(i10)).forEach(function(e12) {
        Object.defineProperty(t7, e12, Object.getOwnPropertyDescriptor(i10, e12));
      });
    }
    return t7;
  }
  function n5(e12, t7, n6) {
    return (t7 = i9(t7)) in e12 ? Object.defineProperty(e12, t7, { value: n6, enumerable: true, configurable: true, writable: true }) : e12[t7] = n6, e12;
  }
  function r8(e12, t7, n6) {
    return t7 && function(e13, t8) {
      for (var n7 = 0; n7 < t8.length; n7++) {
        var r9 = t8[n7];
        r9.enumerable = r9.enumerable || false, r9.configurable = true, "value" in r9 && (r9.writable = true), Object.defineProperty(e13, i9(r9.key), r9);
      }
    }(e12.prototype, t7), Object.defineProperty(e12, "prototype", { writable: false }), e12;
  }
  function i9(e12) {
    var t7 = function(e13, t8) {
      if ("object" != typeof e13 || null === e13) return e13;
      var n6 = e13[Symbol.toPrimitive];
      if (void 0 !== n6) {
        var r9 = n6.call(e13, t8 || "default");
        if ("object" != typeof r9) return r9;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t8 ? String : Number)(e13);
    }(e12, "string");
    return "symbol" == typeof t7 ? t7 : String(t7);
  }
  Yl = 1;
  var o6 = ll.Buffer, s5 = Xl.inspect, a6 = s5 && s5.custom || "inspect";
  return Gl = function() {
    function e12() {
      !function(e13, t7) {
        if (!(e13 instanceof t7)) throw new TypeError("Cannot call a class as a function");
      }(this, e12), this.head = null, this.tail = null, this.length = 0;
    }
    return r8(e12, [{ key: "push", value: function(e13) {
      var t7 = { data: e13, next: null };
      this.length > 0 ? this.tail.next = t7 : this.head = t7, this.tail = t7, ++this.length;
    } }, { key: "unshift", value: function(e13) {
      var t7 = { data: e13, next: this.head };
      0 === this.length && (this.tail = t7), this.head = t7, ++this.length;
    } }, { key: "shift", value: function() {
      if (0 !== this.length) {
        var e13 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e13;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(e13) {
      if (0 === this.length) return "";
      for (var t7 = this.head, n6 = "" + t7.data; t7 = t7.next; ) n6 += e13 + t7.data;
      return n6;
    } }, { key: "concat", value: function(e13) {
      if (0 === this.length) return o6.alloc(0);
      for (var t7, n6, r9, i10 = o6.allocUnsafe(e13 >>> 0), s6 = this.head, a7 = 0; s6; ) t7 = s6.data, n6 = i10, r9 = a7, o6.prototype.copy.call(t7, n6, r9), a7 += s6.data.length, s6 = s6.next;
      return i10;
    } }, { key: "consume", value: function(e13, t7) {
      var n6;
      return e13 < this.head.data.length ? (n6 = this.head.data.slice(0, e13), this.head.data = this.head.data.slice(e13)) : n6 = e13 === this.head.data.length ? this.shift() : t7 ? this._getString(e13) : this._getBuffer(e13), n6;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(e13) {
      var t7 = this.head, n6 = 1, r9 = t7.data;
      for (e13 -= r9.length; t7 = t7.next; ) {
        var i10 = t7.data, o7 = e13 > i10.length ? i10.length : e13;
        if (o7 === i10.length ? r9 += i10 : r9 += i10.slice(0, e13), 0 === (e13 -= o7)) {
          o7 === i10.length ? (++n6, t7.next ? this.head = t7.next : this.head = this.tail = null) : (this.head = t7, t7.data = i10.slice(o7));
          break;
        }
        ++n6;
      }
      return this.length -= n6, r9;
    } }, { key: "_getBuffer", value: function(e13) {
      var t7 = o6.allocUnsafe(e13), n6 = this.head, r9 = 1;
      for (n6.data.copy(t7), e13 -= n6.data.length; n6 = n6.next; ) {
        var i10 = n6.data, s6 = e13 > i10.length ? i10.length : e13;
        if (i10.copy(t7, t7.length - e13, 0, s6), 0 === (e13 -= s6)) {
          s6 === i10.length ? (++r9, n6.next ? this.head = n6.next : this.head = this.tail = null) : (this.head = n6, n6.data = i10.slice(s6));
          break;
        }
        ++r9;
      }
      return this.length -= r9, t7;
    } }, { key: a6, value: function(e13, n6) {
      return s5(this, t6(t6({}, n6), {}, { depth: 0, customInspect: false }));
    } }]), e12;
  }(), Gl;
}
function td() {
  if (Jl) return Zl;
  function e11(e12, r8) {
    n5(e12, r8), t6(e12);
  }
  function t6(e12) {
    e12._writableState && !e12._writableState.emitClose || e12._readableState && !e12._readableState.emitClose || e12.emit("close");
  }
  function n5(e12, t7) {
    e12.emit("error", t7);
  }
  return Jl = 1, Zl = { destroy: function(r8, i9) {
    var o6 = this, s5 = this._readableState && this._readableState.destroyed, a6 = this._writableState && this._writableState.destroyed;
    return s5 || a6 ? (i9 ? i9(r8) : r8 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, ua2.nextTick(n5, this, r8)) : ua2.nextTick(n5, this, r8)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(r8 || null, function(n6) {
      !i9 && n6 ? o6._writableState ? o6._writableState.errorEmitted ? ua2.nextTick(t6, o6) : (o6._writableState.errorEmitted = true, ua2.nextTick(e11, o6, n6)) : ua2.nextTick(e11, o6, n6) : i9 ? (ua2.nextTick(t6, o6), i9(n6)) : ua2.nextTick(t6, o6);
    }), this);
  }, undestroy: function() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }, errorOrDestroy: function(e12, t7) {
    var n6 = e12._readableState, r8 = e12._writableState;
    n6 && n6.autoDestroy || r8 && r8.autoDestroy ? e12.destroy(t7) : e12.emit("error", t7);
  } }, Zl;
}
var nd = {};
var rd;
var id;
var od = {};
function sd(e11, t6, n5) {
  n5 || (n5 = Error);
  var r8 = function(e12) {
    var n6, r9;
    function i9(n7, r10, i10) {
      return e12.call(this, function(e13, n8, r11) {
        return "string" == typeof t6 ? t6 : t6(e13, n8, r11);
      }(n7, r10, i10)) || this;
    }
    return r9 = e12, (n6 = i9).prototype = Object.create(r9.prototype), n6.prototype.constructor = n6, n6.__proto__ = r9, i9;
  }(n5);
  r8.prototype.name = n5.name, r8.prototype.code = e11, od[e11] = r8;
}
function ad(e11, t6) {
  if (Array.isArray(e11)) {
    var n5 = e11.length;
    return e11 = e11.map(function(e12) {
      return String(e12);
    }), n5 > 2 ? "one of ".concat(t6, " ").concat(e11.slice(0, n5 - 1).join(", "), ", or ") + e11[n5 - 1] : 2 === n5 ? "one of ".concat(t6, " ").concat(e11[0], " or ").concat(e11[1]) : "of ".concat(t6, " ").concat(e11[0]);
  }
  return "of ".concat(t6, " ").concat(String(e11));
}
function cd() {
  if (id) return rd;
  id = 1;
  var e11 = nd.codes.ERR_INVALID_OPT_VALUE;
  return rd = { getHighWaterMark: function(t6, n5, r8, i9) {
    var o6 = function(e12, t7, n6) {
      return null != e12.highWaterMark ? e12.highWaterMark : t7 ? e12[n6] : null;
    }(n5, i9, r8);
    if (null != o6) {
      if (!isFinite(o6) || Math.floor(o6) !== o6 || o6 < 0) throw new e11(i9 ? r8 : "highWaterMark", o6);
      return Math.floor(o6);
    }
    return t6.objectMode ? 16 : 16384;
  } };
}
sd("ERR_INVALID_OPT_VALUE", function(e11, t6) {
  return 'The value "' + t6 + '" is invalid for option "' + e11 + '"';
}, TypeError), sd("ERR_INVALID_ARG_TYPE", function(e11, t6, n5) {
  var r8, i9, o6;
  if ("string" == typeof t6 && (i9 = "not ", t6.substr(0, i9.length) === i9) ? (r8 = "must not be", t6 = t6.replace(/^not /, "")) : r8 = "must be", function(e12, t7, n6) {
    return (void 0 === n6 || n6 > e12.length) && (n6 = e12.length), e12.substring(n6 - t7.length, n6) === t7;
  }(e11, " argument")) o6 = "The ".concat(e11, " ").concat(r8, " ").concat(ad(t6, "type"));
  else {
    var s5 = function(e12, t7, n6) {
      return "number" != typeof n6 && (n6 = 0), !(n6 + t7.length > e12.length) && -1 !== e12.indexOf(t7, n6);
    }(e11, ".") ? "property" : "argument";
    o6 = 'The "'.concat(e11, '" ').concat(s5, " ").concat(r8, " ").concat(ad(t6, "type"));
  }
  return o6 += ". Received type ".concat(typeof n5);
}, TypeError), sd("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), sd("ERR_METHOD_NOT_IMPLEMENTED", function(e11) {
  return "The " + e11 + " method is not implemented";
}), sd("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), sd("ERR_STREAM_DESTROYED", function(e11) {
  return "Cannot call " + e11 + " after a stream was destroyed";
}), sd("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), sd("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), sd("ERR_STREAM_WRITE_AFTER_END", "write after end"), sd("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), sd("ERR_UNKNOWN_ENCODING", function(e11) {
  return "Unknown encoding: " + e11;
}, TypeError), sd("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), nd.codes = od;
var ld;
var dd;
var ud;
var hd;
var fd;
var pd;
var gd = "function" == typeof Object.create ? function(e11, t6) {
  e11.super_ = t6, e11.prototype = Object.create(t6.prototype, { constructor: { value: e11, enumerable: false, writable: true, configurable: true } });
} : function(e11, t6) {
  e11.super_ = t6;
  var n5 = function() {
  };
  n5.prototype = t6.prototype, e11.prototype = new n5(), e11.prototype.constructor = e11;
};
var md = he4(Object.freeze({ __proto__: null, default: gd }));
function yd() {
  if (dd) return ld;
  function e11(e12) {
    try {
      if (!de4.localStorage) return false;
    } catch (e13) {
      return false;
    }
    var t6 = de4.localStorage[e12];
    return null != t6 && "true" === String(t6).toLowerCase();
  }
  return dd = 1, ld = function(t6, n5) {
    if (e11("noDeprecation")) return t6;
    var r8 = false;
    return function() {
      if (!r8) {
        if (e11("throwDeprecation")) throw new Error(n5);
        e11("traceDeprecation") ? console.trace(n5) : console.warn(n5), r8 = true;
      }
      return t6.apply(this, arguments);
    };
  }, ld;
}
function vd() {
  if (hd) return ud;
  function e11(e12) {
    var t7 = this;
    this.next = null, this.entry = null, this.finish = function() {
      !function(e13, t8, n6) {
        var r9 = e13.entry;
        e13.entry = null;
        for (; r9; ) {
          var i10 = r9.callback;
          t8.pendingcb--, i10(n6), r9 = r9.next;
        }
        t8.corkedRequestsFree.next = e13;
      }(t7, e12);
    };
  }
  var t6;
  hd = 1, ud = E8, E8.WritableState = w8;
  var n5 = { deprecate: yd() }, r8 = al(), i9 = ll.Buffer, o6 = (void 0 !== de4 ? de4 : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var s5, a6 = td(), c9 = cd().getHighWaterMark, l9 = nd.codes, d7 = l9.ERR_INVALID_ARG_TYPE, u10 = l9.ERR_METHOD_NOT_IMPLEMENTED, h9 = l9.ERR_MULTIPLE_CALLBACK, f16 = l9.ERR_STREAM_CANNOT_PIPE, p9 = l9.ERR_STREAM_DESTROYED, g4 = l9.ERR_STREAM_NULL_VALUES, m6 = l9.ERR_STREAM_WRITE_AFTER_END, y11 = l9.ERR_UNKNOWN_ENCODING, v9 = a6.errorOrDestroy;
  function b6() {
  }
  function w8(n6, r9, i10) {
    t6 = t6 || bd(), n6 = n6 || {}, "boolean" != typeof i10 && (i10 = r9 instanceof t6), this.objectMode = !!n6.objectMode, i10 && (this.objectMode = this.objectMode || !!n6.writableObjectMode), this.highWaterMark = c9(this, n6, "writableHighWaterMark", i10), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var o7 = false === n6.decodeStrings;
    this.decodeStrings = !o7, this.defaultEncoding = n6.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e12) {
      !function(e13, t7) {
        var n7 = e13._writableState, r10 = n7.sync, i11 = n7.writecb;
        if ("function" != typeof i11) throw new h9();
        if (function(e14) {
          e14.writing = false, e14.writecb = null, e14.length -= e14.writelen, e14.writelen = 0;
        }(n7), t7) !function(e14, t8, n8, r11, i12) {
          --t8.pendingcb, n8 ? (ua2.nextTick(i12, r11), ua2.nextTick(x7, e14, t8), e14._writableState.errorEmitted = true, v9(e14, r11)) : (i12(r11), e14._writableState.errorEmitted = true, v9(e14, r11), x7(e14, t8));
        }(e13, n7, r10, t7, i11);
        else {
          var o8 = k11(n7) || e13.destroyed;
          o8 || n7.corked || n7.bufferProcessing || !n7.bufferedRequest || C10(e13, n7), r10 ? ua2.nextTick(_6, e13, n7, o8, i11) : _6(e13, n7, o8, i11);
        }
      }(r9, e12);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== n6.emitClose, this.autoDestroy = !!n6.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e11(this);
  }
  function E8(e12) {
    var n6 = this instanceof (t6 = t6 || bd());
    if (!n6 && !s5.call(E8, this)) return new E8(e12);
    this._writableState = new w8(e12, this, n6), this.writable = true, e12 && ("function" == typeof e12.write && (this._write = e12.write), "function" == typeof e12.writev && (this._writev = e12.writev), "function" == typeof e12.destroy && (this._destroy = e12.destroy), "function" == typeof e12.final && (this._final = e12.final)), r8.call(this);
  }
  function S8(e12, t7, n6, r9, i10, o7, s6) {
    t7.writelen = r9, t7.writecb = s6, t7.writing = true, t7.sync = true, t7.destroyed ? t7.onwrite(new p9("write")) : n6 ? e12._writev(i10, t7.onwrite) : e12._write(i10, o7, t7.onwrite), t7.sync = false;
  }
  function _6(e12, t7, n6, r9) {
    n6 || function(e13, t8) {
      0 === t8.length && t8.needDrain && (t8.needDrain = false, e13.emit("drain"));
    }(e12, t7), t7.pendingcb--, r9(), x7(e12, t7);
  }
  function C10(t7, n6) {
    n6.bufferProcessing = true;
    var r9 = n6.bufferedRequest;
    if (t7._writev && r9 && r9.next) {
      var i10 = n6.bufferedRequestCount, o7 = new Array(i10), s6 = n6.corkedRequestsFree;
      s6.entry = r9;
      for (var a7 = 0, c10 = true; r9; ) o7[a7] = r9, r9.isBuf || (c10 = false), r9 = r9.next, a7 += 1;
      o7.allBuffers = c10, S8(t7, n6, true, n6.length, o7, "", s6.finish), n6.pendingcb++, n6.lastBufferedRequest = null, s6.next ? (n6.corkedRequestsFree = s6.next, s6.next = null) : n6.corkedRequestsFree = new e11(n6), n6.bufferedRequestCount = 0;
    } else {
      for (; r9; ) {
        var l10 = r9.chunk, d8 = r9.encoding, u11 = r9.callback;
        if (S8(t7, n6, false, n6.objectMode ? 1 : l10.length, l10, d8, u11), r9 = r9.next, n6.bufferedRequestCount--, n6.writing) break;
      }
      null === r9 && (n6.lastBufferedRequest = null);
    }
    n6.bufferedRequest = r9, n6.bufferProcessing = false;
  }
  function k11(e12) {
    return e12.ending && 0 === e12.length && null === e12.bufferedRequest && !e12.finished && !e12.writing;
  }
  function A9(e12, t7) {
    e12._final(function(n6) {
      t7.pendingcb--, n6 && v9(e12, n6), t7.prefinished = true, e12.emit("prefinish"), x7(e12, t7);
    });
  }
  function x7(e12, t7) {
    var n6 = k11(t7);
    if (n6 && (function(e13, t8) {
      t8.prefinished || t8.finalCalled || ("function" != typeof e13._final || t8.destroyed ? (t8.prefinished = true, e13.emit("prefinish")) : (t8.pendingcb++, t8.finalCalled = true, ua2.nextTick(A9, e13, t8)));
    }(e12, t7), 0 === t7.pendingcb && (t7.finished = true, e12.emit("finish"), t7.autoDestroy))) {
      var r9 = e12._readableState;
      (!r9 || r9.autoDestroy && r9.endEmitted) && e12.destroy();
    }
    return n6;
  }
  return md(E8, r8), w8.prototype.getBuffer = function() {
    for (var e12 = this.bufferedRequest, t7 = []; e12; ) t7.push(e12), e12 = e12.next;
    return t7;
  }, function() {
    try {
      Object.defineProperty(w8.prototype, "buffer", { get: n5.deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch (e12) {
    }
  }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (s5 = Function.prototype[Symbol.hasInstance], Object.defineProperty(E8, Symbol.hasInstance, { value: function(e12) {
    return !!s5.call(this, e12) || this === E8 && (e12 && e12._writableState instanceof w8);
  } })) : s5 = function(e12) {
    return e12 instanceof this;
  }, E8.prototype.pipe = function() {
    v9(this, new f16());
  }, E8.prototype.write = function(e12, t7, n6) {
    var r9, s6 = this._writableState, a7 = false, c10 = !s6.objectMode && (r9 = e12, i9.isBuffer(r9) || r9 instanceof o6);
    return c10 && !i9.isBuffer(e12) && (e12 = function(e13) {
      return i9.from(e13);
    }(e12)), "function" == typeof t7 && (n6 = t7, t7 = null), c10 ? t7 = "buffer" : t7 || (t7 = s6.defaultEncoding), "function" != typeof n6 && (n6 = b6), s6.ending ? function(e13, t8) {
      var n7 = new m6();
      v9(e13, n7), ua2.nextTick(t8, n7);
    }(this, n6) : (c10 || function(e13, t8, n7, r10) {
      var i10;
      return null === n7 ? i10 = new g4() : "string" == typeof n7 || t8.objectMode || (i10 = new d7("chunk", ["string", "Buffer"], n7)), !i10 || (v9(e13, i10), ua2.nextTick(r10, i10), false);
    }(this, s6, e12, n6)) && (s6.pendingcb++, a7 = function(e13, t8, n7, r10, o7, s7) {
      if (!n7) {
        var a8 = function(e14, t9, n8) {
          e14.objectMode || false === e14.decodeStrings || "string" != typeof t9 || (t9 = i9.from(t9, n8));
          return t9;
        }(t8, r10, o7);
        r10 !== a8 && (n7 = true, o7 = "buffer", r10 = a8);
      }
      var c11 = t8.objectMode ? 1 : r10.length;
      t8.length += c11;
      var l10 = t8.length < t8.highWaterMark;
      l10 || (t8.needDrain = true);
      if (t8.writing || t8.corked) {
        var d8 = t8.lastBufferedRequest;
        t8.lastBufferedRequest = { chunk: r10, encoding: o7, isBuf: n7, callback: s7, next: null }, d8 ? d8.next = t8.lastBufferedRequest : t8.bufferedRequest = t8.lastBufferedRequest, t8.bufferedRequestCount += 1;
      } else S8(e13, t8, false, c11, r10, o7, s7);
      return l10;
    }(this, s6, c10, e12, t7, n6)), a7;
  }, E8.prototype.cork = function() {
    this._writableState.corked++;
  }, E8.prototype.uncork = function() {
    var e12 = this._writableState;
    e12.corked && (e12.corked--, e12.writing || e12.corked || e12.bufferProcessing || !e12.bufferedRequest || C10(this, e12));
  }, E8.prototype.setDefaultEncoding = function(e12) {
    if ("string" == typeof e12 && (e12 = e12.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e12 + "").toLowerCase()) > -1)) throw new y11(e12);
    return this._writableState.defaultEncoding = e12, this;
  }, Object.defineProperty(E8.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(E8.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), E8.prototype._write = function(e12, t7, n6) {
    n6(new u10("_write()"));
  }, E8.prototype._writev = null, E8.prototype.end = function(e12, t7, n6) {
    var r9 = this._writableState;
    return "function" == typeof e12 ? (n6 = e12, e12 = null, t7 = null) : "function" == typeof t7 && (n6 = t7, t7 = null), null != e12 && this.write(e12, t7), r9.corked && (r9.corked = 1, this.uncork()), r9.ending || function(e13, t8, n7) {
      t8.ending = true, x7(e13, t8), n7 && (t8.finished ? ua2.nextTick(n7) : e13.once("finish", n7));
      t8.ended = true, e13.writable = false;
    }(this, r9, n6), this;
  }, Object.defineProperty(E8.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(E8.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  }, set: function(e12) {
    this._writableState && (this._writableState.destroyed = e12);
  } }), E8.prototype.destroy = a6.destroy, E8.prototype._undestroy = a6.undestroy, E8.prototype._destroy = function(e12, t7) {
    t7(e12);
  }, ud;
}
function bd() {
  if (pd) return fd;
  pd = 1;
  var e11 = Object.keys || function(e12) {
    var t7 = [];
    for (var n6 in e12) t7.push(n6);
    return t7;
  };
  fd = s5;
  var t6 = Dd(), n5 = vd();
  md(s5, t6);
  for (var r8 = e11(n5.prototype), i9 = 0; i9 < r8.length; i9++) {
    var o6 = r8[i9];
    s5.prototype[o6] || (s5.prototype[o6] = n5.prototype[o6]);
  }
  function s5(e12) {
    if (!(this instanceof s5)) return new s5(e12);
    t6.call(this, e12), n5.call(this, e12), this.allowHalfOpen = true, e12 && (false === e12.readable && (this.readable = false), false === e12.writable && (this.writable = false), false === e12.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a6)));
  }
  function a6() {
    this._writableState.ended || ua2.nextTick(c9, this);
  }
  function c9(e12) {
    e12.end();
  }
  return Object.defineProperty(s5.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(s5.prototype, "writableBuffer", { enumerable: false, get: function() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(s5.prototype, "writableLength", { enumerable: false, get: function() {
    return this._writableState.length;
  } }), Object.defineProperty(s5.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
  }, set: function(e12) {
    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e12, this._writableState.destroyed = e12);
  } }), fd;
}
var wd = C9.isEncoding || function(e11) {
  switch (e11 && e11.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function Ed(e11) {
  switch (this.encoding = (e11 || "utf8").toLowerCase().replace(/[-_]/, ""), function(e12) {
    if (e12 && !wd(e12)) throw new Error("Unknown encoding: " + e12);
  }(e11), this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2, this.detectIncompleteChar = _d;
      break;
    case "base64":
      this.surrogateSize = 3, this.detectIncompleteChar = Cd;
      break;
    default:
      return void (this.write = Sd);
  }
  this.charBuffer = new C9(6), this.charReceived = 0, this.charLength = 0;
}
function Sd(e11) {
  return e11.toString(this.encoding);
}
function _d(e11) {
  this.charReceived = e11.length % 2, this.charLength = this.charReceived ? 2 : 0;
}
function Cd(e11) {
  this.charReceived = e11.length % 3, this.charLength = this.charReceived ? 3 : 0;
}
Ed.prototype.write = function(e11) {
  for (var t6 = ""; this.charLength; ) {
    var n5 = e11.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e11.length;
    if (e11.copy(this.charBuffer, this.charReceived, 0, n5), this.charReceived += n5, this.charReceived < this.charLength) return "";
    if (e11 = e11.slice(n5, e11.length), !((i9 = (t6 = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t6.length - 1)) >= 55296 && i9 <= 56319)) {
      if (this.charReceived = this.charLength = 0, 0 === e11.length) return t6;
      break;
    }
    this.charLength += this.surrogateSize, t6 = "";
  }
  this.detectIncompleteChar(e11);
  var r8 = e11.length;
  this.charLength && (e11.copy(this.charBuffer, 0, e11.length - this.charReceived, r8), r8 -= this.charReceived);
  var i9;
  r8 = (t6 += e11.toString(this.encoding, 0, r8)).length - 1;
  if ((i9 = t6.charCodeAt(r8)) >= 55296 && i9 <= 56319) {
    var o6 = this.surrogateSize;
    return this.charLength += o6, this.charReceived += o6, this.charBuffer.copy(this.charBuffer, o6, 0, o6), e11.copy(this.charBuffer, 0, 0, o6), t6.substring(0, r8);
  }
  return t6;
}, Ed.prototype.detectIncompleteChar = function(e11) {
  for (var t6 = e11.length >= 3 ? 3 : e11.length; t6 > 0; t6--) {
    var n5 = e11[e11.length - t6];
    if (1 == t6 && n5 >> 5 == 6) {
      this.charLength = 2;
      break;
    }
    if (t6 <= 2 && n5 >> 4 == 14) {
      this.charLength = 3;
      break;
    }
    if (t6 <= 3 && n5 >> 3 == 30) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = t6;
}, Ed.prototype.end = function(e11) {
  var t6 = "";
  if (e11 && e11.length && (t6 = this.write(e11)), this.charReceived) {
    var n5 = this.charReceived, r8 = this.charBuffer, i9 = this.encoding;
    t6 += r8.slice(0, n5).toString(i9);
  }
  return t6;
};
var kd = he4(Object.freeze({ __proto__: null, StringDecoder: Ed }));
var Ad = nd.codes.ERR_STREAM_PREMATURE_CLOSE;
function xd() {
}
var Md;
var Id;
var Td;
var Rd;
var Pd;
var Od;
var Nd = function e9(t6, n5, r8) {
  if ("function" == typeof n5) return e9(t6, null, n5);
  n5 || (n5 = {}), r8 = /* @__PURE__ */ function(e11) {
    var t7 = false;
    return function() {
      if (!t7) {
        t7 = true;
        for (var n6 = arguments.length, r9 = new Array(n6), i10 = 0; i10 < n6; i10++) r9[i10] = arguments[i10];
        e11.apply(this, r9);
      }
    };
  }(r8 || xd);
  var i9 = n5.readable || false !== n5.readable && t6.readable, o6 = n5.writable || false !== n5.writable && t6.writable, s5 = function() {
    t6.writable || c9();
  }, a6 = t6._writableState && t6._writableState.finished, c9 = function() {
    o6 = false, a6 = true, i9 || r8.call(t6);
  }, l9 = t6._readableState && t6._readableState.endEmitted, d7 = function() {
    i9 = false, l9 = true, o6 || r8.call(t6);
  }, u10 = function(e11) {
    r8.call(t6, e11);
  }, h9 = function() {
    var e11;
    return i9 && !l9 ? (t6._readableState && t6._readableState.ended || (e11 = new Ad()), r8.call(t6, e11)) : o6 && !a6 ? (t6._writableState && t6._writableState.ended || (e11 = new Ad()), r8.call(t6, e11)) : void 0;
  }, f16 = function() {
    t6.req.on("finish", c9);
  };
  return !function(e11) {
    return e11.setHeader && "function" == typeof e11.abort;
  }(t6) ? o6 && !t6._writableState && (t6.on("end", s5), t6.on("close", s5)) : (t6.on("complete", c9), t6.on("abort", h9), t6.req ? f16() : t6.on("request", f16)), t6.on("end", d7), t6.on("finish", c9), false !== n5.error && t6.on("error", u10), t6.on("close", h9), function() {
    t6.removeListener("complete", c9), t6.removeListener("abort", h9), t6.removeListener("request", f16), t6.req && t6.req.removeListener("finish", c9), t6.removeListener("end", s5), t6.removeListener("close", s5), t6.removeListener("finish", c9), t6.removeListener("end", d7), t6.removeListener("error", u10), t6.removeListener("close", h9);
  };
};
function Ld() {
  if (Id) return Md;
  var e11;
  function t6(e12, t7, n6) {
    return (t7 = function(e13) {
      var t8 = function(e14, t9) {
        if ("object" != typeof e14 || null === e14) return e14;
        var n7 = e14[Symbol.toPrimitive];
        if (void 0 !== n7) {
          var r9 = n7.call(e14, t9 || "default");
          if ("object" != typeof r9) return r9;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t9 ? String : Number)(e14);
      }(e13, "string");
      return "symbol" == typeof t8 ? t8 : String(t8);
    }(t7)) in e12 ? Object.defineProperty(e12, t7, { value: n6, enumerable: true, configurable: true, writable: true }) : e12[t7] = n6, e12;
  }
  Id = 1;
  var n5 = Nd, r8 = Symbol("lastResolve"), i9 = Symbol("lastReject"), o6 = Symbol("error"), s5 = Symbol("ended"), a6 = Symbol("lastPromise"), c9 = Symbol("handlePromise"), l9 = Symbol("stream");
  function d7(e12, t7) {
    return { value: e12, done: t7 };
  }
  function u10(e12) {
    var t7 = e12[r8];
    if (null !== t7) {
      var n6 = e12[l9].read();
      null !== n6 && (e12[a6] = null, e12[r8] = null, e12[i9] = null, t7(d7(n6, false)));
    }
  }
  function h9(e12) {
    ua2.nextTick(u10, e12);
  }
  var f16 = Object.getPrototypeOf(function() {
  }), p9 = Object.setPrototypeOf((t6(e11 = { get stream() {
    return this[l9];
  }, next: function() {
    var e12 = this, t7 = this[o6];
    if (null !== t7) return Promise.reject(t7);
    if (this[s5]) return Promise.resolve(d7(void 0, true));
    if (this[l9].destroyed) return new Promise(function(t8, n7) {
      ua2.nextTick(function() {
        e12[o6] ? n7(e12[o6]) : t8(d7(void 0, true));
      });
    });
    var n6, r9 = this[a6];
    if (r9) n6 = new Promise(/* @__PURE__ */ function(e13, t8) {
      return function(n7, r10) {
        e13.then(function() {
          t8[s5] ? n7(d7(void 0, true)) : t8[c9](n7, r10);
        }, r10);
      };
    }(r9, this));
    else {
      var i10 = this[l9].read();
      if (null !== i10) return Promise.resolve(d7(i10, false));
      n6 = new Promise(this[c9]);
    }
    return this[a6] = n6, n6;
  } }, Symbol.asyncIterator, function() {
    return this;
  }), t6(e11, "return", function() {
    var e12 = this;
    return new Promise(function(t7, n6) {
      e12[l9].destroy(null, function(e13) {
        e13 ? n6(e13) : t7(d7(void 0, true));
      });
    });
  }), e11), f16);
  return Md = function(e12) {
    var u11, f17 = Object.create(p9, (t6(u11 = {}, l9, { value: e12, writable: true }), t6(u11, r8, { value: null, writable: true }), t6(u11, i9, { value: null, writable: true }), t6(u11, o6, { value: null, writable: true }), t6(u11, s5, { value: e12._readableState.endEmitted, writable: true }), t6(u11, c9, { value: function(e13, t7) {
      var n6 = f17[l9].read();
      n6 ? (f17[a6] = null, f17[r8] = null, f17[i9] = null, e13(d7(n6, false))) : (f17[r8] = e13, f17[i9] = t7);
    }, writable: true }), u11));
    return f17[a6] = null, n5(e12, function(e13) {
      if (e13 && "ERR_STREAM_PREMATURE_CLOSE" !== e13.code) {
        var t7 = f17[i9];
        return null !== t7 && (f17[a6] = null, f17[r8] = null, f17[i9] = null, t7(e13)), void (f17[o6] = e13);
      }
      var n6 = f17[r8];
      null !== n6 && (f17[a6] = null, f17[r8] = null, f17[i9] = null, n6(d7(void 0, true))), f17[s5] = true;
    }), e12.on("readable", h9.bind(null, f17)), f17;
  }, Md;
}
function Dd() {
  if (Od) return Pd;
  var e11;
  Od = 1, Pd = E8, E8.ReadableState = w8, lc2.EventEmitter;
  var t6 = function(e12, t7) {
    return e12.listeners(t7).length;
  }, n5 = al(), r8 = ll.Buffer, i9 = (void 0 !== de4 ? de4 : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var o6, s5 = Xl;
  o6 = s5 && s5.debuglog ? s5.debuglog("stream") : function() {
  };
  var a6, c9, l9, d7 = ed(), u10 = td(), h9 = cd().getHighWaterMark, f16 = nd.codes, p9 = f16.ERR_INVALID_ARG_TYPE, g4 = f16.ERR_STREAM_PUSH_AFTER_EOF, m6 = f16.ERR_METHOD_NOT_IMPLEMENTED, y11 = f16.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  md(E8, n5);
  var v9 = u10.errorOrDestroy, b6 = ["error", "close", "destroy", "pause", "resume"];
  function w8(t7, n6, r9) {
    e11 = e11 || bd(), t7 = t7 || {}, "boolean" != typeof r9 && (r9 = n6 instanceof e11), this.objectMode = !!t7.objectMode, r9 && (this.objectMode = this.objectMode || !!t7.readableObjectMode), this.highWaterMark = h9(this, t7, "readableHighWaterMark", r9), this.buffer = new d7(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t7.emitClose, this.autoDestroy = !!t7.autoDestroy, this.destroyed = false, this.defaultEncoding = t7.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t7.encoding && (a6 || (a6 = kd.StringDecoder), this.decoder = new a6(t7.encoding), this.encoding = t7.encoding);
  }
  function E8(t7) {
    if (e11 = e11 || bd(), !(this instanceof E8)) return new E8(t7);
    var r9 = this instanceof e11;
    this._readableState = new w8(t7, this, r9), this.readable = true, t7 && ("function" == typeof t7.read && (this._read = t7.read), "function" == typeof t7.destroy && (this._destroy = t7.destroy)), n5.call(this);
  }
  function S8(e12, t7, n6, s6, a7) {
    o6("readableAddChunk", t7);
    var c10, l10 = e12._readableState;
    if (null === t7) l10.reading = false, function(e13, t8) {
      if (o6("onEofChunk"), t8.ended) return;
      if (t8.decoder) {
        var n7 = t8.decoder.end();
        n7 && n7.length && (t8.buffer.push(n7), t8.length += t8.objectMode ? 1 : n7.length);
      }
      t8.ended = true, t8.sync ? A9(e13) : (t8.needReadable = false, t8.emittedReadable || (t8.emittedReadable = true, x7(e13)));
    }(e12, l10);
    else if (a7 || (c10 = function(e13, t8) {
      var n7;
      o7 = t8, r8.isBuffer(o7) || o7 instanceof i9 || "string" == typeof t8 || void 0 === t8 || e13.objectMode || (n7 = new p9("chunk", ["string", "Buffer", "Uint8Array"], t8));
      var o7;
      return n7;
    }(l10, t7)), c10) v9(e12, c10);
    else if (l10.objectMode || t7 && t7.length > 0) if ("string" == typeof t7 || l10.objectMode || Object.getPrototypeOf(t7) === r8.prototype || (t7 = function(e13) {
      return r8.from(e13);
    }(t7)), s6) l10.endEmitted ? v9(e12, new y11()) : _6(e12, l10, t7, true);
    else if (l10.ended) v9(e12, new g4());
    else {
      if (l10.destroyed) return false;
      l10.reading = false, l10.decoder && !n6 ? (t7 = l10.decoder.write(t7), l10.objectMode || 0 !== t7.length ? _6(e12, l10, t7, false) : M8(e12, l10)) : _6(e12, l10, t7, false);
    }
    else s6 || (l10.reading = false, M8(e12, l10));
    return !l10.ended && (l10.length < l10.highWaterMark || 0 === l10.length);
  }
  function _6(e12, t7, n6, r9) {
    t7.flowing && 0 === t7.length && !t7.sync ? (t7.awaitDrain = 0, e12.emit("data", n6)) : (t7.length += t7.objectMode ? 1 : n6.length, r9 ? t7.buffer.unshift(n6) : t7.buffer.push(n6), t7.needReadable && A9(e12)), M8(e12, t7);
  }
  Object.defineProperty(E8.prototype, "destroyed", { enumerable: false, get: function() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  }, set: function(e12) {
    this._readableState && (this._readableState.destroyed = e12);
  } }), E8.prototype.destroy = u10.destroy, E8.prototype._undestroy = u10.undestroy, E8.prototype._destroy = function(e12, t7) {
    t7(e12);
  }, E8.prototype.push = function(e12, t7) {
    var n6, i10 = this._readableState;
    return i10.objectMode ? n6 = true : "string" == typeof e12 && ((t7 = t7 || i10.defaultEncoding) !== i10.encoding && (e12 = r8.from(e12, t7), t7 = ""), n6 = true), S8(this, e12, t7, false, n6);
  }, E8.prototype.unshift = function(e12) {
    return S8(this, e12, null, true, false);
  }, E8.prototype.isPaused = function() {
    return false === this._readableState.flowing;
  }, E8.prototype.setEncoding = function(e12) {
    a6 || (a6 = kd.StringDecoder);
    var t7 = new a6(e12);
    this._readableState.decoder = t7, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var n6 = this._readableState.buffer.head, r9 = ""; null !== n6; ) r9 += t7.write(n6.data), n6 = n6.next;
    return this._readableState.buffer.clear(), "" !== r9 && this._readableState.buffer.push(r9), this._readableState.length = r9.length, this;
  };
  var C10 = 1073741824;
  function k11(e12, t7) {
    return e12 <= 0 || 0 === t7.length && t7.ended ? 0 : t7.objectMode ? 1 : e12 != e12 ? t7.flowing && t7.length ? t7.buffer.head.data.length : t7.length : (e12 > t7.highWaterMark && (t7.highWaterMark = function(e13) {
      return e13 >= C10 ? e13 = C10 : (e13--, e13 |= e13 >>> 1, e13 |= e13 >>> 2, e13 |= e13 >>> 4, e13 |= e13 >>> 8, e13 |= e13 >>> 16, e13++), e13;
    }(e12)), e12 <= t7.length ? e12 : t7.ended ? t7.length : (t7.needReadable = true, 0));
  }
  function A9(e12) {
    var t7 = e12._readableState;
    o6("emitReadable", t7.needReadable, t7.emittedReadable), t7.needReadable = false, t7.emittedReadable || (o6("emitReadable", t7.flowing), t7.emittedReadable = true, ua2.nextTick(x7, e12));
  }
  function x7(e12) {
    var t7 = e12._readableState;
    o6("emitReadable_", t7.destroyed, t7.length, t7.ended), t7.destroyed || !t7.length && !t7.ended || (e12.emit("readable"), t7.emittedReadable = false), t7.needReadable = !t7.flowing && !t7.ended && t7.length <= t7.highWaterMark, O8(e12);
  }
  function M8(e12, t7) {
    t7.readingMore || (t7.readingMore = true, ua2.nextTick(I8, e12, t7));
  }
  function I8(e12, t7) {
    for (; !t7.reading && !t7.ended && (t7.length < t7.highWaterMark || t7.flowing && 0 === t7.length); ) {
      var n6 = t7.length;
      if (o6("maybeReadMore read 0"), e12.read(0), n6 === t7.length) break;
    }
    t7.readingMore = false;
  }
  function T8(e12) {
    var t7 = e12._readableState;
    t7.readableListening = e12.listenerCount("readable") > 0, t7.resumeScheduled && !t7.paused ? t7.flowing = true : e12.listenerCount("data") > 0 && e12.resume();
  }
  function R6(e12) {
    o6("readable nexttick read 0"), e12.read(0);
  }
  function P7(e12, t7) {
    o6("resume", t7.reading), t7.reading || e12.read(0), t7.resumeScheduled = false, e12.emit("resume"), O8(e12), t7.flowing && !t7.reading && e12.read(0);
  }
  function O8(e12) {
    var t7 = e12._readableState;
    for (o6("flow", t7.flowing); t7.flowing && null !== e12.read(); ) ;
  }
  function N9(e12, t7) {
    return 0 === t7.length ? null : (t7.objectMode ? n6 = t7.buffer.shift() : !e12 || e12 >= t7.length ? (n6 = t7.decoder ? t7.buffer.join("") : 1 === t7.buffer.length ? t7.buffer.first() : t7.buffer.concat(t7.length), t7.buffer.clear()) : n6 = t7.buffer.consume(e12, t7.decoder), n6);
    var n6;
  }
  function L7(e12) {
    var t7 = e12._readableState;
    o6("endReadable", t7.endEmitted), t7.endEmitted || (t7.ended = true, ua2.nextTick(D9, t7, e12));
  }
  function D9(e12, t7) {
    if (o6("endReadableNT", e12.endEmitted, e12.length), !e12.endEmitted && 0 === e12.length && (e12.endEmitted = true, t7.readable = false, t7.emit("end"), e12.autoDestroy)) {
      var n6 = t7._writableState;
      (!n6 || n6.autoDestroy && n6.finished) && t7.destroy();
    }
  }
  function $8(e12, t7) {
    for (var n6 = 0, r9 = e12.length; n6 < r9; n6++) if (e12[n6] === t7) return n6;
    return -1;
  }
  return E8.prototype.read = function(e12) {
    o6("read", e12), e12 = parseInt(e12, 10);
    var t7 = this._readableState, n6 = e12;
    if (0 !== e12 && (t7.emittedReadable = false), 0 === e12 && t7.needReadable && ((0 !== t7.highWaterMark ? t7.length >= t7.highWaterMark : t7.length > 0) || t7.ended)) return o6("read: emitReadable", t7.length, t7.ended), 0 === t7.length && t7.ended ? L7(this) : A9(this), null;
    if (0 === (e12 = k11(e12, t7)) && t7.ended) return 0 === t7.length && L7(this), null;
    var r9, i10 = t7.needReadable;
    return o6("need readable", i10), (0 === t7.length || t7.length - e12 < t7.highWaterMark) && o6("length less than watermark", i10 = true), t7.ended || t7.reading ? o6("reading or ended", i10 = false) : i10 && (o6("do read"), t7.reading = true, t7.sync = true, 0 === t7.length && (t7.needReadable = true), this._read(t7.highWaterMark), t7.sync = false, t7.reading || (e12 = k11(n6, t7))), null === (r9 = e12 > 0 ? N9(e12, t7) : null) ? (t7.needReadable = t7.length <= t7.highWaterMark, e12 = 0) : (t7.length -= e12, t7.awaitDrain = 0), 0 === t7.length && (t7.ended || (t7.needReadable = true), n6 !== e12 && t7.ended && L7(this)), null !== r9 && this.emit("data", r9), r9;
  }, E8.prototype._read = function(e12) {
    v9(this, new m6("_read()"));
  }, E8.prototype.pipe = function(e12, n6) {
    var r9 = this, i10 = this._readableState;
    switch (i10.pipesCount) {
      case 0:
        i10.pipes = e12;
        break;
      case 1:
        i10.pipes = [i10.pipes, e12];
        break;
      default:
        i10.pipes.push(e12);
    }
    i10.pipesCount += 1, o6("pipe count=%d opts=%j", i10.pipesCount, n6);
    var s6 = (!n6 || false !== n6.end) && e12 !== ua2.stdout && e12 !== ua2.stderr ? c10 : g5;
    function a7(t7, n7) {
      o6("onunpipe"), t7 === r9 && n7 && false === n7.hasUnpiped && (n7.hasUnpiped = true, o6("cleanup"), e12.removeListener("close", f17), e12.removeListener("finish", p10), e12.removeListener("drain", l10), e12.removeListener("error", h10), e12.removeListener("unpipe", a7), r9.removeListener("end", c10), r9.removeListener("end", g5), r9.removeListener("data", u11), d8 = true, !i10.awaitDrain || e12._writableState && !e12._writableState.needDrain || l10());
    }
    function c10() {
      o6("onend"), e12.end();
    }
    i10.endEmitted ? ua2.nextTick(s6) : r9.once("end", s6), e12.on("unpipe", a7);
    var l10 = /* @__PURE__ */ function(e13) {
      return function() {
        var n7 = e13._readableState;
        o6("pipeOnDrain", n7.awaitDrain), n7.awaitDrain && n7.awaitDrain--, 0 === n7.awaitDrain && t6(e13, "data") && (n7.flowing = true, O8(e13));
      };
    }(r9);
    e12.on("drain", l10);
    var d8 = false;
    function u11(t7) {
      o6("ondata");
      var n7 = e12.write(t7);
      o6("dest.write", n7), false === n7 && ((1 === i10.pipesCount && i10.pipes === e12 || i10.pipesCount > 1 && -1 !== $8(i10.pipes, e12)) && !d8 && (o6("false write response, pause", i10.awaitDrain), i10.awaitDrain++), r9.pause());
    }
    function h10(n7) {
      o6("onerror", n7), g5(), e12.removeListener("error", h10), 0 === t6(e12, "error") && v9(e12, n7);
    }
    function f17() {
      e12.removeListener("finish", p10), g5();
    }
    function p10() {
      o6("onfinish"), e12.removeListener("close", f17), g5();
    }
    function g5() {
      o6("unpipe"), r9.unpipe(e12);
    }
    return r9.on("data", u11), function(e13, t7, n7) {
      if ("function" == typeof e13.prependListener) return e13.prependListener(t7, n7);
      e13._events && e13._events[t7] ? Array.isArray(e13._events[t7]) ? e13._events[t7].unshift(n7) : e13._events[t7] = [n7, e13._events[t7]] : e13.on(t7, n7);
    }(e12, "error", h10), e12.once("close", f17), e12.once("finish", p10), e12.emit("pipe", r9), i10.flowing || (o6("pipe resume"), r9.resume()), e12;
  }, E8.prototype.unpipe = function(e12) {
    var t7 = this._readableState, n6 = { hasUnpiped: false };
    if (0 === t7.pipesCount) return this;
    if (1 === t7.pipesCount) return e12 && e12 !== t7.pipes || (e12 || (e12 = t7.pipes), t7.pipes = null, t7.pipesCount = 0, t7.flowing = false, e12 && e12.emit("unpipe", this, n6)), this;
    if (!e12) {
      var r9 = t7.pipes, i10 = t7.pipesCount;
      t7.pipes = null, t7.pipesCount = 0, t7.flowing = false;
      for (var o7 = 0; o7 < i10; o7++) r9[o7].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var s6 = $8(t7.pipes, e12);
    return -1 === s6 || (t7.pipes.splice(s6, 1), t7.pipesCount -= 1, 1 === t7.pipesCount && (t7.pipes = t7.pipes[0]), e12.emit("unpipe", this, n6)), this;
  }, E8.prototype.on = function(e12, t7) {
    var r9 = n5.prototype.on.call(this, e12, t7), i10 = this._readableState;
    return "data" === e12 ? (i10.readableListening = this.listenerCount("readable") > 0, false !== i10.flowing && this.resume()) : "readable" === e12 && (i10.endEmitted || i10.readableListening || (i10.readableListening = i10.needReadable = true, i10.flowing = false, i10.emittedReadable = false, o6("on readable", i10.length, i10.reading), i10.length ? A9(this) : i10.reading || ua2.nextTick(R6, this))), r9;
  }, E8.prototype.addListener = E8.prototype.on, E8.prototype.removeListener = function(e12, t7) {
    var r9 = n5.prototype.removeListener.call(this, e12, t7);
    return "readable" === e12 && ua2.nextTick(T8, this), r9;
  }, E8.prototype.removeAllListeners = function(e12) {
    var t7 = n5.prototype.removeAllListeners.apply(this, arguments);
    return "readable" !== e12 && void 0 !== e12 || ua2.nextTick(T8, this), t7;
  }, E8.prototype.resume = function() {
    var e12 = this._readableState;
    return e12.flowing || (o6("resume"), e12.flowing = !e12.readableListening, function(e13, t7) {
      t7.resumeScheduled || (t7.resumeScheduled = true, ua2.nextTick(P7, e13, t7));
    }(this, e12)), e12.paused = false, this;
  }, E8.prototype.pause = function() {
    return o6("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (o6("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  }, E8.prototype.wrap = function(e12) {
    var t7 = this, n6 = this._readableState, r9 = false;
    for (var i10 in e12.on("end", function() {
      if (o6("wrapped end"), n6.decoder && !n6.ended) {
        var e13 = n6.decoder.end();
        e13 && e13.length && t7.push(e13);
      }
      t7.push(null);
    }), e12.on("data", function(i11) {
      (o6("wrapped data"), n6.decoder && (i11 = n6.decoder.write(i11)), n6.objectMode && null == i11) || (n6.objectMode || i11 && i11.length) && (t7.push(i11) || (r9 = true, e12.pause()));
    }), e12) void 0 === this[i10] && "function" == typeof e12[i10] && (this[i10] = /* @__PURE__ */ function(t8) {
      return function() {
        return e12[t8].apply(e12, arguments);
      };
    }(i10));
    for (var s6 = 0; s6 < b6.length; s6++) e12.on(b6[s6], this.emit.bind(this, b6[s6]));
    return this._read = function(t8) {
      o6("wrapped _read", t8), r9 && (r9 = false, e12.resume());
    }, this;
  }, "function" == typeof Symbol && (E8.prototype[Symbol.asyncIterator] = function() {
    return void 0 === c9 && (c9 = Ld()), c9(this);
  }), Object.defineProperty(E8.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(E8.prototype, "readableBuffer", { enumerable: false, get: function() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(E8.prototype, "readableFlowing", { enumerable: false, get: function() {
    return this._readableState.flowing;
  }, set: function(e12) {
    this._readableState && (this._readableState.flowing = e12);
  } }), E8._fromList = N9, Object.defineProperty(E8.prototype, "readableLength", { enumerable: false, get: function() {
    return this._readableState.length;
  } }), "function" == typeof Symbol && (E8.from = function(e12, t7) {
    return void 0 === l9 && (l9 = Rd ? Td : (Rd = 1, Td = function() {
      throw new Error("Readable.from is not available in the browser");
    })), l9(E8, e12, t7);
  }), Pd;
}
var $d = qd;
var Bd = nd.codes;
var Kd = Bd.ERR_METHOD_NOT_IMPLEMENTED;
var jd = Bd.ERR_MULTIPLE_CALLBACK;
var Ud = Bd.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var Hd = Bd.ERR_TRANSFORM_WITH_LENGTH_0;
var Fd = bd();
function zd(e11, t6) {
  var n5 = this._transformState;
  n5.transforming = false;
  var r8 = n5.writecb;
  if (null === r8) return this.emit("error", new jd());
  n5.writechunk = null, n5.writecb = null, null != t6 && this.push(t6), r8(e11);
  var i9 = this._readableState;
  i9.reading = false, (i9.needReadable || i9.length < i9.highWaterMark) && this._read(i9.highWaterMark);
}
function qd(e11) {
  if (!(this instanceof qd)) return new qd(e11);
  Fd.call(this, e11), this._transformState = { afterTransform: zd.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e11 && ("function" == typeof e11.transform && (this._transform = e11.transform), "function" == typeof e11.flush && (this._flush = e11.flush)), this.on("prefinish", Wd);
}
function Wd() {
  var e11 = this;
  "function" != typeof this._flush || this._readableState.destroyed ? Vd(this, null, null) : this._flush(function(t6, n5) {
    Vd(e11, t6, n5);
  });
}
function Vd(e11, t6, n5) {
  if (t6) return e11.emit("error", t6);
  if (null != n5 && e11.push(n5), e11._writableState.length) throw new Hd();
  if (e11._transformState.transforming) throw new Ud();
  return e11.push(null);
}
md(qd, Fd), qd.prototype.push = function(e11, t6) {
  return this._transformState.needTransform = false, Fd.prototype.push.call(this, e11, t6);
}, qd.prototype._transform = function(e11, t6, n5) {
  n5(new Kd("_transform()"));
}, qd.prototype._write = function(e11, t6, n5) {
  var r8 = this._transformState;
  if (r8.writecb = n5, r8.writechunk = e11, r8.writeencoding = t6, !r8.transforming) {
    var i9 = this._readableState;
    (r8.needTransform || i9.needReadable || i9.length < i9.highWaterMark) && this._read(i9.highWaterMark);
  }
}, qd.prototype._read = function(e11) {
  var t6 = this._transformState;
  null === t6.writechunk || t6.transforming ? t6.needTransform = true : (t6.transforming = true, this._transform(t6.writechunk, t6.writeencoding, t6.afterTransform));
}, qd.prototype._destroy = function(e11, t6) {
  Fd.prototype._destroy.call(this, e11, function(e12) {
    t6(e12);
  });
};
var Gd;
var Yd = Jd;
var Zd = $d;
function Jd(e11) {
  if (!(this instanceof Jd)) return new Jd(e11);
  Zd.call(this, e11);
}
md(Jd, Zd), Jd.prototype._transform = function(e11, t6, n5) {
  n5(null, e11);
};
var Qd = nd.codes;
var Xd = Qd.ERR_MISSING_ARGS;
var eu = Qd.ERR_STREAM_DESTROYED;
function tu(e11) {
  if (e11) throw e11;
}
function nu(e11) {
  e11();
}
function ru(e11, t6) {
  return e11.pipe(t6);
}
var iu = function() {
  for (var e11 = arguments.length, t6 = new Array(e11), n5 = 0; n5 < e11; n5++) t6[n5] = arguments[n5];
  var r8, i9 = function(e12) {
    return e12.length ? "function" != typeof e12[e12.length - 1] ? tu : e12.pop() : tu;
  }(t6);
  if (Array.isArray(t6[0]) && (t6 = t6[0]), t6.length < 2) throw new Xd("streams");
  var o6 = t6.map(function(e12, n6) {
    var s5 = n6 < t6.length - 1;
    return function(e13, t7, n7, r9) {
      r9 = /* @__PURE__ */ function(e14) {
        var t8 = false;
        return function() {
          t8 || (t8 = true, e14.apply(void 0, arguments));
        };
      }(r9);
      var i10 = false;
      e13.on("close", function() {
        i10 = true;
      }), void 0 === Gd && (Gd = Nd), Gd(e13, { readable: t7, writable: n7 }, function(e14) {
        if (e14) return r9(e14);
        i10 = true, r9();
      });
      var o7 = false;
      return function(t8) {
        if (!i10 && !o7) return o7 = true, function(e14) {
          return e14.setHeader && "function" == typeof e14.abort;
        }(e13) ? e13.abort() : "function" == typeof e13.destroy ? e13.destroy() : void r9(t8 || new eu("pipe"));
      };
    }(e12, s5, n6 > 0, function(e13) {
      r8 || (r8 = e13), e13 && o6.forEach(nu), s5 || (o6.forEach(nu), i9(r8));
    });
  });
  return t6.reduce(ru);
};
!function(e11, t6) {
  (t6 = sl.exports = Dd()).Stream = t6, t6.Readable = t6, t6.Writable = vd(), t6.Duplex = bd(), t6.Transform = $d, t6.PassThrough = Yd, t6.finished = Nd, t6.pipeline = iu;
}(0, sl.exports);
var ou = sl.exports;
function su(e11 = {}) {
  const t6 = {}, n5 = new ou.Duplex({ objectMode: true, read: () => {
  }, write: function(n6, o6, s5) {
    let a6 = null;
    try {
      !n6.id ? function(n7) {
        (e11 == null ? void 0 : e11.retryOnMessage) && n7.method === e11.retryOnMessage && Object.values(t6).forEach(({ req: e12, retryCount: n8 = 0 }) => {
          if (!e12.id) return;
          if (n8 >= 3) throw new Error(`StreamMiddleware - Retry limit exceeded for request id "${e12.id}"`);
          const r9 = t6[e12.id];
          r9 && (r9.retryCount = n8 + 1), i9(e12);
        });
        r8.emit("notification", n7);
      }(n6) : function(e12) {
        const { id: n7 } = e12;
        if (null === n7) return;
        const r9 = t6[n7];
        if (!r9) return void console.warn(`StreamMiddleware - Unknown response id "${n7}"`);
        delete t6[n7], Object.assign(r9.res, e12), setTimeout(r9.end);
      }(n6);
    } catch (e12) {
      a6 = e12;
    }
    s5(a6);
  } }), r8 = new Pc2();
  return { events: r8, middleware: (e12, n6, r9, o6) => {
    t6[e12.id] = { req: e12, res: n6, next: r9, end: o6 }, i9(e12);
  }, stream: n5 };
  function i9(e12) {
    n5.push(e12);
  }
}
var au = {};
var cu = { exports: {} };
var lu = function e10(t6, n5) {
  if (t6 && n5) return e10(t6)(n5);
  if ("function" != typeof t6) throw new TypeError("need wrapper function");
  return Object.keys(t6).forEach(function(e11) {
    r8[e11] = t6[e11];
  }), r8;
  function r8() {
    for (var e11 = new Array(arguments.length), n6 = 0; n6 < e11.length; n6++) e11[n6] = arguments[n6];
    var r9 = t6.apply(this, e11), i9 = e11[e11.length - 1];
    return "function" == typeof r9 && r9 !== i9 && Object.keys(i9).forEach(function(e12) {
      r9[e12] = i9[e12];
    }), r9;
  }
};
var du = lu;
function uu(e11) {
  var t6 = function() {
    return t6.called ? t6.value : (t6.called = true, t6.value = e11.apply(this, arguments));
  };
  return t6.called = false, t6;
}
function hu(e11) {
  var t6 = function() {
    if (t6.called) throw new Error(t6.onceError);
    return t6.called = true, t6.value = e11.apply(this, arguments);
  }, n5 = e11.name || "Function wrapped with `once`";
  return t6.onceError = n5 + " shouldn't be called more than once", t6.called = false, t6;
}
cu.exports = du(uu), cu.exports.strict = du(hu), uu.proto = uu(function() {
  Object.defineProperty(Function.prototype, "once", { value: function() {
    return uu(this);
  }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
    return hu(this);
  }, configurable: true });
});
var fu = cu.exports;
var pu = {};
Object.defineProperty(pu, "__esModule", { value: true }), pu.Substream = void 0;
var gu = ou;
var mu = class extends gu.Duplex {
  constructor({ parent: e11, name: t6 }) {
    super({ objectMode: true }), this._parent = e11, this._name = t6;
  }
  _read() {
  }
  _write(e11, t6, n5) {
    this._parent.push({ name: this._name, data: e11 }), n5();
  }
};
pu.Substream = mu;
var yu = de4 && de4.__importDefault || function(e11) {
  return e11 && e11.__esModule ? e11 : { default: e11 };
};
Object.defineProperty(au, "__esModule", { value: true }), au.ObjectMultiplex = void 0;
var vu = ou;
var bu = yu(fu);
var wu = pu;
var Eu = Symbol("IGNORE_SUBSTREAM");
var Su = class extends vu.Duplex {
  constructor(e11 = {}) {
    super(Object.assign(Object.assign({}, e11), { objectMode: true })), this._substreams = {};
  }
  createStream(e11) {
    if (this.destroyed) throw new Error(`ObjectMultiplex - parent stream for name "${e11}" already destroyed`);
    if (this._readableState.ended || this._writableState.ended) throw new Error(`ObjectMultiplex - parent stream for name "${e11}" already ended`);
    if (!e11) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e11]) throw new Error(`ObjectMultiplex - Substream for name "${e11}" already exists`);
    const t6 = new wu.Substream({ parent: this, name: e11 });
    return this._substreams[e11] = t6, function(e12, t7) {
      const n5 = (0, bu.default)(t7);
      (0, vu.finished)(e12, { readable: false }, n5), (0, vu.finished)(e12, { writable: false }, n5);
    }(this, (e12) => t6.destroy(e12 || void 0)), t6;
  }
  ignoreStream(e11) {
    if (!e11) throw new Error("ObjectMultiplex - name must not be empty");
    if (this._substreams[e11]) throw new Error(`ObjectMultiplex - Substream for name "${e11}" already exists`);
    this._substreams[e11] = Eu;
  }
  _read() {
  }
  _write(e11, t6, n5) {
    const { name: r8, data: i9 } = e11;
    if (!r8) return console.warn(`ObjectMultiplex - malformed chunk without name "${e11}"`), n5();
    const o6 = this._substreams[r8];
    return o6 ? (o6 !== Eu && o6.push(i9), n5()) : (console.warn(`ObjectMultiplex - orphaned data for stream "${r8}"`), n5());
  }
};
au.ObjectMultiplex = Su;
var _u = ue4(au.ObjectMultiplex);
var Cu = (e11) => null !== e11 && "object" == typeof e11 && "function" == typeof e11.pipe;
Cu.writable = (e11) => Cu(e11) && false !== e11.writable && "function" == typeof e11._write && "object" == typeof e11._writableState, Cu.readable = (e11) => Cu(e11) && false !== e11.readable && "function" == typeof e11._read && "object" == typeof e11._readableState, Cu.duplex = (e11) => Cu.writable(e11) && Cu.readable(e11), Cu.transform = (e11) => Cu.duplex(e11) && "function" == typeof e11._transform;
var ku;
var Au = Cu;
var xu = class extends ol {
  constructor(e11, { jsonRpcStreamName: t6, logger: n5 = console, maxEventListeners: r8 = 100, rpcMiddleware: i9 = [] }) {
    if (super({ logger: n5, maxEventListeners: r8, rpcMiddleware: i9 }), !Au.duplex(e11)) throw new Error(is2.errors.invalidDuplexStream());
    this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);
    const o6 = new _u();
    ou.pipeline(e11, o6, e11, this._handleStreamDisconnect.bind(this, "MetaMask")), this._jsonRpcConnection = su({ retryOnMessage: "METAMASK_EXTENSION_CONNECT_CAN_RETRY" }), ou.pipeline(this._jsonRpcConnection.stream, o6.createStream(t6), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, "MetaMask RpcProvider")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on("notification", (t7) => {
      const { method: n6, params: r9 } = t7;
      "metamask_accountsChanged" === n6 ? this._handleAccountsChanged(r9) : "metamask_unlockStateChanged" === n6 ? this._handleUnlockStateChanged(r9) : "metamask_chainChanged" === n6 ? this._handleChainChanged(r9) : Dc2.includes(n6) ? this.emit("message", { type: n6, data: r9 }) : "METAMASK_STREAM_FAILURE" === n6 && e11.destroy(new Error(is2.errors.permanentlyDisconnected()));
    });
  }
  async _initializeStateAsync() {
    let e11;
    try {
      e11 = await this.request({ method: "metamask_getProviderState" });
    } catch (e12) {
      this._log.error("MetaMask: Failed to get initial state. Please report this bug.", e12);
    }
    this._initializeState(e11);
  }
  _handleStreamDisconnect(e11, t6) {
    let n5 = `MetaMask: Lost connection to "${e11}".`;
    (t6 == null ? void 0 : t6.stack) && (n5 += `
${t6.stack}`), this._log.warn(n5), this.listenerCount("error") > 0 && this.emit("error", n5), this._handleDisconnect(false, t6 ? t6.message : void 0);
  }
  _handleChainChanged({ chainId: e11, networkVersion: t6 } = {}) {
    jc2(e11) && ((e12) => Boolean(e12) && "string" == typeof e12)(t6) ? "loading" === t6 ? this._handleDisconnect(true) : super._handleChainChanged({ chainId: e11 }) : this._log.error(is2.errors.invalidNetworkParams(), { chainId: e11, networkVersion: t6 });
  }
};
var Mu = class extends xu {
  constructor(e11, { jsonRpcStreamName: t6 = "metamask-provider", logger: n5 = console, maxEventListeners: r8 = 100, shouldSendMetadata: i9 } = {}) {
    if (super(e11, { jsonRpcStreamName: t6, logger: n5, maxEventListeners: r8, rpcMiddleware: $c2(n5) }), this._sentWarnings = { chainId: false, networkVersion: false, selectedAddress: false, enable: false, experimentalMethods: false, send: false, events: { close: false, data: false, networkChanged: false, notification: false } }, Gc2(this, ku, void 0), this._initializeStateAsync(), Yc2(this, ku, null), this.isMetaMask = true, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on("notification", (e12) => {
      const { method: t7 } = e12;
      Dc2.includes(t7) && (this.emit("data", e12), this.emit("notification", e12.params.result));
    }), i9) if ("complete" === document.readyState) Hc2(this._rpcEngine, this._log);
    else {
      const e12 = () => {
        Hc2(this._rpcEngine, this._log), window.removeEventListener("DOMContentLoaded", e12);
      };
      window.addEventListener("DOMContentLoaded", e12);
    }
  }
  get chainId() {
    return this._sentWarnings.chainId || (this._log.warn(is2.warnings.chainIdDeprecation), this._sentWarnings.chainId = true), super.chainId;
  }
  get networkVersion() {
    return this._sentWarnings.networkVersion || (this._log.warn(is2.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = true), Vc2(this, ku);
  }
  get selectedAddress() {
    return this._sentWarnings.selectedAddress || (this._log.warn(is2.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = true), super.selectedAddress;
  }
  sendAsync(e11, t6) {
    this._rpcRequest(e11, t6);
  }
  addListener(e11, t6) {
    return this._warnOfDeprecation(e11), super.addListener(e11, t6);
  }
  on(e11, t6) {
    return this._warnOfDeprecation(e11), super.on(e11, t6);
  }
  once(e11, t6) {
    return this._warnOfDeprecation(e11), super.once(e11, t6);
  }
  prependListener(e11, t6) {
    return this._warnOfDeprecation(e11), super.prependListener(e11, t6);
  }
  prependOnceListener(e11, t6) {
    return this._warnOfDeprecation(e11), super.prependOnceListener(e11, t6);
  }
  _handleDisconnect(e11, t6) {
    super._handleDisconnect(e11, t6), Vc2(this, ku) && !e11 && Yc2(this, ku, null);
  }
  _warnOfDeprecation(e11) {
    var _a14;
    false === ((_a14 = this._sentWarnings) == null ? void 0 : _a14.events[e11]) && (this._log.warn(is2.warnings.events[e11]), this._sentWarnings.events[e11] = true);
  }
  async enable() {
    return this._sentWarnings.enable || (this._log.warn(is2.warnings.enableDeprecation), this._sentWarnings.enable = true), new Promise((e11, t6) => {
      try {
        this._rpcRequest({ method: "eth_requestAccounts", params: [] }, Kc2(e11, t6));
      } catch (e12) {
        t6(e12);
      }
    });
  }
  send(e11, t6) {
    return this._sentWarnings.send || (this._log.warn(is2.warnings.sendDeprecation), this._sentWarnings.send = true), "string" != typeof e11 || t6 && !Array.isArray(t6) ? e11 && "object" == typeof e11 && "function" == typeof t6 ? this._rpcRequest(e11, t6) : this._sendSync(e11) : new Promise((n5, r8) => {
      try {
        this._rpcRequest({ method: e11, params: t6 }, Kc2(n5, r8, false));
      } catch (e12) {
        r8(e12);
      }
    });
  }
  _sendSync(e11) {
    let t6;
    switch (e11.method) {
      case "eth_accounts":
        t6 = this.selectedAddress ? [this.selectedAddress] : [];
        break;
      case "eth_coinbase":
        t6 = this.selectedAddress ?? null;
        break;
      case "eth_uninstallFilter":
        this._rpcRequest(e11, Uc2), t6 = true;
        break;
      case "net_version":
        t6 = Vc2(this, ku) ?? null;
        break;
      default:
        throw new Error(is2.errors.unsupportedSync(e11.method));
    }
    return { id: e11.id, jsonrpc: e11.jsonrpc, result: t6 };
  }
  _getExperimentalApi() {
    return new Proxy({ isUnlocked: async () => (this._state.initialized || await new Promise((e11) => {
      this.on("_initialized", () => e11());
    }), this._state.isUnlocked), requestBatch: async (e11) => {
      if (!Array.isArray(e11)) throw Xa({ message: "Batch requests must be made with an array of request objects.", data: e11 });
      return new Promise((t6, n5) => {
        this._rpcRequest(e11, Kc2(t6, n5));
      });
    } }, { get: (e11, t6, ...n5) => (this._sentWarnings.experimentalMethods || (this._log.warn(is2.warnings.experimentalMethods), this._sentWarnings.experimentalMethods = true), Reflect.get(e11, t6, ...n5)) });
  }
  _handleChainChanged({ chainId: e11, networkVersion: t6 } = {}) {
    super._handleChainChanged({ chainId: e11, networkVersion: t6 }), this._state.isConnected && t6 !== Vc2(this, ku) && (Yc2(this, ku, t6), this._state.initialized && this.emit("networkChanged", Vc2(this, ku)));
  }
};
ku = /* @__PURE__ */ new WeakMap();
var Iu = (0, import_debug4.default)("MM_SDK");
var Tu;
Iu.color = "#FFAC1C";
var Ru = {};
var Pu = {};
Object.defineProperty(Pu, "__esModule", { value: true }), Pu.EthereumProviderError = Pu.EthereumRpcError = void 0;
var Ou = $a2;
var Nu = class extends Error {
  constructor(e11, t6, n5) {
    if (!Number.isInteger(e11)) throw new Error('"code" must be an integer.');
    if (!t6 || "string" != typeof t6) throw new Error('"message" must be a nonempty string.');
    super(t6), this.code = e11, void 0 !== n5 && (this.data = n5);
  }
  serialize() {
    const e11 = { code: this.code, message: this.message };
    return void 0 !== this.data && (e11.data = this.data), this.stack && (e11.stack = this.stack), e11;
  }
  toString() {
    return Ou.default(this.serialize(), Lu, 2);
  }
};
Pu.EthereumRpcError = Nu;
function Lu(e11, t6) {
  if ("[Circular]" !== t6) return t6;
}
Pu.EthereumProviderError = class extends Nu {
  constructor(e11, t6, n5) {
    if (!function(e12) {
      return Number.isInteger(e12) && e12 >= 1e3 && e12 <= 4999;
    }(e11)) throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e11, t6, n5);
  }
};
var Du = {};
var $u = {};
Object.defineProperty($u, "__esModule", { value: true }), $u.errorValues = $u.errorCodes = void 0, $u.errorCodes = { rpc: { invalidInput: -32e3, resourceNotFound: -32001, resourceUnavailable: -32002, transactionRejected: -32003, methodNotSupported: -32004, limitExceeded: -32005, parse: -32700, invalidRequest: -32600, methodNotFound: -32601, invalidParams: -32602, internal: -32603 }, provider: { userRejectedRequest: 4001, unauthorized: 4100, unsupportedMethod: 4200, disconnected: 4900, chainDisconnected: 4901 } }, $u.errorValues = { "-32700": { standard: "JSON RPC 2.0", message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text." }, "-32600": { standard: "JSON RPC 2.0", message: "The JSON sent is not a valid Request object." }, "-32601": { standard: "JSON RPC 2.0", message: "The method does not exist / is not available." }, "-32602": { standard: "JSON RPC 2.0", message: "Invalid method parameter(s)." }, "-32603": { standard: "JSON RPC 2.0", message: "Internal JSON-RPC error." }, "-32000": { standard: "EIP-1474", message: "Invalid input." }, "-32001": { standard: "EIP-1474", message: "Resource not found." }, "-32002": { standard: "EIP-1474", message: "Resource unavailable." }, "-32003": { standard: "EIP-1474", message: "Transaction rejected." }, "-32004": { standard: "EIP-1474", message: "Method not supported." }, "-32005": { standard: "EIP-1474", message: "Request limit exceeded." }, 4001: { standard: "EIP-1193", message: "User rejected the request." }, 4100: { standard: "EIP-1193", message: "The requested account and/or method has not been authorized by the user." }, 4200: { standard: "EIP-1193", message: "The requested method is not supported by this Ethereum provider." }, 4900: { standard: "EIP-1193", message: "The provider is disconnected from all chains." }, 4901: { standard: "EIP-1193", message: "The provider is disconnected from the specified chain." } }, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.serializeError = e11.isValidCode = e11.getMessageFromCode = e11.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const t6 = $u, n5 = Pu, r8 = t6.errorCodes.rpc.internal, i9 = "Unspecified error message. This is a bug, please report it.", o6 = { code: r8, message: s5(r8) };
  function s5(n6, r9 = i9) {
    if (Number.isInteger(n6)) {
      const r10 = n6.toString();
      if (d7(t6.errorValues, r10)) return t6.errorValues[r10].message;
      if (c9(n6)) return e11.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return r9;
  }
  function a6(e12) {
    if (!Number.isInteger(e12)) return false;
    const n6 = e12.toString();
    return !!t6.errorValues[n6] || !!c9(e12);
  }
  function c9(e12) {
    return e12 >= -32099 && e12 <= -32e3;
  }
  function l9(e12) {
    return e12 && "object" == typeof e12 && !Array.isArray(e12) ? Object.assign({}, e12) : e12;
  }
  function d7(e12, t7) {
    return Object.prototype.hasOwnProperty.call(e12, t7);
  }
  e11.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.", e11.getMessageFromCode = s5, e11.isValidCode = a6, e11.serializeError = function(e12, { fallbackError: t7 = o6, shouldIncludeStack: r9 = false } = {}) {
    var i10, c10;
    if (!t7 || !Number.isInteger(t7.code) || "string" != typeof t7.message) throw new Error("Must provide fallback error with integer number code and string message.");
    if (e12 instanceof n5.EthereumRpcError) return e12.serialize();
    const u10 = {};
    if (e12 && "object" == typeof e12 && !Array.isArray(e12) && d7(e12, "code") && a6(e12.code)) {
      const t8 = e12;
      u10.code = t8.code, t8.message && "string" == typeof t8.message ? (u10.message = t8.message, d7(t8, "data") && (u10.data = t8.data)) : (u10.message = s5(u10.code), u10.data = { originalError: l9(e12) });
    } else {
      u10.code = t7.code;
      const n6 = null === (i10 = e12) || void 0 === i10 ? void 0 : i10.message;
      u10.message = n6 && "string" == typeof n6 ? n6 : t7.message, u10.data = { originalError: l9(e12) };
    }
    const h9 = null === (c10 = e12) || void 0 === c10 ? void 0 : c10.stack;
    return r9 && e12 && h9 && "string" == typeof h9 && (u10.stack = h9), u10;
  };
}(Du);
var Bu = {};
Object.defineProperty(Bu, "__esModule", { value: true }), Bu.ethErrors = void 0;
var Ku = Pu;
var ju = Du;
var Uu = $u;
function Hu(e11, t6) {
  const [n5, r8] = zu(t6);
  return new Ku.EthereumRpcError(e11, n5 || ju.getMessageFromCode(e11), r8);
}
function Fu(e11, t6) {
  const [n5, r8] = zu(t6);
  return new Ku.EthereumProviderError(e11, n5 || ju.getMessageFromCode(e11), r8);
}
function zu(e11) {
  if (e11) {
    if ("string" == typeof e11) return [e11];
    if ("object" == typeof e11 && !Array.isArray(e11)) {
      const { message: t6, data: n5 } = e11;
      if (t6 && "string" != typeof t6) throw new Error("Must specify string message.");
      return [t6 || void 0, n5];
    }
  }
  return [];
}
Bu.ethErrors = { rpc: { parse: (e11) => Hu(Uu.errorCodes.rpc.parse, e11), invalidRequest: (e11) => Hu(Uu.errorCodes.rpc.invalidRequest, e11), invalidParams: (e11) => Hu(Uu.errorCodes.rpc.invalidParams, e11), methodNotFound: (e11) => Hu(Uu.errorCodes.rpc.methodNotFound, e11), internal: (e11) => Hu(Uu.errorCodes.rpc.internal, e11), server: (e11) => {
  if (!e11 || "object" != typeof e11 || Array.isArray(e11)) throw new Error("Ethereum RPC Server errors must provide single object argument.");
  const { code: t6 } = e11;
  if (!Number.isInteger(t6) || t6 > -32005 || t6 < -32099) throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
  return Hu(t6, e11);
}, invalidInput: (e11) => Hu(Uu.errorCodes.rpc.invalidInput, e11), resourceNotFound: (e11) => Hu(Uu.errorCodes.rpc.resourceNotFound, e11), resourceUnavailable: (e11) => Hu(Uu.errorCodes.rpc.resourceUnavailable, e11), transactionRejected: (e11) => Hu(Uu.errorCodes.rpc.transactionRejected, e11), methodNotSupported: (e11) => Hu(Uu.errorCodes.rpc.methodNotSupported, e11), limitExceeded: (e11) => Hu(Uu.errorCodes.rpc.limitExceeded, e11) }, provider: { userRejectedRequest: (e11) => Fu(Uu.errorCodes.provider.userRejectedRequest, e11), unauthorized: (e11) => Fu(Uu.errorCodes.provider.unauthorized, e11), unsupportedMethod: (e11) => Fu(Uu.errorCodes.provider.unsupportedMethod, e11), disconnected: (e11) => Fu(Uu.errorCodes.provider.disconnected, e11), chainDisconnected: (e11) => Fu(Uu.errorCodes.provider.chainDisconnected, e11), custom: (e11) => {
  if (!e11 || "object" != typeof e11 || Array.isArray(e11)) throw new Error("Ethereum Provider custom errors must provide single object argument.");
  const { code: t6, message: n5, data: r8 } = e11;
  if (!n5 || "string" != typeof n5) throw new Error('"message" must be a nonempty string');
  return new Ku.EthereumProviderError(t6, n5, r8);
} } }, function(e11) {
  Object.defineProperty(e11, "__esModule", { value: true }), e11.getMessageFromCode = e11.serializeError = e11.EthereumProviderError = e11.EthereumRpcError = e11.ethErrors = e11.errorCodes = void 0;
  const t6 = Pu;
  Object.defineProperty(e11, "EthereumRpcError", { enumerable: true, get: function() {
    return t6.EthereumRpcError;
  } }), Object.defineProperty(e11, "EthereumProviderError", { enumerable: true, get: function() {
    return t6.EthereumProviderError;
  } });
  const n5 = Du;
  Object.defineProperty(e11, "serializeError", { enumerable: true, get: function() {
    return n5.serializeError;
  } }), Object.defineProperty(e11, "getMessageFromCode", { enumerable: true, get: function() {
    return n5.getMessageFromCode;
  } });
  const r8 = Bu;
  Object.defineProperty(e11, "ethErrors", { enumerable: true, get: function() {
    return r8.ethErrors;
  } });
  const i9 = $u;
  Object.defineProperty(e11, "errorCodes", { enumerable: true, get: function() {
    return i9.errorCodes;
  } });
}(Ru);
var qu = { exports: {} };
qu.exports = function(e11) {
  var t6 = {};
  function n5(r8) {
    if (t6[r8]) return t6[r8].exports;
    var i9 = t6[r8] = { i: r8, l: false, exports: {} };
    return e11[r8].call(i9.exports, i9, i9.exports, n5), i9.l = true, i9.exports;
  }
  return n5.m = e11, n5.c = t6, n5.d = function(e12, t7, r8) {
    n5.o(e12, t7) || Object.defineProperty(e12, t7, { enumerable: true, get: r8 });
  }, n5.r = function(e12) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e12, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e12, "__esModule", { value: true });
  }, n5.t = function(e12, t7) {
    if (1 & t7 && (e12 = n5(e12)), 8 & t7) return e12;
    if (4 & t7 && "object" == typeof e12 && e12 && e12.__esModule) return e12;
    var r8 = /* @__PURE__ */ Object.create(null);
    if (n5.r(r8), Object.defineProperty(r8, "default", { enumerable: true, value: e12 }), 2 & t7 && "string" != typeof e12) for (var i9 in e12) n5.d(r8, i9, (function(t8) {
      return e12[t8];
    }).bind(null, i9));
    return r8;
  }, n5.n = function(e12) {
    var t7 = e12 && e12.__esModule ? function() {
      return e12.default;
    } : function() {
      return e12;
    };
    return n5.d(t7, "a", t7), t7;
  }, n5.o = function(e12, t7) {
    return Object.prototype.hasOwnProperty.call(e12, t7);
  }, n5.p = "", n5(n5.s = 90);
}({ 17: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8 = n5(18), i9 = function() {
    function e12() {
    }
    return e12.getFirstMatch = function(e13, t7) {
      var n6 = t7.match(e13);
      return n6 && n6.length > 0 && n6[1] || "";
    }, e12.getSecondMatch = function(e13, t7) {
      var n6 = t7.match(e13);
      return n6 && n6.length > 1 && n6[2] || "";
    }, e12.matchAndReturnConst = function(e13, t7, n6) {
      if (e13.test(t7)) return n6;
    }, e12.getWindowsVersionName = function(e13) {
      switch (e13) {
        case "NT":
          return "NT";
        case "XP":
        case "NT 5.1":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return;
      }
    }, e12.getMacOSVersionName = function(e13) {
      var t7 = e13.split(".").splice(0, 2).map(function(e14) {
        return parseInt(e14, 10) || 0;
      });
      if (t7.push(0), 10 === t7[0]) switch (t7[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
    }, e12.getAndroidVersionName = function(e13) {
      var t7 = e13.split(".").splice(0, 2).map(function(e14) {
        return parseInt(e14, 10) || 0;
      });
      if (t7.push(0), !(1 === t7[0] && t7[1] < 5)) return 1 === t7[0] && t7[1] < 6 ? "Cupcake" : 1 === t7[0] && t7[1] >= 6 ? "Donut" : 2 === t7[0] && t7[1] < 2 ? "Eclair" : 2 === t7[0] && 2 === t7[1] ? "Froyo" : 2 === t7[0] && t7[1] > 2 ? "Gingerbread" : 3 === t7[0] ? "Honeycomb" : 4 === t7[0] && t7[1] < 1 ? "Ice Cream Sandwich" : 4 === t7[0] && t7[1] < 4 ? "Jelly Bean" : 4 === t7[0] && t7[1] >= 4 ? "KitKat" : 5 === t7[0] ? "Lollipop" : 6 === t7[0] ? "Marshmallow" : 7 === t7[0] ? "Nougat" : 8 === t7[0] ? "Oreo" : 9 === t7[0] ? "Pie" : void 0;
    }, e12.getVersionPrecision = function(e13) {
      return e13.split(".").length;
    }, e12.compareVersions = function(t7, n6, r9) {
      void 0 === r9 && (r9 = false);
      var i10 = e12.getVersionPrecision(t7), o6 = e12.getVersionPrecision(n6), s5 = Math.max(i10, o6), a6 = 0, c9 = e12.map([t7, n6], function(t8) {
        var n7 = s5 - e12.getVersionPrecision(t8), r10 = t8 + new Array(n7 + 1).join(".0");
        return e12.map(r10.split("."), function(e13) {
          return new Array(20 - e13.length).join("0") + e13;
        }).reverse();
      });
      for (r9 && (a6 = s5 - Math.min(i10, o6)), s5 -= 1; s5 >= a6; ) {
        if (c9[0][s5] > c9[1][s5]) return 1;
        if (c9[0][s5] === c9[1][s5]) {
          if (s5 === a6) return 0;
          s5 -= 1;
        } else if (c9[0][s5] < c9[1][s5]) return -1;
      }
    }, e12.map = function(e13, t7) {
      var n6, r9 = [];
      if (Array.prototype.map) return Array.prototype.map.call(e13, t7);
      for (n6 = 0; n6 < e13.length; n6 += 1) r9.push(t7(e13[n6]));
      return r9;
    }, e12.find = function(e13, t7) {
      var n6, r9;
      if (Array.prototype.find) return Array.prototype.find.call(e13, t7);
      for (n6 = 0, r9 = e13.length; n6 < r9; n6 += 1) {
        var i10 = e13[n6];
        if (t7(i10, n6)) return i10;
      }
    }, e12.assign = function(e13) {
      for (var t7, n6, r9 = e13, i10 = arguments.length, o6 = new Array(i10 > 1 ? i10 - 1 : 0), s5 = 1; s5 < i10; s5++) o6[s5 - 1] = arguments[s5];
      if (Object.assign) return Object.assign.apply(Object, [e13].concat(o6));
      var a6 = function() {
        var e14 = o6[t7];
        "object" == typeof e14 && null !== e14 && Object.keys(e14).forEach(function(t8) {
          r9[t8] = e14[t8];
        });
      };
      for (t7 = 0, n6 = o6.length; t7 < n6; t7 += 1) a6();
      return e13;
    }, e12.getBrowserAlias = function(e13) {
      return r8.BROWSER_ALIASES_MAP[e13];
    }, e12.getBrowserTypeByAlias = function(e13) {
      return r8.BROWSER_MAP[e13] || "";
    }, e12;
  }();
  t6.default = i9, e11.exports = t6.default;
}, 18: function(e11, t6, n5) {
  t6.__esModule = true, t6.ENGINE_MAP = t6.OS_MAP = t6.PLATFORMS_MAP = t6.BROWSER_MAP = t6.BROWSER_ALIASES_MAP = void 0, t6.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" }, t6.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" }, t6.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" }, t6.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" }, t6.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
}, 90: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8, i9 = (r8 = n5(91)) && r8.__esModule ? r8 : { default: r8 }, o6 = n5(18);
  function s5(e12, t7) {
    for (var n6 = 0; n6 < t7.length; n6++) {
      var r9 = t7[n6];
      r9.enumerable = r9.enumerable || false, r9.configurable = true, "value" in r9 && (r9.writable = true), Object.defineProperty(e12, r9.key, r9);
    }
  }
  var a6 = function() {
    function e12() {
    }
    var t7, n6, r9;
    return e12.getParser = function(e13, t8) {
      if (void 0 === t8 && (t8 = false), "string" != typeof e13) throw new Error("UserAgent should be a string");
      return new i9.default(e13, t8);
    }, e12.parse = function(e13) {
      return new i9.default(e13).getResult();
    }, t7 = e12, r9 = [{ key: "BROWSER_MAP", get: function() {
      return o6.BROWSER_MAP;
    } }, { key: "ENGINE_MAP", get: function() {
      return o6.ENGINE_MAP;
    } }, { key: "OS_MAP", get: function() {
      return o6.OS_MAP;
    } }, { key: "PLATFORMS_MAP", get: function() {
      return o6.PLATFORMS_MAP;
    } }], (n6 = null) && s5(t7.prototype, n6), r9 && s5(t7, r9), e12;
  }();
  t6.default = a6, e11.exports = t6.default;
}, 91: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8 = c9(n5(92)), i9 = c9(n5(93)), o6 = c9(n5(94)), s5 = c9(n5(95)), a6 = c9(n5(17));
  function c9(e12) {
    return e12 && e12.__esModule ? e12 : { default: e12 };
  }
  var l9 = function() {
    function e12(e13, t8) {
      if (void 0 === t8 && (t8 = false), null == e13 || "" === e13) throw new Error("UserAgent parameter can't be empty");
      this._ua = e13, this.parsedResult = {}, true !== t8 && this.parse();
    }
    var t7 = e12.prototype;
    return t7.getUA = function() {
      return this._ua;
    }, t7.test = function(e13) {
      return e13.test(this._ua);
    }, t7.parseBrowser = function() {
      var e13 = this;
      this.parsedResult.browser = {};
      var t8 = a6.default.find(r8.default, function(t9) {
        if ("function" == typeof t9.test) return t9.test(e13);
        if (t9.test instanceof Array) return t9.test.some(function(t10) {
          return e13.test(t10);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t8 && (this.parsedResult.browser = t8.describe(this.getUA())), this.parsedResult.browser;
    }, t7.getBrowser = function() {
      return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
    }, t7.getBrowserName = function(e13) {
      return e13 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
    }, t7.getBrowserVersion = function() {
      return this.getBrowser().version;
    }, t7.getOS = function() {
      return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
    }, t7.parseOS = function() {
      var e13 = this;
      this.parsedResult.os = {};
      var t8 = a6.default.find(i9.default, function(t9) {
        if ("function" == typeof t9.test) return t9.test(e13);
        if (t9.test instanceof Array) return t9.test.some(function(t10) {
          return e13.test(t10);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t8 && (this.parsedResult.os = t8.describe(this.getUA())), this.parsedResult.os;
    }, t7.getOSName = function(e13) {
      var t8 = this.getOS().name;
      return e13 ? String(t8).toLowerCase() || "" : t8 || "";
    }, t7.getOSVersion = function() {
      return this.getOS().version;
    }, t7.getPlatform = function() {
      return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
    }, t7.getPlatformType = function(e13) {
      void 0 === e13 && (e13 = false);
      var t8 = this.getPlatform().type;
      return e13 ? String(t8).toLowerCase() || "" : t8 || "";
    }, t7.parsePlatform = function() {
      var e13 = this;
      this.parsedResult.platform = {};
      var t8 = a6.default.find(o6.default, function(t9) {
        if ("function" == typeof t9.test) return t9.test(e13);
        if (t9.test instanceof Array) return t9.test.some(function(t10) {
          return e13.test(t10);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t8 && (this.parsedResult.platform = t8.describe(this.getUA())), this.parsedResult.platform;
    }, t7.getEngine = function() {
      return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
    }, t7.getEngineName = function(e13) {
      return e13 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
    }, t7.parseEngine = function() {
      var e13 = this;
      this.parsedResult.engine = {};
      var t8 = a6.default.find(s5.default, function(t9) {
        if ("function" == typeof t9.test) return t9.test(e13);
        if (t9.test instanceof Array) return t9.test.some(function(t10) {
          return e13.test(t10);
        });
        throw new Error("Browser's test function is not valid");
      });
      return t8 && (this.parsedResult.engine = t8.describe(this.getUA())), this.parsedResult.engine;
    }, t7.parse = function() {
      return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
    }, t7.getResult = function() {
      return a6.default.assign({}, this.parsedResult);
    }, t7.satisfies = function(e13) {
      var t8 = this, n6 = {}, r9 = 0, i10 = {}, o7 = 0;
      if (Object.keys(e13).forEach(function(t9) {
        var s7 = e13[t9];
        "string" == typeof s7 ? (i10[t9] = s7, o7 += 1) : "object" == typeof s7 && (n6[t9] = s7, r9 += 1);
      }), r9 > 0) {
        var s6 = Object.keys(n6), c10 = a6.default.find(s6, function(e14) {
          return t8.isOS(e14);
        });
        if (c10) {
          var l10 = this.satisfies(n6[c10]);
          if (void 0 !== l10) return l10;
        }
        var d7 = a6.default.find(s6, function(e14) {
          return t8.isPlatform(e14);
        });
        if (d7) {
          var u10 = this.satisfies(n6[d7]);
          if (void 0 !== u10) return u10;
        }
      }
      if (o7 > 0) {
        var h9 = Object.keys(i10), f16 = a6.default.find(h9, function(e14) {
          return t8.isBrowser(e14, true);
        });
        if (void 0 !== f16) return this.compareVersion(i10[f16]);
      }
    }, t7.isBrowser = function(e13, t8) {
      void 0 === t8 && (t8 = false);
      var n6 = this.getBrowserName().toLowerCase(), r9 = e13.toLowerCase(), i10 = a6.default.getBrowserTypeByAlias(r9);
      return t8 && i10 && (r9 = i10.toLowerCase()), r9 === n6;
    }, t7.compareVersion = function(e13) {
      var t8 = [0], n6 = e13, r9 = false, i10 = this.getBrowserVersion();
      if ("string" == typeof i10) return ">" === e13[0] || "<" === e13[0] ? (n6 = e13.substr(1), "=" === e13[1] ? (r9 = true, n6 = e13.substr(2)) : t8 = [], ">" === e13[0] ? t8.push(1) : t8.push(-1)) : "=" === e13[0] ? n6 = e13.substr(1) : "~" === e13[0] && (r9 = true, n6 = e13.substr(1)), t8.indexOf(a6.default.compareVersions(i10, n6, r9)) > -1;
    }, t7.isOS = function(e13) {
      return this.getOSName(true) === String(e13).toLowerCase();
    }, t7.isPlatform = function(e13) {
      return this.getPlatformType(true) === String(e13).toLowerCase();
    }, t7.isEngine = function(e13) {
      return this.getEngineName(true) === String(e13).toLowerCase();
    }, t7.is = function(e13, t8) {
      return void 0 === t8 && (t8 = false), this.isBrowser(e13, t8) || this.isOS(e13) || this.isPlatform(e13);
    }, t7.some = function(e13) {
      var t8 = this;
      return void 0 === e13 && (e13 = []), e13.some(function(e14) {
        return t8.is(e14);
      });
    }, e12;
  }();
  t6.default = l9, e11.exports = t6.default;
}, 92: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8, i9 = (r8 = n5(17)) && r8.__esModule ? r8 : { default: r8 }, o6 = /version\/(\d+(\.?_?\d+)+)/i, s5 = [{ test: [/googlebot/i], describe: function(e12) {
    var t7 = { name: "Googlebot" }, n6 = i9.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/opera/i], describe: function(e12) {
    var t7 = { name: "Opera" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/opr\/|opios/i], describe: function(e12) {
    var t7 = { name: "Opera" }, n6 = i9.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/SamsungBrowser/i], describe: function(e12) {
    var t7 = { name: "Samsung Internet for Android" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/Whale/i], describe: function(e12) {
    var t7 = { name: "NAVER Whale Browser" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/MZBrowser/i], describe: function(e12) {
    var t7 = { name: "MZ Browser" }, n6 = i9.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/focus/i], describe: function(e12) {
    var t7 = { name: "Focus" }, n6 = i9.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/swing/i], describe: function(e12) {
    var t7 = { name: "Swing" }, n6 = i9.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/coast/i], describe: function(e12) {
    var t7 = { name: "Opera Coast" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e12) {
    var t7 = { name: "Opera Touch" }, n6 = i9.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/yabrowser/i], describe: function(e12) {
    var t7 = { name: "Yandex Browser" }, n6 = i9.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/ucbrowser/i], describe: function(e12) {
    var t7 = { name: "UC Browser" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/Maxthon|mxios/i], describe: function(e12) {
    var t7 = { name: "Maxthon" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/epiphany/i], describe: function(e12) {
    var t7 = { name: "Epiphany" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/puffin/i], describe: function(e12) {
    var t7 = { name: "Puffin" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/sleipnir/i], describe: function(e12) {
    var t7 = { name: "Sleipnir" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/k-meleon/i], describe: function(e12) {
    var t7 = { name: "K-Meleon" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/micromessenger/i], describe: function(e12) {
    var t7 = { name: "WeChat" }, n6 = i9.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/qqbrowser/i], describe: function(e12) {
    var t7 = { name: /qqbrowserlite/i.test(e12) ? "QQ Browser Lite" : "QQ Browser" }, n6 = i9.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/msie|trident/i], describe: function(e12) {
    var t7 = { name: "Internet Explorer" }, n6 = i9.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/\sedg\//i], describe: function(e12) {
    var t7 = { name: "Microsoft Edge" }, n6 = i9.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/edg([ea]|ios)/i], describe: function(e12) {
    var t7 = { name: "Microsoft Edge" }, n6 = i9.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/vivaldi/i], describe: function(e12) {
    var t7 = { name: "Vivaldi" }, n6 = i9.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/seamonkey/i], describe: function(e12) {
    var t7 = { name: "SeaMonkey" }, n6 = i9.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/sailfish/i], describe: function(e12) {
    var t7 = { name: "Sailfish" }, n6 = i9.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/silk/i], describe: function(e12) {
    var t7 = { name: "Amazon Silk" }, n6 = i9.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/phantom/i], describe: function(e12) {
    var t7 = { name: "PhantomJS" }, n6 = i9.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/slimerjs/i], describe: function(e12) {
    var t7 = { name: "SlimerJS" }, n6 = i9.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e12) {
    var t7 = { name: "BlackBerry" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e12) {
    var t7 = { name: "WebOS Browser" }, n6 = i9.default.getFirstMatch(o6, e12) || i9.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/bada/i], describe: function(e12) {
    var t7 = { name: "Bada" }, n6 = i9.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/tizen/i], describe: function(e12) {
    var t7 = { name: "Tizen" }, n6 = i9.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/qupzilla/i], describe: function(e12) {
    var t7 = { name: "QupZilla" }, n6 = i9.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e12) {
    var t7 = { name: "Firefox" }, n6 = i9.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/electron/i], describe: function(e12) {
    var t7 = { name: "Electron" }, n6 = i9.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/MiuiBrowser/i], describe: function(e12) {
    var t7 = { name: "Miui" }, n6 = i9.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/chromium/i], describe: function(e12) {
    var t7 = { name: "Chromium" }, n6 = i9.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e12) || i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/chrome|crios|crmo/i], describe: function(e12) {
    var t7 = { name: "Chrome" }, n6 = i9.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/GSA/i], describe: function(e12) {
    var t7 = { name: "Google Search" }, n6 = i9.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: function(e12) {
    var t7 = !e12.test(/like android/i), n6 = e12.test(/android/i);
    return t7 && n6;
  }, describe: function(e12) {
    var t7 = { name: "Android Browser" }, n6 = i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/playstation 4/i], describe: function(e12) {
    var t7 = { name: "PlayStation 4" }, n6 = i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/safari|applewebkit/i], describe: function(e12) {
    var t7 = { name: "Safari" }, n6 = i9.default.getFirstMatch(o6, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/.*/i], describe: function(e12) {
    var t7 = -1 !== e12.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
    return { name: i9.default.getFirstMatch(t7, e12), version: i9.default.getSecondMatch(t7, e12) };
  } }];
  t6.default = s5, e11.exports = t6.default;
}, 93: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8, i9 = (r8 = n5(17)) && r8.__esModule ? r8 : { default: r8 }, o6 = n5(18), s5 = [{ test: [/Roku\/DVP/], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e12);
    return { name: o6.OS_MAP.Roku, version: t7 };
  } }, { test: [/windows phone/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e12);
    return { name: o6.OS_MAP.WindowsPhone, version: t7 };
  } }, { test: [/windows /i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e12), n6 = i9.default.getWindowsVersionName(t7);
    return { name: o6.OS_MAP.Windows, version: t7, versionName: n6 };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e12) {
    var t7 = { name: o6.OS_MAP.iOS }, n6 = i9.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/macintosh/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e12).replace(/[_\s]/g, "."), n6 = i9.default.getMacOSVersionName(t7), r9 = { name: o6.OS_MAP.MacOS, version: t7 };
    return n6 && (r9.versionName = n6), r9;
  } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e12).replace(/[_\s]/g, ".");
    return { name: o6.OS_MAP.iOS, version: t7 };
  } }, { test: function(e12) {
    var t7 = !e12.test(/like android/i), n6 = e12.test(/android/i);
    return t7 && n6;
  }, describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e12), n6 = i9.default.getAndroidVersionName(t7), r9 = { name: o6.OS_MAP.Android, version: t7 };
    return n6 && (r9.versionName = n6), r9;
  } }, { test: [/(web|hpw)[o0]s/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e12), n6 = { name: o6.OS_MAP.WebOS };
    return t7 && t7.length && (n6.version = t7), n6;
  } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e12) || i9.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e12) || i9.default.getFirstMatch(/\bbb(\d+)/i, e12);
    return { name: o6.OS_MAP.BlackBerry, version: t7 };
  } }, { test: [/bada/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e12);
    return { name: o6.OS_MAP.Bada, version: t7 };
  } }, { test: [/tizen/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e12);
    return { name: o6.OS_MAP.Tizen, version: t7 };
  } }, { test: [/linux/i], describe: function() {
    return { name: o6.OS_MAP.Linux };
  } }, { test: [/CrOS/], describe: function() {
    return { name: o6.OS_MAP.ChromeOS };
  } }, { test: [/PlayStation 4/], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e12);
    return { name: o6.OS_MAP.PlayStation4, version: t7 };
  } }];
  t6.default = s5, e11.exports = t6.default;
}, 94: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8, i9 = (r8 = n5(17)) && r8.__esModule ? r8 : { default: r8 }, o6 = n5(18), s5 = [{ test: [/googlebot/i], describe: function() {
    return { type: "bot", vendor: "Google" };
  } }, { test: [/huawei/i], describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/(can-l01)/i, e12) && "Nova", n6 = { type: o6.PLATFORMS_MAP.mobile, vendor: "Huawei" };
    return t7 && (n6.model = t7), n6;
  } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet, vendor: "Nexus" };
  } }, { test: [/ipad/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
  } }, { test: [/kftt build/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
  } }, { test: [/silk/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet, vendor: "Amazon" };
  } }, { test: [/tablet(?! pc)/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet };
  } }, { test: function(e12) {
    var t7 = e12.test(/ipod|iphone/i), n6 = e12.test(/like (ipod|iphone)/i);
    return t7 && !n6;
  }, describe: function(e12) {
    var t7 = i9.default.getFirstMatch(/(ipod|iphone)/i, e12);
    return { type: o6.PLATFORMS_MAP.mobile, vendor: "Apple", model: t7 };
  } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.mobile, vendor: "Nexus" };
  } }, { test: [/[^-]mobi/i], describe: function() {
    return { type: o6.PLATFORMS_MAP.mobile };
  } }, { test: function(e12) {
    return "blackberry" === e12.getBrowserName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
  } }, { test: function(e12) {
    return "bada" === e12.getBrowserName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.mobile };
  } }, { test: function(e12) {
    return "windows phone" === e12.getBrowserName();
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
  } }, { test: function(e12) {
    var t7 = Number(String(e12.getOSVersion()).split(".")[0]);
    return "android" === e12.getOSName(true) && t7 >= 3;
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.tablet };
  } }, { test: function(e12) {
    return "android" === e12.getOSName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.mobile };
  } }, { test: function(e12) {
    return "macos" === e12.getOSName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.desktop, vendor: "Apple" };
  } }, { test: function(e12) {
    return "windows" === e12.getOSName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.desktop };
  } }, { test: function(e12) {
    return "linux" === e12.getOSName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.desktop };
  } }, { test: function(e12) {
    return "playstation 4" === e12.getOSName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.tv };
  } }, { test: function(e12) {
    return "roku" === e12.getOSName(true);
  }, describe: function() {
    return { type: o6.PLATFORMS_MAP.tv };
  } }];
  t6.default = s5, e11.exports = t6.default;
}, 95: function(e11, t6, n5) {
  t6.__esModule = true, t6.default = void 0;
  var r8, i9 = (r8 = n5(17)) && r8.__esModule ? r8 : { default: r8 }, o6 = n5(18), s5 = [{ test: function(e12) {
    return "microsoft edge" === e12.getBrowserName(true);
  }, describe: function(e12) {
    if (/\sedg\//i.test(e12)) return { name: o6.ENGINE_MAP.Blink };
    var t7 = i9.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e12);
    return { name: o6.ENGINE_MAP.EdgeHTML, version: t7 };
  } }, { test: [/trident/i], describe: function(e12) {
    var t7 = { name: o6.ENGINE_MAP.Trident }, n6 = i9.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: function(e12) {
    return e12.test(/presto/i);
  }, describe: function(e12) {
    var t7 = { name: o6.ENGINE_MAP.Presto }, n6 = i9.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: function(e12) {
    var t7 = e12.test(/gecko/i), n6 = e12.test(/like gecko/i);
    return t7 && !n6;
  }, describe: function(e12) {
    var t7 = { name: o6.ENGINE_MAP.Gecko }, n6 = i9.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
    return { name: o6.ENGINE_MAP.Blink };
  } }, { test: [/(apple)?webkit/i], describe: function(e12) {
    var t7 = { name: o6.ENGINE_MAP.WebKit }, n6 = i9.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e12);
    return n6 && (t7.version = n6), t7;
  } }];
  t6.default = s5, e11.exports = t6.default;
} });
var Wu = ue4(qu.exports);
var Vu = { Initialized: "initialized", DisplayURI: "display_uri", ProviderUpdate: "provider_update", ConnectWithResponse: "connectWithResponse", ConnectionStatus: "connection_status", ServiceStatus: "service_status" };
var Gu = class _Gu {
  constructor({ shouldSetOnWindow: e11, connectionStream: t6, shouldSendMetadata: n5 = false, shouldShimWeb3: r8, sdkInstance: i9 }) {
    const o6 = new Ju({ connectionStream: t6, shouldSendMetadata: n5, shouldSetOnWindow: e11, shouldShimWeb3: r8, autoRequestAccounts: false }), s5 = new Proxy(o6, { deleteProperty: () => true });
    if (this.provider = s5, this.sdkInstance = i9, e11 && "undefined" != typeof window) try {
      a6 = o6, window.ethereum = a6, window.dispatchEvent(new Event("ethereum#initialized"));
    } catch (e12) {
      Iu("[Ethereum] Unable to set global provider - window.ethereum may be read-only", e12);
    }
    var a6;
    if (r8 && "undefined" != typeof window) try {
      !function(e12, t7 = console) {
        let n6 = false, r9 = false;
        if (!window.web3) {
          const i10 = "__isMetaMaskShim__";
          let o7 = { currentProvider: e12 };
          Object.defineProperty(o7, i10, { value: true, enumerable: true, configurable: false, writable: false }), o7 = new Proxy(o7, { get: (o8, s6, ...a7) => ("currentProvider" !== s6 || n6 ? "currentProvider" === s6 || s6 === i10 || r9 || (r9 = true, t7.error("MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), e12.request({ method: "metamask_logWeb3ShimUsage" }).catch((e13) => {
            t7.debug("MetaMask: Failed to log web3 shim usage.", e13);
          })) : (n6 = true, t7.warn("You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3")), Reflect.get(o8, s6, ...a7)), set: (...e13) => (t7.warn("You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3"), Reflect.set(...e13)) }), Object.defineProperty(window, "web3", { value: o7, enumerable: false, configurable: true, writable: true });
        }
      }(this.provider);
    } catch (e12) {
      Iu("[Ethereum] Unable to shim web3 - window.web3 may be read-only", e12);
    }
    this.provider.on("display_uri", (e12) => {
      this.sdkInstance.emit(Vu.DisplayURI, e12);
    }), this.provider.on("_initialized", () => {
      const e12 = { chainId: this.provider.getChainId(), isConnected: this.provider.isConnected(), isMetaMask: this.provider.isMetaMask, selectedAddress: this.provider.getSelectedAddress(), networkVersion: this.provider.getNetworkVersion() };
      this.sdkInstance.emit(Vu.Initialized, e12), Iu("[Ethereum: constructor()] provider initialized", e12);
    });
  }
  static init(e11) {
    var t6;
    return Iu("[Ethereum: init()] Initializing Ethereum service"), this.instance = new _Gu(e11), null === (t6 = this.instance) || void 0 === t6 ? void 0 : t6.provider;
  }
  static destroy() {
  }
  static getInstance() {
    var e11;
    if (!(null === (e11 = this.instance) || void 0 === e11 ? void 0 : e11.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance;
  }
  static getProvider() {
    var e11;
    if (!(null === (e11 = this.instance) || void 0 === e11 ? void 0 : e11.provider)) throw new Error("Ethereum instance not intiialized - call Ethereum.factory first.");
    return this.instance.provider;
  }
};
var Yu = class _Yu {
  constructor({ useDeepLink: e11, preferredOpenLink: t6, debug: n5 = false }) {
    this.state = { platformType: void 0, useDeeplink: false, preferredOpenLink: void 0, debug: false }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e11, this.state.preferredOpenLink = t6, this.state.debug = n5;
  }
  openDeeplink(e11, t6, n5) {
    return function(e12, t7, n6, r8) {
      const { state: i9 } = e12;
      Iu(`[PlatfformManager: openDeeplink()] universalLink --> ${t7}`), Iu(`[PlatfformManager: openDeeplink()] deepLink --> ${n6}`);
      try {
        if (i9.preferredOpenLink) return void i9.preferredOpenLink(i9.useDeeplink ? n6 : t7, r8);
        if (Iu(`[PlatfformManager: openDeeplink()] open link now useDeepLink=${i9.useDeeplink} link=${i9.useDeeplink ? n6 : t7}`), i9.useDeeplink) "undefined" != typeof window && (window.location.href = n6);
        else if ("undefined" != typeof document) {
          const e13 = document.createElement("a");
          e13.href = t7, e13.target = "_self", e13.rel = "noreferrer noopener", e13.click();
        }
      } catch (e13) {
        console.log("[PlatfformManager: openDeeplink()] can't open link", e13);
      }
    }(this, e11, t6, n5);
  }
  isReactNative() {
    var e11;
    return this.isNotBrowser() && "undefined" != typeof window && (null === window || void 0 === window ? void 0 : window.navigator) && "ReactNative" === (null === (e11 = window.navigator) || void 0 === e11 ? void 0 : e11.product);
  }
  isMetaMaskInstalled() {
    return function() {
      const e11 = Gu.getProvider() || (null === window || void 0 === window ? void 0 : window.ethereum);
      return Iu(`[PlatfformManager: isMetaMaskInstalled()] isMetaMask=${null == e11 ? void 0 : e11.isMetaMask} isConnected=${null == e11 ? void 0 : e11.isConnected()}`), (null == e11 ? void 0 : e11.isMetaMask) && (null == e11 ? void 0 : e11.isConnected());
    }();
  }
  isDesktopWeb() {
    return this.isBrowser() && !this.isMobileWeb();
  }
  isMobile() {
    var e11, t6;
    const n5 = Wu.parse(window.navigator.userAgent);
    return "mobile" === (null === (e11 = null == n5 ? void 0 : n5.platform) || void 0 === e11 ? void 0 : e11.type) || "tablet" === (null === (t6 = null == n5 ? void 0 : n5.platform) || void 0 === t6 ? void 0 : t6.type);
  }
  isSecure() {
    return this.isReactNative() || this.isMobileWeb();
  }
  isMetaMaskMobileWebView() {
    return "undefined" != typeof window && (Boolean(window.ReactNativeWebView) && Boolean(navigator.userAgent.endsWith("MetaMaskMobile")));
  }
  isMobileWeb() {
    return this.state.platformType === Uo3.MobileWeb;
  }
  static isNotBrowser() {
    var e11;
    return "undefined" == typeof window || !(null === window || void 0 === window ? void 0 : window.navigator) || void 0 !== l8 && "ReactNative" === (null === (e11 = null == l8 ? void 0 : l8.navigator) || void 0 === e11 ? void 0 : e11.product) || "ReactNative" === (null === navigator || void 0 === navigator ? void 0 : navigator.product);
  }
  isNotBrowser() {
    return _Yu.isNotBrowser();
  }
  static isBrowser() {
    return !this.isNotBrowser();
  }
  isBrowser() {
    return _Yu.isBrowser();
  }
  isNodeJS() {
    return this.isNotBrowser() && !this.isReactNative();
  }
  isUseDeepLink() {
    return this.state.useDeeplink;
  }
  getPlatformType() {
    return function(e11) {
      const { state: t6 } = e11;
      return t6.platformType ? t6.platformType : e11.isReactNative() ? Uo3.ReactNative : e11.isNotBrowser() ? Uo3.NonBrowser : e11.isMetaMaskMobileWebView() ? Uo3.MetaMaskMobileWebview : e11.isMobile() ? Uo3.MobileWeb : Uo3.DesktopWeb;
    }(this);
  }
};
var Zu = (e11) => c8(void 0, void 0, void 0, function* () {
  if (Yu.isBrowser()) {
    const { StorageManagerWeb: t7 } = yield Promise.resolve().then(function() {
      return cf2;
    });
    return new t7(e11);
  }
  const t6 = { persistChannelConfig: () => c8(void 0, void 0, void 0, function* () {
  }), getPersistedChannelConfig: () => c8(void 0, void 0, void 0, function* () {
  }), persistAccounts: () => c8(void 0, void 0, void 0, function* () {
  }), getCachedAccounts: () => c8(void 0, void 0, void 0, function* () {
    return [];
  }), persistChainId: () => c8(void 0, void 0, void 0, function* () {
  }), getCachedChainId: () => c8(void 0, void 0, void 0, function* () {
  }), terminate: () => c8(void 0, void 0, void 0, function* () {
  }) };
  return Promise.resolve(t6);
});
var Ju = class extends Mu {
  constructor({ connectionStream: e11, shouldSendMetadata: t6, autoRequestAccounts: n5 = false }) {
    super(e11, { logger: console, maxEventListeners: 100, shouldSendMetadata: t6 }), this.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "", networkVersion: "" }, Iu(`[SDKProvider: constructor()] autoRequestAccounts=${n5}`), this.state.autoRequestAccounts = n5;
  }
  forceInitializeState() {
    return c8(this, void 0, void 0, function* () {
      return Iu(`[SDKProvider: forceInitializeState()] autoRequestAccounts=${this.state.autoRequestAccounts}`), this._initializeStateAsync();
    });
  }
  _setConnected() {
    Iu("[SDKProvider: _setConnected()] Setting connected state"), this._state.isConnected = true;
  }
  getState() {
    return this._state;
  }
  getSDKProviderState() {
    return this.state;
  }
  getSelectedAddress() {
    var e11;
    const { accounts: t6 } = this._state;
    return t6 && 0 !== t6.length ? (null === (e11 = t6[0]) || void 0 === e11 ? void 0 : e11.toLowerCase()) || "" : (Iu("[SDKProvider: getSelectedAddress] No accounts found"), null);
  }
  getChainId() {
    return this.state.chainId;
  }
  getNetworkVersion() {
    return this.state.networkVersion;
  }
  setSDKProviderState(e11) {
    this.state = Object.assign(Object.assign({}, this.state), e11);
  }
  handleAccountsChanged(e11, t6) {
    return this._handleAccountsChanged(e11, t6);
  }
  handleDisconnect({ terminate: e11 = false }) {
    !function({ terminate: e12 = false, instance: t6 }) {
      const { state: n5 } = t6;
      Iu(`[SDKProvider: handleDisconnect()] cleaning up provider state terminate=${e12}`, t6), e12 && (t6._state.accounts = null, t6._state.isUnlocked = false, t6._state.isPermanentlyDisconnected = true, t6._state.initialized = false), t6._handleAccountsChanged([]), t6._state.isConnected = false, t6.emit("disconnect", Ru.ethErrors.provider.disconnected()), n5.providerStateRequested = false;
    }({ terminate: e11, instance: this });
  }
  _initializeStateAsync() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        var t6, n5;
        return c8(this, void 0, void 0, function* () {
          void 0 === e11.state && (e11.state = { accounts: null, autoRequestAccounts: false, providerStateRequested: false, chainId: "" });
          const { state: r8 } = e11;
          let i9;
          if (r8.providerStateRequested) Iu("[SDKProvider: initializeStateAsync()] initialization already in progress");
          else {
            let o6;
            r8.providerStateRequested = true;
            let s5 = null, a6 = false, c9 = false;
            const l9 = yield Zu({ enabled: true });
            if (l9) {
              const e12 = yield l9.getPersistedChannelConfig({});
              a6 = null !== (t6 = null == e12 ? void 0 : e12.relayPersistence) && void 0 !== t6 && t6, o6 = yield l9.getCachedChainId();
              const n6 = yield l9.getCachedAccounts();
              n6.length > 0 && (s5 = n6[0]);
            }
            if (Iu(`[SDKProvider: initializeStateAsync()] relayPersistence=${a6}`, { relayPersistence: a6, cachedChainId: o6, cachedSelectedAddress: s5 }), a6) if (o6 && s5) i9 = { accounts: [s5], chainId: o6, isUnlocked: false }, c9 = true;
            else try {
              i9 = yield e11.request({ method: "metamask_getProviderState" });
            } catch (t7) {
              return e11._log.error("MetaMask: Failed to get initial state. Please report this bug.", t7), void (r8.providerStateRequested = false);
            }
            if (0 === (null === (n5 = null == i9 ? void 0 : i9.accounts) || void 0 === n5 ? void 0 : n5.length)) if (e11.getSelectedAddress()) i9.accounts = [e11.getSelectedAddress()];
            else {
              Iu("[SDKProvider: initializeStateAsync()] Fetch accounts remotely.");
              const t7 = yield e11.request({ method: "eth_requestAccounts", params: [] });
              i9.accounts = t7;
            }
            e11._initializeState(i9), r8.providerStateRequested = false, c9 && (e11._state.isConnected = true, e11.emit("connect", { chainId: null == i9 ? void 0 : i9.chainId }));
          }
        });
      }(this);
    });
  }
  _initializeState(e11) {
    return Iu("[SDKProvider: _initializeState()]", e11), function(e12, t6, n5) {
      return Iu("[SDKProvider: initializeState()] set state._initialized to false"), e12._state.initialized = false, t6(n5);
    }(this, super._initializeState.bind(this), e11);
  }
  _handleChainChanged({ chainId: e11, networkVersion: t6 } = {}) {
    this.state.chainId = e11, this.state.networkVersion = t6, function({ instance: e12, chainId: t7, networkVersion: r8, superHandleChainChanged: i9 }) {
      Iu(`[SDKProvider: handleChainChanged()] chainId=${t7} networkVersion=${r8}`);
      let o6 = r8;
      r8 || (Iu("[SDKProvider: handleChainChanged()] forced network version to prevent provider error"), o6 = "1"), t7 !== Tu && (import_sdk_analytics.analytics.track("sdk_used_chain", { caip_chain_id: `eip155:${parseInt(null != t7 ? t7 : "0x1", 16)}` }), Tu = t7), e12._state.isConnected = true, e12.emit("connect", { chainId: t7 }), i9({ chainId: t7, networkVersion: o6 });
    }({ instance: this, chainId: e11, networkVersion: t6, superHandleChainChanged: super._handleChainChanged.bind(this) });
  }
};
var Qu;
var Xu = { name: "@metamask/sdk", version: "0.33.0", description: "", homepage: "https://github.com/MetaMask/metamask-sdk#readme", bugs: { url: "https://github.com/MetaMask/metamask-sdk/issues" }, repository: { type: "git", url: "https://github.com/MetaMask/metamask-sdk", directory: "packages/sdk" }, main: "dist/node/cjs/metamask-sdk.js", module: "dist/browser/es/metamask-sdk.js", browser: "dist/browser/es/metamask-sdk.js", unpkg: "dist/browser/umd/metamask-sdk.js", "react-native": "dist/react-native/es/metamask-sdk.js", types: "dist/types/src/index.d.ts", sideEffects: false, files: ["/dist"], scripts: { "build:types": "tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types", build: "yarn build:types && rollup -c --bundleConfigAsCjs", "build:clean": "yarn clean && yarn build", "build:post-tsc": "echo 'N/A'", "build:pre-tsc": "echo 'N/A'", typecheck: "tsc --noEmit", clean: "rimraf ./dist", size: "node bundle-size && size-limit", lint: "yarn lint:eslint && yarn lint:misc --check", "lint:changelog": "../../scripts/validate-changelog.sh @metamask/sdk", "lint:eslint": "eslint . --cache --ext js,ts", "lint:fix": "yarn lint:eslint --fix && yarn lint:misc --write", "lint:misc": "prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore", prepack: "../../scripts/prepack.sh", "publish:preview": "yarn npm publish --tag preview", reset: "yarn clean && rimraf ./node_modules/", test: 'jest --testPathIgnorePatterns "/e2e/"', "test:coverage": 'jest --coverage --testPathIgnorePatterns "/e2e/"', "test:e2e": 'jest --testPathPattern "/e2e/"', "test:ci": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns "/e2e/"', "test:dev": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns "/e2e/"', watch: "rollup -c -w", dev: 'concurrently "tsc --watch" "rollup -c -w --bundleConfigAsCjs"', "build:dev": "yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs" }, dependencies: { "@babel/runtime": "^7.26.0", "@metamask/onboarding": "^1.0.1", "@metamask/providers": "16.1.0", "@metamask/sdk-analytics": "workspace:*", "@metamask/sdk-communication-layer": "workspace:*", "@metamask/sdk-install-modal-web": "workspace:*", "@paulmillr/qr": "^0.2.1", bowser: "^2.9.0", "cross-fetch": "^4.0.0", debug: "^4.3.4", eciesjs: "^0.4.11", "eth-rpc-errors": "^4.0.3", eventemitter2: "^6.4.9", "obj-multiplex": "^1.0.0", pump: "^3.0.0", "readable-stream": "^3.6.2", "socket.io-client": "^4.5.1", tslib: "^2.6.0", util: "^0.12.4", uuid: "^8.3.2" }, devDependencies: { "@jest/globals": "^29.3.1", "@lavamoat/allow-scripts": "^2.3.1", "@metamask/auto-changelog": "3.1.0", "@metamask/eslint-config": "^6.0.0", "@metamask/eslint-config-nodejs": "^6.0.0", "@metamask/eslint-config-typescript": "^6.0.0", "@react-native-async-storage/async-storage": "^1.19.6", "@rollup/plugin-alias": "^5.1.1", "@rollup/plugin-commonjs": "^25.0.7", "@rollup/plugin-json": "^6.0.0", "@rollup/plugin-node-resolve": "^15.0.2", "@rollup/plugin-replace": "^6.0.1", "@rollup/plugin-terser": "^0.4.1", "@size-limit/preset-big-lib": "^11.0.2", "@types/dom-screen-wake-lock": "^1.0.2", "@types/node": "^20.1.3", "@types/pump": "^1.1.1", "@types/qrcode-terminal": "^0.12.0", "@types/uuid": "^10.0.0", "@typescript-eslint/eslint-plugin": "^4.26.0", "@typescript-eslint/parser": "^4.26.0", "browserify-zlib": "^0.2.0", buffer: "^6.0.3", concurrently: "^9.1.2", "crypto-browserify": "^3.12.0", eslint: "^7.30.0", "eslint-config-prettier": "^8.3.0", "eslint-plugin-import": "^2.23.4", "eslint-plugin-jest": "^24.4.0", "eslint-plugin-jsdoc": "^36.1.0", "eslint-plugin-node": "^11.1.0", "eslint-plugin-prettier": "^3.4.0", "https-browserify": "^1.0.0", jest: "^29.3.1", "jest-environment-jsdom": "^29.3.1", prettier: "^2.3.0", process: "^0.11.10", rimraf: "^4.4.0", rollup: "^4.26.0", "rollup-plugin-analyzer": "^4.0.0", "rollup-plugin-jscc": "^2.0.0", "rollup-plugin-natives": "^0.7.5", "rollup-plugin-node-builtins": "^2.1.2", "rollup-plugin-polyfill-node": "^0.13.0", "rollup-plugin-sizes": "^1.0.6", "rollup-plugin-typescript2": "^0.31.2", "rollup-plugin-visualizer": "^5.12.0", "size-limit": "^11.0.2", "stream-browserify": "^3.0.0", "stream-http": "^3.2.0", "ts-jest": "^29.0.3", "ts-node": "^10.9.1", typescript: "^4.3.2", url: "^0.11.0", webpack: "^5.0.0" }, publishConfig: { access: "public", registry: "https://registry.npmjs.org/" }, lavamoat: { allowScripts: { "eciesjs>secp256k1": false, "socket.io-client>engine.io-client>ws>bufferutil": false, "socket.io-client>engine.io-client>ws>utf-8-validate": false, "@metamask/sdk-communication-layer>bufferutil": false, "@metamask/sdk-communication-layer>eciesjs>secp256k1": false, "@metamask/sdk-communication-layer>utf-8-validate": false } } };
!function(e11) {
  e11.INPAGE = "metamask-inpage", e11.CONTENT_SCRIPT = "metamask-contentscript", e11.PROVIDER = "metamask-provider";
}(Qu || (Qu = {}));
var eh = "direct";
var th = "https://metamask.app.link/connect";
var nh = "metamask://connect";
var rh = { NAME: "MetaMask", RDNS: ["io.metamask", "io.metamask.flask"] };
var ih = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u;
var oh = { METAMASK_GETPROVIDERSTATE: "metamask_getProviderState", METAMASK_CONNECTSIGN: "metamask_connectSign", METAMASK_CONNECTWITH: "metamask_connectWith", METAMASK_OPEN: "metamask_open", METAMASK_BATCH: "metamask_batch", PERSONAL_SIGN: "personal_sign", WALLET_REQUESTPERMISSIONS: "wallet_requestPermissions", WALLET_REVOKEPERMISSIONS: "wallet_revokePermissions", WALLET_GETPERMISSIONS: "wallet_getPermissions", WALLET_WATCHASSET: "wallet_watchAsset", WALLET_ADDETHEREUMCHAIN: "wallet_addEthereumChain", WALLET_SWITCHETHETHEREUMCHAIN: "wallet_switchEthereumChain", ETH_REQUESTACCOUNTS: "eth_requestAccounts", ETH_ACCOUNTS: "eth_accounts", ETH_CHAINID: "eth_chainId", ETH_SENDTRANSACTION: "eth_sendTransaction", ETH_SIGNTYPEDDATA: "eth_signTypedData", ETH_SIGNTYPEDDATA_V3: "eth_signTypedData_v3", ETH_SIGNTYPEDDATA_V4: "eth_signTypedData_v4", ETH_SIGNTRANSACTION: "eth_signTransaction", ETH_SIGN: "eth_sign", PERSONAL_EC_RECOVER: "personal_ecRecover" };
var sh = { [oh.ETH_REQUESTACCOUNTS]: true, [oh.ETH_SENDTRANSACTION]: true, [oh.ETH_SIGNTRANSACTION]: true, [oh.ETH_SIGN]: true, [oh.PERSONAL_SIGN]: true, [oh.ETH_ACCOUNTS]: false, [oh.ETH_CHAINID]: false, [oh.PERSONAL_SIGN]: true, [oh.ETH_SIGNTYPEDDATA]: true, [oh.ETH_SIGNTYPEDDATA_V3]: true, [oh.ETH_SIGNTYPEDDATA_V4]: true, [oh.WALLET_REQUESTPERMISSIONS]: true, [oh.WALLET_GETPERMISSIONS]: true, [oh.WALLET_WATCHASSET]: true, [oh.WALLET_ADDETHEREUMCHAIN]: true, [oh.WALLET_SWITCHETHETHEREUMCHAIN]: true, [oh.METAMASK_CONNECTSIGN]: true, [oh.METAMASK_CONNECTWITH]: true, [oh.PERSONAL_EC_RECOVER]: true, [oh.METAMASK_BATCH]: true, [oh.METAMASK_OPEN]: true };
var ah = Object.keys(sh).filter((e11) => true === sh[e11]).map((e11) => e11.toLowerCase());
var ch = ["eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sign"].map((e11) => e11.toLowerCase());
var lh = ".sdk-comm";
var dh = "providerType";
var uh = ".MMSDK_cached_address";
var hh = ".MMSDK_cached_chainId";
var fh = { CHAIN_CHANGED: "chainChanged", ACCOUNTS_CHANGED: "accountsChanged", DISCONNECT: "disconnect", CONNECT: "connect", CONNECTED: "connected" };
var ph = 1e6;
var gh;
!function(e11) {
  e11.TERMINATE = "terminate", e11.EXTENSION = "extension", e11.INITIALIZED = "initialized";
}(gh || (gh = {}));
var mh = "undefined" != typeof window && window.localStorage;
function yh({ instance: e11, msg: t6 }) {
  return c8(this, void 0, void 0, function* () {
    if (e11._initialized || (Iu("[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()"), yield e11.init()), Iu(`[MetaMaskSDK: connectAndSign()] activeProvider=${e11.activeProvider}`), !e11.activeProvider) throw new Error("SDK state invalid -- undefined provider");
    const n5 = /^0x([0-9A-Fa-f]{2})*$/u.test(t6) ? t6 : function(e12) {
      let t7;
      if (void 0 !== C9) t7 = C9.from(e12, "utf8").toString("hex");
      else if ("undefined" != typeof TextEncoder) {
        const n6 = new TextEncoder().encode(e12);
        t7 = Array.from(n6).map((e13) => e13.toString(16).padStart(2, "0")).join("");
      } else {
        if ("object" != typeof l8 || !("Buffer" in l8)) throw new Error("Unable to convert string to hex: No available method.");
        t7 = l8.Buffer.from(e12, "utf8").toString("hex");
      }
      return `0x${t7}`;
    }(t6);
    return e11.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [{ method: oh.PERSONAL_SIGN, params: [n5] }] });
  });
}
function vh(e11) {
  var t6, n5;
  return c8(this, void 0, void 0, function* () {
    Iu("[MetaMaskSDK: connectWithExtensionProvider()] ", e11), e11.sdkProvider = e11.activeProvider, e11.activeProvider = window.extension, window.ethereum = window.extension;
    try {
      const e12 = yield null === (t6 = window.extension) || void 0 === t6 ? void 0 : t6.request({ method: "eth_requestAccounts" });
      Iu(`[MetaMaskSDK: connectWithExtensionProvider()] accounts=${e12}`);
    } catch (e12) {
      return void console.warn("[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error", e12);
    }
    localStorage.setItem(dh, "extension"), e11.extensionActive = true, e11.emit(Vu.ProviderUpdate, gh.EXTENSION), e11.options.enableAnalytics && (null === (n5 = e11.analytics) || void 0 === n5 || n5.send({ event: Ao3.SDK_USE_EXTENSION }));
  });
}
function bh(e11) {
  let t6;
  if (void 0 !== C9) t6 = C9.from(e11, "utf8").toString("base64");
  else if ("function" == typeof btoa) t6 = btoa(encodeURIComponent(e11).replace(/%([0-9A-F]{2})/gu, (e12, t7) => String.fromCharCode(parseInt(t7, 16))));
  else {
    if ("object" != typeof l8 || !("Buffer" in l8)) throw new Error("Unable to base64 encode: No available method.");
    t6 = l8.Buffer.from(e11, "utf8").toString("base64");
  }
  return t6;
}
function wh(e11, t6, n5, r8) {
  var i9, o6, s5, a6, l9, d7, u10, h9, f16, p9, g4, m6, y11, v9, b6, w8, E8, S8, _6, k11;
  return c8(this, void 0, void 0, function* () {
    const n6 = null === (i9 = e11.state.remote) || void 0 === i9 ? void 0 : i9.isReady(), c9 = null === (o6 = e11.state.remote) || void 0 === o6 ? void 0 : o6.isConnected(), A9 = null === (s5 = e11.state.remote) || void 0 === s5 ? void 0 : s5.isPaused(), x7 = Gu.getProvider(), M8 = null === (a6 = e11.state.remote) || void 0 === a6 ? void 0 : a6.getChannelId(), I8 = null === (l9 = e11.state.remote) || void 0 === l9 ? void 0 : l9.isAuthorized(), { deeplinkProtocol: T8 } = e11.state, { method: R6, data: P7, triggeredInstaller: O8 } = ((e12) => {
      var t7, n7, r9, i10;
      let o7;
      C9.isBuffer(e12) ? (o7 = e12.toJSON(), o7._isBuffer = true) : o7 = e12;
      const s6 = null === (t7 = null == o7 ? void 0 : o7.data) || void 0 === t7 ? void 0 : t7.method;
      let a7 = false;
      return "object" == typeof (null === (n7 = null == o7 ? void 0 : o7.data) || void 0 === n7 ? void 0 : n7.params) && true === (null === (i10 = null === (r9 = null == o7 ? void 0 : o7.data) || void 0 === r9 ? void 0 : r9.params) || void 0 === i10 ? void 0 : i10.__triggeredInstaller) && (a7 = true, o7.data.params = o7.data.params.wrappedParams), { method: s6, data: o7, triggeredInstaller: a7 };
    })(t6);
    if (Iu(`[RCPMS: write()] method='${R6}' isRemoteReady=${n6} channelId=${M8} isSocketConnected=${c9} isRemotePaused=${A9} providerConnected=${x7.isConnected()}`, t6), !M8) return R6 !== oh.METAMASK_GETPROVIDERSTATE && Iu(`[RCPMS: write()] ${R6} --> channelId is undefined`), r8(new Error("disconnected"));
    Iu(`[RCPMS: write()] remote.isPaused()=${null === (d7 = e11.state.remote) || void 0 === d7 ? void 0 : d7.isPaused()} authorized=${I8} ready=${n6} socketConnected=${c9}`, t6);
    const N9 = null === (u10 = e11.state.platformManager) || void 0 === u10 ? void 0 : u10.isSecure(), L7 = null !== (f16 = null === (h9 = e11.state.platformManager) || void 0 === h9 ? void 0 : h9.isMobileWeb()) && void 0 !== f16 && f16, D9 = null !== (g4 = null === (p9 = e11.state.remote) || void 0 === p9 ? void 0 : p9.hasDeeplinkProtocol()) && void 0 !== g4 && g4 && L7 && I8;
    try {
      if (!O8) {
        const t8 = JSON.stringify(null == P7 ? void 0 : P7.data);
        if (t8.length > ph) return r8(new Error(`Message size ${t8.length} exceeds maximum allowed size of 1000000 bytes`));
        null === (m6 = e11.state.remote) || void 0 === m6 || m6.sendMessage(null == P7 ? void 0 : P7.data).then(() => {
          Iu(`[RCPMS: _write()] ${R6} sent successfully`);
        }).catch((e12) => {
          Iu("[RCPMS: _write()] error sending message", e12);
        });
      }
      if (!N9) return Iu(`[RCPMS: _write()] unsecure platform for method ${R6} -- return callback`), r8();
      if (O8) return Iu("[RCPMS: _write()] prevent deeplink -- installation completed separately."), r8();
      const t7 = null !== (b6 = null === (v9 = null === (y11 = e11.state.remote) || void 0 === y11 ? void 0 : y11.getKeyInfo()) || void 0 === v9 ? void 0 : v9.ecies.public) && void 0 !== b6 ? b6 : "";
      let n7 = encodeURI(`channelId=${M8}&pubkey=${t7}&comm=socket&t=d&v=2`);
      if (D9) {
        const t8 = JSON.stringify(null == P7 ? void 0 : P7.data), i10 = null === (w8 = e11.state.remote) || void 0 === w8 ? void 0 : w8.encrypt(t8);
        if (!i10) return Iu("[RCPMS: _write()] error encrypting message"), r8(new Error("RemoteCommunicationPostMessageStream - disconnected"));
        n7 += `&scheme=${T8}&rpc=${bh(i10)}`;
      }
      if (!(null === (E8 = e11.state.platformManager) || void 0 === E8 ? void 0 : E8.isMetaMaskInstalled())) return Iu("[RCPMS: _write()] prevent deeplink until installation is completed."), r8();
      sh[R6] ? (Iu(`[RCPMS: _write()] redirect link for '${R6}' socketConnected=${c9} connect?${n7}`), null === (S8 = e11.state.platformManager) || void 0 === S8 || S8.openDeeplink(`${th}?${n7}`, `${nh}?${n7}`, "_self")) : (null === (_6 = e11.state.remote) || void 0 === _6 ? void 0 : _6.isPaused()) ? (Iu(`[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=${R6}`), null === (k11 = e11.state.platformManager) || void 0 === k11 || k11.openDeeplink(`${th}?redirect=true&${n7}`, `${nh}?redirect=true&${n7}`, "_self")) : Iu(`[RCPMS: _write()] method ${R6} doesn't need redirect.`);
    } catch (e12) {
      return Iu("[RCPMS: _write()] error sending message", e12), r8(new Error("RemoteCommunicationPostMessageStream - disconnected"));
    }
    return r8();
  });
}
var Eh = class extends ou.Duplex {
  constructor({ name: e11, remote: t6, deeplinkProtocol: n5, platformManager: r8 }) {
    super({ objectMode: true }), this.state = { _name: null, remote: null, deeplinkProtocol: false, platformManager: null }, this.state._name = e11, this.state.remote = t6, this.state.deeplinkProtocol = n5, this.state.platformManager = r8, this._onMessage = this._onMessage.bind(this), this.state.remote.on(So3.MESSAGE, this._onMessage);
  }
  _write(e11, t6, n5) {
    return c8(this, void 0, void 0, function* () {
      return wh(this, e11, 0, n5);
    });
  }
  _read() {
  }
  _onMessage(e11) {
    return function(e12, t6) {
      try {
        if (Iu("[RCPMS: onMessage()] message", t6), !t6 || "object" != typeof t6) return;
        if ("object" != typeof (null == t6 ? void 0 : t6.data)) return;
        if (!(null == t6 ? void 0 : t6.name)) return void Iu("[RCPMS: onMessage()] ignore message without name", t6);
        if ((null == t6 ? void 0 : t6.name) !== Qu.PROVIDER) return void Iu(`[RCPMS: onMessage()] ignore message with wrong name message=${t6}`);
        if (C9.isBuffer(t6)) {
          const n5 = C9.from(t6);
          e12.push(n5);
        } else e12.push(t6);
      } catch (e13) {
        Iu(`[RCPMS: onMessage()] ignore message error err=${e13}`);
      }
    }(this, e11);
  }
  start() {
  }
};
var Sh = 1;
var _h = (e11) => new Promise((t6) => {
  setTimeout(() => {
    t6(true);
  }, e11);
});
var Ch = ({ checkInstallationOnAllCalls: t6 = false, communicationLayerPreference: n5, injectProvider: r8, shouldShimWeb3: i9, platformManager: o6, installer: s5, sdk: a6, remoteConnection: l9, debug: d7 }) => c8(void 0, void 0, void 0, function* () {
  var u10, h9;
  const f16 = (({ name: e11, remoteConnection: t7 }) => {
    if (!t7 || !(null == t7 ? void 0 : t7.getConnector())) throw new Error("Missing remote connection parameter");
    return new Eh({ name: e11, remote: null == t7 ? void 0 : t7.getConnector(), deeplinkProtocol: null == t7 ? void 0 : t7.state.deeplinkProtocol, platformManager: null == t7 ? void 0 : t7.getPlatformManager() });
  })({ name: Qu.INPAGE, target: Qu.CONTENT_SCRIPT, platformManager: o6, communicationLayerPreference: n5, remoteConnection: l9 }), p9 = o6.getPlatformType(), g4 = a6.options.dappMetadata, m6 = `Sdk/Javascript SdkVersion/${Xu.version} Platform/${p9} dApp/${null !== (u10 = g4.url) && void 0 !== u10 ? u10 : g4.name} dAppTitle/${g4.name}`;
  let y11 = null, v9 = null;
  const b6 = null === (h9 = a6.options.storage) || void 0 === h9 ? void 0 : h9.storageManager;
  if (b6) {
    try {
      const e11 = yield b6.getCachedAccounts();
      e11.length > 0 && (y11 = e11[0]);
    } catch (e11) {
      console.error(`[initializeMobileProvider] failed to get cached addresses: ${e11}`);
    }
    try {
      const e11 = yield b6.getCachedChainId();
      e11 && (v9 = e11);
    } catch (e11) {
      console.error(`[initializeMobileProvider] failed to parse cached chainId: ${e11}`);
    }
  }
  Iu(`[initializeMobileProvider] cachedAccountAddress: ${y11}, cachedChainId: ${v9}`);
  const w8 = !(!r8 || p9 === Uo3.NonBrowser || p9 === Uo3.ReactNative), E8 = Gu.init({ shouldSetOnWindow: w8, connectionStream: f16, shouldShimWeb3: i9, sdkInstance: a6 });
  let S8 = false;
  const _6 = (e11) => {
    S8 = e11;
  }, C10 = () => S8, k11 = (n6, r9, i10, d8) => c8(void 0, void 0, void 0, function* () {
    var u11, h10, f17, p10, g5, w9, E9, k12, A10;
    const x8 = Gu.getProvider();
    if (S8) {
      x8.emit("display_uri", (null == l9 ? void 0 : l9.state.qrcodeLink) || ""), null == l9 || l9.showActiveModal();
      let e11 = C10();
      for (; e11; ) {
        const t7 = C10(), n7 = null == l9 ? void 0 : l9.isAuthorized();
        e11 = t7 && !n7, Iu(`[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: ${t7} authorized: ${n7}`), yield _h(1e3);
      }
      return Iu("[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider"), i10(...r9);
    }
    const M8 = o6.isMetaMaskInstalled(), I8 = null == l9 ? void 0 : l9.isConnected();
    let T8 = null, R6 = null, P7 = null;
    if (T8 = null !== (u11 = x8.getSelectedAddress()) && void 0 !== u11 ? u11 : y11, P7 = x8.getChainId() || v9, T8 && b6 && T8 !== y11 && b6.persistAccounts([T8]).catch((e11) => {
      console.error(`[initializeMobileProvider] failed to persist account: ${e11}`);
    }), P7 && (v9 = P7, b6 && b6.persistChainId(P7).catch((e11) => {
      console.error(`[initializeMobileProvider] failed to persist chainId: ${e11}`);
    })), Iu("[initializeMobileProvider: sendRequest()]", { selectedAddress: T8, chainId: P7 }), d8 && Iu(`[initializeMobileProvider: sendRequest()] method=${n6} ongoing=${S8} selectedAddress=${T8} isInstalled=${M8} checkInstallationOnAllCalls=${t6} socketConnected=${I8}`), T8 && n6.toLowerCase() === oh.ETH_ACCOUNTS.toLowerCase()) return [T8];
    if (P7 && n6.toLowerCase() === oh.ETH_CHAINID.toLowerCase()) return P7;
    const O8 = [oh.ETH_REQUESTACCOUNTS, oh.WALLET_REQUESTPERMISSIONS, oh.METAMASK_CONNECTSIGN, oh.METAMASK_CONNECTWITH], N9 = !sh[n6], L7 = null === (h10 = a6.options.readonlyRPCMap) || void 0 === h10 ? void 0 : h10[P7];
    if (L7 && N9) try {
      const t7 = null === (f17 = null == r9 ? void 0 : r9[0]) || void 0 === f17 ? void 0 : f17.params, i11 = yield (({ rpcEndpoint: t8, method: n7, sdkInfo: r10, params: i12 }) => c8(void 0, void 0, void 0, function* () {
        const o7 = JSON.stringify({ jsonrpc: "2.0", method: n7, params: i12, id: (Sh += 1, Sh) }), s6 = { Accept: "application/json", "Content-Type": "application/json" };
        let a7;
        t8.includes("infura") && (s6["Metamask-Sdk-Info"] = r10);
        try {
          a7 = yield (0, import_cross_fetch2.default)(t8, { method: "POST", headers: s6, body: o7 });
        } catch (e11) {
          throw e11 instanceof Error ? new Error(`Failed to fetch from RPC: ${e11.message}`) : new Error(`Failed to fetch from RPC: ${e11}`);
        }
        if (!a7.ok) throw new Error(`Server responded with a status of ${a7.status}`);
        return (yield a7.json()).result;
      }))({ rpcEndpoint: L7, sdkInfo: m6, method: n6, params: t7 || [] });
      return d8 && Iu(`initializeProvider::ReadOnlyRPCResponse ${i11}`), i11;
    } catch (e11) {
      console.warn(`[initializeMobileProvider: sendRequest()] method=${n6} readOnlyRPCRequest failed:`, e11);
    }
    if ((!M8 || M8 && !I8) && n6 !== oh.METAMASK_GETPROVIDERSTATE) {
      const e11 = (null === (p10 = null == r9 ? void 0 : r9[0]) || void 0 === p10 ? void 0 : p10.params) || [];
      if (-1 !== O8.indexOf(n6) || t6) {
        _6(true);
        const t7 = n6 === oh.METAMASK_CONNECTWITH, o7 = `${Date.now()}`;
        try {
          yield s5.start({ wait: false, connectWith: t7 ? { method: n6, id: o7, params: e11 } : void 0 }), yield new Promise((e12, t8) => {
            (null == l9 ? void 0 : l9.isAuthorized()) && (Iu("[initializeMobileProvider: sendRequest()] already authorized"), e12(true)), null == l9 || l9.getConnector().once(So3.AUTHORIZED, () => {
              e12(true);
            }), a6.once(So3.PROVIDER_UPDATE, (e13) => {
              Iu(`[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=${e13}`), e13 === gh.EXTENSION ? t8(So3.PROVIDER_UPDATE) : t8(new Error("Connection Terminated"));
            });
          });
        } catch (t8) {
          if (gh.EXTENSION === t8) {
            if (Iu(`[initializeMobileProvider: sendRequest()] extension provider detect: re-create ${n6} on the active provider`), n6.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase()) {
              const t9 = yield null === (g5 = a6.getProvider()) || void 0 === g5 ? void 0 : g5.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
              if (!t9.length) throw new Error("SDK state invalid -- undefined accounts");
              const n7 = yield null === (w9 = a6.getProvider()) || void 0 === w9 ? void 0 : w9.request({ method: oh.PERSONAL_SIGN, params: [e11[0], t9[0]] });
              return a6.emit(Vu.ConnectWithResponse, n7), n7;
            }
            if (n6.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase()) {
              const [t9] = e11, n7 = yield (({ method: e12, sdk: t10, params: n8 }) => c8(void 0, void 0, void 0, function* () {
                var r10, i11, o8, s6;
                if (!t10.isExtensionActive()) throw new Error("SDK state invalid -- extension is not active");
                Iu("[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method", e12, n8);
                const a7 = yield null === (r10 = t10.getProvider()) || void 0 === r10 ? void 0 : r10.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
                if (!a7.length) throw new Error("SDK state invalid -- undefined accounts");
                if ((null == e12 ? void 0 : e12.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase()) {
                  const r11 = { method: e12, params: [n8[0], a7[0]] };
                  return yield null === (i11 = t10.getProvider()) || void 0 === i11 ? void 0 : i11.request(r11);
                }
                if ((null == e12 ? void 0 : e12.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase()) {
                  const r11 = { method: e12, params: [Object.assign(Object.assign({}, n8[0]), { from: a7[0] })] };
                  return yield null === (o8 = t10.getProvider()) || void 0 === o8 ? void 0 : o8.request(r11);
                }
                return ch.includes(e12.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${e12} -- not handled by the extension -- call separately`), a7) : yield null === (s6 = t10.getProvider()) || void 0 === s6 ? void 0 : s6.request({ method: e12, params: n8 });
              }))({ method: t9.method, sdk: a6, params: t9.params });
              return a6.emit(Vu.ConnectWithResponse, n7), n7;
            }
            return Iu(`[initializeMobileProvider: sendRequest()] sending '${n6}' on active provider`, e11), yield null === (E9 = a6.getProvider()) || void 0 === E9 ? void 0 : E9.request({ method: n6, params: e11 });
          }
          if (t8 === So3.REJECTED) throw null == l9 || l9.closeModal(), null === (k12 = a6.getProvider()) || void 0 === k12 || k12.handleDisconnect({ terminate: false }), Object.assign(new Error("User rejected connection"), { code: 4001 });
          throw Iu(`[initializeMobileProvider: sendRequest()] failed to start installer: ${t8}`), t8;
        } finally {
          _6(false);
        }
        if (n6 === oh.ETH_REQUESTACCOUNTS) return R6 = yield new Promise((e12) => {
          const t8 = setInterval(() => {
            const { accounts: n7 } = x8.getState();
            n7 && (clearInterval(t8), e12(n7));
          }, 100);
        }), Iu(`[initializeMobileProvider: sendRequest()] selectedAddress: ${T8} --- SKIP rpc call`), R6;
        if (n6 === oh.METAMASK_CONNECTWITH) try {
          let e12 = 0;
          const t8 = 5, n7 = ({ resolve: n8, reject: r11 }) => {
            e12 += 1;
            const i12 = null == l9 ? void 0 : l9.getConnector().getRPCMethodTracker(), s7 = null == i12 ? void 0 : i12[o7];
            return Iu(`TRACKER: update method ${o7}`, s7), (null == s7 ? void 0 : s7.result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", s7.result), a6.emit(Vu.ConnectWithResponse, s7.result), void n8(s7.result)) : (null == s7 ? void 0 : s7.error) ? (Iu("[initializeMobileProvider: sendRequest()] found error", s7.error), void r11(s7.error)) : e12 >= t8 ? (Iu("[initializeMobileProvider: sendRequest()] max message count reached without result"), void r11(new Error("Max message count reached without result"))) : void Iu("[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update");
          };
          let r10, i11;
          const s6 = yield new Promise((e13, t9) => {
            const s7 = null == l9 ? void 0 : l9.getConnector().getRPCMethodTracker();
            Iu(`TRACKER: method ${o7}`, s7), (null == s7 ? void 0 : s7[o7].result) ? (Iu("[initializeMobileProvider: sendRequest()] found result", null == s7 ? void 0 : s7[o7].result), e13(null == s7 ? void 0 : s7[o7].result)) : (null == s7 ? void 0 : s7[o7].error) && (Iu("[initializeMobileProvider: sendRequest()] found error", null == s7 ? void 0 : s7[o7].error), t9(null == s7 ? void 0 : s7[o7].error)), i11 = () => n7({ resolve: e13, reject: t9 }), r10 = null == l9 ? void 0 : l9.getConnector().on(So3.RPC_UPDATE, i11);
          });
          return i11 && (null == r10 || r10.off(So3.RPC_UPDATE, i11)), Iu("TRACKER: result", s6), s6;
        } catch (e12) {
          throw Iu("[initializeMobileProvider: sendRequest()] error:", e12), e12;
        }
        r9[0] && "object" == typeof r9[0] && (r9[0].params = { __triggeredInstaller: true, wrappedParams: r9[0].params });
        return i10(...r9);
      }
      if (o6.isSecure() && sh[n6]) return i10(...r9);
      if (a6.isExtensionActive()) return Iu(`[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '${n6}' to it`, r9, e11), yield null === (A10 = a6.getProvider()) || void 0 === A10 ? void 0 : A10.request({ method: n6, params: e11 });
      throw Iu(`[initializeMobileProvider: sendRequest()] method=${n6} --- skip --- not connected/installed`), new Error("MetaMask is not connected/installed, please call eth_requestAccounts to connect first.");
    }
    try {
      const e11 = yield i10(...r9);
      if (Iu(`[initializeMobileProvider: sendRequest()] method=${n6} rpcResponse`, e11), n6 === oh.WALLET_REQUESTPERMISSIONS) {
        const t7 = e11.reduce((e12, t8) => {
          var n7;
          if ("eth_accounts" === t8.parentCapability) {
            const r10 = null === (n7 = t8.caveats.find((e13) => "restrictReturnedAccounts" === e13.type)) || void 0 === n7 ? void 0 : n7.value;
            r10 && e12.push(...r10);
          }
          return e12;
        }, []);
        Iu("[initializeMobileProvider: sendRequest()] accountsToPersist:", t7), t7.length > 0 && (x8.handleAccountsChanged(t7, false), null == b6 || b6.persistAccounts(t7));
      }
      return e11;
    } catch (e11) {
      throw console.error("[initializeMobileProvider: sendRequest()] error:", e11), e11;
    }
  }), { request: A9 } = E8;
  E8.request = (...e11) => c8(void 0, void 0, void 0, function* () {
    return k11(null == e11 ? void 0 : e11[0].method, e11, A9, d7);
  });
  const { send: x7 } = E8;
  return E8.send = (...e11) => c8(void 0, void 0, void 0, function* () {
    return k11(null == e11 ? void 0 : e11[0], e11, x7, d7);
  }), Iu("[initializeMobileProvider: sendRequest()] metamaskStream.start()"), f16.start(), E8;
});
function kh(e11) {
  var t6, n5, r8, i9;
  return c8(this, void 0, void 0, function* () {
    const { options: o6 } = e11, s5 = { communicationLayerPreference: null !== (t6 = o6.communicationLayerPreference) && void 0 !== t6 ? t6 : jo3.SOCKET, platformManager: e11.platformManager, sdk: e11, checkInstallationOnAllCalls: o6.checkInstallationOnAllCalls, injectProvider: null === (n5 = o6.injectProvider) || void 0 === n5 || n5, shouldShimWeb3: null === (r8 = o6.shouldShimWeb3) || void 0 === r8 || r8, extensionOnly: null === (i9 = o6.extensionOnly) || void 0 === i9 || i9, installer: e11.installer, remoteConnection: e11.remoteConnection, debug: e11.debug }, a6 = yield Ch(s5);
    e11.activeProvider = a6, function(e12) {
      var t7, n6, r9, i10;
      null === (n6 = null === (t7 = e12.remoteConnection) || void 0 === t7 ? void 0 : t7.getConnector()) || void 0 === n6 || n6.on(Vu.ConnectionStatus, (t8) => {
        e12.emit(Vu.ConnectionStatus, t8);
      }), null === (i10 = null === (r9 = e12.remoteConnection) || void 0 === r9 ? void 0 : r9.getConnector()) || void 0 === i10 || i10.on(Vu.ServiceStatus, (t8) => {
        e12.emit(Vu.ServiceStatus, t8);
      });
    }(e11);
  });
}
var Ah = "sdk";
var xh = class {
  constructor({ serverUrl: e11, enabled: t6, originatorInfo: n5 }) {
    this.serverURL = fo3, this.serverURL = e11, this.originatorInfo = n5, this.enabled = null == t6 || t6;
  }
  send({ event: e11, params: t6 }) {
    if (!this.enabled) return;
    const n5 = Object.assign(Object.assign({ id: Ah, event: e11, sdkVersion: Xu.version }, this.originatorInfo), { params: t6 });
    Iu(`[Analytics: send()] event: ${e11}`, n5), lo3(n5, this.serverURL).catch((e12) => {
      Iu(`[Analytics: send()] error: ${e12}`);
    });
  }
};
var Mh = () => {
  if ("undefined" == typeof document) return;
  let e11;
  const t6 = document.getElementsByTagName("link");
  for (let n5 = 0; n5 < t6.length; n5++) "icon" !== t6[n5].getAttribute("rel") && "shortcut icon" !== t6[n5].getAttribute("rel") || (e11 = t6[n5].getAttribute("href"));
  return e11;
};
var Ih = 163400;
function Th(e11) {
  var t6, n5, r8;
  const { dappMetadata: i9 } = e11, o6 = function({ url: e12, name: t7 }) {
    var n6;
    const r9 = e12 + t7, i10 = bh(r9);
    if (!localStorage) return "";
    let o7 = null !== (n6 = localStorage.getItem(i10)) && void 0 !== n6 ? n6 : "";
    if (!o7) {
      o7 = v4_default2();
      try {
        localStorage.setItem(i10, o7);
      } catch (e13) {
        return "";
      }
    }
    return o7;
  }({ url: null !== (t6 = null == i9 ? void 0 : i9.url) && void 0 !== t6 ? t6 : "no_url", name: null !== (n5 = null == i9 ? void 0 : i9.name) && void 0 !== n5 ? n5 : "no_name" }), a6 = null === (r8 = e11.platformManager) || void 0 === r8 ? void 0 : r8.getPlatformType(), c9 = a6 === Uo3.DesktopWeb, l9 = a6 === Uo3.MetaMaskMobileWebview;
  let d7 = "N/A";
  return c9 ? d7 = "extension" : l9 && (d7 = "mobile"), { id: o6, from: d7 };
}
var Rh = (e11, t6, r8) => {
  if (bo3(e11)) {
    if (r8 || t6 && "object" == typeof t6 && null !== t6 && "error" in t6) {
      const i9 = r8 || (null == t6 ? void 0 : t6.error);
      i9 && 4001 === i9.code ? import_sdk_analytics.analytics.track("sdk_action_rejected", { action: e11 }) : import_sdk_analytics.analytics.track("sdk_action_failed", { action: e11 });
    } else import_sdk_analytics.analytics.track("sdk_action_succeeded", { action: e11 });
  }
};
var Ph = ({ provider: e11, sdkInstance: t6 }) => {
  if ("state" in e11) throw new Error("INVALID EXTENSION PROVIDER");
  return new Proxy(e11, { get: (r8, i9) => "request" === i9 ? function(e12) {
    var i10, o6;
    return c8(this, void 0, void 0, function* () {
      Iu("[wrapExtensionProvider()] Overwriting request method", e12);
      const { method: s5, params: a6 } = e12, l9 = ah.includes(s5.toLowerCase()), { id: d7, from: u10 } = Th(t6);
      if (l9 && (null === (i10 = t6.analytics) || void 0 === i10 || i10.send({ event: Ao3.SDK_RPC_REQUEST, params: { method: s5, from: u10, id: d7 } })), bo3(s5) && import_sdk_analytics.analytics.track("sdk_action_requested", { action: s5 }), s5 === oh.METAMASK_BATCH && Array.isArray(a6)) return (({ target: e13, args: t7, trackEvent: n5, sdkInstance: r9 }) => c8(void 0, void 0, void 0, function* () {
        var i11, o7;
        if ("metamask_batch" !== t7.method) throw new Error("Invalid usage");
        const s6 = [], a7 = null !== (i11 = null == t7 ? void 0 : t7.params) && void 0 !== i11 ? i11 : [];
        for (const t8 of a7) {
          const n6 = yield null == e13 ? void 0 : e13.request({ method: t8.method, params: t8.params });
          s6.push(n6);
        }
        const { id: c9, from: l10 } = Th(r9);
        n5 && (null === (o7 = r9.analytics) || void 0 === o7 || o7.send({ event: Ao3.SDK_RPC_REQUEST_DONE, params: { method: t7.method, from: l10, id: c9 } }));
        for (const e14 of s6) Rh(t7.method, e14, null);
        return s6;
      }))({ target: r8, args: e12, trackEvent: l9, sdkInstance: t6 });
      if (s5.toLowerCase() === oh.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(a6)) return (({ target: e13, params: t7 }) => c8(void 0, void 0, void 0, function* () {
        let n5, r9 = null;
        try {
          const r10 = yield e13.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!r10.length) throw new Error("SDK state invalid -- undefined accounts");
          return n5 = yield e13.request({ method: oh.PERSONAL_SIGN, params: [t7[0], r10[0]] }), n5;
        } catch (e14) {
          throw r9 = e14, e14;
        } finally {
          Rh(oh.PERSONAL_SIGN, n5, r9);
        }
      }))({ target: r8, params: a6 });
      if (s5.toLowerCase() === oh.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(a6)) return (({ target: e13, params: t7 }) => c8(void 0, void 0, void 0, function* () {
        const [n5] = t7, r9 = n5.method, i11 = n5.params;
        let o7, s6 = null;
        try {
          const t8 = yield e13.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
          if (!Array.isArray(t8) || !t8.length) throw new Error("SDK state invalid -- undefined accounts");
          return (null == r9 ? void 0 : r9.toLowerCase()) === oh.PERSONAL_SIGN.toLowerCase() ? (o7 = yield e13.request({ method: r9, params: [i11[0], t8[0]] }), o7) : (null == r9 ? void 0 : r9.toLowerCase()) === oh.ETH_SENDTRANSACTION.toLowerCase() ? (o7 = yield e13.request({ method: r9, params: [Object.assign(Object.assign({}, i11[0]), { from: t8[0] })] }), o7) : ch.includes(r9.toLowerCase()) ? (console.warn(`MetaMaskSDK connectWith method=${r9} -- not handled by the extension -- call separately`), o7 = t8, o7) : (o7 = yield e13.request({ method: r9, params: i11 }), o7);
        } catch (e14) {
          throw s6 = e14, e14;
        } finally {
          Rh(r9, o7, s6);
        }
      }))({ target: r8, params: a6 });
      let h9, f16 = null;
      try {
        return h9 = yield r8.request(e12), h9;
      } catch (e13) {
        throw f16 = e13, e13;
      } finally {
        l9 && (null === (o6 = t6.analytics) || void 0 === o6 || o6.send({ event: Ao3.SDK_RPC_REQUEST_DONE, params: { method: s5, from: u10, id: d7 } })), Rh(s5, h9, f16);
      }
    });
  } : "getChainId" === i9 ? function() {
    return e11.chainId;
  } : "getNetworkVersion" === i9 ? function() {
    return e11.networkVersion;
  } : "getSelectedAddress" === i9 ? function() {
    return e11.selectedAddress;
  } : "isConnected" === i9 ? function() {
    return e11._state.isConnected;
  } : r8[i9] });
};
var Oh;
function Nh({ mustBeMetaMask: e11, sdkInstance: t6 }) {
  return c8(this, void 0, void 0, function* () {
    if ("undefined" == typeof window) throw new Error("window not available");
    try {
      const e12 = yield new Promise((e13, t7) => {
        const n5 = setTimeout(() => {
          t7(new Error("eip6963RequestProvider timed out"));
        }, 500);
        window.addEventListener(Oh.Announce, (t8) => {
          const r8 = t8, { detail: { info: i9, provider: o6 } = {} } = r8, { name: s5, rdns: a6, uuid: c9 } = null != i9 ? i9 : {};
          ih.test(c9) && s5.startsWith(rh.NAME) && rh.RDNS.includes(a6) && (clearTimeout(n5), e13(o6));
        }), window.dispatchEvent(new Event(Oh.Request));
      });
      return Ph({ provider: e12, sdkInstance: t6 });
    } catch (n5) {
      if (!e11 && window.ethereum) return Ph({ provider: window.ethereum, sdkInstance: t6 });
      throw new Error("Provider not found");
    }
  });
}
!function(e11) {
  e11.Announce = "eip6963:announceProvider", e11.Request = "eip6963:requestProvider";
}(Oh || (Oh = {}));
var Lh = (e11) => c8(void 0, void 0, void 0, function* () {
  const { options: t6 } = e11, { infuraAPIKey: n5 } = t6;
  if (!n5) return;
  const r8 = { "0x1": `https://mainnet.infura.io/v3/${n5}`, "0x5": `https://goerli.infura.io/v3/${n5}`, "0xaa36a7": `https://sepolia.infura.io/v3/${n5}`, "0xe708": `https://linea-mainnet.infura.io/v3/${n5}`, "0xe704": `https://linea-goerli.infura.io/v3/${n5}`, "0x89": `https://polygon-mainnet.infura.io/v3/${n5}`, "0x13881": `https://polygon-mumbai.infura.io/v3/${n5}`, "0x45": `https://optimism-mainnet.infura.io/v3/${n5}`, "0x1a4": `https://optimism-goerli.infura.io/v3/${n5}`, "0xa4b1": `https://arbitrum-mainnet.infura.io/v3/${n5}`, "0x66eed": `https://arbitrum-goerli.infura.io/v3/${n5}`, "0x2a15c308d": `https://palm-mainnet.infura.io/v3/${n5}`, "0x2a15c3083": `https://palm-testnet.infura.io/v3/${n5}`, "0xa86a": `https://avalanche-mainnet.infura.io/v3/${n5}`, "0xa869": `https://avalanche-fuji.infura.io/v3/${n5}`, "0x4e454152": `https://aurora-mainnet.infura.io/v3/${n5}`, "0x4e454153": `https://aurora-testnet.infura.io/v3/${n5}`, "0x534e5f4d41494e": `https://starknet-mainnet.infura.io/v3/${n5}`, "0x534e5f474f45524c49": `https://starknet-goerli.infura.io/v3/${n5}`, "0x534e5f474f45524c4932": `https://starknet-goerli2.infura.io/v3/${n5}`, "0xa4ec": `https://celo-mainnet.infura.io/v3/${n5}`, "0xaef3": `https://celo-alfajores.infura.io/v3/${n5}` };
  e11.options.readonlyRPCMap ? e11.options.readonlyRPCMap = Object.assign(Object.assign({}, e11.options.readonlyRPCMap), r8) : e11.options.readonlyRPCMap = r8;
});
var Dh = (e11) => c8(void 0, void 0, void 0, function* () {
  const { options: t6 } = e11, { readonlyRPCMap: n5 } = t6;
  if (n5) try {
    Iu("[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers", n5), e11.setReadOnlyRPCCalls(true);
  } catch (e12) {
    throw new Error("Invalid Infura Settings");
  }
});
function $h(e11, t6, n5, r8) {
  return new (n5 || (n5 = Promise))(function(t7, i9) {
    function o6(e12) {
      try {
        a6(r8.next(e12));
      } catch (e13) {
        i9(e13);
      }
    }
    function s5(e12) {
      try {
        a6(r8.throw(e12));
      } catch (e13) {
        i9(e13);
      }
    }
    function a6(e12) {
      var r9;
      e12.done ? t7(e12.value) : (r9 = e12.value, r9 instanceof n5 ? r9 : new n5(function(e13) {
        e13(r9);
      })).then(o6, s5);
    }
    a6((r8 = r8.apply(e11, [])).next());
  });
}
function Bh(e11, t6) {
  var n5, r8, i9, o6, s5 = { label: 0, sent: function() {
    if (1 & i9[0]) throw i9[1];
    return i9[1];
  }, trys: [], ops: [] };
  return o6 = { next: a6(0), throw: a6(1), return: a6(2) }, "function" == typeof Symbol && (o6[Symbol.iterator] = function() {
    return this;
  }), o6;
  function a6(o7) {
    return function(a7) {
      return function(o8) {
        if (n5) throw new TypeError("Generator is already executing.");
        for (; s5; ) try {
          if (n5 = 1, r8 && (i9 = 2 & o8[0] ? r8.return : o8[0] ? r8.throw || ((i9 = r8.return) && i9.call(r8), 0) : r8.next) && !(i9 = i9.call(r8, o8[1])).done) return i9;
          switch (r8 = 0, i9 && (o8 = [2 & o8[0], i9.value]), o8[0]) {
            case 0:
            case 1:
              i9 = o8;
              break;
            case 4:
              return s5.label++, { value: o8[1], done: false };
            case 5:
              s5.label++, r8 = o8[1], o8 = [0];
              continue;
            case 7:
              o8 = s5.ops.pop(), s5.trys.pop();
              continue;
            default:
              if (!(i9 = s5.trys, (i9 = i9.length > 0 && i9[i9.length - 1]) || 6 !== o8[0] && 2 !== o8[0])) {
                s5 = 0;
                continue;
              }
              if (3 === o8[0] && (!i9 || o8[1] > i9[0] && o8[1] < i9[3])) {
                s5.label = o8[1];
                break;
              }
              if (6 === o8[0] && s5.label < i9[1]) {
                s5.label = i9[1], i9 = o8;
                break;
              }
              if (i9 && s5.label < i9[2]) {
                s5.label = i9[2], s5.ops.push(o8);
                break;
              }
              i9[2] && s5.ops.pop(), s5.trys.pop();
              continue;
          }
          o8 = t6.call(e11, s5);
        } catch (e12) {
          o8 = [6, e12], r8 = 0;
        } finally {
          n5 = i9 = 0;
        }
        if (5 & o8[0]) throw o8[1];
        return { value: o8[0] ? o8[1] : void 0, done: true };
      }([o7, a7]);
    };
  }
}
var Kh = "INSTALLED";
var jh = "NOT_INSTALLED";
var Uh = "REGISTERED";
var Hh = "REGISTERING";
var Fh = "RELOADING";
var zh = { CHROME: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn", FIREFOX: "https://addons.mozilla.org/firefox/addon/ether-metamask/", DEFAULT: "https://metamask.io" };
var qh = "REGISTRATION_IN_PROGRESS";
var Wh = "FORWARDER_ID";
var Vh = function() {
  function e11(t6) {
    var n5 = void 0 === t6 ? {} : t6, r8 = n5.forwarderOrigin, i9 = void 0 === r8 ? "https://fwd.metamask.io" : r8, o6 = n5.forwarderMode, s5 = void 0 === o6 ? e11.FORWARDER_MODE.INJECT : o6;
    this.forwarderOrigin = i9, this.forwarderMode = s5, this.state = e11.isMetaMaskInstalled() ? Kh : jh;
    var a6 = e11._detectBrowser();
    this.downloadUrl = a6 ? zh[a6] : zh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener("message", this._onMessage), s5 === e11.FORWARDER_MODE.INJECT && "true" === sessionStorage.getItem(qh) && e11._injectForwarder(this.forwarderOrigin);
  }
  return e11.prototype._onMessage = function(e12) {
    if (e12.origin === this.forwarderOrigin) return "metamask:reload" === e12.data.type ? this._onMessageFromForwarder(e12) : void console.debug("Unknown message from '" + e12.origin + "' with data " + JSON.stringify(e12.data));
  }, e11.prototype._onMessageUnknownStateError = function(e12) {
    throw new Error("Unknown state: '" + e12 + "'");
  }, e11.prototype._onMessageFromForwarder = function(t6) {
    return $h(this, 0, void 0, function() {
      return Bh(this, function(n5) {
        switch (n5.label) {
          case 0:
            switch (this.state) {
              case Fh:
                return [3, 1];
              case jh:
                return [3, 2];
              case Kh:
                return [3, 3];
              case Hh:
                return [3, 5];
              case Uh:
                return [3, 6];
            }
            return [3, 7];
          case 1:
            return console.debug("Ignoring message while reloading"), [3, 8];
          case 2:
            return console.debug("Reloading now to register with MetaMask"), this.state = Fh, location.reload(), [3, 8];
          case 3:
            return console.debug("Registering with MetaMask"), this.state = Hh, [4, e11._register()];
          case 4:
            return n5.sent(), this.state = Uh, t6.source.postMessage({ type: "metamask:registrationCompleted" }, t6.origin), this.stopOnboarding(), [3, 8];
          case 5:
            return console.debug("Already registering - ignoring reload message"), [3, 8];
          case 6:
            return console.debug("Already registered - ignoring reload message"), [3, 8];
          case 7:
            this._onMessageUnknownStateError(this.state), n5.label = 8;
          case 8:
            return [2];
        }
      });
    });
  }, e11.prototype.startOnboarding = function() {
    sessionStorage.setItem(qh, "true"), this._openDownloadPage(), this._openForwarder();
  }, e11.prototype.stopOnboarding = function() {
    "true" === sessionStorage.getItem(qh) && (this.forwarderMode === e11.FORWARDER_MODE.INJECT && (console.debug("Removing forwarder"), e11._removeForwarder()), sessionStorage.setItem(qh, "false"));
  }, e11.prototype._openForwarder = function() {
    this.forwarderMode === e11.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, "_blank") : e11._injectForwarder(this.forwarderOrigin);
  }, e11.prototype._openDownloadPage = function() {
    window.open(this.downloadUrl, "_blank");
  }, e11.isMetaMaskInstalled = function() {
    return Boolean(window.ethereum && window.ethereum.isMetaMask);
  }, e11._register = function() {
    return window.ethereum.request({ method: "wallet_registerOnboarding" });
  }, e11._injectForwarder = function(e12) {
    var t6 = document.body, n5 = document.createElement("iframe");
    n5.setAttribute("height", "0"), n5.setAttribute("width", "0"), n5.setAttribute("style", "display: none;"), n5.setAttribute("src", e12), n5.setAttribute("id", Wh), t6.insertBefore(n5, t6.children[0]);
  }, e11._removeForwarder = function() {
    var e12;
    null === (e12 = document.getElementById(Wh)) || void 0 === e12 || e12.remove();
  }, e11._detectBrowser = function() {
    var e12 = Wu.parse(window.navigator.userAgent);
    return "Firefox" === e12.browser.name ? "FIREFOX" : ["Chrome", "Chromium"].includes(e12.browser.name || "") ? "CHROME" : null;
  }, e11.FORWARDER_MODE = { INJECT: "INJECT", OPEN_TAB: "OPEN_TAB" }, e11;
}();
function Gh(e11, { wait: t6 = false }) {
  return c8(this, void 0, void 0, function* () {
    return Iu(`[MetamaskInstaller: startInstaller()] wait=${t6}`), t6 && (yield _h(1e3)), yield e11.checkInstallation();
  });
}
var Yh = class {
  constructor({ remote: e11, preferDesktop: t6, platformManager: n5, debug: r8 = false }) {
    this.state = { isInstalling: false, hasInstalled: false, resendRequest: null, preferDesktop: false, platformManager: null, remote: null, debug: false, connectWith: void 0 }, this.state.remote = e11, this.state.preferDesktop = t6, this.state.platformManager = n5, this.state.debug = r8;
  }
  startDesktopOnboarding() {
    return function() {
      return c8(this, void 0, void 0, function* () {
        Iu("[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding"), window.ethereum && (window.ethereum = void 0), new Vh().startOnboarding();
      });
    }();
  }
  redirectToProperInstall() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        var t6, n5;
        return c8(this, void 0, void 0, function* () {
          const { state: r8 } = e11, i9 = null === (t6 = r8.platformManager) || void 0 === t6 ? void 0 : t6.getPlatformType();
          if (Iu(`[MetamaskInstaller: redirectToProperInstall()] platform=${i9}`), i9 === Uo3.MetaMaskMobileWebview) return false;
          r8.isInstalling = true;
          try {
            yield null === (n5 = r8.remote) || void 0 === n5 ? void 0 : n5.startConnection({ connectWith: r8.connectWith }), r8.isInstalling = false, r8.hasInstalled = true;
          } catch (e12) {
            throw r8.isInstalling = false, e12;
          }
          return true;
        });
      }(this);
    });
  }
  checkInstallation() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        var t6;
        return c8(this, void 0, void 0, function* () {
          const { state: n5 } = e11, r8 = null === (t6 = n5.platformManager) || void 0 === t6 ? void 0 : t6.isMetaMaskInstalled();
          return Iu(`[MetamaskInstaller: checkInstallation()] isInstalled=${r8}`), !!r8 || (yield e11.redirectToProperInstall());
        });
      }(this);
    });
  }
  start({ wait: e11 = false, connectWith: t6 }) {
    return c8(this, void 0, void 0, function* () {
      this.state.connectWith = t6, Iu(`[MetaMaskInstaller: start()] wait=${e11}`, t6), yield Gh(this, { wait: e11 });
    });
  }
};
var Zh = class {
  constructor({ debug: e11, sdkVersion: t6 }) {
    this.containers = { install: void 0, pending: void 0, select: void 0 }, this.defined = { install: false, pending: false, select: false }, this.debug = null != e11 && e11, this.sdkVersion = t6;
  }
  loadComponent(e11) {
    return c8(this, void 0, void 0, function* () {
      if (!this.defined[e11]) {
        this.defined[e11] = true;
        try {
          const e12 = yield Promise.resolve().then(function() {
            return Lp;
          });
          console.log("loader", e12), e12.defineCustomElements();
        } catch (t6) {
          console.error(`Failed to load ${e11} modal:`, t6);
        }
      }
    });
  }
  renderInstallModal(e11) {
    var t6;
    return c8(this, void 0, void 0, function* () {
      this.debug && console.debug("ModalLoader: renderInstallModal", e11), this.containers.install = e11.parentElement, yield this.loadComponent("install");
      const n5 = document.createElement("mm-install-modal");
      n5.link = e11.link, n5.preferDesktop = e11.preferDesktop, n5.sdkVersion = null !== (t6 = e11.sdkVersion) && void 0 !== t6 ? t6 : this.sdkVersion, n5.addEventListener("close", ({ detail: { shouldTerminate: t7 } }) => e11.onClose(t7)), n5.addEventListener("startDesktopOnboarding", e11.metaMaskInstaller.startDesktopOnboarding), n5.addEventListener("trackAnalytics", (t7) => {
        var n6;
        return null === (n6 = e11.onAnalyticsEvent) || void 0 === n6 ? void 0 : n6.call(e11, t7.detail);
      }), e11.parentElement.appendChild(n5);
    });
  }
  renderSelectModal(e11) {
    var t6;
    return c8(this, void 0, void 0, function* () {
      this.containers.select = e11.parentElement, yield this.loadComponent("select");
      const n5 = document.createElement("mm-select-modal");
      n5.link = e11.link, n5.sdkVersion = null !== (t6 = e11.sdkVersion) && void 0 !== t6 ? t6 : this.sdkVersion, n5.preferDesktop = e11.preferDesktop, n5.addEventListener("close", ({ detail: { shouldTerminate: t7 } }) => e11.onClose(t7)), n5.addEventListener("connectWithExtension", e11.connectWithExtension), e11.parentElement.appendChild(n5), setTimeout(() => this.updateQRCode(e11.link), 100);
    });
  }
  renderPendingModal(e11) {
    var t6;
    return c8(this, void 0, void 0, function* () {
      this.containers.pending = e11.parentElement, yield this.loadComponent("pending");
      const n5 = document.createElement("mm-pending-modal");
      n5.sdkVersion = null !== (t6 = e11.sdkVersion) && void 0 !== t6 ? t6 : this.sdkVersion, n5.displayOTP = e11.displayOTP, n5.addEventListener("close", e11.onClose), n5.addEventListener("updateOTPValue", ({ detail: { otpValue: t7 } }) => e11.updateOTPValue(t7)), e11.onDisconnect && n5.addEventListener("disconnect", e11.onDisconnect), e11.parentElement.appendChild(n5);
    });
  }
  updateOTPValue(e11) {
    const t6 = () => {
      var t7;
      const n5 = null === (t7 = this.containers.pending) || void 0 === t7 ? void 0 : t7.querySelector("mm-pending-modal");
      return !!n5 && (n5.otpCode = e11, true);
    };
    setTimeout(() => {
      t6();
    }, 800);
  }
  updateQRCode(e11) {
    var t6, n5;
    const r8 = null === (t6 = this.containers.install) || void 0 === t6 ? void 0 : t6.querySelector("mm-install-modal");
    if (r8) r8.link = e11;
    else {
      const t7 = null === (n5 = this.containers.select) || void 0 === n5 ? void 0 : n5.querySelector("mm-select-modal");
      t7 && (t7.link = e11);
    }
  }
  unmount() {
    Object.entries(this.containers).forEach(([e11, t6]) => {
      var n5;
      null === (n5 = null == t6 ? void 0 : t6.parentNode) || void 0 === n5 || n5.removeChild(t6), this.containers[e11] = void 0;
    });
  }
};
var Jh = ({ link: e11, debug: t6, installer: n5, terminate: r8, connectWithExtension: i9, preferDesktop: o6, onAnalyticsEvent: s5 }) => {
  let a6 = null, c9 = null;
  Iu("[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################"), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] link=${e11}`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e11}" --ios`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open "${e11}" --android`), Iu(`[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d "${e11}"`);
  const l9 = (e12) => {
    var t7;
    Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:", e12, c9), (null == c9 ? void 0 : c9.parentNode) && (null === (t7 = c9.parentNode) || void 0 === t7 || t7.removeChild(c9)), c9 = null, a6 = null, true === e12 && (null == r8 || r8());
  };
  return { mount: (r9) => {
    if (Iu("[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal", c9), c9) return c9.style.display = "block", void (null == a6 || a6.updateQRCode(r9));
    a6 = new Zh({ debug: t6, sdkVersion: Xu.version }), c9 = document.createElement("div"), document.body.appendChild(c9), window.extension ? a6.renderSelectModal({ parentElement: c9, connectWithExtension: () => {
      l9(), null == i9 || i9();
    }, onClose: l9, link: e11, preferDesktop: null != o6 && o6 }).catch((e12) => {
      console.error(e12);
    }) : a6.renderInstallModal({ parentElement: c9, preferDesktop: null != o6 && o6, link: e11, metaMaskInstaller: n5, onClose: l9, onAnalyticsEvent: s5 }).catch((e12) => {
      console.error("[UI: InstallModal-web: sdkWebInstallModal()]", e12);
    });
  }, unmount: l9 };
};
var Qh = ({ onDisconnect: e11, debug: t6 }) => {
  let n5 = null, r8 = null;
  const i9 = () => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount", n5), (null == n5 ? void 0 : n5.parentNode) && n5.parentNode.removeChild(n5), n5 = null, r8 = null;
  }, o6 = (e12) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue", e12), r8 && r8.updateOTPValue(e12);
  }, s5 = ({ displayOTP: s6 } = { displayOTP: true }) => {
    Iu("[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount", n5), n5 ? n5.style.display = "block" : (r8 = new Zh({ debug: t6, sdkVersion: Xu.version }), n5 = document.createElement("div"), document.body.appendChild(n5), r8.renderPendingModal({ parentElement: n5, onClose: i9, onDisconnect: e11, updateOTPValue: o6, displayOTP: s6 }).catch((e12) => {
      console.error("[UI: pendingModal-web: sdkWebPendingModal()]", e12);
    }));
  };
  return s5(), { mount: s5, unmount: i9, updateOTPValue: o6 };
};
function Xh(e11, t6) {
  var n5, r8, i9, o6;
  e11.connector || (Iu("[RemoteConnection: initializeConnector()] initialize connector"), e11.connector = new ts2({ anonId: t6.anonId, platformType: t6.platformManager.getPlatformType(), communicationLayerPreference: t6.communicationLayerPreference, transports: t6.transports, dappMetadata: Object.assign(Object.assign({}, t6.dappMetadata), { source: t6._source }), analytics: t6.enableAnalytics, communicationServerUrl: t6.communicationServerUrl, sdkVersion: Xu.version, context: "dapp", ecies: t6.ecies, storage: t6.storage, logging: t6.logging }), t6.timer && (Iu("[RemoteConnection: initializeConnector()] reset background timer", t6.timer), null === (r8 = null === (n5 = t6.timer) || void 0 === n5 ? void 0 : n5.stopBackgroundTimer) || void 0 === r8 || r8.call(n5), null === (o6 = null === (i9 = t6.timer) || void 0 === i9 ? void 0 : i9.runBackgroundTimer) || void 0 === o6 || o6.call(i9, () => false, 1e4)));
}
function ef2(e11) {
  e11.listeners.forEach(({ event: t6, handler: n5 }) => {
    var r8;
    null === (r8 = e11.connector) || void 0 === r8 || r8.off(t6, n5);
  }), e11.listeners = [];
}
function tf2(e11, t6, r8) {
  return c8(this, void 0, void 0, function* () {
    const i9 = setTimeout(() => {
      import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
    }, 6e4);
    return new Promise((n5, o6) => {
      if (!e11.connector) return void o6(new Error("No connector available"));
      Iu("[RemoteConnection: connectWithModalInstaller()]", { state: e11, options: t6, linkParams: r8 });
      const s5 = `${e11.useDeeplink ? nh : th}?${r8}`;
      !function(e12, t7, n6) {
        var r9, i10, o7, s6;
        e12.installModal = null === (i10 = (r9 = t7.modals).install) || void 0 === i10 ? void 0 : i10.call(r9, { link: n6, preferDesktop: e12.preferDesktop, installer: t7.getMetaMaskInstaller(), terminate: () => {
          Iu("[RemoteConnection: showInstallModal() => terminate()] terminate connection"), t7.sdk.terminate().catch((e13) => {
            console.warn("[MMSDK] failed to terminate connection", e13);
          });
        }, debug: e12.developerMode, connectWithExtension: () => {
          var e13;
          return null === (e13 = t7.connectWithExtensionProvider) || void 0 === e13 || e13.call(t7), false;
        }, onAnalyticsEvent: ({ event: n7, params: r10 }) => {
          var i11, o8, s7;
          const a6 = Object.assign(Object.assign({}, r10), { sdkVersion: t7.sdk.getVersion(), dappId: null === (i11 = t7.dappMetadata) || void 0 === i11 ? void 0 : i11.name, source: t7._source, url: null === (o8 = t7.dappMetadata) || void 0 === o8 ? void 0 : o8.url });
          null === (s7 = e12.analytics) || void 0 === s7 || s7.send({ event: n7, params: a6 });
        } }), null === (s6 = null === (o7 = e12.installModal) || void 0 === o7 ? void 0 : o7.mount) || void 0 === s6 || s6.call(o7, n6);
      }(e11, t6, s5), t6.sdk.once(So3.PROVIDER_UPDATE, (e12) => c8(this, void 0, void 0, function* () {
        if (Iu("[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise"), e12 === gh.TERMINATE) {
          const e13 = { code: 4001, message: "User rejected the request." };
          return clearTimeout(i9), void o6(e13);
        }
        o6(e12);
      })), e11.connector.once(So3.AUTHORIZED, () => {
        clearTimeout(i9), n5();
      }), e11.connector.once(So3.REJECTED, () => {
        clearTimeout(i9), o6(So3.REJECTED);
      }), e11.connector.once(So3.CLIENTS_READY, () => c8(this, void 0, void 0, function* () {
        Iu("[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise"), clearTimeout(i9), n5();
      }));
    });
  });
}
function nf2(e11, t6) {
  function n5(t7, n6) {
    var r8;
    null === (r8 = e11.connector) || void 0 === r8 || r8.on(t7, n6), e11.listeners.push({ event: t7, handler: n6 });
  }
  e11.connector && (ef2(e11), n5(So3.WALLET_INIT, ({ accounts: e12, chainId: t7 }) => c8(this, void 0, void 0, function* () {
    Iu(`[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=${e12} chainId=${t7}`);
    const n6 = Gu.getProvider();
    n6._setConnected();
    const r8 = { accounts: e12, chainId: t7, isUnlocked: false };
    n6._initializeState(r8), n6.emit("chainChanged", t7), n6.emit("accountsChanged", e12);
  })), n5(So3.AUTHORIZED, () => c8(this, void 0, void 0, function* () {
    var t7, n6, r8, i9;
    try {
      Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals", e11.pendingModal, e11.installModal);
      const o6 = Gu.getProvider();
      o6._setConnected(), null === (n6 = null === (t7 = e11.pendingModal) || void 0 === t7 ? void 0 : t7.unmount) || void 0 === n6 || n6.call(t7), null === (i9 = null === (r8 = e11.installModal) || void 0 === r8 ? void 0 : r8.unmount) || void 0 === i9 || i9.call(r8, false), e11.otpAnswer = void 0, e11.authorized = true, Iu("[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state", o6.getState()), yield o6.forceInitializeState();
    } catch (e12) {
    }
  })), n5(So3.TERMINATE, () => {
    var t7, n6, r8, i9, o6;
    null === (n6 = null === (t7 = e11.pendingModal) || void 0 === t7 ? void 0 : t7.unmount) || void 0 === n6 || n6.call(t7), null === (i9 = null === (r8 = e11.installModal) || void 0 === r8 ? void 0 : r8.unmount) || void 0 === i9 || i9.call(r8, true), e11.pendingModal = void 0, e11.installModal = void 0, e11.otpAnswer = void 0, null === (o6 = e11.connector) || void 0 === o6 || o6.disconnect({ terminate: true }), e11.authorized = false;
    Gu.getProvider().handleDisconnect({ terminate: true }), ef2(e11), Iu("[RemoteConnection: setupListeners()] All listeners cleaned up");
  }));
}
function rf2(e11, t6, { initialCheck: r8, connectWith: i9 } = {}) {
  var o6, s5, a6, l9, d7, u10, h9, f16, p9, g4, m6, y11, v9, b6, w8, E8, S8, _6, C10;
  return c8(this, void 0, void 0, function* () {
    try {
      if (Xh(e11, t6), !e11.connector) throw new Error("no connector defined");
      nf2(e11);
      const k11 = Gu.getProvider();
      e11.authorized = false, k11.emit("connecting");
      const A9 = yield null === (o6 = e11.connector) || void 0 === o6 ? void 0 : o6.originatorSessionConnect();
      Iu(`[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=${r8}`, A9);
      let x7 = null !== (s5 = null == A9 ? void 0 : A9.channelId) && void 0 !== s5 ? s5 : "", M8 = null !== (l9 = null === (a6 = e11.connector.getKeyInfo()) || void 0 === a6 ? void 0 : a6.ecies.public) && void 0 !== l9 ? l9 : "", I8 = null !== (u10 = null === (d7 = e11.connector.getKeyInfo()) || void 0 === d7 ? void 0 : d7.ecies.private) && void 0 !== u10 ? u10 : "";
      if (r8 && !A9) return Promise.resolve();
      if (!A9 && !r8) {
        const t7 = yield e11.connector.generateChannelIdConnect();
        x7 = null !== (h9 = t7.channelId) && void 0 !== h9 ? h9 : "", M8 = null !== (f16 = t7.pubKey) && void 0 !== f16 ? f16 : "", I8 = null !== (p9 = t7.privKey) && void 0 !== p9 ? p9 : "";
        const n5 = Date.now();
        null === (g4 = e11.connector.state.storageManager) || void 0 === g4 || g4.persistChannelConfig({ channelId: x7, localKey: I8, lastActive: n5, validUntil: n5 + go3 });
      }
      if (r8 && (null == A9 ? void 0 : A9.channelId)) return (null === (m6 = e11.connector) || void 0 === m6 ? void 0 : m6.isConnected()) || (Iu(`[RemoteConnection: startConnection()] reconnecting to channel initialCheck=${r8}`, A9), yield null === (y11 = e11.connector) || void 0 === y11 ? void 0 : y11.connectToChannel({ channelId: x7 })), Promise.resolve();
      A9 && !(null === (v9 = e11.connector) || void 0 === v9 ? void 0 : v9.isConnected()) && (Iu("[RemoteConnection: startConnection()] reconnecting to channel", A9), yield null === (b6 = e11.connector) || void 0 === b6 ? void 0 : b6.connectToChannel({ channelId: x7 }));
      const T8 = (null === (w8 = e11.platformManager) || void 0 === w8 ? void 0 : w8.isSecure()) ? "" : "&t=q", R6 = Xu.version, { iconUrl: P7, name: O8, url: N9, scheme: L7 } = t6.dappMetadata || {}, D9 = null === (E8 = e11.platformManager) || void 0 === E8 ? void 0 : E8.getPlatformType();
      let $8 = "N/A";
      "undefined" != typeof window && window.location && window.location.hostname ? $8 = window.location.hostname : void 0 !== O8 ? $8 = O8 : void 0 !== N9 && ($8 = N9);
      const B9 = { url: null != N9 ? N9 : "", title: null != O8 ? O8 : "", icon: P7, scheme: null != L7 ? L7 : "", apiVersion: R6, dappId: $8 || N9 || "N/A", anonId: t6.anonId, platform: null != D9 ? D9 : "", source: null !== (S8 = t6._source) && void 0 !== S8 ? S8 : "" }, K5 = bh(JSON.stringify(B9));
      let j9 = `channelId=${x7}&v=2&comm=${null !== (_6 = e11.communicationLayerPreference) && void 0 !== _6 ? _6 : ""}&pubkey=${M8}${T8}&originatorInfo=${K5}`;
      if (i9) {
        j9 += `&rpc=${bh(JSON.stringify(i9))}`;
        const t7 = e11.connector.getRPCMethodTracker();
        t7 && (t7[`${i9.id}`] = Object.assign(Object.assign({}, i9), { id: `${i9.id}`, timestamp: Date.now() }));
      }
      const U6 = encodeURI(j9), H4 = `${e11.useDeeplink ? nh : th}?${j9}`;
      if (e11.qrcodeLink = H4, e11.developerMode && Iu(`[RemoteConnection: startConnection()] qrcodeLink=${U6}`), k11.emit("display_uri", H4), import_sdk_analytics.analytics.track("sdk_connection_initiated", { transport_type: "websocket" }), null === (C10 = e11.platformManager) || void 0 === C10 ? void 0 : C10.isSecure()) {
        const t7 = setTimeout(() => {
          import_sdk_analytics.analytics.track("sdk_connection_failed", { transport_type: "websocket" });
        }, 6e4);
        return yield function(e12, t8) {
          var n5, r9;
          return c8(this, void 0, void 0, function* () {
            const i10 = `${th}?${t8}`, o7 = `${nh}?${t8}`;
            null === (r9 = null === (n5 = e12.platformManager) || void 0 === n5 ? void 0 : n5.openDeeplink) || void 0 === r9 || r9.call(n5, i10, o7, "_self");
          });
        }(e11, U6), new Promise((n5, r9) => {
          var i10, o7, s6;
          if (null === (i10 = e11.connector) || void 0 === i10 ? void 0 : i10.isAuthorized()) return clearTimeout(t7), void n5();
          null === (o7 = e11.connector) || void 0 === o7 || o7.once(So3.AUTHORIZED, () => {
            clearTimeout(t7), n5();
          }), null === (s6 = e11.connector) || void 0 === s6 || s6.once(So3.REJECTED, () => {
            clearTimeout(t7), r9(So3.REJECTED);
          });
        });
      }
      return tf2(e11, t6, U6);
    } catch (e12) {
      throw console.error("[startConnection] error", e12), e12;
    }
  });
}
var of27 = class {
  constructor(e11) {
    var t6, n5, r8;
    this.state = { connector: void 0, qrcodeLink: void 0, analytics: void 0, developerMode: false, authorized: false, reconnection: false, preferDesktop: false, deeplinkProtocol: false, listeners: [], communicationLayerPreference: void 0, platformManager: void 0, pendingModal: void 0, installModal: void 0, otpAnswer: void 0 }, this.options = e11;
    const i9 = true === (null === (t6 = e11.logging) || void 0 === t6 ? void 0 : t6.developerMode) || true === (null === (n5 = e11.logging) || void 0 === n5 ? void 0 : n5.sdk);
    this.state.developerMode = i9, this.state.analytics = e11.analytics, this.state.preferDesktop = null !== (r8 = e11.preferDesktop) && void 0 !== r8 && r8, this.state.useDeeplink = e11.sdk.options.useDeeplink, this.state.communicationLayerPreference = e11.communicationLayerPreference, this.state.platformManager = e11.platformManager, e11.modals.install || (e11.modals.install = Jh), e11.modals.otp || (e11.modals.otp = Qh);
  }
  startConnection(e11) {
    return c8(this, void 0, void 0, function* () {
      return rf2(this.state, this.options, e11);
    });
  }
  initRemoteCommunication({ sdkInstance: e11 }) {
    var t6, n5, r8;
    return c8(this, void 0, void 0, function* () {
      const i9 = yield null === (n5 = null === (t6 = e11.options.storage) || void 0 === t6 ? void 0 : t6.storageManager) || void 0 === n5 ? void 0 : n5.getPersistedChannelConfig();
      if (!this.options.ecies) {
        const e12 = { privateKey: null == i9 ? void 0 : i9.localKey };
        this.options.ecies = e12;
      }
      Xh(this.state, this.options), yield null === (r8 = this.getConnector()) || void 0 === r8 ? void 0 : r8.initFromDappStorage(), nf2(this.state, this.options);
    });
  }
  showActiveModal() {
    return function(e11) {
      var t6, n5, r8, i9;
      e11.authorized ? Iu("[RemoteConnection: showActiveModal()] already authorized") : e11.pendingModal ? null === (n5 = (t6 = e11.pendingModal).mount) || void 0 === n5 || n5.call(t6) : e11.installModal && (null === (i9 = (r8 = e11.installModal).mount) || void 0 === i9 || i9.call(r8, e11.qrcodeLink || ""));
    }(this.state);
  }
  closeModal() {
    var e11, t6, n5, r8;
    null === (t6 = null === (e11 = this.state.pendingModal) || void 0 === e11 ? void 0 : e11.unmount) || void 0 === t6 || t6.call(e11), null === (r8 = null === (n5 = this.state.installModal) || void 0 === n5 ? void 0 : n5.unmount) || void 0 === r8 || r8.call(n5, false);
  }
  getUniversalLink() {
    if (!this.state.qrcodeLink) throw new Error("connection not started. run startConnection() first.");
    return this.state.qrcodeLink;
  }
  getChannelConfig() {
    var e11;
    return null === (e11 = this.state.connector) || void 0 === e11 ? void 0 : e11.getChannelConfig();
  }
  getKeyInfo() {
    var e11;
    return null === (e11 = this.state.connector) || void 0 === e11 ? void 0 : e11.getKeyInfo();
  }
  getConnector() {
    if (!this.state.connector) throw new Error("invalid remote connector");
    return this.state.connector;
  }
  getPlatformManager() {
    if (!this.state.platformManager) throw new Error("PlatformManager not available");
    return this.state.platformManager;
  }
  isConnected() {
    var e11;
    return (null === (e11 = this.state.connector) || void 0 === e11 ? void 0 : e11.isReady()) || false;
  }
  isAuthorized() {
    var e11;
    return (null === (e11 = this.state.connector) || void 0 === e11 ? void 0 : e11.isAuthorized()) || false;
  }
  isPaused() {
    var e11;
    return null === (e11 = this.state.connector) || void 0 === e11 ? void 0 : e11.isPaused();
  }
  disconnect(e11) {
    var t6, n5, r8;
    Iu("[RemoteConnection: disconnect()]", e11), (null == e11 ? void 0 : e11.terminate) && (Gu.getProvider().handleDisconnect({ terminate: true }), null === (n5 = null === (t6 = this.state.pendingModal) || void 0 === t6 ? void 0 : t6.unmount) || void 0 === n5 || n5.call(t6), this.state.otpAnswer = void 0), null === (r8 = this.state.connector) || void 0 === r8 || r8.disconnect(e11), function(e12) {
      Iu("[RemoteConnection: cleanupConnector()] cleaning up connector"), e12.connector && (ef2(e12), e12.connector.disconnect({ terminate: true }).catch((e13) => {
        Iu("[RemoteConnection: cleanupConnector()] error disconnecting connector", e13);
      }));
    }(this.state);
  }
};
function sf2(e11) {
  var r8, i9, o6, s5, a6, l9, d7, u10, h9, f16, p9;
  return c8(this, void 0, void 0, function* () {
    const { options: g4 } = e11;
    if (g4.logging = null !== (r8 = g4.logging) && void 0 !== r8 ? r8 : {}, g4.communicationLayerPreference = null !== (i9 = g4.communicationLayerPreference) && void 0 !== i9 ? i9 : jo3.SOCKET, void 0 !== g4.enableDebug && (import_debug4.default.enable("MM_SDK"), console.warn("enableDebug is removed. Please use enableAnalytics instead.")), g4.enableAnalytics = null === (o6 = g4.enableAnalytics) || void 0 === o6 || o6, g4.injectProvider = null === (s5 = g4.injectProvider) || void 0 === s5 || s5, g4.shouldShimWeb3 = null === (a6 = g4.shouldShimWeb3) || void 0 === a6 || a6, g4.extensionOnly = null === (l9 = g4.extensionOnly) || void 0 === l9 || l9, g4.useDeeplink = null === (d7 = g4.useDeeplink) || void 0 === d7 || d7, g4.storage = null !== (u10 = g4.storage) && void 0 !== u10 ? u10 : { enabled: true }, g4.headless) {
      (0, import_debug4.default)("[MetaMaskSDK: performSDKInitialization()] headless mode enabled");
      const e12 = () => {
      }, n5 = { install: () => ({ mount: e12, unmount: e12 }) }, r9 = { installer: e12 };
      g4.modals = n5, g4.ui = r9;
    }
    const m6 = true === (null === (h9 = g4.logging) || void 0 === h9 ? void 0 : h9.developerMode);
    e11.debug = (null === (f16 = g4.logging) || void 0 === f16 ? void 0 : f16.sdk) || m6, Iu("[MetaMaskSDK: performSDKInitialization()] options", e11.options);
    const y11 = Object.assign({}, g4.logging);
    m6 && (y11.sdk = true, y11.eciesLayer = true, y11.keyExchangeLayer = true, y11.remoteLayer = true, y11.serviceLayer = true, y11.plaintext = true), yield function(e12) {
      var t6;
      return c8(this, void 0, void 0, function* () {
        const { options: n5 } = e12;
        e12.platformManager = new Yu({ useDeepLink: null !== (t6 = n5.useDeeplink) && void 0 !== t6 && t6, preferredOpenLink: n5.openDeeplink, debug: e12.debug });
      });
    }(e11), yield function(e12) {
      var t6, n5, r9, i10, o7;
      return c8(this, void 0, void 0, function* () {
        const { options: s6 } = e12, a7 = null === (t6 = e12.platformManager) || void 0 === t6 ? void 0 : t6.getPlatformType();
        e12.analytics = new xh({ serverUrl: null !== (n5 = s6.communicationServerUrl) && void 0 !== n5 ? n5 : fo3, enabled: s6.enableAnalytics, originatorInfo: { url: null !== (r9 = s6.dappMetadata.url) && void 0 !== r9 ? r9 : "", title: null !== (i10 = s6.dappMetadata.name) && void 0 !== i10 ? i10 : "", dappId: e12.getDappId(), platform: null != a7 ? a7 : "", source: null !== (o7 = s6._source) && void 0 !== o7 ? o7 : "", anonId: "" } });
      });
    }(e11), yield function(e12) {
      var t6, r9, i10;
      return c8(this, void 0, void 0, function* () {
        if (!e12.options.enableAnalytics) return;
        if (!(null === (t6 = e12.platformManager) || void 0 === t6 ? void 0 : t6.isBrowser()) && !(null === (r9 = e12.platformManager) || void 0 === r9 ? void 0 : r9.isReactNative())) return;
        const o7 = e12.getVersion(), s6 = e12.getDappId(), a7 = yield e12.getAnonId(), c9 = null === (i10 = e12.platformManager) || void 0 === i10 ? void 0 : i10.getPlatformType(), l10 = e12.options._source;
        import_sdk_analytics.analytics.setGlobalProperty("sdk_version", o7), import_sdk_analytics.analytics.setGlobalProperty("dapp_id", s6), import_sdk_analytics.analytics.setGlobalProperty("anon_id", a7), import_sdk_analytics.analytics.setGlobalProperty("platform", c9), import_sdk_analytics.analytics.setGlobalProperty("integration_type", l10), import_sdk_analytics.analytics.enable(), import_sdk_analytics.analytics.track("sdk_initialized", {});
      });
    }(e11), yield function(e12) {
      var t6;
      return c8(this, void 0, void 0, function* () {
        const { options: n5 } = e12;
        true !== (null === (t6 = n5.storage) || void 0 === t6 ? void 0 : t6.enabled) || n5.storage.storageManager || (n5.storage.storageManager = yield Zu(n5.storage));
      });
    }(e11), yield function(e12) {
      return c8(this, void 0, void 0, function* () {
        const { options: t6 } = e12, n5 = /^(http|https):\/\/[^\s]*$/;
        if (t6.dappMetadata) {
          t6.dappMetadata.iconUrl && !n5.test(t6.dappMetadata.iconUrl) && (console.warn("Invalid dappMetadata.iconUrl: URL must start with http:// or https://"), t6.dappMetadata.iconUrl = void 0), t6.dappMetadata.base64Icon && t6.dappMetadata.base64Icon.length > Ih && (console.warn("Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters"), t6.dappMetadata.base64Icon = void 0), t6.dappMetadata.url && !n5.test(t6.dappMetadata.url) && console.warn("Invalid dappMetadata.url: URL must start with http:// or https://");
          const e13 = Mh();
          if (e13 && !t6.dappMetadata.iconUrl && !t6.dappMetadata.base64Icon) {
            const n6 = `${window.location.protocol}//${window.location.host}${e13}`;
            t6.dappMetadata.iconUrl = n6;
          }
        }
        e12.dappMetadata = t6.dappMetadata;
      });
    }(e11), yield Lh(e11), yield Dh(e11);
    const { metamaskBrowserExtension: v9, preferExtension: b6, shouldReturn: w8 } = yield function(e12) {
      var t6, n5, r9, i10;
      return c8(this, void 0, void 0, function* () {
        const { options: o7 } = e12;
        let s6, a7 = false, l10 = false;
        if ("undefined" != typeof window && window.ethereum && !(null === (t6 = e12.platformManager) || void 0 === t6 ? void 0 : t6.isMetaMaskMobileWebView())) {
          a7 = "extension" === localStorage.getItem(dh);
          try {
            s6 = yield Nh({ mustBeMetaMask: true, sdkInstance: e12 }), window.extension = s6, s6.on(fh.CHAIN_CHANGED, (t7) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=${t7}`), Boolean(e12.sdkProvider) && e12.getMobileProvider().emit(fh.CHAIN_CHANGED, t7);
            }), s6.on(fh.ACCOUNTS_CHANGED, (t7) => c8(this, void 0, void 0, function* () {
              var n6;
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=${t7}`);
              const r10 = Boolean(e12.sdkProvider), i11 = Boolean(e12.extensionActive);
              if (r10 && e12.getMobileProvider().emit(fh.ACCOUNTS_CHANGED, t7), i11 && 0 === (null == t7 ? void 0 : t7.length) && 0 === (yield null === (n6 = e12.getProvider()) || void 0 === n6 ? void 0 : n6.request({ method: oh.WALLET_GETPERMISSIONS, params: [] })).length) try {
                yield e12.terminate();
              } catch (e13) {
                Iu("[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked", e13);
              }
            })), s6.on(fh.DISCONNECT, (t7) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=${t7}`), Boolean(e12.sdkProvider) && e12.getMobileProvider().emit(fh.DISCONNECT, t7);
            }), s6.on(fh.CONNECT, (t7) => {
              Iu(`[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=${t7}`), Boolean(e12.sdkProvider) && e12.getMobileProvider().emit(fh.CONNECT, t7);
            }), s6.on(fh.CONNECTED, (t7) => {
              Iu("[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected", t7), Boolean(e12.sdkProvider) && e12.getMobileProvider().emit(fh.CONNECTED, t7);
            });
          } catch (e13) {
            window.extension = void 0;
          }
        } else (null === (n5 = e12.platformManager) || void 0 === n5 ? void 0 : n5.isMetaMaskMobileWebView()) && (null === (r9 = e12.analytics) || void 0 === r9 || r9.send({ event: Ao3.SDK_USE_INAPP_BROWSER }), e12.activeProvider = Ph({ provider: window.ethereum, sdkInstance: e12 }), e12._initialized = true, l10 = true);
        return s6 && o7.extensionOnly && (Iu("[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization"), null === (i10 = e12.analytics) || void 0 === i10 || i10.send({ event: Ao3.SDK_USE_EXTENSION }), e12.activeProvider = s6, e12.extensionActive = true, e12.extension = s6, e12._initialized = true, l10 = true), { preferExtension: a7, shouldReturn: l10, metamaskBrowserExtension: s6 };
      });
    }(e11);
    if (w8) Iu("[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization");
    else {
      yield function(e12, t6) {
        var n5, r9, i10, o7, s6;
        return c8(this, void 0, void 0, function* () {
          const { options: a7 } = e12, c9 = Object.assign({}, a7.logging);
          e12.remoteConnection = new of27({ anonId: yield e12.getAnonId(), preferDesktop: null !== (n5 = a7.preferDesktop) && void 0 !== n5 && n5, communicationLayerPreference: null !== (r9 = a7.communicationLayerPreference) && void 0 !== r9 ? r9 : jo3.SOCKET, analytics: e12.analytics, dappMetadata: a7.dappMetadata, _source: a7._source, enableAnalytics: null === (i10 = a7.enableAnalytics) || void 0 === i10 || i10, timer: a7.timer, sdk: e12, platformManager: e12.platformManager, transports: a7.transports, communicationServerUrl: a7.communicationServerUrl, storage: null !== (o7 = a7.storage) && void 0 !== o7 ? o7 : { enabled: true }, getMetaMaskInstaller: () => {
            if (!e12.installer) throw new Error("Invalid SDK status -- installer not initialized");
            return e12.installer;
          }, logging: c9, connectWithExtensionProvider: void 0 === t6 ? void 0 : () => vh(e12), modals: Object.assign(Object.assign({}, a7.modals), { onPendingModalDisconnect: e12.terminate.bind(e12) }) }), yield e12.remoteConnection.initRemoteCommunication({ sdkInstance: e12 }), e12.installer = new Yh({ remote: e12.remoteConnection, preferDesktop: null !== (s6 = a7.preferDesktop) && void 0 !== s6 && s6, platformManager: e12.platformManager, debug: e12.debug });
        });
      }(e11, v9), yield kh(e11), yield function(e12, t6) {
        var n5, r9;
        return c8(this, void 0, void 0, function* () {
          const { options: i10 } = e12;
          t6 ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it."), null === (n5 = e12.analytics) || void 0 === n5 || n5.send({ event: Ao3.SDK_EXTENSION_UTILIZED }), vh(e12).catch((e13) => {
            console.warn("Can't connect with MetaMask extension...", e13), localStorage.removeItem(dh);
          })) : i10.checkInstallationImmediately && ((null === (r9 = e12.platformManager) || void 0 === r9 ? void 0 : r9.isDesktopWeb()) ? (Iu("[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately"), e12.connect().catch((e13) => {
            Iu(`[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=${e13}`);
          })) : console.warn("[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop")), e12._initialized = true;
        });
      }(e11, b6);
      try {
        yield null === (p9 = e11.remoteConnection) || void 0 === p9 ? void 0 : p9.startConnection({ initialCheck: true });
      } catch (e12) {
        console.error("[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation", e12);
      }
      e11.emit(Vu.ProviderUpdate, gh.INITIALIZED);
    }
  });
}
var af2 = class extends import_eventemitter2.default {
  constructor(e11 = { storage: { enabled: true }, injectProvider: true, forceInjectProvider: false, enableAnalytics: true, shouldShimWeb3: true, useDeeplink: true, extensionOnly: true, headless: false, dappMetadata: { name: "", url: "", iconUrl: "" }, _source: eh, i18nOptions: { enabled: false } }) {
    var n5, r8, i9;
    super(), this.extensionActive = false, this._initialized = false, this.sdkInitPromise = void 0, this.debug = false, this.readonlyRPCCalls = false, this.availableLanguages = ["en"], this.ANON_ID_STORAGE_KEY = "mm-sdk-anon-id", import_debug4.default.disable();
    const o6 = true === (null === (n5 = e11.logging) || void 0 === n5 ? void 0 : n5.developerMode);
    if (((null === (r8 = e11.logging) || void 0 === r8 ? void 0 : r8.sdk) || o6) && import_debug4.default.enable("MM_SDK"), Iu("[MetaMaskSDK: constructor()]: begin."), this.setMaxListeners(50), !(null === (i9 = e11.dappMetadata) || void 0 === i9 ? void 0 : i9.url)) {
      if ("undefined" == typeof window || "undefined" == typeof document) throw new Error("You must provide dAppMetadata url");
      e11.dappMetadata = Object.assign(Object.assign({}, e11.dappMetadata), { url: `${window.location.protocol}//${window.location.host}` });
    }
    this.options = e11, this.options._source || (e11._source = eh), this.init().then(() => {
      Iu("[MetaMaskSDK: constructor()]: initialized successfully."), "undefined" != typeof window && (window.mmsdk = this);
    }).catch((e12) => {
      console.error("[MetaMaskSDK: constructor()] error during initialization", e12);
    });
  }
  init() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        var t6;
        return c8(this, void 0, void 0, function* () {
          if ("undefined" != typeof window && (null === (t6 = window.mmsdk) || void 0 === t6 ? void 0 : t6.isInitialized())) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), Promise.resolve(window.mmsdk);
          if (e11._initialized) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initialized"), e11.sdkInitPromise;
          if (e11.sdkInitPromise) return Iu("[MetaMaskSDK: initializeMetaMaskSDK()] already initializing"), e11.sdkInitPromise;
          try {
            e11.sdkInitPromise = sf2(e11), yield e11.sdkInitPromise;
          } catch (e12) {
            throw console.error(e12), e12;
          }
          return e11.sdkInitPromise;
        });
      }(this);
    });
  }
  isExtensionActive() {
    return this.extensionActive;
  }
  checkExtensionAvailability() {
    var e11;
    return "undefined" != typeof window && Boolean(null === (e11 = window.ethereum) || void 0 === e11 ? void 0 : e11.isMetaMask);
  }
  connect() {
    return c8(this, void 0, void 0, function* () {
      return function(e11) {
        return c8(this, void 0, void 0, function* () {
          if (e11._initialized || (Iu("[MetaMaskSDK: connect()] provider not ready -- wait for init()"), yield e11.init()), Iu(`[MetaMaskSDK: connect()] isExtensionActive=${e11.isExtensionActive()} activeProvider`, e11.activeProvider), !e11.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          const t6 = e11.activeProvider.getSelectedAddress();
          return t6 ? [t6] : e11.activeProvider.request({ method: oh.ETH_REQUESTACCOUNTS, params: [] });
        });
      }(this);
    });
  }
  connectAndSign({ msg: e11 }) {
    return c8(this, void 0, void 0, function* () {
      return yh({ instance: this, msg: e11 });
    });
  }
  connectWith(e11) {
    return c8(this, void 0, void 0, function* () {
      return function({ instance: e12, rpc: t6 }) {
        return c8(this, void 0, void 0, function* () {
          if (e12._initialized || (Iu("[MetaMaskSDK: connectWith()] provider not ready -- wait for init()"), yield e12.init()), Iu(`[MetaMaskSDK: connectWith()] method: ${t6.method} rpc=${t6}`), !e12.activeProvider) throw new Error("SDK state invalid -- undefined provider");
          return e12.activeProvider.request({ method: oh.METAMASK_CONNECTWITH, params: [t6] });
        });
      }({ instance: this, rpc: e11 });
    });
  }
  resume() {
    return function(e11) {
      var t6, n5, r8;
      return c8(this, void 0, void 0, function* () {
        if (!(null === (n5 = null === (t6 = e11.remoteConnection) || void 0 === t6 ? void 0 : t6.getConnector()) || void 0 === n5 ? void 0 : n5.isReady())) return Iu("[MetaMaskSDK: resume()] channel is not ready -- starting connection"), void (null === (r8 = e11.remoteConnection) || void 0 === r8 || r8.startConnection());
        Iu("[MetaMaskSDK: resume()] channel is ready");
      });
    }(this);
  }
  disconnect() {
    return console.warn("MetaMaskSDK.disconnect() is deprecated, use terminate()"), this.terminate();
  }
  isAuthorized() {
    var e11;
    null === (e11 = this.remoteConnection) || void 0 === e11 || e11.isAuthorized();
  }
  terminate() {
    return function(e11) {
      var t6, n5, r8;
      return c8(this, void 0, void 0, function* () {
        if (!(null === (t6 = e11.platformManager) || void 0 === t6 ? void 0 : t6.isMetaMaskMobileWebView())) {
          if (mh && (window.localStorage.removeItem(dh), window.localStorage.removeItem(hh), window.localStorage.removeItem(uh)), e11.extensionActive) {
            try {
              yield null === (n5 = e11.activeProvider) || void 0 === n5 ? void 0 : n5.request({ method: oh.WALLET_REVOKEPERMISSIONS, params: [{ eth_accounts: {} }] });
            } catch (e12) {
              Iu("[MetaMaskSDK: terminate()] error revoking permissions", e12);
            }
            return e11.options.extensionOnly ? (e11.emit(Vu.ProviderUpdate, gh.TERMINATE), void Iu("[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers")) : (e11.activeProvider = e11.sdkProvider, window.ethereum = e11.activeProvider, e11.extensionActive = false, void e11.emit(Vu.ProviderUpdate, gh.TERMINATE));
          }
          e11.emit(Vu.ProviderUpdate, gh.TERMINATE), Iu(`[MetaMaskSDK: terminate()] remoteConnection=${e11.remoteConnection}`), null === (r8 = e11.remoteConnection) || void 0 === r8 || r8.disconnect({ terminate: true, sendMessage: true });
        }
      });
    }(this);
  }
  isInitialized() {
    return this._initialized;
  }
  setReadOnlyRPCCalls(e11) {
    this.readonlyRPCCalls = e11;
  }
  hasReadOnlyRPCCalls() {
    return this.readonlyRPCCalls;
  }
  getProvider() {
    if (this.activeProvider) return this.activeProvider;
    console.warn("MetaMaskSDK: No active provider found");
  }
  getMobileProvider() {
    if (!this.sdkProvider) throw new Error("SDK state invalid -- undefined mobile provider");
    return this.sdkProvider;
  }
  getUniversalLink() {
    var e11;
    const t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getUniversalLink();
    if (!t6) throw new Error("No Universal Link available, please call eth_requestAccounts first.");
    return t6;
  }
  getChannelId() {
    var e11, t6;
    return null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getChannelConfig()) || void 0 === t6 ? void 0 : t6.channelId;
  }
  getRPCHistory() {
    var e11, t6;
    return null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getConnector()) || void 0 === t6 ? void 0 : t6.getRPCMethodTracker();
  }
  getVersion() {
    return Xu.version;
  }
  getDappId() {
    var e11, t6, n5, r8;
    return "undefined" == typeof window || void 0 === window.location ? null !== (r8 = null !== (t6 = null === (e11 = this.options.dappMetadata) || void 0 === e11 ? void 0 : e11.name) && void 0 !== t6 ? t6 : null === (n5 = this.options.dappMetadata) || void 0 === n5 ? void 0 : n5.url) && void 0 !== r8 ? r8 : "N/A" : window.location.hostname;
  }
  getAnonId() {
    var e11, t6;
    return c8(this, void 0, void 0, function* () {
      if (this._anonId) return this._anonId;
      let n5;
      return n5 = (null === (e11 = this.platformManager) || void 0 === e11 ? void 0 : e11.isBrowser()) ? this.getBrowserAnonId() : (null === (t6 = this.platformManager) || void 0 === t6 ? void 0 : t6.isReactNative()) ? yield this.getReactNativeAnonId() : v4_default2(), this._anonId = n5, n5;
    });
  }
  getBrowserAnonId() {
    const e11 = this.ANON_ID_STORAGE_KEY;
    try {
      const t6 = localStorage.getItem(e11);
      if (t6) return t6;
      const n5 = v4_default2();
      return localStorage.setItem(e11, n5), n5;
    } catch (e12) {
      return console.error("[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:", e12), v4_default2();
    }
  }
  getReactNativeAnonId() {
    return c8(this, void 0, void 0, function* () {
      const e11 = this.ANON_ID_STORAGE_KEY;
      try {
        const t6 = __require("@react-native-async-storage/async-storage").default, n5 = yield t6.getItem(e11);
        if (n5) return n5;
        const r8 = v4_default2();
        return yield t6.setItem(e11, r8), r8;
      } catch (e12) {
        return console.error("[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:", e12), v4_default2();
      }
    });
  }
  getWalletStatus() {
    var e11, t6;
    return null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getConnector()) || void 0 === t6 ? void 0 : t6.getConnectionStatus();
  }
  _getChannelConfig() {
    var e11;
    return null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getChannelConfig();
  }
  _ping() {
    var e11, t6;
    null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getConnector()) || void 0 === t6 || t6.ping();
  }
  _keyCheck() {
    var e11, t6;
    null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getConnector()) || void 0 === t6 || t6.keyCheck();
  }
  _getServiceStatus() {
    var e11, t6;
    return null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getConnector()) || void 0 === t6 ? void 0 : t6.getServiceStatus();
  }
  _getRemoteConnection() {
    return this.remoteConnection;
  }
  _getDappMetadata() {
    return this.dappMetadata;
  }
  _getKeyInfo() {
    var e11;
    return null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getKeyInfo();
  }
  _resetKeys() {
    var e11, t6;
    null === (t6 = null === (e11 = this.remoteConnection) || void 0 === e11 ? void 0 : e11.getConnector()) || void 0 === t6 || t6.resetKeys();
  }
  _getConnection() {
    return this.remoteConnection;
  }
  emit(e11, t6) {
    return super.emit(e11, t6);
  }
  on(e11, t6) {
    return super.on(e11, t6);
  }
};
var cf2 = Object.freeze({ __proto__: null, StorageManagerWeb: class {
  constructor({ enabled: e11 } = { enabled: false }) {
    this.enabled = false, this.enabled = e11;
  }
  persistChannelConfig(e11) {
    return c8(this, void 0, void 0, function* () {
      const t6 = JSON.stringify(e11);
      Iu(`[StorageManagerWeb: persistChannelConfig()] enabled=${this.enabled}`, e11), localStorage.setItem(lh, t6);
    });
  }
  getPersistedChannelConfig() {
    return c8(this, void 0, void 0, function* () {
      let e11;
      try {
        if (Iu(`[StorageManagerWeb: getPersistedChannelConfig()] enabled=${this.enabled}`), e11 = localStorage.getItem(lh), Iu("[StorageManagerWeb: getPersistedChannelConfig()]", e11), !e11) return;
        const t6 = JSON.parse(e11);
        return Iu("[StorageManagerWeb: getPersistedChannelConfig()] channelConfig", t6), t6;
      } catch (e12) {
        return void console.error("[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config", e12);
      }
    });
  }
  persistAccounts(e11) {
    return c8(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: persistAccounts()] enabled=${this.enabled}`, e11);
      const t6 = JSON.stringify(e11);
      localStorage.setItem(uh, t6);
    });
  }
  getCachedAccounts() {
    return c8(this, void 0, void 0, function* () {
      try {
        const e11 = localStorage.getItem(uh);
        return e11 ? JSON.parse(e11) : [];
      } catch (e11) {
        throw console.error("[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts", e11), e11;
      }
    });
  }
  persistChainId(e11) {
    return c8(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: persistChainId()] enabled=${this.enabled}`, e11), localStorage.setItem(hh, e11);
    });
  }
  getCachedChainId() {
    return c8(this, void 0, void 0, function* () {
      try {
        const e11 = localStorage.getItem(hh);
        return null != e11 ? e11 : void 0;
      } catch (e11) {
        throw console.error("[StorageManagerWeb: getCachedChainId()] Error reading cached chainId", e11), e11;
      }
    });
  }
  terminate() {
    return c8(this, void 0, void 0, function* () {
      Iu(`[StorageManagerWeb: terminate()] enabled=${this.enabled}`), localStorage.removeItem(lh);
    });
  }
} });
var lf2 = "hydrated";
var df2 = false;
var uf2 = false;
var hf2 = true;
var ff2 = Object.defineProperty;
var pf2 = /* @__PURE__ */ new WeakMap();
var gf2 = (e11) => pf2.get(e11);
var mf = (e11, t6) => pf2.set(t6.$lazyInstance$ = e11, t6);
var yf2 = (e11, t6) => t6 in e11;
var vf = (e11, t6) => (0, console.error)(e11, t6);
var bf2 = /* @__PURE__ */ new Map();
var wf = /* @__PURE__ */ new Map();
var Ef2 = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var Sf2 = "undefined" != typeof window ? window : {};
var _f2 = Sf2.document || { head: {} };
var Cf2 = { $flags$: 0, $resourcesUrl$: "", jmp: (e11) => e11(), raf: (e11) => requestAnimationFrame(e11), ael: (e11, t6, n5, r8) => e11.addEventListener(t6, n5, r8), rel: (e11, t6, n5, r8) => e11.removeEventListener(t6, n5, r8), ce: (e11, t6) => new CustomEvent(e11, t6) };
var kf2 = (() => {
  try {
    return new CSSStyleSheet(), "function" == typeof new CSSStyleSheet().replaceSync;
  } catch (e11) {
  }
  return false;
})();
var Af2 = false;
var xf = [];
var Mf2 = [];
var If2 = (e11, t6) => (t7) => {
  e11.push(t7), Af2 || (Af2 = true, 4 & Cf2.$flags$ ? Pf2(Rf2) : Cf2.raf(Rf2));
};
var Tf2 = (e11) => {
  for (let t6 = 0; t6 < e11.length; t6++) try {
    e11[t6](performance.now());
  } catch (e12) {
    vf(e12);
  }
  e11.length = 0;
};
var Rf2 = () => {
  Tf2(xf), Tf2(Mf2), (Af2 = xf.length > 0) && Cf2.raf(Rf2);
};
var Pf2 = (e11) => ((e12) => Promise.resolve(e12))().then(e11);
var Of2 = If2(Mf2);
var Nf2 = {};
var Lf2 = (e11) => "object" === (e11 = typeof e11) || "function" === e11;
function Df2(e11) {
  var t6, n5, r8;
  return null != (r8 = null == (n5 = null == (t6 = e11.head) ? void 0 : t6.querySelector('meta[name="csp-nonce"]')) ? void 0 : n5.getAttribute("content")) ? r8 : void 0;
}
((e11, t6) => {
  for (var n5 in t6) ff2(e11, n5, { get: t6[n5], enumerable: true });
})({}, { err: () => Bf2, map: () => Kf2, ok: () => $f2, unwrap: () => Hf2, unwrapErr: () => Ff2 });
var $f2 = (e11) => ({ isOk: true, isErr: false, value: e11 });
var Bf2 = (e11) => ({ isOk: false, isErr: true, value: e11 });
function Kf2(e11, t6) {
  if (e11.isOk) {
    const n5 = t6(e11.value);
    return n5 instanceof Promise ? n5.then((e12) => $f2(e12)) : $f2(n5);
  }
  if (e11.isErr) {
    const t7 = e11.value;
    return Bf2(t7);
  }
  throw "should never get here";
}
var jf2;
var Uf2;
var Hf2 = (e11) => {
  if (e11.isOk) return e11.value;
  throw e11.value;
};
var Ff2 = (e11) => {
  if (e11.isErr) return e11.value;
  throw e11.value;
};
var zf2 = (e11, t6, ...n5) => {
  let r8 = null, i9 = false, o6 = false;
  const s5 = [], a6 = (t7) => {
    for (let n6 = 0; n6 < t7.length; n6++) r8 = t7[n6], Array.isArray(r8) ? a6(r8) : null != r8 && "boolean" != typeof r8 && ((i9 = "function" != typeof e11 && !Lf2(r8)) && (r8 = String(r8)), i9 && o6 ? s5[s5.length - 1].$text$ += r8 : s5.push(i9 ? qf2(null, r8) : r8), o6 = i9);
  };
  if (a6(n5), t6) {
    const e12 = t6.className || t6.class;
    e12 && (t6.class = "object" != typeof e12 ? e12 : Object.keys(e12).filter((t7) => e12[t7]).join(" "));
  }
  if ("function" == typeof e11) return e11(null === t6 ? {} : t6, s5, Vf2);
  const c9 = qf2(e11, null);
  return c9.$attrs$ = t6, s5.length > 0 && (c9.$children$ = s5), c9;
};
var qf2 = (e11, t6) => {
  const n5 = { $flags$: 0, $tag$: e11, $text$: t6, $elm$: null, $children$: null, $attrs$: null };
  return n5;
};
var Wf2 = {};
var Vf2 = { forEach: (e11, t6) => e11.map(Gf2).forEach(t6), map: (e11, t6) => e11.map(Gf2).map(t6).map(Yf2) };
var Gf2 = (e11) => ({ vattrs: e11.$attrs$, vchildren: e11.$children$, vkey: e11.$key$, vname: e11.$name$, vtag: e11.$tag$, vtext: e11.$text$ });
var Yf2 = (e11) => {
  if ("function" == typeof e11.vtag) {
    const t7 = { ...e11.vattrs };
    return e11.vkey && (t7.key = e11.vkey), e11.vname && (t7.name = e11.vname), zf2(e11.vtag, t7, ...e11.vchildren || []);
  }
  const t6 = qf2(e11.vtag, e11.vtext);
  return t6.$attrs$ = e11.vattrs, t6.$children$ = e11.vchildren, t6.$key$ = e11.vkey, t6.$name$ = e11.vname, t6;
};
var Zf2 = (e11) => gf2(e11).$hostElement$;
var Jf2 = (e11, t6, n5) => {
  const r8 = Zf2(e11);
  return { emit: (e12) => Qf2(r8, t6, { bubbles: !!(4 & n5), composed: !!(2 & n5), cancelable: !!(1 & n5), detail: e12 }) };
};
var Qf2 = (e11, t6, n5) => {
  const r8 = Cf2.ce(t6, n5);
  return e11.dispatchEvent(r8), r8;
};
var Xf2 = /* @__PURE__ */ new WeakMap();
var ep = (e11) => {
  const t6 = e11.$cmpMeta$, n5 = e11.$hostElement$, r8 = t6.$flags$, i9 = (t6.$tagName$, () => {
  }), o6 = ((e12, t7, n6) => {
    var r9;
    const i10 = tp(t7), o7 = wf.get(i10);
    if (e12 = 11 === e12.nodeType ? e12 : _f2, o7) if ("string" == typeof o7) {
      e12 = e12.head || e12;
      let n7, s5 = Xf2.get(e12);
      if (s5 || Xf2.set(e12, s5 = /* @__PURE__ */ new Set()), !s5.has(i10)) {
        {
          n7 = _f2.createElement("style"), n7.innerHTML = o7;
          const i11 = null != (r9 = Cf2.$nonce$) ? r9 : Df2(_f2);
          if (null != i11 && n7.setAttribute("nonce", i11), !(1 & t7.$flags$)) if ("HEAD" === e12.nodeName) {
            const t8 = e12.querySelectorAll("link[rel=preconnect]"), r10 = t8.length > 0 ? t8[t8.length - 1].nextSibling : e12.querySelector("style");
            e12.insertBefore(n7, r10);
          } else if ("host" in e12) if (kf2) {
            const t8 = new CSSStyleSheet();
            t8.replaceSync(o7), e12.adoptedStyleSheets = [t8, ...e12.adoptedStyleSheets];
          } else {
            const t8 = e12.querySelector("style");
            t8 ? t8.innerHTML = o7 + t8.innerHTML : e12.prepend(n7);
          }
          else e12.append(n7);
          1 & t7.$flags$ && "HEAD" !== e12.nodeName && e12.insertBefore(n7, null);
        }
        4 & t7.$flags$ && (n7.innerHTML += Ef2), s5 && s5.add(i10);
      }
    } else e12.adoptedStyleSheets.includes(o7) || (e12.adoptedStyleSheets = [...e12.adoptedStyleSheets, o7]);
    return i10;
  })(n5.shadowRoot ? n5.shadowRoot : n5.getRootNode(), t6);
  10 & r8 && 2 & r8 && (n5["s-sc"] = o6, n5.classList.add(o6 + "-h")), i9();
};
var tp = (e11, t6) => "sc-" + e11.$tagName$;
var np = (e11, t6, n5, r8, i9, o6) => {
  if (n5 !== r8) {
    let s5 = yf2(e11, t6), a6 = t6.toLowerCase();
    if ("class" === t6) {
      const t7 = e11.classList, i10 = ip(n5), o7 = ip(r8);
      t7.remove(...i10.filter((e12) => e12 && !o7.includes(e12))), t7.add(...o7.filter((e12) => e12 && !i10.includes(e12)));
    } else if ("style" === t6) {
      for (const t7 in n5) r8 && null != r8[t7] || (t7.includes("-") ? e11.style.removeProperty(t7) : e11.style[t7] = "");
      for (const t7 in r8) n5 && r8[t7] === n5[t7] || (t7.includes("-") ? e11.style.setProperty(t7, r8[t7]) : e11.style[t7] = r8[t7]);
    } else if (s5 || "o" !== t6[0] || "n" !== t6[1]) {
      const a7 = Lf2(r8);
      if ((s5 || a7 && null !== r8) && !i9) try {
        if (e11.tagName.includes("-")) e11[t6] = r8;
        else {
          const i10 = null == r8 ? "" : r8;
          "list" === t6 ? s5 = false : null != n5 && e11[t6] == i10 || ("function" == typeof e11.__lookupSetter__(t6) ? e11[t6] = i10 : e11.setAttribute(t6, i10));
        }
      } catch (e12) {
      }
      null == r8 || false === r8 ? false === r8 && "" !== e11.getAttribute(t6) || e11.removeAttribute(t6) : (!s5 || 4 & o6 || i9) && !a7 && (r8 = true === r8 ? "" : r8, e11.setAttribute(t6, r8));
    } else if (t6 = "-" === t6[2] ? t6.slice(3) : yf2(Sf2, a6) ? a6.slice(2) : a6[2] + t6.slice(3), n5 || r8) {
      const i10 = t6.endsWith(op);
      t6 = t6.replace(sp, ""), n5 && Cf2.rel(e11, t6, n5, i10), r8 && Cf2.ael(e11, t6, r8, i10);
    }
  }
};
var rp = /\s/;
var ip = (e11) => e11 ? e11.split(rp) : [];
var op = "Capture";
var sp = new RegExp(op + "$");
var ap26 = (e11, t6, n5) => {
  const r8 = 11 === t6.$elm$.nodeType && t6.$elm$.host ? t6.$elm$.host : t6.$elm$, i9 = e11 && e11.$attrs$ || Nf2, o6 = t6.$attrs$ || Nf2;
  for (const e12 of cp(Object.keys(i9))) e12 in o6 || np(r8, e12, i9[e12], void 0, n5, t6.$flags$);
  for (const e12 of cp(Object.keys(o6))) np(r8, e12, i9[e12], o6[e12], n5, t6.$flags$);
};
function cp(e11) {
  return e11.includes("ref") ? [...e11.filter((e12) => "ref" !== e12), "ref"] : e11;
}
var lp = false;
var dp = false;
var up = (e11, t6, n5, r8) => {
  const i9 = t6.$children$[n5];
  let o6, s5, a6 = 0;
  if (null !== i9.$text$) o6 = i9.$elm$ = _f2.createTextNode(i9.$text$);
  else {
    dp || (dp = "svg" === i9.$tag$), o6 = i9.$elm$ = _f2.createElementNS(dp ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", !lp && uf2 && 2 & i9.$flags$ ? "slot-fb" : i9.$tag$), dp && "foreignObject" === i9.$tag$ && (dp = false), ap26(null, i9, dp);
    if (!!o6.getRootNode().querySelector("body") && df2 && ((e12) => null != e12)(jf2) && o6["s-si"] !== jf2 && o6.classList.add(o6["s-si"] = jf2), i9.$children$) for (a6 = 0; a6 < i9.$children$.length; ++a6) s5 = up(e11, i9, a6), s5 && o6.appendChild(s5);
    "svg" === i9.$tag$ ? dp = false : "foreignObject" === o6.tagName && (dp = true);
  }
  return o6["s-hn"] = Uf2, o6;
};
var hp = (e11, t6, n5, r8, i9, o6) => {
  let s5, a6 = e11;
  for (a6.shadowRoot && a6.tagName === Uf2 && (a6 = a6.shadowRoot); i9 <= o6; ++i9) r8[i9] && (s5 = up(null, n5, i9), s5 && (r8[i9].$elm$ = s5, mp(a6, s5, t6)));
};
var fp = (e11, t6, n5) => {
  for (let r8 = t6; r8 <= n5; ++r8) {
    const t7 = e11[r8];
    if (t7) {
      const e12 = t7.$elm$;
      e12 && e12.remove();
    }
  }
};
var pp = (e11, t6, n5 = false) => e11.$tag$ === t6.$tag$;
var gp = (e11, t6, n5 = false) => {
  const r8 = t6.$elm$ = e11.$elm$, i9 = e11.$children$, o6 = t6.$children$, s5 = t6.$tag$, a6 = t6.$text$;
  null === a6 ? (ap26(e11, t6, dp = "svg" === s5 || "foreignObject" !== s5 && dp), null !== i9 && null !== o6 ? ((e12, t7, n6, r9, i10 = false) => {
    let o7, s6 = 0, a7 = 0, c9 = t7.length - 1, l9 = t7[0], d7 = t7[c9], u10 = r9.length - 1, h9 = r9[0], f16 = r9[u10];
    for (; s6 <= c9 && a7 <= u10; ) null == l9 ? l9 = t7[++s6] : null == d7 ? d7 = t7[--c9] : null == h9 ? h9 = r9[++a7] : null == f16 ? f16 = r9[--u10] : pp(l9, h9, i10) ? (gp(l9, h9, i10), l9 = t7[++s6], h9 = r9[++a7]) : pp(d7, f16, i10) ? (gp(d7, f16, i10), d7 = t7[--c9], f16 = r9[--u10]) : pp(l9, f16, i10) ? (gp(l9, f16, i10), mp(e12, l9.$elm$, d7.$elm$.nextSibling), l9 = t7[++s6], f16 = r9[--u10]) : pp(d7, h9, i10) ? (gp(d7, h9, i10), mp(e12, d7.$elm$, l9.$elm$), d7 = t7[--c9], h9 = r9[++a7]) : (o7 = up(t7 && t7[a7], n6, a7), h9 = r9[++a7], o7 && mp(l9.$elm$.parentNode, o7, l9.$elm$));
    s6 > c9 ? hp(e12, null == r9[u10 + 1] ? null : r9[u10 + 1].$elm$, n6, r9, a7, u10) : a7 > u10 && fp(t7, s6, c9);
  })(r8, i9, t6, o6, n5) : null !== o6 ? (null !== e11.$text$ && (r8.textContent = ""), hp(r8, null, t6, o6, 0, o6.length - 1)) : !n5 && hf2 && null !== i9 && fp(i9, 0, i9.length - 1), dp && "svg" === s5 && (dp = false)) : e11.$text$ !== a6 && (r8.data = a6);
};
var mp = (e11, t6, n5) => null == e11 ? void 0 : e11.insertBefore(t6, n5);
var yp = (e11, t6, n5 = false) => {
  const r8 = e11.$hostElement$, i9 = e11.$cmpMeta$, o6 = e11.$vnode$ || qf2(null, null), s5 = (a6 = t6) && a6.$tag$ === Wf2 ? t6 : zf2(null, null, t6);
  var a6;
  if (Uf2 = r8.tagName, n5 && s5.$attrs$) for (const e12 of Object.keys(s5.$attrs$)) r8.hasAttribute(e12) && !["key", "ref", "style", "class"].includes(e12) && (s5.$attrs$[e12] = r8[e12]);
  s5.$tag$ = null, s5.$flags$ |= 4, e11.$vnode$ = s5, s5.$elm$ = o6.$elm$ = r8.shadowRoot || r8, jf2 = r8["s-sc"], lp = 0 != (1 & i9.$flags$), gp(o6, s5, n5);
};
var vp = (e11, t6) => {
  t6 && !e11.$onRenderResolve$ && t6["s-p"] && t6["s-p"].push(new Promise((t7) => e11.$onRenderResolve$ = t7));
};
var bp = (e11, t6) => {
  if (e11.$flags$ |= 16, 4 & e11.$flags$) return void (e11.$flags$ |= 512);
  vp(e11, e11.$ancestorComponent$);
  return Of2(() => wp(e11, t6));
};
var wp = (e11, t6) => {
  const n5 = e11.$hostElement$, r8 = (e11.$cmpMeta$.$tagName$, () => {
  }), i9 = e11.$lazyInstance$;
  if (!i9) throw new Error(`Can't render component <${n5.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);
  return r8(), Ep(void 0, () => _p(e11, i9, t6));
};
var Ep = (e11, t6) => Sp(e11) ? e11.then(t6).catch((e12) => {
  console.error(e12), t6();
}) : t6();
var Sp = (e11) => e11 instanceof Promise || e11 && e11.then && "function" == typeof e11.then;
var _p = async (e11, t6, n5) => {
  var r8;
  const i9 = e11.$hostElement$, o6 = (e11.$cmpMeta$.$tagName$, () => {
  }), s5 = i9["s-rc"];
  n5 && ep(e11);
  const a6 = (e11.$cmpMeta$.$tagName$, () => {
  });
  Cp(e11, t6, i9, n5), s5 && (s5.map((e12) => e12()), i9["s-rc"] = void 0), a6(), o6();
  {
    const t7 = null != (r8 = i9["s-p"]) ? r8 : [], n6 = () => kp(e11);
    0 === t7.length ? n6() : (Promise.all(t7).then(n6), e11.$flags$ |= 4, t7.length = 0);
  }
};
var Cp = (e11, t6, n5, r8) => {
  try {
    t6 = t6.render(), e11.$flags$ &= -17, e11.$flags$ |= 2, yp(e11, t6, r8);
  } catch (t7) {
    vf(t7, e11.$hostElement$);
  }
  return null;
};
var kp = (e11) => {
  e11.$cmpMeta$.$tagName$;
  const t6 = e11.$hostElement$, n5 = () => {
  }, r8 = e11.$lazyInstance$, i9 = e11.$ancestorComponent$;
  64 & e11.$flags$ ? n5() : (e11.$flags$ |= 64, Mp(t6), xp(r8, "componentDidLoad"), n5(), e11.$onReadyResolve$(t6), i9 || Ap()), e11.$onRenderResolve$ && (e11.$onRenderResolve$(), e11.$onRenderResolve$ = void 0), 512 & e11.$flags$ && Pf2(() => bp(e11, false)), e11.$flags$ &= -517;
};
var Ap = (e11) => {
  Mp(_f2.documentElement), Pf2(() => Qf2(Sf2, "appload", { detail: { namespace: "sdk-install-modal-web" } }));
};
var xp = (e11, t6, n5) => {
  if (e11 && e11[t6]) try {
    return e11[t6](n5);
  } catch (e12) {
    vf(e12);
  }
};
var Mp = (e11) => {
  var t6;
  return e11.classList.add(null != (t6 = lf2) ? t6 : "hydrated");
};
var Ip = (e11, t6, n5, r8) => {
  const i9 = gf2(e11);
  if (!i9) throw new Error(`Couldn't find host element for "${r8.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).`);
  const o6 = i9.$hostElement$, s5 = i9.$instanceValues$.get(t6), a6 = i9.$flags$, c9 = i9.$lazyInstance$;
  var l9, d7;
  l9 = n5, d7 = r8.$members$[t6][0], n5 = null == l9 || Lf2(l9) ? l9 : 4 & d7 ? "false" !== l9 && ("" === l9 || !!l9) : 1 & d7 ? String(l9) : l9;
  const u10 = Number.isNaN(s5) && Number.isNaN(n5);
  if ((!(8 & a6) || void 0 === s5) && (n5 !== s5 && !u10) && (i9.$instanceValues$.set(t6, n5), c9)) {
    if (r8.$watchers$ && 128 & a6) {
      const e12 = r8.$watchers$[t6];
      e12 && e12.map((e13) => {
        try {
          c9[e13](n5, s5, t6);
        } catch (e14) {
          vf(e14, o6);
        }
      });
    }
    2 == (18 & a6) && bp(i9, false);
  }
};
var Tp = (e11, t6, n5) => {
  var r8, i9;
  const o6 = e11.prototype;
  if (t6.$members$ || t6.$watchers$ || e11.watchers) {
    e11.watchers && !t6.$watchers$ && (t6.$watchers$ = e11.watchers);
    const s5 = Object.entries(null != (r8 = t6.$members$) ? r8 : {});
    if (s5.map(([e12, [r9]]) => {
      (31 & r9 || 2 & n5 && 32 & r9) && Object.defineProperty(o6, e12, { get() {
        return t7 = e12, gf2(this).$instanceValues$.get(t7);
        var t7;
      }, set(n6) {
        Ip(this, e12, n6, t6);
      }, configurable: true, enumerable: true });
    }), 1 & n5) {
      const n6 = /* @__PURE__ */ new Map();
      o6.attributeChangedCallback = function(e12, r9, i10) {
        Cf2.jmp(() => {
          var s6;
          const a6 = n6.get(e12);
          if (this.hasOwnProperty(a6)) i10 = this[a6], delete this[a6];
          else {
            if (o6.hasOwnProperty(a6) && "number" == typeof this[a6] && this[a6] == i10) return;
            if (null == a6) {
              const n7 = gf2(this), o7 = null == n7 ? void 0 : n7.$flags$;
              if (o7 && !(8 & o7) && 128 & o7 && i10 !== r9) {
                const o8 = n7.$lazyInstance$, a7 = null == (s6 = t6.$watchers$) ? void 0 : s6[e12];
                null == a7 || a7.forEach((t7) => {
                  null != o8[t7] && o8[t7].call(o8, i10, r9, e12);
                });
              }
              return;
            }
          }
          this[a6] = (null !== i10 || "boolean" != typeof this[a6]) && i10;
        });
      }, e11.observedAttributes = Array.from(/* @__PURE__ */ new Set([...Object.keys(null != (i9 = t6.$watchers$) ? i9 : {}), ...s5.filter(([e12, t7]) => 15 & t7[0]).map(([e12, t7]) => {
        const r9 = t7[1] || e12;
        return n6.set(r9, e12), r9;
      })]));
    }
  }
  return e11;
};
var Rp = async (e11, t6, n5, r8) => {
  let i9;
  if (0 == (32 & t6.$flags$)) {
    t6.$flags$ |= 32;
    if (n5.$lazyBundleId$) {
      const e12 = ((e13, t7, n6) => {
        const r10 = e13.$tagName$.replace(/-/g, "_"), i10 = e13.$lazyBundleId$;
        if (!i10) return;
        const o7 = bf2.get(i10);
        if (o7) return o7[r10];
        {
          const e14 = (e15) => (bf2.set(i10, e15), e15[r10]);
          if ("mm-install-modal_3" === i10) return Promise.resolve().then(function() {
            return wg;
          }).then(e14, vf);
        }
        return /* webpackIgnore: true */ /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${i10}.entry.js`).then((e14) => (bf2.set(i10, e14), e14[r10]), vf);
      })(n5);
      if (e12 && "then" in e12) {
        const t7 = () => {
        };
        i9 = await e12, t7();
      } else i9 = e12;
      if (!i9) throw new Error(`Constructor for "${n5.$tagName$}#${t6.$modeName$}" was not found`);
      i9.isProxied || (n5.$watchers$ = i9.watchers, Tp(i9, n5, 2), i9.isProxied = true);
      const r9 = (n5.$tagName$, () => {
      });
      t6.$flags$ |= 8;
      try {
        new i9(t6);
      } catch (e13) {
        vf(e13);
      }
      t6.$flags$ &= -9, t6.$flags$ |= 128, r9(), Pp(t6.$lazyInstance$);
    } else {
      i9 = e11.constructor;
      const n6 = e11.localName;
      customElements.whenDefined(n6).then(() => t6.$flags$ |= 128);
    }
    if (i9 && i9.style) {
      let e12;
      "string" == typeof i9.style && (e12 = i9.style);
      const t7 = tp(n5);
      if (!wf.has(t7)) {
        const r9 = (n5.$tagName$, () => {
        });
        ((e13, t8, n6) => {
          let r10 = wf.get(e13);
          kf2 && n6 ? (r10 = r10 || new CSSStyleSheet(), "string" == typeof r10 ? r10 = t8 : r10.replaceSync(t8)) : r10 = t8, wf.set(e13, r10);
        })(t7, e12, !!(1 & n5.$flags$)), r9();
      }
    }
  }
  const o6 = t6.$ancestorComponent$, s5 = () => bp(t6, true);
  o6 && o6["s-rc"] ? o6["s-rc"].push(s5) : s5();
};
var Pp = (e11) => {
  xp(e11, "connectedCallback");
};
var Op = (e11) => {
  xp(e11, "disconnectedCallback");
};
var Np = (e11, t6 = {}) => {
  var n5;
  const r8 = () => {
  }, i9 = [], o6 = t6.exclude || [], s5 = Sf2.customElements, a6 = _f2.head, c9 = a6.querySelector("meta[charset]"), l9 = _f2.createElement("style"), d7 = [];
  let u10, h9 = true;
  Object.assign(Cf2, t6), Cf2.$resourcesUrl$ = new URL(t6.resourcesUrl || "./", _f2.baseURI).href;
  let f16 = false;
  if (e11.map((e12) => {
    e12[1].map((t7) => {
      var n6;
      const r9 = { $flags$: t7[0], $tagName$: t7[1], $members$: t7[2], $listeners$: t7[3] };
      4 & r9.$flags$ && (f16 = true), r9.$members$ = t7[2], r9.$watchers$ = null != (n6 = t7[4]) ? n6 : {};
      const a7 = r9.$tagName$, c10 = class extends HTMLElement {
        constructor(e13) {
          if (super(e13), this.hasRegisteredEventListeners = false, ((e14, t8) => {
            const n7 = { $flags$: 0, $hostElement$: e14, $cmpMeta$: t8, $instanceValues$: /* @__PURE__ */ new Map() };
            n7.$onReadyPromise$ = new Promise((e15) => n7.$onReadyResolve$ = e15), e14["s-p"] = [], e14["s-rc"] = [], pf2.set(e14, n7);
          })(e13 = this, r9), 1 & r9.$flags$) if (e13.shadowRoot) {
            if ("open" !== e13.shadowRoot.mode) throw new Error(`Unable to re-use existing shadow root for ${r9.$tagName$}! Mode is set to ${e13.shadowRoot.mode} but Stencil only supports open shadow roots.`);
          } else e13.attachShadow({ mode: "open" });
        }
        connectedCallback() {
          gf2(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = true), u10 && (clearTimeout(u10), u10 = null), h9 ? d7.push(this) : Cf2.jmp(() => ((e13) => {
            if (0 == (1 & Cf2.$flags$)) {
              const t8 = gf2(e13), n7 = t8.$cmpMeta$, r10 = (n7.$tagName$, () => {
              });
              if (1 & t8.$flags$) (null == t8 ? void 0 : t8.$lazyInstance$) ? Pp(t8.$lazyInstance$) : (null == t8 ? void 0 : t8.$onReadyPromise$) && t8.$onReadyPromise$.then(() => Pp(t8.$lazyInstance$));
              else {
                t8.$flags$ |= 1;
                {
                  let n8 = e13;
                  for (; n8 = n8.parentNode || n8.host; ) if (n8["s-p"]) {
                    vp(t8, t8.$ancestorComponent$ = n8);
                    break;
                  }
                }
                n7.$members$ && Object.entries(n7.$members$).map(([t9, [n8]]) => {
                  if (31 & n8 && e13.hasOwnProperty(t9)) {
                    const n9 = e13[t9];
                    delete e13[t9], e13[t9] = n9;
                  }
                }), Rp(e13, t8, n7);
              }
              r10();
            }
          })(this));
        }
        disconnectedCallback() {
          Cf2.jmp(() => (async (e13) => {
            if (0 == (1 & Cf2.$flags$)) {
              const t8 = gf2(e13);
              (null == t8 ? void 0 : t8.$lazyInstance$) ? Op(t8.$lazyInstance$) : (null == t8 ? void 0 : t8.$onReadyPromise$) && t8.$onReadyPromise$.then(() => Op(t8.$lazyInstance$));
            }
          })(this));
        }
        componentOnReady() {
          return gf2(this).$onReadyPromise$;
        }
      };
      r9.$lazyBundleId$ = e12[0], o6.includes(a7) || s5.get(a7) || (i9.push(a7), s5.define(a7, Tp(c10, r9, 1)));
    });
  }), i9.length > 0 && (f16 && (l9.textContent += Ef2), l9.textContent += i9.sort() + "{visibility:hidden}.hydrated{visibility:inherit}", l9.innerHTML.length)) {
    l9.setAttribute("data-styles", "");
    const e12 = null != (n5 = Cf2.$nonce$) ? n5 : Df2(_f2);
    null != e12 && l9.setAttribute("nonce", e12), a6.insertBefore(l9, c9 ? c9.nextSibling : a6.firstChild);
  }
  h9 = false, d7.length ? d7.map((e12) => e12.connectedCallback()) : Cf2.jmp(() => u10 = setTimeout(Ap, 30)), r8();
};
!function() {
  if ("undefined" != typeof window && void 0 !== window.Reflect && void 0 !== window.customElements) {
    var e11 = HTMLElement;
    window.HTMLElement = function() {
      return Reflect.construct(e11, [], this.constructor);
    }, HTMLElement.prototype = e11.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e11);
  }
}();
var Lp = Object.freeze({ __proto__: null, defineCustomElements: async (e11, t6) => {
  if ("undefined" != typeof window) return await void 0, Np([["mm-install-modal_3", [[1, "mm-install-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }], [1, "mm-pending-modal", { displayOTP: [4, "display-o-t-p"], sdkVersion: [1, "sdk-version"], otpCode: [1, "otp-code"], translationsLoaded: [32] }], [1, "mm-select-modal", { link: [1], sdkVersion: [1, "sdk-version"], preferDesktop: [4, "prefer-desktop"], tab: [32], isDefaultTab: [32], translationsLoaded: [32] }, null, { preferDesktop: ["updatePreferDesktop"] }]]]], t6);
}, setNonce: (e11) => Cf2.$nonce$ = e11 });
var Dp = { fontFamily: "Roboto, sans-serif" };
var $p = ({ className: e11 }, t6) => zf2("div", { style: Dp, class: e11 }, t6);
var Bp = ({ Icon: e11, text: t6 }) => zf2("div", { class: "flexContainer", style: { padding: "6", flexDirection: "row" } }, zf2("div", { class: "flexItem1" }, zf2(e11, null)), zf2("div", { class: "flexItem11" }, zf2("span", { style: { lineHeight: "2", color: "black" } }, t6)));
var Kp = () => zf2("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("path", { d: "M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z", fill: "#037DD6" }), zf2("path", { d: "M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z", fill: "#037DD6" }));
var jp = () => zf2("svg", { width: "20", height: "18", viewBox: "0 0 20 18", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("path", { d: "M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z", fill: "#037DD6" }));
var Up = () => zf2("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("path", { d: "M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z", fill: "#037DD6" }));
var Hp = () => zf2("svg", { width: "20", height: "20", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("path", { d: "M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf2("path", { d: "M12 2V14.88", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }), zf2("path", { d: "M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }));
function Fp3({ version: e11 }) {
  return zf2("div", { style: { textAlign: "center", color: "#BBC0C5", fontSize: "12" } }, "SDK Version ", e11 ? `v${e11}` : "unknown");
}
var zp = () => zf2("svg", { width: "14", height: "14", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("rect", { width: "16", height: "16", fill: "white" }), zf2("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z", fill: "#BBC0C5" }));
var qp = () => zf2("svg", { width: "120", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 127 63" }, zf2("path", { fill: "currentColor", d: "M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z" }));
function Wp(e11, t6) {
  return e11.toString(2).padStart(t6, "0");
}
function Vp(e11, t6) {
  const n5 = e11 % t6;
  return n5 >= 0 ? n5 : t6 + n5;
}
function Gp(e11, t6) {
  return new Array(e11).fill(t6);
}
function Yp(...e11) {
  let t6 = 0;
  for (const n6 of e11) t6 = Math.max(t6, n6.length);
  const n5 = [];
  for (let r8 = 0; r8 < t6; r8++) for (const t7 of e11) r8 >= t7.length || n5.push(t7[r8]);
  return new Uint8Array(n5);
}
function Zp(e11, t6, n5) {
  if (n5 < 0 || n5 + t6.length > e11.length) return false;
  for (let r8 = 0; r8 < t6.length; r8++) if (t6[r8] !== e11[n5 + r8]) return false;
  return true;
}
function Jp(e11) {
  return { has: (t6) => e11.includes(t6), decode: (t6) => {
    if (!Array.isArray(t6) || t6.length && "string" != typeof t6[0]) throw new Error("alphabet.decode input should be array of strings");
    return t6.map((t7) => {
      if ("string" != typeof t7) throw new Error(`alphabet.decode: not string element=${t7}`);
      const n5 = e11.indexOf(t7);
      if (-1 === n5) throw new Error(`Unknown letter: "${t7}". Allowed: ${e11}`);
      return n5;
    });
  }, encode: (t6) => {
    if (!Array.isArray(t6) || t6.length && "number" != typeof t6[0]) throw new Error("alphabet.encode input should be an array of numbers");
    return t6.map((t7) => {
      if (function(e12) {
        if (!Number.isSafeInteger(e12)) throw new Error(`Wrong integer: ${e12}`);
      }(t7), t7 < 0 || t7 >= e11.length) throw new Error(`Digit index outside alphabet: ${t7} (alphabet: ${e11.length})`);
      return e11[t7];
    });
  } };
}
var Qp = class _Qp {
  static size(e11, t6) {
    if ("number" == typeof e11 && (e11 = { height: e11, width: e11 }), !Number.isSafeInteger(e11.height) && e11.height !== 1 / 0) throw new Error(`Bitmap: wrong height=${e11.height} (${typeof e11.height})`);
    if (!Number.isSafeInteger(e11.width) && e11.width !== 1 / 0) throw new Error(`Bitmap: wrong width=${e11.width} (${typeof e11.width})`);
    return void 0 !== t6 && (e11 = { width: Math.min(e11.width, t6.width), height: Math.min(e11.height, t6.height) }), e11;
  }
  static fromString(e11) {
    const t6 = (e11 = e11.replace(/^\n+/g, "").replace(/\n+$/g, "")).split("\n"), n5 = t6.length, r8 = new Array(n5);
    let i9;
    for (const e12 of t6) {
      const t7 = e12.split("").map((e13) => {
        if ("X" === e13) return true;
        if (" " === e13) return false;
        if ("?" !== e13) throw new Error(`Bitmap.fromString: unknown symbol=${e13}`);
      });
      if (i9 && t7.length !== i9) throw new Error(`Bitmap.fromString different row sizes: width=${i9} cur=${t7.length}`);
      i9 = t7.length, r8.push(t7);
    }
    return i9 || (i9 = 0), new _Qp({ height: n5, width: i9 }, r8);
  }
  constructor(e11, t6) {
    const { height: n5, width: r8 } = _Qp.size(e11);
    this.data = t6 || Array.from({ length: n5 }, () => Gp(r8, void 0)), this.height = n5, this.width = r8;
  }
  point(e11) {
    return this.data[e11.y][e11.x];
  }
  isInside(e11) {
    return 0 <= e11.x && e11.x < this.width && 0 <= e11.y && e11.y < this.height;
  }
  size(e11) {
    if (!e11) return { height: this.height, width: this.width };
    const { x: t6, y: n5 } = this.xy(e11);
    return { height: this.height - n5, width: this.width - t6 };
  }
  xy(e11) {
    if ("number" == typeof e11 && (e11 = { x: e11, y: e11 }), !Number.isSafeInteger(e11.x)) throw new Error(`Bitmap: wrong x=${e11.x}`);
    if (!Number.isSafeInteger(e11.y)) throw new Error(`Bitmap: wrong y=${e11.y}`);
    return e11.x = Vp(e11.x, this.width), e11.y = Vp(e11.y, this.height), e11;
  }
  rect(e11, t6, n5) {
    const { x: r8, y: i9 } = this.xy(e11), { height: o6, width: s5 } = _Qp.size(t6, this.size({ x: r8, y: i9 }));
    for (let e12 = 0; e12 < o6; e12++) for (let t7 = 0; t7 < s5; t7++) this.data[i9 + e12][r8 + t7] = "function" == typeof n5 ? n5({ x: t7, y: e12 }, this.data[i9 + e12][r8 + t7]) : n5;
    return this;
  }
  rectRead(e11, t6, n5) {
    return this.rect(e11, t6, (e12, t7) => (n5(e12, t7), t7));
  }
  hLine(e11, t6, n5) {
    return this.rect(e11, { width: t6, height: 1 }, n5);
  }
  vLine(e11, t6, n5) {
    return this.rect(e11, { width: 1, height: t6 }, n5);
  }
  border(e11 = 2, t6) {
    const n5 = this.height + 2 * e11, r8 = this.width + 2 * e11, i9 = Gp(e11, t6), o6 = Array.from({ length: e11 }, () => Gp(r8, t6));
    return new _Qp({ height: n5, width: r8 }, [...o6, ...this.data.map((e12) => [...i9, ...e12, ...i9]), ...o6]);
  }
  embed(e11, t6) {
    return this.rect(e11, t6.size(), ({ x: e12, y: n5 }) => t6.data[n5][e12]);
  }
  rectSlice(e11, t6 = this.size()) {
    const n5 = new _Qp(_Qp.size(t6, this.size(this.xy(e11))));
    return this.rect(e11, t6, ({ x: e12, y: t7 }, r8) => n5.data[t7][e12] = r8), n5;
  }
  inverse() {
    const { height: e11, width: t6 } = this;
    return new _Qp({ height: t6, width: e11 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: e12, y: t7 }) => this.data[e12][t7]);
  }
  scale(e11) {
    if (!Number.isSafeInteger(e11) || e11 > 1024) throw new Error(`Wrong scale factor: ${e11}`);
    const { height: t6, width: n5 } = this;
    return new _Qp({ height: e11 * t6, width: e11 * n5 }).rect({ x: 0, y: 0 }, 1 / 0, ({ x: t7, y: n6 }) => this.data[Math.floor(n6 / e11)][Math.floor(t7 / e11)]);
  }
  clone() {
    return new _Qp(this.size()).rect({ x: 0, y: 0 }, this.size(), ({ x: e11, y: t6 }) => this.data[t6][e11]);
  }
  assertDrawn() {
    this.rectRead(0, 1 / 0, (e11, t6) => {
      if ("boolean" != typeof t6) throw new Error("Invalid color type=" + typeof t6);
    });
  }
  toString() {
    return this.data.map((e11) => e11.map((e12) => void 0 === e12 ? "?" : e12 ? "X" : " ").join("")).join("\n");
  }
  toASCII() {
    const { height: e11, width: t6, data: n5 } = this;
    let r8 = "";
    for (let i9 = 0; i9 < e11; i9 += 2) {
      for (let o6 = 0; o6 < t6; o6++) {
        const t7 = n5[i9][o6], s5 = i9 + 1 >= e11 || n5[i9 + 1][o6];
        t7 || s5 ? !t7 && s5 ? r8 += "" : t7 && !s5 ? r8 += "" : t7 && s5 && (r8 += " ") : r8 += "";
      }
      r8 += "\n";
    }
    return r8;
  }
  toTerm() {
    const e11 = "\x1B[0m", t6 = `\x1B[1;47m  ${e11}`, n5 = `\x1B[40m  ${e11}`;
    return this.data.map((e12) => e12.map((e13) => e13 ? n5 : t6).join("")).join("\n");
  }
  toSVG() {
    let e11 = `<svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 ${this.width} ${this.height}" version="1.1" xmlns="http://www.w3.org/2000/svg">`;
    return this.rectRead(0, 1 / 0, ({ x: t6, y: n5 }, r8) => {
      r8 && (e11 += `<rect x="${t6}" y="${n5}" width="1" height="1" />`);
    }), e11 += "</svg>", e11;
  }
  toGIF() {
    const e11 = (e12) => [255 & e12, e12 >>> 8 & 255], t6 = [...e11(this.width), ...e11(this.height)], n5 = [];
    this.rectRead(0, 1 / 0, (e12, t7) => n5.push(+(true === t7)));
    const r8 = 126, i9 = [71, 73, 70, 56, 55, 97, ...t6, 246, 0, 0, 255, 255, 255, ...Gp(381, 0), 44, 0, 0, 0, 0, ...t6, 0, 7], o6 = Math.floor(n5.length / r8);
    for (let e12 = 0; e12 < o6; e12++) i9.push(127, 128, ...n5.slice(r8 * e12, r8 * (e12 + 1)).map((e13) => +e13));
    return i9.push(n5.length % r8 + 1, 128, ...n5.slice(o6 * r8).map((e12) => +e12)), i9.push(1, 129, 0, 59), new Uint8Array(i9);
  }
  toImage(e11 = false) {
    const { height: t6, width: n5 } = this.size(), r8 = new Uint8Array(t6 * n5 * (e11 ? 3 : 4));
    let i9 = 0;
    for (let o6 = 0; o6 < t6; o6++) for (let t7 = 0; t7 < n5; t7++) {
      const n6 = this.data[o6][t7] ? 0 : 255;
      r8[i9++] = n6, r8[i9++] = n6, r8[i9++] = n6, e11 || (r8[i9++] = 255);
    }
    return { height: t6, width: n5, data: r8 };
  }
};
var Xp = ["low", "medium", "quartile", "high"];
var eg = ["numeric", "alphanumeric", "byte", "kanji", "eci"];
var tg = [26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
var ng = { low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] };
var rg = { low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] };
var ig = { size: { encode: (e11) => 21 + 4 * (e11 - 1), decode: (e11) => (e11 - 17) / 4 }, sizeType: (e11) => Math.floor((e11 + 7) / 17), alignmentPatterns(e11) {
  if (1 === e11) return [];
  const t6 = ig.size.encode(e11) - 6 - 1, n5 = t6 - 6, r8 = Math.ceil(n5 / 28);
  let i9 = Math.floor(n5 / r8);
  i9 % 2 ? i9 += 1 : n5 % r8 * 2 >= r8 && (i9 += 2);
  const o6 = [6];
  for (let e12 = 1; e12 < r8; e12++) o6.push(t6 - (r8 - e12) * i9);
  return o6.push(t6), o6;
}, ECCode: { low: 1, medium: 0, quartile: 3, high: 2 }, formatMask: 21522, formatBits(e11, t6) {
  const n5 = ig.ECCode[e11] << 3 | t6;
  let r8 = n5;
  for (let e12 = 0; e12 < 10; e12++) r8 = r8 << 1 ^ 1335 * (r8 >> 9);
  return (n5 << 10 | r8) ^ ig.formatMask;
}, versionBits(e11) {
  let t6 = e11;
  for (let e12 = 0; e12 < 12; e12++) t6 = t6 << 1 ^ 7973 * (t6 >> 11);
  return e11 << 12 | t6;
}, alphabet: { numeric: Jp("0123456789"), alphanumerc: Jp("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:") }, lengthBits: (e11, t6) => ({ numeric: [10, 12, 14], alphanumeric: [9, 11, 13], byte: [8, 16, 16], kanji: [8, 10, 12], eci: [0, 0, 0] })[t6][ig.sizeType(e11)], modeBits: { numeric: "0001", alphanumeric: "0010", byte: "0100", kanji: "1000", eci: "0111" }, capacity(e11, t6) {
  const n5 = tg[e11 - 1], r8 = ng[t6][e11 - 1], i9 = rg[t6][e11 - 1], o6 = Math.floor(n5 / i9) - r8, s5 = i9 - n5 % i9;
  return { words: r8, numBlocks: i9, shortBlocks: s5, blockLen: o6, capacity: 8 * (n5 - r8 * i9), total: (r8 + o6) * i9 + i9 - s5 };
} };
var og = [(e11, t6) => (e11 + t6) % 2 == 0, (e11, t6) => t6 % 2 == 0, (e11, t6) => e11 % 3 == 0, (e11, t6) => (e11 + t6) % 3 == 0, (e11, t6) => (Math.floor(t6 / 2) + Math.floor(e11 / 3)) % 2 == 0, (e11, t6) => e11 * t6 % 2 + e11 * t6 % 3 == 0, (e11, t6) => (e11 * t6 % 2 + e11 * t6 % 3) % 2 == 0, (e11, t6) => ((e11 + t6) % 2 + e11 * t6 % 3) % 2 == 0];
var sg = { tables: ((e11) => {
  const t6 = Gp(256, 0), n5 = Gp(256, 0);
  for (let e12 = 0, r8 = 1; e12 < 256; e12++) t6[e12] = r8, n5[r8] = e12, r8 <<= 1, 256 & r8 && (r8 ^= 285);
  return { exp: t6, log: n5 };
})(), exp: (e11) => sg.tables.exp[e11], log(e11) {
  if (0 === e11) throw new Error(`GF.log: wrong arg=${e11}`);
  return sg.tables.log[e11] % 255;
}, mul: (e11, t6) => 0 === e11 || 0 === t6 ? 0 : sg.tables.exp[(sg.tables.log[e11] + sg.tables.log[t6]) % 255], add: (e11, t6) => e11 ^ t6, pow: (e11, t6) => sg.tables.exp[sg.tables.log[e11] * t6 % 255], inv(e11) {
  if (0 === e11) throw new Error(`GF.inverse: wrong arg=${e11}`);
  return sg.tables.exp[255 - sg.tables.log[e11]];
}, polynomial(e11) {
  if (0 == e11.length) throw new Error("GF.polymomial: wrong length");
  if (0 !== e11[0]) return e11;
  let t6 = 0;
  for (; t6 < e11.length - 1 && 0 == e11[t6]; t6++) ;
  return e11.slice(t6);
}, monomial(e11, t6) {
  if (e11 < 0) throw new Error(`GF.monomial: wrong degree=${e11}`);
  if (0 == t6) return [0];
  let n5 = Gp(e11 + 1, 0);
  return n5[0] = t6, sg.polynomial(n5);
}, degree: (e11) => e11.length - 1, coefficient: (e11, t6) => e11[sg.degree(e11) - t6], mulPoly(e11, t6) {
  if (0 === e11[0] || 0 === t6[0]) return [0];
  const n5 = Gp(e11.length + t6.length - 1, 0);
  for (let r8 = 0; r8 < e11.length; r8++) for (let i9 = 0; i9 < t6.length; i9++) n5[r8 + i9] = sg.add(n5[r8 + i9], sg.mul(e11[r8], t6[i9]));
  return sg.polynomial(n5);
}, mulPolyScalar(e11, t6) {
  if (0 == t6) return [0];
  if (1 == t6) return e11;
  const n5 = Gp(e11.length, 0);
  for (let r8 = 0; r8 < e11.length; r8++) n5[r8] = sg.mul(e11[r8], t6);
  return sg.polynomial(n5);
}, mulPolyMonomial(e11, t6, n5) {
  if (t6 < 0) throw new Error("GF.mulPolyMonomial: wrong degree");
  if (0 == n5) return [0];
  const r8 = Gp(e11.length + t6, 0);
  for (let t7 = 0; t7 < e11.length; t7++) r8[t7] = sg.mul(e11[t7], n5);
  return sg.polynomial(r8);
}, addPoly(e11, t6) {
  if (0 === e11[0]) return t6;
  if (0 === t6[0]) return e11;
  let n5 = e11, r8 = t6;
  n5.length > r8.length && ([n5, r8] = [r8, n5]);
  let i9 = Gp(r8.length, 0), o6 = r8.length - n5.length, s5 = r8.slice(0, o6);
  for (let e12 = 0; e12 < s5.length; e12++) i9[e12] = s5[e12];
  for (let e12 = o6; e12 < r8.length; e12++) i9[e12] = sg.add(n5[e12 - o6], r8[e12]);
  return sg.polynomial(i9);
}, remainderPoly(e11, t6) {
  const n5 = Array.from(e11);
  for (let r8 = 0; r8 < e11.length - t6.length + 1; r8++) {
    const e12 = n5[r8];
    if (0 !== e12) for (let i9 = 1; i9 < t6.length; i9++) 0 !== t6[i9] && (n5[r8 + i9] = sg.add(n5[r8 + i9], sg.mul(t6[i9], e12)));
  }
  return n5.slice(e11.length - t6.length + 1, n5.length);
}, divisorPoly(e11) {
  let t6 = [1];
  for (let n5 = 0; n5 < e11; n5++) t6 = sg.mulPoly(t6, [1, sg.pow(2, n5)]);
  return t6;
}, evalPoly(e11, t6) {
  if (0 == t6) return sg.coefficient(e11, 0);
  let n5 = e11[0];
  for (let r8 = 1; r8 < e11.length; r8++) n5 = sg.add(sg.mul(t6, n5), e11[r8]);
  return n5;
}, euclidian(e11, t6, n5) {
  sg.degree(e11) < sg.degree(t6) && ([e11, t6] = [t6, e11]);
  let r8 = e11, i9 = t6, o6 = [0], s5 = [1];
  for (; 2 * sg.degree(i9) >= n5; ) {
    let e12 = r8, t7 = o6;
    if (r8 = i9, o6 = s5, 0 === r8[0]) throw new Error("rLast[0] === 0");
    i9 = e12;
    let n6 = [0];
    const a7 = sg.inv(r8[0]);
    for (; sg.degree(i9) >= sg.degree(r8) && 0 !== i9[0]; ) {
      const e13 = sg.degree(i9) - sg.degree(r8), t8 = sg.mul(i9[0], a7);
      n6 = sg.addPoly(n6, sg.monomial(e13, t8)), i9 = sg.addPoly(i9, sg.mulPolyMonomial(r8, e13, t8));
    }
    if (n6 = sg.mulPoly(n6, o6), s5 = sg.addPoly(n6, t7), sg.degree(i9) >= sg.degree(r8)) throw new Error(`Division failed r: ${i9}, rLast: ${r8}`);
  }
  const a6 = sg.coefficient(s5, 0);
  if (0 == a6) throw new Error("sigmaTilde(0) was zero");
  const c9 = sg.inv(a6);
  return [sg.mulPolyScalar(s5, c9), sg.mulPolyScalar(i9, c9)];
} };
function ag(e11, t6) {
  const { words: n5, shortBlocks: r8, numBlocks: i9, blockLen: o6, total: s5 } = ig.capacity(e11, t6), a6 = (c9 = n5, { encode(e12) {
    const t7 = sg.divisorPoly(c9), n6 = Array.from(e12);
    return n6.push(...t7.slice(0, -1).fill(0)), Uint8Array.from(sg.remainderPoly(n6, t7));
  }, decode(e12) {
    const t7 = e12.slice(), n6 = sg.polynomial(Array.from(e12));
    let r9 = Gp(c9, 0), i10 = false;
    for (let e13 = 0; e13 < c9; e13++) {
      const t8 = sg.evalPoly(n6, sg.exp(e13));
      r9[r9.length - 1 - e13] = t8, 0 !== t8 && (i10 = true);
    }
    if (!i10) return t7;
    r9 = sg.polynomial(r9);
    const o7 = sg.monomial(c9, 1), [s6, a7] = sg.euclidian(o7, r9, c9), l9 = Gp(sg.degree(s6), 0);
    let d7 = 0;
    for (let e13 = 1; e13 < 256 && d7 < l9.length; e13++) 0 === sg.evalPoly(s6, e13) && (l9[d7++] = sg.inv(e13));
    if (d7 !== l9.length) throw new Error("RS.decode: wrong errors number");
    for (let e13 = 0; e13 < l9.length; e13++) {
      const n7 = t7.length - 1 - sg.log(l9[e13]);
      if (n7 < 0) throw new Error("RS.decode: wrong error location");
      const r10 = sg.inv(l9[e13]);
      let i11 = 1;
      for (let t8 = 0; t8 < l9.length; t8++) e13 !== t8 && (i11 = sg.mul(i11, sg.add(1, sg.mul(l9[t8], r10))));
      t7[n7] = sg.add(t7[n7], sg.mul(sg.evalPoly(a7, r10), sg.inv(i11)));
    }
    return t7;
  } });
  var c9;
  return { encode(e12) {
    const t7 = [], n6 = [];
    for (let s7 = 0; s7 < i9; s7++) {
      const i10 = o6 + (s7 < r8 ? 0 : 1);
      t7.push(e12.subarray(0, i10)), n6.push(a6.encode(e12.subarray(0, i10))), e12 = e12.subarray(i10);
    }
    const s6 = Yp(...t7), c10 = Yp(...n6), l9 = new Uint8Array(s6.length + c10.length);
    return l9.set(s6), l9.set(c10, s6.length), l9;
  }, decode(e12) {
    if (e12.length !== s5) throw new Error(`interleave.decode: len(data)=${e12.length}, total=${s5}`);
    const t7 = [];
    for (let e13 = 0; e13 < i9; e13++) {
      const i10 = e13 < r8;
      t7.push(new Uint8Array(n5 + o6 + (i10 ? 0 : 1)));
    }
    let c10 = 0;
    for (let n6 = 0; n6 < o6; n6++) for (let r9 = 0; r9 < i9; r9++) t7[r9][n6] = e12[c10++];
    for (let n6 = r8; n6 < i9; n6++) t7[n6][o6] = e12[c10++];
    for (let s6 = o6; s6 < o6 + n5; s6++) for (let n6 = 0; n6 < i9; n6++) {
      const i10 = n6 < r8;
      t7[n6][s6 + (i10 ? 0 : 1)] = e12[c10++];
    }
    const l9 = [];
    for (const e13 of t7) l9.push(...Array.from(a6.decode(e13)).slice(0, -n5));
    return Uint8Array.from(l9);
  } };
}
function cg(e11, t6, n5, r8) {
  let i9 = "", o6 = n5.length;
  if ("numeric" === r8) {
    const e12 = ig.alphabet.numeric.decode(n5.split("")), t7 = e12.length;
    for (let n6 = 0; n6 < t7 - 2; n6 += 3) i9 += Wp(100 * e12[n6] + 10 * e12[n6 + 1] + e12[n6 + 2], 10);
    t7 % 3 == 1 ? i9 += Wp(e12[t7 - 1], 4) : t7 % 3 == 2 && (i9 += Wp(10 * e12[t7 - 2] + e12[t7 - 1], 7));
  } else if ("alphanumeric" === r8) {
    const e12 = ig.alphabet.alphanumerc.decode(n5.split("")), t7 = e12.length;
    for (let n6 = 0; n6 < t7 - 1; n6 += 2) i9 += Wp(45 * e12[n6] + e12[n6 + 1], 11);
    t7 % 2 == 1 && (i9 += Wp(e12[t7 - 1], 6));
  } else {
    if ("byte" !== r8) throw new Error("encode: unsupported type");
    {
      const e12 = function(e13) {
        if ("string" != typeof e13) throw new Error("utf8ToBytes expected string, got " + typeof e13);
        return new Uint8Array(new TextEncoder().encode(e13));
      }(n5);
      o6 = e12.length, i9 = Array.from(e12).map((e13) => Wp(e13, 8)).join("");
    }
  }
  const { capacity: s5 } = ig.capacity(e11, t6), a6 = Wp(o6, ig.lengthBits(e11, r8));
  let c9 = ig.modeBits[r8] + a6 + i9;
  if (c9.length > s5) throw new Error("Capacity overflow");
  c9 += "0".repeat(Math.min(4, Math.max(0, s5 - c9.length))), c9.length % 8 && (c9 += "0".repeat(8 - c9.length % 8));
  const l9 = "1110110000010001";
  for (let e12 = 0; c9.length !== s5; e12++) c9 += l9[e12 % 16];
  const d7 = Uint8Array.from(c9.match(/(.{8})/g).map((e12) => Number(`0b${e12}`)));
  return ag(e11, t6).encode(d7);
}
function lg(e11, t6, n5, r8, i9 = false) {
  const o6 = function(e12, t7, n6, r9 = false) {
    const i10 = ig.size.encode(e12);
    let o7 = new Qp(i10 + 2);
    const s6 = new Qp(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);
    o7 = o7.embed(0, s6).embed({ x: -s6.width, y: 0 }, s6).embed({ x: 0, y: -s6.height }, s6), o7 = o7.rectSlice(1, i10);
    const a7 = new Qp(1).rect(0, 1, true).border(1, false).border(1, true), c9 = ig.alignmentPatterns(e12);
    for (const e13 of c9) for (const t8 of c9) void 0 === o7.data[e13][t8] && o7.embed({ x: t8 - 2, y: e13 - 2 }, a7);
    o7 = o7.hLine({ x: 0, y: 6 }, 1 / 0, ({ x: e13 }, t8) => void 0 === t8 ? e13 % 2 == 0 : t8).vLine({ x: 6, y: 0 }, 1 / 0, ({ y: e13 }, t8) => void 0 === t8 ? e13 % 2 == 0 : t8);
    {
      const e13 = ig.formatBits(t7, n6), s7 = (t8) => !r9 && 1 == (e13 >> t8 & 1);
      for (let e14 = 0; e14 < 6; e14++) o7.data[e14][8] = s7(e14);
      for (let e14 = 6; e14 < 8; e14++) o7.data[e14 + 1][8] = s7(e14);
      for (let e14 = 8; e14 < 15; e14++) o7.data[i10 - 15 + e14][8] = s7(e14);
      for (let e14 = 0; e14 < 8; e14++) o7.data[8][i10 - e14 - 1] = s7(e14);
      for (let e14 = 8; e14 < 9; e14++) o7.data[8][15 - e14 - 1 + 1] = s7(e14);
      for (let e14 = 9; e14 < 15; e14++) o7.data[8][15 - e14 - 1] = s7(e14);
      o7.data[i10 - 8][8] = !r9;
    }
    if (e12 >= 7) {
      const t8 = ig.versionBits(e12);
      for (let e13 = 0; e13 < 18; e13 += 1) {
        const n7 = !r9 && 1 == (t8 >> e13 & 1), s7 = Math.floor(e13 / 3), a8 = e13 % 3 + i10 - 8 - 3;
        o7.data[s7][a8] = n7, o7.data[a8][s7] = n7;
      }
    }
    return o7;
  }(e11, t6, r8, i9);
  let s5 = 0;
  const a6 = 8 * n5.length;
  if (function(e12, t7, n6) {
    const r9 = e12.height, i10 = og[t7];
    let o7 = -1, s6 = r9 - 1;
    for (let t8 = r9 - 1; t8 > 0; t8 -= 2) {
      for (6 == t8 && (t8 = 5); ; s6 += o7) {
        for (let r10 = 0; r10 < 2; r10 += 1) {
          const o8 = t8 - r10;
          void 0 === e12.data[s6][o8] && n6(o8, s6, i10(o8, s6));
        }
        if (s6 + o7 < 0 || s6 + o7 >= r9) break;
      }
      o7 = -o7;
    }
  }(o6, r8, (e12, t7, r9) => {
    let i10 = false;
    s5 < a6 && (i10 = 0 != (n5[s5 >>> 3] >> (7 - s5 & 7) & 1), s5++), o6.data[t7][e12] = i10 !== r9;
  }), s5 !== a6) throw new Error("QR: bytes left after draw");
  return o6;
}
function dg(e11) {
  const t6 = e11.inverse(), n5 = (e12) => {
    let t7 = 0;
    for (let n6, r9 = 0, i10 = 1; r9 < e12.length; r9++) n6 === e12[r9] && (i10++, r9 !== e12.length - 1) || (i10 >= 5 && (t7 += i10 - 5 + 3), n6 = e12[r9], i10 = 1);
    return t7;
  };
  let r8 = 0;
  e11.data.forEach((e12) => r8 += n5(e12)), t6.data.forEach((e12) => r8 += n5(e12));
  let i9 = 0, o6 = e11.data;
  const s5 = e11.width - 1, a6 = e11.height - 1;
  for (let e12 = 0; e12 < s5; e12++) for (let t7 = 0; t7 < a6; t7++) {
    const n6 = e12 + 1, r9 = t7 + 1;
    o6[e12][t7] === o6[n6][t7] && o6[n6][t7] === o6[e12][r9] && o6[n6][t7] === o6[n6][r9] && (i9 += 3);
  }
  const c9 = (e12) => {
    const t7 = [true, false, true, true, true, false, true], n6 = [false, false, false, false], r9 = [...t7, ...n6], i10 = [...n6, ...t7];
    let o7 = 0;
    for (let t8 = 0; t8 < e12.length; t8++) Zp(e12, r9, t8) && (o7 += 40), Zp(e12, i10, t8) && (o7 += 40);
    return o7;
  };
  let l9 = 0;
  for (const t7 of e11.data) l9 += c9(t7);
  for (const e12 of t6.data) l9 += c9(e12);
  let d7 = 0;
  e11.rectRead(0, 1 / 0, (e12, t7) => d7 += t7 ? 1 : 0);
  const u10 = d7 / (e11.height * e11.width) * 100, h9 = 10 * Math.floor(Math.abs(u10 - 50) / 5);
  return r8 + i9 + l9 + h9;
}
function ug(e11, t6 = "raw", n5 = {}) {
  const r8 = void 0 !== n5.ecc ? n5.ecc : "medium";
  !function(e12) {
    if (!Xp.includes(e12)) throw new Error(`Invalid error correction mode=${e12}. Expected: ${Xp}`);
  }(r8);
  const i9 = void 0 !== n5.encoding ? n5.encoding : function(e12) {
    let t7 = "numeric";
    for (let n6 of e12) if (!ig.alphabet.numeric.has(n6) && (t7 = "alphanumeric", !ig.alphabet.alphanumerc.has(n6))) return "byte";
    return t7;
  }(e11);
  !function(e12) {
    if (!eg.includes(e12)) throw new Error(`Encoding: invalid mode=${e12}. Expected: ${eg}`);
    if ("kanji" === e12 || "eci" === e12) throw new Error(`Encoding: ${e12} is not supported (yet?).`);
  }(i9), void 0 !== n5.mask && function(e12) {
    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(e12) || !og[e12]) throw new Error(`Invalid mask=${e12}. Expected number [0..7]`);
  }(n5.mask);
  let o6, s5 = n5.version, a6 = new Error("Unknown error");
  if (void 0 !== s5) !function(e12) {
    if (!Number.isSafeInteger(e12) || e12 < 1 || e12 > 40) throw new Error(`Invalid version=${e12}. Expected number [1..40]`);
  }(s5), o6 = cg(s5, r8, e11, i9);
  else for (let t7 = 1; t7 <= 40; t7++) try {
    o6 = cg(t7, r8, e11, i9), s5 = t7;
    break;
  } catch (e12) {
    a6 = e12;
  }
  if (!s5 || !o6) throw a6;
  let c9 = function(e12, t7, n6, r9) {
    if (void 0 === r9) {
      const i10 = function() {
        let e13, t8 = 1 / 0;
        return { add(n7, r10) {
          n7 >= t8 || (e13 = r10, t8 = n7);
        }, get: () => e13, score: () => t8 };
      }();
      for (let r10 = 0; r10 < og.length; r10++) i10.add(dg(lg(e12, t7, n6, r10, true)), r10);
      r9 = i10.get();
    }
    if (void 0 === r9) throw new Error("Cannot find mask");
    return lg(e12, t7, n6, r9);
  }(s5, r8, o6, n5.mask);
  c9.assertDrawn();
  const l9 = void 0 === n5.border ? 2 : n5.border;
  if (!Number.isSafeInteger(l9)) throw new Error("Wrong border type=" + typeof l9);
  if (c9 = c9.border(l9, false), void 0 !== n5.scale && (c9 = c9.scale(n5.scale)), "raw" === t6) return c9.data;
  if ("ascii" === t6) return c9.toASCII();
  if ("svg" === t6) return c9.toSVG();
  if ("gif" === t6) return c9.toGIF();
  if ("term" === t6) return c9.toTerm();
  throw new Error(`Unknown output: ${t6}`);
}
var hg = { DESKTOP: "Desktop", MOBILE: "Mobile", META_MASK_MOBILE_APP: "MetaMask mobile app", SCAN_TO_CONNECT: "Scan to connect and sign with", CONNECT_WITH_EXTENSION: "Connect With MetaMask Extension", INSTALL_MODAL: { TRUSTED_BY_USERS: "Trusted by over 30 million users to buy, store, send and swap crypto securely", LEADING_CRYPTO_WALLET: "The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks", CONTROL_DIGITAL_INTERACTIONS: "Puts you in control of your digital interactions by making power of cryptography more accessible", INSTALL_META_MASK_EXTENSION: "Install MetaMask Extension" }, PENDING_MODAL: { OPEN_META_MASK_SELECT_CODE: "Please open the MetaMask wallet app and select the code on the screen OR disconnect", OPEN_META_MASK_CONTINUE: "Open the MetaMask app to continue with your session.", NUMBER_AFTER_OPEN_NOTICE: "If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.", DISCONNECT: "Disconnect" }, SELECT_MODAL: { CRYPTO_TAKE_CONTROL_TEXT: "Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide" }, META_MASK_MODAL: { ADDRESS_COPIED: "Address copied to clipboard!", DISCONNECT: "Disconnect", ACTIVE_NETWORK: "Active Network" } };
var fg = class {
  constructor(e11) {
    var t6;
    this.translations = hg, this.supportedLocales = ["es", "fr", "he", "it", "pt", "tr"], this.baseUrl = null !== (t6 = null == e11 ? void 0 : e11.baseUrl) && void 0 !== t6 ? t6 : "https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales";
  }
  getBrowserLanguage() {
    if ((navigator.languages || [navigator.language]).some((e12) => e12.toLowerCase().startsWith("en"))) return "en";
    const e11 = navigator.language.toLowerCase().split("-")[0];
    return this.supportedLocales.includes(e11) ? e11 : "en";
  }
  async init(e11) {
    const t6 = this.getBrowserLanguage() || e11.fallbackLng;
    await this.loadTranslations(t6);
  }
  async loadTranslations(e11) {
    const t6 = e11.split("-")[0];
    if ("en" !== t6 && this.supportedLocales.includes(t6)) try {
      const e12 = `${this.baseUrl}/${t6}.json`, n5 = await fetch(e12);
      if (!n5.ok) throw new Error(`HTTP error! status: ${n5.status}`);
      this.translations = await n5.json();
    } catch (e12) {
      console.warn(` Failed to load ${t6} translations, falling back to English:`, e12), this.translations = hg;
    }
    else this.translations = hg;
  }
  t(e11) {
    return this.getNestedTranslation(e11, this.translations) || e11;
  }
  getNestedTranslation(e11, t6) {
    const n5 = e11.split(".");
    let r8 = t6;
    for (const e12 of n5) {
      if ("object" != typeof r8) return "";
      r8 = r8[e12];
    }
    return "string" == typeof r8 ? r8 : "";
  }
};
var pg;
!function(e11) {
  e11.SDK_MODAL_VIEWED = "sdk_modal_viewed", e11.SDK_MODAL_BUTTON_CLICKED = "sdk_modal_button_clicked", e11.SDK_MODAL_TOGGLE_CHANGED = "sdk_modal_toggle_changed";
}(pg || (pg = {}));
var gg = class {
  constructor(e11) {
    mf(this, e11), this.close = Jf2(this, "close", 7), this.startDesktopOnboarding = Jf2(this, "startDesktopOnboarding", 7), this.trackAnalytics = Jf2(this, "trackAnalytics", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new fg();
  }
  componentDidLoad() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_VIEWED, params: { extensionInstalled: false, tab: 1 === this.tab ? "desktop" : "mobile" } });
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  updatePreferDesktop(e11) {
    e11 ? this.setTab(1) : this.setTab(2);
  }
  onClose(e11 = false) {
    this.close.emit({ shouldTerminate: e11 });
  }
  onStartDesktopOnboardingHandler() {
    this.trackAnalytics.emit({ event: pg.SDK_MODAL_BUTTON_CLICKED, params: { button_type: "install_extension", tab: "desktop" } }), this.startDesktopOnboarding.emit();
  }
  setTab(e11, t6 = false) {
    t6 && this.trackAnalytics.emit({ event: pg.SDK_MODAL_TOGGLE_CHANGED, params: { toggle: 1 === this.tab ? "desktop_to_mobile" : "mobile_to_desktop" } }), this.tab = e11, this.isDefaultTab = false;
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e11 = (e12) => this.i18nInstance.t(e12), t6 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n5 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf2($p, { className: "install-model" }, zf2("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf2("div", { class: "modal" }, zf2("div", { class: "closeButtonContainer" }, zf2("div", { class: "right" }, zf2("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf2(zp, null)))), zf2("div", { class: "logoContainer" }, zf2(qp, null)), zf2("div", null, zf2("div", { class: "tabcontainer" }, zf2("div", { class: "flexContainer" }, zf2("div", { onClick: () => this.setTab(1, true), class: "tab flexItem " + (1 === t6 ? "tabactive" : "") }, e11("DESKTOP")), zf2("div", { onClick: () => this.setTab(2, true), class: "tab flexItem " + (2 === t6 ? "tabactive" : "") }, e11("MOBILE")))), zf2("div", { style: { display: 1 === t6 ? "none" : "block" } }, zf2("div", { class: "flexContainer" }, zf2("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, n5 && zf2("div", { id: "sdk-mm-qrcode", class: "center", innerHTML: n5 }), zf2("div", { class: "connectMobileText" }, e11("SCAN_TO_CONNECT"), " ", zf2("br", null), zf2("span", { class: "blue" }, zf2("b", null, e11("META_MASK_MOBILE_APP"))))))), zf2("div", { style: { display: 2 === t6 ? "none" : "block" } }, zf2("div", { class: "item" }, zf2(Bp, { Icon: jp, text: e11("INSTALL_MODAL.TRUSTED_BY_USERS") })), zf2("div", { class: "item" }, zf2(Bp, { Icon: Kp, text: e11("INSTALL_MODAL.LEADING_CRYPTO_WALLET") })), zf2("div", { class: "item" }, zf2(Bp, { Icon: Up, text: e11("INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS") })), zf2("button", { class: "button", onClick: () => this.onStartDesktopOnboardingHandler() }, zf2(Hp, null), zf2("span", { class: "installExtensionText" }, e11("INSTALL_MODAL.INSTALL_META_MASK_EXTENSION"))))), zf2(Fp3, { version: this.sdkVersion })));
  }
  get el() {
    return Zf2(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
gg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var mg = class {
  constructor(e11) {
    mf(this, e11), this.close = Jf2(this, "close", 7), this.disconnect = Jf2(this, "disconnect", 7), this.updateOTPValue = Jf2(this, "updateOTPValue", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = false, this.i18nInstance = new fg();
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose() {
    this.close.emit();
  }
  onDisconnect() {
    this.disconnect.emit();
  }
  onUpdateOTPValueHandler(e11) {
    this.updateOTPValue.emit({ otpValue: e11 });
  }
  disconnectedCallback() {
    this.onClose();
  }
  render() {
    var e11;
    if (!this.translationsLoaded) return null;
    const t6 = null === (e11 = this.displayOTP) || void 0 === e11 || e11, n5 = this.sdkVersion, r8 = (e12) => this.i18nInstance.t(e12);
    return zf2($p, { className: "pending-modal" }, zf2("div", { class: "backdrop", onClick: () => this.onClose() }), zf2("div", { class: "modal" }, zf2("div", { class: "closeButtonContainer" }, zf2("div", { class: "right" }, zf2("span", { class: "closeButton", onClick: () => this.onClose() }, zf2(zp, null)))), zf2("div", { class: "logoContainer" }, zf2(qp, null)), zf2("div", null, zf2("div", { class: "flexContainer", style: { flexDirection: "column", color: "black" } }, zf2("div", { class: "flexItem", style: { textAlign: "center", marginTop: "30px", marginBottom: "30px", fontSize: "16px" } }, r8(t6 ? "PENDING_MODAL.OPEN_META_MASK_SELECT_CODE" : "PENDING_MODAL.OPEN_META_MASK_CONTINUE")), zf2("div", { id: "sdk-mm-otp-value", style: { padding: "10px", fontSize: "32px", display: this.otpCode ? "block" : "none" } }, this.otpCode), t6 && zf2("div", { class: "notice" }, "* ", r8("PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE"))), zf2("div", { style: { marginTop: "20px" } }, zf2("button", { class: "button blue", style: { marginTop: "5px", color: "#0376C9", borderColor: "#0376C9", borderWidth: "1px", borderStyle: "solid", backgroundColor: "white" }, onClick: () => this.onDisconnect() }, r8("PENDING_MODAL.DISCONNECT")))), zf2(Fp3, { version: n5 })));
  }
  get el() {
    return Zf2(this);
  }
};
mg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var yg = () => zf2("svg", { width: "21", height: "15", viewBox: "0 0 21 15", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("path", { d: "M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z", fill: "white" }));
var vg = () => zf2("svg", { width: "400", height: "300", viewBox: "0 0 400 300", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, zf2("rect", { width: "400", height: "300", fill: "white" }), zf2("path", { d: "M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z", fill: "#FF5C16" }), zf2("path", { d: "M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z", fill: "#FF5C16" }), zf2("path", { d: "M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z", fill: "#FF5C16" }), zf2("path", { d: "M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z", fill: "#FF5C16" }), zf2("path", { d: "M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z", fill: "#FF5C16" }), zf2("path", { d: "M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z", fill: "#FF5C16" }), zf2("path", { d: "M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z", fill: "#FF5C16" }), zf2("path", { d: "M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z", fill: "#E34807" }), zf2("path", { d: "M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z", fill: "#E34807" }), zf2("path", { d: "M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z", fill: "#E34807" }), zf2("path", { d: "M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z", fill: "#E34807" }), zf2("path", { d: "M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z", fill: "#FF8D5D" }), zf2("path", { d: "M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z", fill: "#FF8D5D" }), zf2("path", { d: "M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z", fill: "#FF8D5D" }), zf2("path", { d: "M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z", fill: "#661800" }), zf2("path", { d: "M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z", fill: "#661800" }), zf2("path", { d: "M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z", fill: "#661800" }), zf2("path", { d: "M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z", fill: "#661800" }), zf2("path", { d: "M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789", fill: "#661800" }), zf2("path", { d: "M213.047 229.789V250.066H186.944V229.789H213.047Z", fill: "#C0C4CD" }), zf2("path", { d: "M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z", fill: "#E7EBF6" }), zf2("path", { d: "M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z", fill: "#E7EBF6" }));
var bg = class {
  constructor(e11) {
    mf(this, e11), this.close = Jf2(this, "close", 7), this.connectWithExtension = Jf2(this, "connectWithExtension", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = true, this.translationsLoaded = false, this.i18nInstance = new fg(), this.setTab(this.preferDesktop ? 1 : 2);
  }
  async connectedCallback() {
    await this.i18nInstance.init({ fallbackLng: "en" }), this.translationsLoaded = true;
  }
  onClose(e11 = false) {
    this.close.emit({ shouldTerminate: e11 });
  }
  connectWithExtensionHandler() {
    this.connectWithExtension.emit();
  }
  setTab(e11) {
    this.tab = e11, this.isDefaultTab = false;
  }
  disconnectedCallback() {
    this.onClose();
  }
  updatePreferDesktop(e11) {
    e11 ? this.setTab(1) : this.setTab(2);
  }
  render() {
    if (!this.translationsLoaded) return null;
    const e11 = (e12) => this.i18nInstance.t(e12), t6 = this.sdkVersion, n5 = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r8 = ug(this.link, "svg", { ecc: "medium", scale: 2 });
    return zf2($p, { className: "select-modal" }, zf2("div", { class: "backdrop", onClick: () => this.onClose(true) }), zf2("div", { class: "modal" }, zf2("div", { class: "closeButtonContainer" }, zf2("div", { class: "right" }, zf2("span", { class: "closeButton", onClick: () => this.onClose(true) }, zf2(zp, null)))), zf2("div", { class: "logoContainer" }, zf2(qp, null)), zf2("div", null, zf2("div", { class: "tabcontainer" }, zf2("div", { class: "flexContainer" }, zf2("div", { onClick: () => this.setTab(1), class: "tab flexItem " + (1 === n5 ? "tabactive" : "") }, e11("DESKTOP")), zf2("div", { onClick: () => this.setTab(2), class: "tab flexItem " + (2 === n5 ? "tabactive" : "") }, e11("MOBILE")))), zf2("div", { style: { display: 1 === n5 ? "none" : "block" } }, zf2("div", { class: "flexContainer" }, zf2("div", { class: "flexItem", style: { textAlign: "center", marginTop: "4" } }, zf2("div", { class: "center", id: "sdk-mm-qrcode", innerHTML: r8 }), zf2("div", { class: "connectMobileText" }, e11("SCAN_TO_CONNECT"), zf2("br", null), zf2("span", { class: "blue" }, zf2("b", null, e11("META_MASK_MOBILE_APP"))))))), zf2("div", { style: { display: 2 === n5 ? "none" : "block" } }, zf2("div", { style: { display: "flex", justifyContent: "center", height: "300", marginTop: "-20" } }, zf2(vg, null)), zf2("div", { class: "extensionLabel" }, e11("SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT")), zf2("button", { class: "button", onClick: () => this.connectWithExtensionHandler() }, zf2(yg, null), zf2("span", { class: "installExtensionText" }, e11("CONNECT_WITH_EXTENSION"))))), zf2(Fp3, { version: t6 })));
  }
  get el() {
    return Zf2(this);
  }
  static get watchers() {
    return { preferDesktop: ["updatePreferDesktop"] };
  }
};
bg.style = ".flexContainer {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: row;\n}\n\n.flexItem {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem11 {\n    flex: 11;\n    justify-content: center;\n    align-items: center;\n}\n\n.flexItem1 {\n    flex: 1;\n    justify-content: center;\n    align-items: center;\n}\n\n.tab {\n    padding: 8px;\n    cursor: pointer;\n    background-color: #F2F4F6;\n    font-size: 12px;\n    text-align: center;\n    color: #24292E;\n}\n\n.tabcontainer {\n    padding: 4px;\n    background-color: #F2F4F6;\n    border-radius: 8px;\n    margin-bottom: 30px;\n    margin-top: 30px;\n}\n\n.tabactive {\n    background-color: white;\n    -webkit-transition: background-color 300ms linear;\n    -ms-transition: background-color 300ms linear;\n    transition: background-color 300ms linear;\n    border-radius: 8px;\n}\n\n.item {\n    font-size: 12px;\n    margin-bottom: 16px;\n    border-radius: 8px;\n    padding: 10px;\n    border: 2px #F2F4F6 solid;\n    color: #24292E;\n}\n\n.extensionLabel {\n    font-style: normal;\n    font-weight: bold;\n    font-size: 14px;\n    text-align: cetner;\n    color: #24272A;\n}\n\n.notice {\n    font-size: 12px;\n    margin-left: 10px;\n    margin-right: 10px;\n    color: grey;\n}\n\n.button {\n    margin-top: 41.5px;\n    margin-bottom: 20px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-items: center;\n    padding: 12px 20px;\n    background: #037DD6;\n    border-radius: 32px;\n    color: white;\n    border: 0;\n    font-size: 14px;\n    cursor: pointer;\n}\n\n.backdrop {\n    visibility: visible;\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    z-index: 99998;\n    background: rgba(0, 0, 0, 0.87);\n    opacity: 0.3;\n}\n\n.modal {\n    visibility: visible;\n    position: fixed;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 99999;\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    top: 50%;\n    max-width: 100%;\n    width: 460px;\n    min-width: 300px;\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\n    -webkit-font-smoothing: antialiased;\n}\n\n.closeButton {\n    color: #BBC0C5;\n    cursor: pointer;\n}\n\n.logoContainer {\n    margin-left: 24px;\n    margin-right: 24px;\n    margin-top: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.connectMobileText {\n    font-size: 14px;\n    color: black;\n    margin-top: 28px;\n    margin-bottom: 28px;\n    line-height: 2;\n}\n\n.blue {\n    color: #037DD6;\n    font-weight: 700;\n}\n\n.installExtensionText {\n    margin-left: 10px;\n}\n\n.center {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n.right {\n    display: flex;\n    align-items: center;\n    justify-content: right;\n}\n\n#sdk-mm-qrcode {\n    svg {\n        width: 50%;\n    }\n}";
var wg = Object.freeze({ __proto__: null, mm_install_modal: gg, mm_pending_modal: mg, mm_select_modal: bg });

// node_modules/@dynamic-labs/ethereum/src/metaMask/utils/isPendingWalletRequestPermissionError.js
var isPendingWalletRequestPermissionError = (error) => typeof error === "object" && error !== null && "message" in error && error.message.includes("Request of type 'wallet_requestPermissions' already pending for origin");

// node_modules/@dynamic-labs/ethereum/src/metaMask/utils/waitForConnection.js
var waitForConnection = (provider) => new Promise((resolve) => {
  provider.once("connect", () => resolve());
});

// node_modules/@dynamic-labs/ethereum/src/metaMask/MetaMaskConnector.js
var _metaMaskSDK = null;
var _metaMaskDisplayUri = null;
var _metaMaskConnectUri = null;
var eventTimeline = createEventTimeline();
var setMetaMaskDisplayUri = (displayUri) => {
  _metaMaskDisplayUri = displayUri;
};
var MetaMaskConnector = class extends InjectedWalletBase {
  constructor(props) {
    super(props);
    this.name = "MetaMask";
    this.overrideKey = "metamask";
    this.canConnectViaQrCode = true;
    this.isInAppBrowser = false;
    this.appName = props.appName;
    this.appLogoUrl = props.appLogoUrl;
    this.isInAppBrowser = this.getIsInAppBrowser();
    this.canHandleMultipleConnections = this.isInstalledOnBrowser();
    logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] constructor", {
      hasMetaMaskSDK: Boolean(_metaMaskSDK)
    });
    if (!_metaMaskSDK) {
      this.createMetaMaskSDK();
    }
  }
  isInstalledOnBrowser() {
    var _a14;
    const metaMaskEip6963Provider = (_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.eip6963ProviderLookup(this.rdns);
    const isInstalled = Boolean(metaMaskEip6963Provider);
    return isInstalled;
  }
  getSupportedNetworks() {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.evmNetworks.map((network) => network.chainId.toString());
    });
  }
  get metaMaskSDK() {
    if (!_metaMaskSDK)
      throw new Error("MetaMaskSDK not initialized");
    return _metaMaskSDK;
  }
  set metaMaskSDK(metaMaskSDK) {
    _metaMaskSDK = metaMaskSDK;
  }
  createMetaMaskSDK() {
    const dappMetadata = {
      iconUrl: this.appLogoUrl,
      name: this.appName,
      url: PlatformService.getOrigin()
    };
    logger3.debug("[MetaMaskConnector] createMetaMaskSDK - creating sdk", {
      dappMetadata
    });
    _metaMaskSDK = new af2({
      checkInstallationImmediately: true,
      dappMetadata,
      enableAnalytics: false,
      extensionOnly: this.isInstalledOnBrowser(),
      headless: true,
      injectProvider: false,
      openDeeplink: (url2) => {
        if (url2.includes("://connect")) {
          _metaMaskConnectUri = url2;
        } else {
          _metaMaskConnectUri = null;
        }
        PlatformService.openURL(url2);
      },
      preferDesktop: !isMobile(),
      readonlyRPCMap: getReadonlyRPCMap(this.evmNetworkRpcMap()),
      useDeeplink: true
    });
    logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] createMetaMaskSDK - created sdk", { _metaMaskSDK });
  }
  endSession() {
    return __awaiter2(this, void 0, void 0, function* () {
      eventTimeline.postEvent("disconnect");
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] endSession - terminating sdk");
      if (isMobile()) {
        return this.metaMaskSDK.terminate().then(() => {
          _metaMaskSDK = null;
          _metaMaskConnectUri = null;
          return this.createMetaMaskSDK();
        });
      }
      return this.metaMaskSDK.terminate();
    });
  }
  getAddress(opts2) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - waiting for sdk init");
      yield this.metaMaskSDK.sdkInitPromise;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - sdk init promise resolved");
      const handleDisplayUri = (displayUri) => {
        var _a14;
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] handleDisplayUri", { displayUri });
        if (!displayUri)
          return;
        setMetaMaskDisplayUri(displayUri);
        (_a14 = opts2 === null || opts2 === void 0 ? void 0 : opts2.onDisplayUri) === null || _a14 === void 0 ? void 0 : _a14.call(opts2, displayUri);
      };
      if (!isMobile() && Boolean(opts2 === null || opts2 === void 0 ? void 0 : opts2.onDisplayUri)) {
        this.metaMaskSDK.on("display_uri", handleDisplayUri);
      }
      try {
        if (this.shouldDeepLinkToMetaMaskInAppBrowser() && this.metadata.inAppBrowserUrl) {
          const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
          const { href } = PlatformService.getUrl();
          const deepLink = inAppBrowserCompiledTemplate({
            dappURI: href
          });
          PlatformService.openURL(deepLink);
          return;
        }
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - getting initial connected accounts");
        const initialConnectedAccounts = yield this.getConnectedAccountsSafely();
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - got initial connected accounts", { initialConnectedAccounts });
        if (initialConnectedAccounts.length) {
          return this.parseAddress(initialConnectedAccounts[0]);
        }
        try {
          logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - connecting to metaMask");
          yield this.metaMaskSDK.connect();
          logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - connected to metaMask");
        } catch (error) {
          logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - error connecting to metaMask", { error });
          if (eventTimeline.isEventRecent("disconnect", 1e3)) {
            throw new GetAddressCancelledError();
          }
          const isRequestPendingError = isPendingWalletRequestPermissionError(error);
          if (!isRequestPendingError) {
            throw MetaMaskError.fromError(error);
          } else {
            logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - error connection - waiting for connection");
            yield waitForConnection(this.getProvider());
          }
        }
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - getting connected accounts");
        const accounts = yield this.getConnectedAccounts();
        logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getAddress - got connected accounts", { accounts });
        return accounts[0];
      } finally {
        this.metaMaskSDK.off("display_uri", handleDisplayUri);
      }
    });
  }
  getConnectedAccountsSafely() {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        const connectedAccounts = yield this.getConnectedAccounts();
        return connectedAccounts;
      } catch (err) {
        logger3.error(err);
        return [];
      }
    });
  }
  getConnectedAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.metaMaskSDK.sdkInitPromise;
      const provider = this.getProvider();
      if (!provider) {
        return [];
      }
      const accounts = yield retryableFn(() => provider.request({
        method: "eth_accounts",
        params: []
      }), {
        fallbackValue: [],
        timeoutMs: 1e3
      });
      if (!(accounts === null || accounts === void 0 ? void 0 : accounts.length)) {
        return [];
      }
      return accounts.map(this.parseAddress);
    });
  }
  signMessage(messageToSign) {
    return __awaiter2(this, void 0, void 0, function* () {
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - waiting for sdk init");
      yield this.metaMaskSDK.sdkInitPromise;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - sdk init promise resolved");
      const windowFocusPromiseForMobile = !this.isInAppBrowser && isMobile() ? waitForFocusWindowEvent() : Promise.resolve();
      const provider = this.getProvider();
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - got provider", { provider });
      if (!provider) {
        return void 0;
      }
      const [selectedAddress] = yield this.getConnectedAccounts();
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - got selected address", { selectedAddress });
      if (!selectedAddress) {
        return void 0;
      }
      const walletClient = this.getWalletClientForAddress(selectedAddress);
      if (!walletClient)
        return void 0;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - will sign", { messageToSign });
      const signature = yield walletClient.signMessage({
        message: messageToSign
      });
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - will wait for window focus");
      yield windowFocusPromiseForMobile;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] signMessage - signed", { signature });
      return signature;
    });
  }
  chooseAccountsToConnect() {
    return __awaiter2(this, void 0, void 0, function* () {
      return [];
    });
  }
  getWalletClient(chainId) {
    const provider = this.getProvider();
    logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getWalletClient - got provider", { provider });
    if (!provider) {
      return void 0;
    }
    const selectedAddress = provider.getSelectedAddress();
    return this.getWalletClientForAddress(selectedAddress || void 0, chainId);
  }
  get rdns() {
    const { rdns } = this.metadata;
    if (!rdns) {
      throw new Error("rdns not found in metadata");
    }
    return rdns;
  }
  setupEventListeners() {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.metaMaskSDK.sdkInitPromise;
      const metaMaskProvider = this.getProvider();
      if (!metaMaskProvider) {
        return;
      }
      const { handleAccountChange, handleChainChange, handleDisconnect } = eventListenerHandlers(this);
      const handleAccountsChangedFromMetaMask = (accounts) => {
        if (eventTimeline.isEventRecent("disconnect", 1e3)) {
          return;
        }
        handleAccountChange(accounts);
      };
      metaMaskProvider.on("accountsChanged", handleAccountsChangedFromMetaMask);
      metaMaskProvider.on("chainChanged", handleChainChange);
      metaMaskProvider.on("disconnect", handleDisconnect);
      this.teardownEventListeners = () => {
        metaMaskProvider.off("accountsChanged", handleAccountsChangedFromMetaMask);
        metaMaskProvider.off("chainChanged", handleChainChange);
        metaMaskProvider.off("disconnect", handleDisconnect);
      };
    });
  }
  /**
   * This override is necessary to wait for the MetaMask SDK to initialize
   * before calling the super method. Otherwise, the super method may fail
   * to fetch the provider
   */
  getNetwork() {
    const _super = Object.create(null, {
      getNetwork: { get: () => super.getNetwork }
    });
    return __awaiter2(this, void 0, void 0, function* () {
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getNetwork - waiting for sdk init");
      yield this.metaMaskSDK.sdkInitPromise;
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getNetwork - sdk init promise resolved");
      const net = yield _super.getNetwork.call(this);
      logger3.logVerboseTroubleshootingMessage("[MetaMaskConnector] getNetwork - got network", { network: net });
      return net;
    });
  }
  // Utils
  getProvider() {
    var _a14;
    return (_a14 = this.metaMaskSDK.getProvider()) !== null && _a14 !== void 0 ? _a14 : this.metaMaskSDK.getMobileProvider();
  }
  evmNetworkByChainId(chainId) {
    return this.evmNetworks.find((network) => network.chainId === chainId);
  }
  getWalletClientForAddress(address, chainId) {
    var _a14, _b;
    const provider = this.getProvider();
    if (!provider) {
      return void 0;
    }
    const effectiveChainId = (_b = (_a14 = this.toInt(chainId)) !== null && _a14 !== void 0 ? _a14 : this.getCurrentChainId()) !== null && _b !== void 0 ? _b : "1";
    const network = this.evmNetworkByChainId(effectiveChainId);
    return createWalletClient({
      account: address,
      chain: network ? getOrMapViemChain(network) : this.getActiveChain(),
      transport: custom(provider, this.providersConfig.httpTransportConfig)
    });
  }
  toInt(chainId) {
    if (!chainId)
      return void 0;
    try {
      return parseInt(chainId);
    } catch (err) {
      logger3.debug(err);
      return void 0;
    }
  }
  getCurrentChainId() {
    const provider = this.getProvider();
    if (!provider) {
      return void 0;
    }
    const chainId = provider.getChainId();
    if (isHex(chainId)) {
      return parseInt(chainId);
    }
    return chainId;
  }
  /**
   * Checks if the current environment is the MetaMask in-app browser
   * by checking if the MetaMask provider is installed in the window object
   * on a mobile device
   */
  getIsInAppBrowser() {
    var _a14, _b;
    if (!isMobile())
      return false;
    const provider = ((_a14 = this.ethProviderHelper) === null || _a14 === void 0 ? void 0 : _a14.eip6963ProviderLookup(this.rdns)) || ((_b = this.ethProviderHelper) === null || _b === void 0 ? void 0 : _b.getInjectedProvider());
    return Boolean(provider);
  }
  shouldDeepLinkToMetaMaskInAppBrowser() {
    if (this.isInAppBrowser) {
      return false;
    }
    if (!isMobile()) {
      return false;
    }
    if (this.mobileExperience !== "in-app-browser") {
      return false;
    }
    if (!this.metadata.inAppBrowserUrl) {
      return false;
    }
    if (navigator.userAgent.match(/metamaskmobile/i)) {
      return false;
    }
    return true;
  }
  getConnectionUri() {
    return _metaMaskDisplayUri !== null && _metaMaskDisplayUri !== void 0 ? _metaMaskDisplayUri : void 0;
  }
  retryDeeplinkConnection() {
    if (_metaMaskConnectUri) {
      PlatformService.openURL(_metaMaskConnectUri);
    }
  }
};
var getReadonlyRPCMap = (evmNetworkRpcMap) => Object.keys(evmNetworkRpcMap).reduce((acc, chainId) => Object.assign(Object.assign({}, acc), { [toHex(parseInt(chainId))]: evmNetworkRpcMap[chainId] }), {});
var waitForFocusWindowEvent = () => new Promise((resolve) => {
  PlatformEventsService.once("appFocused", resolve);
}).then(() => new Promise((resolve) => setTimeout(resolve, 1e3)));

// node_modules/@dynamic-labs/ethereum/src/EthereumWalletConnectors.js
var EthereumWalletConnectors = (props) => {
  const { useMetamaskSdk } = props;
  const walletsWithCustomConnectors = [
    "phantomevm",
    "coinbase",
    "exodusevm",
    "abstract",
    "edenonline",
    "intersend"
  ];
  if (useMetamaskSdk) {
    walletsWithCustomConnectors.push("metamask");
  }
  return [
    ...injectedWalletOverrides,
    ...fetchInjectedWalletConnector(Object.assign(Object.assign({}, props), { walletsWithCustomConnectors })),
    ...fetchWalletConnectWallets(props),
    ...TurnkeyEVMWalletConnectors(props),
    ...DynamicWaasEVMConnectors(),
    ...useMetamaskSdk ? [MetaMaskConnector] : [],
    Coinbase,
    ...createBaseAccountConnector(props.baseAccountSdkOpts)(props),
    FallbackEvmConnector,
    getWalletConnectConnector()
  ];
};

// node_modules/@dynamic-labs/ethereum/src/EthereumWalletConnectorsWithConfig.js
var EthereumWalletConnectorsWithConfig = (providersConfig) => {
  const classWithConfig = (className) => class extends className {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(...args) {
      const [opts2] = args;
      const updatedProviderConfig = {
        httpTransportConfig: Object.assign(Object.assign({}, providersConfig.httpTransportConfig), providersConfig.publicClientHttpTransportConfig)
      };
      super(Object.assign(Object.assign({}, opts2), { providersConfig: updatedProviderConfig }));
    }
  };
  return (props) => EthereumWalletConnectors(Object.assign(Object.assign({}, props), { baseAccountSdkOpts: providersConfig.baseAccountSdkOpts })).map(classWithConfig);
};

// node_modules/@dynamic-labs/ethereum/src/index.js
assertPackageVersion("@dynamic-labs/ethereum", version);
export {
  EthProviderHelper,
  InjectedWalletBase as EthereumInjectedConnector,
  EthereumWalletConnector,
  EthereumWalletConnectors,
  EthereumWalletConnectorsWithConfig,
  ExodusEvm,
  FallbackEvmConnector,
  INFURA_ID,
  PhantomEvm,
  createConnector,
  createInjectedConnector,
  fetchInjectedWalletConnector,
  getConnectorConstructorForEip6963Wallet,
  injectedWalletOverrides,
  isEthereumWallet
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

eventemitter2/lib/eventemitter2.js:
  (*!
   * EventEmitter2
   * https://github.com/hij1nx/EventEmitter2
   *
   * Copyright (c) 2013 hij1nx
   * Licensed under the MIT license.
   *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@walletconnect/utils/dist/index.es.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/curves/esm/nist.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/bls.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/tower.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/post-quantum/utils.js:
  (*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) *)

@noble/post-quantum/_crystals.js:
  (*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) *)

@noble/post-quantum/ml-kem.js:
  (*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@vue/shared/dist/shared.esm-bundler.js:
  (**
  * @vue/shared v3.5.22
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)

@vue/reactivity/dist/reactivity.esm-bundler.js:
  (**
  * @vue/reactivity v3.5.22
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
*/
//# sourceMappingURL=@dynamic-labs_ethereum.js.map
