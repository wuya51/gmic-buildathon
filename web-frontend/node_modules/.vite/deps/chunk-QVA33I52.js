import {
  eventemitter3_default
} from "./chunk-2UFRZFM3.js";
import {
  require_react
} from "./chunk-I6OM4FBL.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-CVK6YDBK.js";

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string4, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string4, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string4, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array2[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string4, encoding) {
      if (Buffer3.isBuffer(string4)) {
        return string4.length;
      }
      if (ArrayBuffer.isView(string4) || isInstance(string4, ArrayBuffer)) {
        return string4.byteLength;
      }
      if (typeof string4 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string4
        );
      }
      const len = string4.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string4).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string4).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string4).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string4, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string4.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string4.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string4, offset, length) {
      return blitBuffer(utf8ToBytes(string4, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string4, offset, length) {
      return blitBuffer(asciiToBytes(string4), buf, offset, length);
    }
    function base64Write(buf, string4, offset, length) {
      return blitBuffer(base64ToBytes(string4), buf, offset, length);
    }
    function ucs2Write(buf, string4, offset, length) {
      return blitBuffer(utf16leToBytes(string4, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string4, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string4.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string4, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string4, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string4, offset, length);
          case "base64":
            return base64Write(this, string4, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string4, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last2 = this[offset + 7];
      if (first === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string4, units) {
      units = units || Infinity;
      let codePoint;
      const length = string4.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string4.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@dynamic-labs/logger/_virtual/_tslib.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/logger/src/utils/deepMerge.js
var deepMerge = (obj1, obj2) => {
  if (typeof obj1 !== "object" || typeof obj2 !== "object") {
    return obj2;
  }
  const result = Object.assign({}, obj1);
  for (const key in obj2) {
    if (Object.prototype.hasOwnProperty.call(obj2, key)) {
      if (typeof obj2[key] === "object" && Object.prototype.hasOwnProperty.call(obj1, key) && typeof obj1[key] === "object") {
        result[key] = deepMerge(obj1[key], obj2[key]);
      } else {
        result[key] = obj2[key];
      }
    }
  }
  return result;
};

// node_modules/@dynamic-labs/logger/src/MetaData/MetaData.js
var MetaData = class _MetaData {
  constructor(meta = {}) {
    this.meta = {};
    this.meta = meta;
  }
  /**
   * Sets a value in the metadata using dot notation for nested keys.
   * @param {string} key - The key in dot notation (e.g., "a.b.c").
   * @param {unknown} value - The value to set.
   */
  set(key, value) {
    const data = {};
    key.split(".").reduce((acc, k, i, arr) => {
      if (i === arr.length - 1) {
        acc[k] = value;
      } else {
        if (!acc[k]) {
          acc[k] = {};
        }
        return acc[k];
      }
    }, data);
    this.meta = deepMerge(this.meta, data);
  }
  /**
   * Retrieves the current metadata.
   * @returns {TMetaData} The metadata.
   */
  get() {
    return this.meta;
  }
  /**
   * Clears the metadata.
   */
  clear() {
    this.meta = {};
  }
  /**
   * Merges another MetaData instance into another MetaData instance.
   * @param {MetaData} meta - The MetaData instance to merge.
   * @returns {MetaData} A new MetaData instance with merged metadata.
   */
  merge(meta) {
    return new _MetaData(deepMerge(this.get(), meta.get()));
  }
};

// node_modules/@dynamic-labs/logger/src/types.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  LogLevel2[LogLevel2["MUTE"] = 99] = "MUTE";
})(LogLevel || (LogLevel = {}));

// node_modules/@dynamic-labs/logger/src/utils/createCircularReferenceReplacer.js
var createCircularReferenceReplacer = () => {
  const seen = /* @__PURE__ */ new WeakSet();
  return (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (seen.has(value))
        return;
      seen.add(value);
    }
    return value;
  };
};

// node_modules/@dynamic-labs/logger/src/utils/mapLogLevel.js
var mapLogLevel = (level) => {
  if (level in LogLevel && typeof level === "string") {
    return LogLevel[level];
  } else if (level in LogLevel && typeof level === "number") {
    return level;
  } else {
    throw new Error(`Invalid log level: ${level}`);
  }
};

// node_modules/@dynamic-labs/logger/src/utils/processArgs.js
var processArgs = (message) => {
  const objectArgs = message.args.filter((arg) => typeof arg === "object");
  const remainingArgs = message.args.filter((arg) => typeof arg !== "object" || arg instanceof Error).map((arg) => {
    var _a5;
    return (_a5 = arg === null || arg === void 0 ? void 0 : arg.toString) === null || _a5 === void 0 ? void 0 : _a5.call(arg);
  });
  return { objectArgs, remainingArgs };
};

// node_modules/@dynamic-labs/logger/src/index.js
var IGNORE_MESSAGES = ["Failed to send logs to server"];
var messageQueue = [];
var Logger = class _Logger {
  constructor(name, level) {
    this.name = name;
    this._level = void 0;
    this.metaData = new MetaData();
    this._level = level;
    if (typeof window !== "undefined" && window.localStorage !== void 0) {
      _Logger.troubleshootModeEnabled = _Logger.troubleshootModeEnabled || window.localStorage.getItem("dynamic_enableTroubleshootMode") === "true";
      window.enableTroubleshootMode = () => {
        window.localStorage.setItem("dynamic_enableTroubleshootMode", "true");
        _Logger.troubleshootModeEnabled = true;
      };
      window.disableTroubleshootMode = () => {
        window.localStorage.removeItem("dynamic_enableTroubleshootMode");
        _Logger.troubleshootModeEnabled = false;
      };
    }
  }
  static setEmitErrors(emit) {
    if (emit !== void 0) {
      _Logger.globalKeys.emitErrors = emit;
    }
  }
  static setEnvironmentId(environmentId) {
    if (environmentId !== void 0) {
      _Logger.globalKeys.environmentId = environmentId;
    }
  }
  getNameArray(name) {
    return Array.isArray(name) ? name : [name];
  }
  createLogger(name, level) {
    return new _Logger([...this.getNameArray(this.name), ...this.getNameArray(name)], level !== null && level !== void 0 ? level : this.level);
  }
  get logLevel() {
    return LogLevel[this.level];
  }
  setLogLevel(level) {
    this._level = mapLogLevel(level);
  }
  static setLogLevel(level) {
    _Logger.globalLogLevel = mapLogLevel(level);
  }
  static resetLogLevel() {
    _Logger.globalLogLevel = void 0;
  }
  get level() {
    var _a5;
    if (_Logger.globalLogLevel && !this._level) {
      return _Logger.globalLogLevel;
    }
    if (this._level === void 0 && typeof process !== "undefined" && ((_a5 = process.env) === null || _a5 === void 0 ? void 0 : _a5["NODE_ENV"]) !== "production") {
      return LogLevel.DEBUG;
    }
    if (this._level === void 0) {
      return LogLevel.WARN;
    }
    return this._level;
  }
  formatMessage(level, message) {
    var _a5;
    if (message instanceof Error) {
      message = message.stack;
    } else if (
      // Handle Error-Like Objects
      message instanceof Object && Object.prototype.hasOwnProperty.call(message, "stack")
    ) {
      message = message.stack;
    } else if (message instanceof Object) {
      message = JSON.stringify(message, createCircularReferenceReplacer());
    }
    const names = (Array.isArray(this.name) ? this.name : [this.name]).map((name) => `[${name}]`);
    return `${names.join("")} [${(_a5 = LogLevel[level]) !== null && _a5 !== void 0 ? _a5 : "TROUBLESHOOTING"}]: ${message}`;
  }
  captureAndSend(level, message, ...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (_Logger.globalKeys.emitErrors && !IGNORE_MESSAGES.includes(message === null || message === void 0 ? void 0 : message.toString()) && typeof window !== "undefined") {
        this.emitHttpLogs(level, message, { args });
      }
    });
  }
  emitHttpLogs(level, message, { args = [], transformMeta = (meta) => meta }) {
    messageQueue.push({ args, level, message, stack: new Error().stack });
    if (messageQueue.length === 1) {
      queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {
        var _a5, _b;
        const messages = [];
        messageQueue.forEach((msg) => {
          var _a6, _b2, _c, _d, _e, _f;
          const body = {};
          const { objectArgs, remainingArgs } = processArgs(msg);
          Object.assign(body, ...objectArgs);
          Object.assign(body, {
            level: LogLevel[msg.level],
            message: [msg.message, ...remainingArgs].join(" "),
            meta: transformMeta(_Logger.globalMetaData.merge(this.metaData).get()),
            stack: msg.stack,
            url: {
              hostname: (_a6 = window.location) === null || _a6 === void 0 ? void 0 : _a6.hostname,
              origin: (_b2 = window.location) === null || _b2 === void 0 ? void 0 : _b2.origin,
              pathname: (_c = window.location) === null || _c === void 0 ? void 0 : _c.pathname,
              port: (_d = window.location) === null || _d === void 0 ? void 0 : _d.port,
              protocol: (_e = window.location) === null || _e === void 0 ? void 0 : _e.protocol
            },
            userAgent: (_f = window.navigator) === null || _f === void 0 ? void 0 : _f.userAgent
          });
          messages.push(body);
        });
        try {
          if (!((_a5 = _Logger.globalKeys) === null || _a5 === void 0 ? void 0 : _a5.environmentId)) {
            throw new Error("Environment ID not set");
          }
          yield fetch(`https://logs.dynamicauth.com/api/v1/${(_b = _Logger.globalKeys) === null || _b === void 0 ? void 0 : _b.environmentId}`, {
            body: JSON.stringify(messages),
            headers: {
              "Content-Type": "application/json"
            },
            method: "POST",
            mode: "cors",
            referrerPolicy: "origin-when-cross-origin"
          });
        } catch (error40) {
          this.debug("Failed to send logs to server", error40);
        }
        messageQueue.length = 0;
      }));
    }
  }
  /**
   * Emits an INFO type message to the backend for analysis and debugging
   */
  instrument(message, options) {
    return this.emitHttpLogs(LogLevel.INFO, message, {
      args: [options],
      // Don't send any meta to avoid storing PII
      transformMeta: () => void 0
    });
  }
  log(level, message, ...args) {
    const enableTroubleshootMode = typeof window !== "undefined" && _Logger.troubleshootModeEnabled;
    if (!enableTroubleshootMode && (level < this.level || level === LogLevel.MUTE)) {
      return;
    }
    _Logger.events.emit("log", level, message, ...args);
    const fmtMsg = this.formatMessage(level, message);
    switch (level) {
      case LogLevel.WARN:
        console.warn(fmtMsg, ...args);
        break;
      case LogLevel.ERROR:
        console.error(fmtMsg, ...args);
        break;
      default:
        console.log(fmtMsg, ...args);
    }
    if (level === LogLevel.ERROR) {
      this.captureAndSend(level, message, ...args);
    }
  }
  logVerboseTroubleshootingMessage(message, ...args) {
    this.log(-1, message, ...args);
  }
  debug(message, ...args) {
    this.log(LogLevel.DEBUG, message, ...args);
  }
  info(message, ...args) {
    this.log(LogLevel.INFO, message, ...args);
  }
  warn(message, ...args) {
    this.log(LogLevel.WARN, message, ...args);
  }
  error(message, ...args) {
    this.log(LogLevel.ERROR, message, ...args);
  }
};
Logger.globalLogLevel = void 0;
Logger.globalKeys = {
  emitErrors: true
};
Logger.troubleshootModeEnabled = false;
Logger.globalMetaData = new MetaData();
Logger.events = new eventemitter3_default();

// node_modules/@dynamic-labs/assert-package-version/src/lib/assertPackageVersion/assertPackageVersion.js
var packageVersions = {};
var logger = new Logger("@dynamic-labs/assert-package-version");
var versionCheckTimeout = null;
var assertPackageVersion = (packageName, version8) => {
  packageVersions[packageName] = version8;
  if (versionCheckTimeout) {
    clearTimeout(versionCheckTimeout);
    versionCheckTimeout = null;
  }
  const timeout = 100;
  versionCheckTimeout = setTimeout(() => {
    const versions = Object.values(packageVersions);
    const [firstVersion] = versions;
    const allSameVersion = versions.every((v) => v === firstVersion);
    if (!allSameVersion) {
      const targetVersion = packageVersions["@dynamic-labs/sdk-react-core"] || firstVersion;
      const errorMessage = getErrorMessage(targetVersion);
      logger.error(new Error(errorMessage));
    }
    versionCheckTimeout = null;
  }, timeout);
};
var getErrorMessage = (targetVersion) => {
  const affectedPackages = Object.entries(packageVersions).filter(([, v]) => v !== targetVersion).map(([pkgName, installedVersion]) => `- \`${pkgName}\` (installed: **${installedVersion}**, required: **${targetVersion}**)`).join("\n");
  const errorMessage = `
 Version Mismatch Error

One or more \`@dynamic-labs\` packages are installed with mismatched versions. All \`@dynamic-labs\` packages must be on the same version to work correctly.

Affected Packages:
${affectedPackages}

 To fix this issue, update all @dynamic-labs/* packages to version \`${targetVersion}\` in your package.json
 Tip: You can use the \`npx dynamic-doctor run\` command to check for other issues with your project setup.
`;
  return errorMessage.trim();
};

// node_modules/@dynamic-labs/utils/src/tracing/tracing.js
var formatTrace = (trace) => `
--- ${trace.scope} : ${trace.timestamp.toISOString()} ---
${trace.payload.join("\n")}
`.trim();
var createTracing = () => {
  const traces = [];
  return {
    /**
     * Formats an object as a pretty-printed JSON string
     * @param object - The object to format
     * @returns JSON string representation of the object
     */
    formatObject: (object2) => JSON.stringify(object2, null, 2),
    /**
     * Logs an event to the trace collection
     * @param scope - The scope/category of the event
     * @param args - String messages to include in the trace
     */
    logEvent: (scope, ...args) => {
      traces.push({
        payload: args,
        scope,
        timestamp: /* @__PURE__ */ new Date()
      });
    },
    /**
     * Formats and returns traces filtered by scope
     * @param scopes - Optional array of scopes to filter traces
     * @returns Formatted trace output as a string
     */
    packScopes: (scopes) => traces.filter((trace) => scopes ? scopes.includes(trace.scope) : true).map(formatTrace).join("\n\n")
  };
};
var tracing = createTracing();

// node_modules/@dynamic-labs/sdk-api-core/src/models/ChainEnum.js
var ChainEnum;
(function(ChainEnum2) {
  ChainEnum2["Eth"] = "ETH";
  ChainEnum2["Evm"] = "EVM";
  ChainEnum2["Flow"] = "FLOW";
  ChainEnum2["Sol"] = "SOL";
  ChainEnum2["Algo"] = "ALGO";
  ChainEnum2["Stark"] = "STARK";
  ChainEnum2["Cosmos"] = "COSMOS";
  ChainEnum2["Btc"] = "BTC";
  ChainEnum2["Eclipse"] = "ECLIPSE";
  ChainEnum2["Sui"] = "SUI";
  ChainEnum2["Spark"] = "SPARK";
  ChainEnum2["Tron"] = "TRON";
  ChainEnum2["Aptos"] = "APTOS";
  ChainEnum2["Ton"] = "TON";
})(ChainEnum || (ChainEnum = {}));
function ChainEnumFromJSON(json) {
  return ChainEnumFromJSONTyped(json);
}
function ChainEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ChainEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAction.js
var MFAAction;
(function(MFAAction2) {
  MFAAction2["WalletWaasSign"] = "wallet.waas.sign";
  MFAAction2["WalletWaasExport"] = "wallet.waas.export";
  MFAAction2["WalletWaasReshare"] = "wallet.waas.reshare";
  MFAAction2["WalletWaasRefresh"] = "wallet.waas.refresh";
  MFAAction2["UserUpdate"] = "user.update";
})(MFAAction || (MFAAction = {}));
function MFAActionFromJSON(json) {
  return MFAActionFromJSONTyped(json);
}
function MFAActionFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/_virtual/_tslib.js
function __awaiter2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/sdk-api-core/src/runtime.js
var BASE_PATH = "https://app.dynamicauth.com/api/v0".replace(/\/+$/, "");
var isBlob = (value) => typeof Blob !== "undefined" && value instanceof Blob;
var BaseAPI = class {
  constructor(configuration = new Configuration()) {
    this.configuration = configuration;
    this.fetchApi = (url, init) => __awaiter2(this, void 0, void 0, function* () {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (yield middleware.pre(Object.assign({ fetch: this.fetchApi }, fetchParams))) || fetchParams;
        }
      }
      let response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = (yield middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          })) || response;
        }
      }
      return response;
    });
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  request(context, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { url, init } = this.createFetchParams(context, initOverrides);
      const response = yield this.fetchApi(url, init);
      if (response.status >= 200 && response.status < 300) {
        return response;
      }
      throw response;
    });
  }
  createFetchParams(context, initOverrides) {
    let url = this.configuration.basePath + context.path;
    if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
      url += "?" + this.configuration.queryParamsStringify(context.query);
    }
    const body = typeof FormData !== "undefined" && context.body instanceof FormData || context.body instanceof URLSearchParams || isBlob(context.body) ? context.body : JSON.stringify(context.body);
    const headers = Object.assign({}, this.configuration.headers, context.headers);
    const init = Object.assign({ method: context.method, headers, body, credentials: this.configuration.credentials }, initOverrides);
    return { url, init };
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : () => __awaiter2(this, void 0, void 0, function* () {
        return accessToken;
      });
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => {
    const fullKey = prefix + (prefix.length ? `[${key}]` : key);
    const value = params[key];
    if (value instanceof Array) {
      const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
      return `${encodeURIComponent(fullKey)}=${multiValue}`;
    }
    if (value instanceof Date) {
      return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
    }
    if (value instanceof Object) {
      return querystring(value, fullKey);
    }
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
  }).filter((part) => part.length > 0).join("&");
}
function mapValues(data, fn) {
  return Object.keys(data).reduce((acc, key) => Object.assign(Object.assign({}, acc), { [key]: fn(data[key]) }), {});
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  value() {
    return __awaiter2(this, void 0, void 0, function* () {
      return this.transformer(yield this.raw.json());
    });
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __awaiter2(this, void 0, void 0, function* () {
      return void 0;
    });
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.raw.text();
    });
  }
};

// node_modules/@dynamic-labs/sdk-api-core/src/models/NameServiceData.js
function NameServiceDataFromJSON(json) {
  return NameServiceDataFromJSONTyped(json);
}
function NameServiceDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "avatar": !exists(json, "avatar") ? void 0 : json["avatar"],
    "name": !exists(json, "name") ? void 0 : json["name"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletProviderEnum.js
var WalletProviderEnum;
(function(WalletProviderEnum2) {
  WalletProviderEnum2["BrowserExtension"] = "browserExtension";
  WalletProviderEnum2["CustodialService"] = "custodialService";
  WalletProviderEnum2["WalletConnect"] = "walletConnect";
  WalletProviderEnum2["QrCode"] = "qrCode";
  WalletProviderEnum2["DeepLink"] = "deepLink";
  WalletProviderEnum2["EmbeddedWallet"] = "embeddedWallet";
  WalletProviderEnum2["SmartContractWallet"] = "smartContractWallet";
})(WalletProviderEnum || (WalletProviderEnum = {}));
function WalletProviderEnumFromJSON(json) {
  return WalletProviderEnumFromJSONTyped(json);
}
function WalletProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function WalletProviderEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtBlockchainAccount.js
function JwtBlockchainAccountFromJSON(json) {
  return JwtBlockchainAccountFromJSONTyped(json);
}
function JwtBlockchainAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "chain": json["chain"],
    "id": json["id"],
    "nameService": !exists(json, "name_service") ? void 0 : NameServiceDataFromJSON(json["name_service"]),
    "walletName": json["wallet_name"],
    "walletProvider": WalletProviderEnumFromJSON(json["wallet_provider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtPayloadDeprecatedInfo.js
function JwtPayloadDeprecatedInfoFromJSON(json) {
  return JwtPayloadDeprecatedInfoFromJSONTyped(json);
}
function JwtPayloadDeprecatedInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "chain": !exists(json, "chain") ? void 0 : ChainEnumFromJSON(json["chain"]),
    "email": !exists(json, "email") ? void 0 : json["email"],
    "ens": !exists(json, "ens") ? void 0 : NameServiceDataFromJSON(json["ens"]),
    "environmentId": json["environmentId"],
    "firstName": !exists(json, "firstName") ? void 0 : json["firstName"],
    "jobTitle": !exists(json, "jobTitle") ? void 0 : json["jobTitle"],
    "lastName": !exists(json, "lastName") ? void 0 : json["lastName"],
    "lists": !exists(json, "lists") ? void 0 : json["lists"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "tShirtSize": !exists(json, "tShirtSize") ? void 0 : json["tShirtSize"],
    "userId": !exists(json, "userId") ? void 0 : json["userId"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "wallet": !exists(json, "wallet") ? void 0 : json["wallet"],
    "walletPublicKey": !exists(json, "walletPublicKey") ? void 0 : json["walletPublicKey"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtVerifiedCredentialFormatEnum.js
var JwtVerifiedCredentialFormatEnum;
(function(JwtVerifiedCredentialFormatEnum2) {
  JwtVerifiedCredentialFormatEnum2["Blockchain"] = "blockchain";
  JwtVerifiedCredentialFormatEnum2["Email"] = "email";
  JwtVerifiedCredentialFormatEnum2["Oauth"] = "oauth";
  JwtVerifiedCredentialFormatEnum2["Passkey"] = "passkey";
  JwtVerifiedCredentialFormatEnum2["PhoneNumber"] = "phoneNumber";
  JwtVerifiedCredentialFormatEnum2["ExternalUser"] = "externalUser";
})(JwtVerifiedCredentialFormatEnum || (JwtVerifiedCredentialFormatEnum = {}));
function JwtVerifiedCredentialFormatEnumFromJSON(json) {
  return JwtVerifiedCredentialFormatEnumFromJSONTyped(json);
}
function JwtVerifiedCredentialFormatEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderEnum.js
var ProviderEnum;
(function(ProviderEnum2) {
  ProviderEnum2["EmailOnly"] = "emailOnly";
  ProviderEnum2["MagicLink"] = "magicLink";
  ProviderEnum2["Apple"] = "apple";
  ProviderEnum2["Bitbucket"] = "bitbucket";
  ProviderEnum2["Coinbasesocial"] = "coinbasesocial";
  ProviderEnum2["Discord"] = "discord";
  ProviderEnum2["Epicgames"] = "epicgames";
  ProviderEnum2["Facebook"] = "facebook";
  ProviderEnum2["Farcaster"] = "farcaster";
  ProviderEnum2["Github"] = "github";
  ProviderEnum2["Gitlab"] = "gitlab";
  ProviderEnum2["Google"] = "google";
  ProviderEnum2["Instagram"] = "instagram";
  ProviderEnum2["Linkedin"] = "linkedin";
  ProviderEnum2["Microsoft"] = "microsoft";
  ProviderEnum2["Twitch"] = "twitch";
  ProviderEnum2["Twitter"] = "twitter";
  ProviderEnum2["Blocto"] = "blocto";
  ProviderEnum2["Banxa"] = "banxa";
  ProviderEnum2["CoinbaseOnramp"] = "coinbaseOnramp";
  ProviderEnum2["CryptoDotCom"] = "cryptoDotCom";
  ProviderEnum2["Dynamic"] = "dynamic";
  ProviderEnum2["Alchemy"] = "alchemy";
  ProviderEnum2["Zerodev"] = "zerodev";
  ProviderEnum2["Telegram"] = "telegram";
  ProviderEnum2["Turnkey"] = "turnkey";
  ProviderEnum2["CoinbaseWaas"] = "coinbaseWaas";
  ProviderEnum2["Sms"] = "sms";
  ProviderEnum2["Spotify"] = "spotify";
  ProviderEnum2["Tiktok"] = "tiktok";
  ProviderEnum2["Line"] = "line";
  ProviderEnum2["Steam"] = "steam";
  ProviderEnum2["Shopify"] = "shopify";
  ProviderEnum2["Zksync"] = "zksync";
  ProviderEnum2["Kraken"] = "kraken";
  ProviderEnum2["Blockaid"] = "blockaid";
  ProviderEnum2["Passkey"] = "passkey";
  ProviderEnum2["Okta"] = "okta";
  ProviderEnum2["Sendgrid"] = "sendgrid";
  ProviderEnum2["Resend"] = "resend";
})(ProviderEnum || (ProviderEnum = {}));
function ProviderEnumFromJSON(json) {
  return ProviderEnumFromJSONTyped(json);
}
function ProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ProviderEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletAddressType.js
var WalletAddressType;
(function(WalletAddressType2) {
  WalletAddressType2["Ordinals"] = "ordinals";
  WalletAddressType2["Payment"] = "payment";
  WalletAddressType2["Cosmos"] = "cosmos";
  WalletAddressType2["Evm"] = "evm";
})(WalletAddressType || (WalletAddressType = {}));
function WalletAddressTypeFromJSON(json) {
  return WalletAddressTypeFromJSONTyped(json);
}
function WalletAddressTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function WalletAddressTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletAdditionalAddress.js
function WalletAdditionalAddressFromJSON(json) {
  return WalletAdditionalAddressFromJSONTyped(json);
}
function WalletAdditionalAddressFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "publicKey": !exists(json, "publicKey") ? void 0 : json["publicKey"],
    "type": WalletAddressTypeFromJSON(json["type"])
  };
}
function WalletAdditionalAddressToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "publicKey": value.publicKey,
    "type": WalletAddressTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EcdsaValidatorOptions.js
var EcdsaValidatorOptions;
(function(EcdsaValidatorOptions2) {
  EcdsaValidatorOptions2["SignerToEcdsa"] = "zerodev_signer_to_ecdsa";
  EcdsaValidatorOptions2["MultiChain"] = "zerodev_multi_chain";
})(EcdsaValidatorOptions || (EcdsaValidatorOptions = {}));
function EcdsaValidatorOptionsFromJSON(json) {
  return EcdsaValidatorOptionsFromJSONTyped(json);
}
function EcdsaValidatorOptionsFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletVersionEnum.js
var EmbeddedWalletVersionEnum;
(function(EmbeddedWalletVersionEnum2) {
  EmbeddedWalletVersionEnum2["V1"] = "V1";
  EmbeddedWalletVersionEnum2["V2"] = "V2";
  EmbeddedWalletVersionEnum2["V3"] = "V3";
})(EmbeddedWalletVersionEnum || (EmbeddedWalletVersionEnum = {}));
function EmbeddedWalletVersionEnumFromJSON(json) {
  return EmbeddedWalletVersionEnumFromJSONTyped(json);
}
function EmbeddedWalletVersionEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HardwareWalletEnum.js
var HardwareWalletEnum;
(function(HardwareWalletEnum2) {
  HardwareWalletEnum2["Ledger"] = "ledger";
})(HardwareWalletEnum || (HardwareWalletEnum = {}));
function HardwareWalletEnumFromJSON(json) {
  return HardwareWalletEnumFromJSONTyped(json);
}
function HardwareWalletEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasswordSourceTypeEnum.js
var PasswordSourceTypeEnum;
(function(PasswordSourceTypeEnum2) {
  PasswordSourceTypeEnum2["Dynamic"] = "dynamic";
  PasswordSourceTypeEnum2["User"] = "user";
})(PasswordSourceTypeEnum || (PasswordSourceTypeEnum = {}));
function PasswordSourceTypeEnumFromJSON(json) {
  return PasswordSourceTypeEnumFromJSONTyped(json);
}
function PasswordSourceTypeEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PasswordSourceTypeEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderEntryPointVersionEnum.js
var ProviderEntryPointVersionEnum;
(function(ProviderEntryPointVersionEnum2) {
  ProviderEntryPointVersionEnum2["V6"] = "v6";
  ProviderEntryPointVersionEnum2["V7"] = "v7";
})(ProviderEntryPointVersionEnum || (ProviderEntryPointVersionEnum = {}));
function ProviderEntryPointVersionEnumFromJSON(json) {
  return ProviderEntryPointVersionEnumFromJSONTyped(json);
}
function ProviderEntryPointVersionEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderKernelVersionEnum.js
var ProviderKernelVersionEnum;
(function(ProviderKernelVersionEnum2) {
  ProviderKernelVersionEnum2["V24"] = "v2_4";
  ProviderKernelVersionEnum2["V30"] = "v3_0";
  ProviderKernelVersionEnum2["V31"] = "v3_1";
  ProviderKernelVersionEnum2["V32"] = "v3_2";
  ProviderKernelVersionEnum2["V33"] = "v3_3";
})(ProviderKernelVersionEnum || (ProviderKernelVersionEnum = {}));
function ProviderKernelVersionEnumFromJSON(json) {
  return ProviderKernelVersionEnumFromJSONTyped(json);
}
function ProviderKernelVersionEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ThresholdSignatureScheme.js
var ThresholdSignatureScheme;
(function(ThresholdSignatureScheme2) {
  ThresholdSignatureScheme2["TwoOfTwo"] = "TWO_OF_TWO";
  ThresholdSignatureScheme2["TwoOfThree"] = "TWO_OF_THREE";
  ThresholdSignatureScheme2["ThreeOfFive"] = "THREE_OF_FIVE";
})(ThresholdSignatureScheme || (ThresholdSignatureScheme = {}));
function ThresholdSignatureSchemeFromJSON(json) {
  return ThresholdSignatureSchemeFromJSONTyped(json);
}
function ThresholdSignatureSchemeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function ThresholdSignatureSchemeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WaasWalletSettings.js
function WaasWalletSettingsFromJSON(json) {
  return WaasWalletSettingsFromJSONTyped(json);
}
function WaasWalletSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "hasDeniedDelegatedAccess": !exists(json, "hasDeniedDelegatedAccess") ? void 0 : json["hasDeniedDelegatedAccess"],
    "shouldRefreshOnNextSignOn": !exists(json, "shouldRefreshOnNextSignOn") ? void 0 : json["shouldRefreshOnNextSignOn"],
    "reshareOnNextSignOn": !exists(json, "reshareOnNextSignOn") ? void 0 : ThresholdSignatureSchemeFromJSON(json["reshareOnNextSignOn"]),
    "revokeOnNextSignOn": !exists(json, "revokeOnNextSignOn") ? void 0 : json["revokeOnNextSignOn"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletKeyShareInfo.js
function WalletKeyShareInfoFromJSON(json) {
  return WalletKeyShareInfoFromJSONTyped(json);
}
function WalletKeyShareInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "backupLocation": json["backupLocation"],
    "passwordEncrypted": json["passwordEncrypted"],
    "externalKeyShareId": !exists(json, "externalKeyShareId") ? void 0 : json["externalKeyShareId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletProperties.js
function WalletPropertiesFromJSON(json) {
  return WalletPropertiesFromJSONTyped(json);
}
function WalletPropertiesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "turnkeySubOrganizationId": !exists(json, "turnkeySubOrganizationId") ? void 0 : json["turnkeySubOrganizationId"],
    "turnkeyPrivateKeyId": !exists(json, "turnkeyPrivateKeyId") ? void 0 : json["turnkeyPrivateKeyId"],
    "turnkeyHDWalletId": !exists(json, "turnkeyHDWalletId") ? void 0 : json["turnkeyHDWalletId"],
    "isAuthenticatorAttached": !exists(json, "isAuthenticatorAttached") ? void 0 : json["isAuthenticatorAttached"],
    "turnkeyUserId": !exists(json, "turnkeyUserId") ? void 0 : json["turnkeyUserId"],
    "isSessionKeyCompatible": !exists(json, "isSessionKeyCompatible") ? void 0 : json["isSessionKeyCompatible"],
    "version": !exists(json, "version") ? void 0 : EmbeddedWalletVersionEnumFromJSON(json["version"]),
    "ecdsaProviderType": !exists(json, "ecdsaProviderType") ? void 0 : EcdsaValidatorOptionsFromJSON(json["ecdsaProviderType"]),
    "entryPointVersion": !exists(json, "entryPointVersion") ? void 0 : ProviderEntryPointVersionEnumFromJSON(json["entryPointVersion"]),
    "kernelVersion": !exists(json, "kernelVersion") ? void 0 : ProviderKernelVersionEnumFromJSON(json["kernelVersion"]),
    "hardwareWallet": !exists(json, "hardwareWallet") ? void 0 : HardwareWalletEnumFromJSON(json["hardwareWallet"]),
    "claimed": !exists(json, "claimed") ? void 0 : json["claimed"],
    "source": !exists(json, "source") ? void 0 : PasswordSourceTypeEnumFromJSON(json["source"]),
    "keyShares": !exists(json, "keyShares") ? void 0 : json["keyShares"].map(WalletKeyShareInfoFromJSON),
    "thresholdSignatureScheme": !exists(json, "thresholdSignatureScheme") ? void 0 : ThresholdSignatureSchemeFromJSON(json["thresholdSignatureScheme"]),
    "derivationPath": !exists(json, "derivationPath") ? void 0 : json["derivationPath"],
    "settings": !exists(json, "settings") ? void 0 : WaasWalletSettingsFromJSON(json["settings"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtVerifiedCredential.js
function JwtVerifiedCredentialFromJSON(json) {
  return JwtVerifiedCredentialFromJSONTyped(json);
}
function JwtVerifiedCredentialFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": !exists(json, "address") ? void 0 : json["address"],
    "chain": !exists(json, "chain") ? void 0 : json["chain"],
    "refId": !exists(json, "refId") ? void 0 : json["refId"],
    "signerRefId": !exists(json, "signerRefId") ? void 0 : json["signerRefId"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "id": json["id"],
    "nameService": !exists(json, "name_service") ? void 0 : NameServiceDataFromJSON(json["name_service"]),
    "publicIdentifier": !exists(json, "public_identifier") ? void 0 : json["public_identifier"],
    "walletName": !exists(json, "wallet_name") ? void 0 : json["wallet_name"],
    "walletProvider": !exists(json, "wallet_provider") ? void 0 : WalletProviderEnumFromJSON(json["wallet_provider"]),
    "walletProperties": !exists(json, "wallet_properties") ? void 0 : WalletPropertiesFromJSON(json["wallet_properties"]),
    "format": JwtVerifiedCredentialFormatEnumFromJSON(json["format"]),
    "oauthProvider": !exists(json, "oauth_provider") ? void 0 : ProviderEnumFromJSON(json["oauth_provider"]),
    "oauthUsername": !exists(json, "oauth_username") ? void 0 : json["oauth_username"],
    "oauthDisplayName": !exists(json, "oauth_display_name") ? void 0 : json["oauth_display_name"],
    "oauthAccountId": !exists(json, "oauth_account_id") ? void 0 : json["oauth_account_id"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "phoneCountryCode": !exists(json, "phoneCountryCode") ? void 0 : json["phoneCountryCode"],
    "isoCountryCode": !exists(json, "isoCountryCode") ? void 0 : json["isoCountryCode"],
    "oauthAccountPhotos": !exists(json, "oauth_account_photos") ? void 0 : json["oauth_account_photos"],
    "oauthEmails": !exists(json, "oauth_emails") ? void 0 : json["oauth_emails"],
    "oauthMetadata": !exists(json, "oauth_metadata") ? void 0 : json["oauth_metadata"],
    "previousUsers": !exists(json, "previous_users") ? void 0 : json["previous_users"],
    "embeddedWalletId": !exists(json, "embedded_wallet_id") ? void 0 : json["embedded_wallet_id"],
    "walletAdditionalAddresses": !exists(json, "wallet_additional_addresses") ? void 0 : json["wallet_additional_addresses"].map(WalletAdditionalAddressFromJSON),
    "lastSelectedAt": !exists(json, "lastSelectedAt") ? void 0 : new Date(json["lastSelectedAt"]),
    "signInEnabled": json["signInEnabled"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwtVerifiedCredentialHashes.js
function JwtVerifiedCredentialHashesFromJSON(json) {
  return JwtVerifiedCredentialHashesFromJSONTyped(json);
}
function JwtVerifiedCredentialHashesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "blockchain": !exists(json, "blockchain") ? void 0 : json["blockchain"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "oauth": !exists(json, "oauth") ? void 0 : json["oauth"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "externalUser": !exists(json, "externalUser") ? void 0 : json["externalUser"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CustomFieldType.js
var CustomFieldType;
(function(CustomFieldType2) {
  CustomFieldType2["Text"] = "text";
  CustomFieldType2["Checkbox"] = "checkbox";
  CustomFieldType2["Select"] = "select";
})(CustomFieldType || (CustomFieldType = {}));
function CustomFieldTypeFromJSON(json) {
  return CustomFieldTypeFromJSONTyped(json);
}
function CustomFieldTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CustomFieldValidValue.js
function CustomFieldValidValueFromJSON(json) {
  return CustomFieldValidValueFromJSONTyped(json);
}
function CustomFieldValidValueFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "label": json["label"],
    "key": !exists(json, "key") ? void 0 : json["key"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CustomFieldValidationRules.js
function CustomFieldValidationRulesFromJSON(json) {
  return CustomFieldValidationRulesFromJSONTyped(json);
}
function CustomFieldValidationRulesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "unique": !exists(json, "unique") ? void 0 : json["unique"],
    "regex": !exists(json, "regex") ? void 0 : json["regex"],
    "validOptions": !exists(json, "validOptions") ? void 0 : json["validOptions"].map(CustomFieldValidValueFromJSON),
    "checkboxText": !exists(json, "checkboxText") ? void 0 : json["checkboxText"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/KycFieldType.js
var KycFieldType;
(function(KycFieldType2) {
  KycFieldType2["Standard"] = "standard";
  KycFieldType2["Custom"] = "custom";
})(KycFieldType || (KycFieldType = {}));
function KycFieldTypeFromJSON(json) {
  return KycFieldTypeFromJSONTyped(json);
}
function KycFieldTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function KycFieldTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsKyc.js
function ProjectSettingsKycFromJSON(json) {
  return ProjectSettingsKycFromJSONTyped(json);
}
function ProjectSettingsKycFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "required": json["required"],
    "enabled": json["enabled"],
    "unique": json["unique"],
    "verify": json["verify"],
    "type": !exists(json, "type") ? void 0 : KycFieldTypeFromJSON(json["type"]),
    "validationRules": !exists(json, "validationRules") ? void 0 : CustomFieldValidationRulesFromJSON(json["validationRules"]),
    "validationType": !exists(json, "validationType") ? void 0 : CustomFieldTypeFromJSON(json["validationType"]),
    "label": !exists(json, "label") ? void 0 : json["label"],
    "position": !exists(json, "position") ? void 0 : json["position"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/DynamicJwt.js
function DynamicJwtFromJSON(json) {
  return DynamicJwtFromJSONTyped(json);
}
function DynamicJwtFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "kid": json["kid"],
    "aud": json["aud"],
    "iss": json["iss"],
    "sub": json["sub"],
    "exp": !exists(json, "exp") ? void 0 : json["exp"],
    "iat": !exists(json, "iat") ? void 0 : json["iat"],
    "sid": json["sid"],
    "sessionPublicKey": !exists(json, "session_public_key") ? void 0 : json["session_public_key"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "blockchainAccounts": !exists(json, "blockchain_accounts") ? void 0 : json["blockchain_accounts"].map(JwtBlockchainAccountFromJSON),
    "country": !exists(json, "country") ? void 0 : json["country"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "environmentId": json["environment_id"],
    "familyName": !exists(json, "family_name") ? void 0 : json["family_name"],
    "givenName": !exists(json, "given_name") ? void 0 : json["given_name"],
    "jobTitle": !exists(json, "job_title") ? void 0 : json["job_title"],
    "lastAuthenticatedAccountId": !exists(json, "last_authenticated_account_id") ? void 0 : json["last_authenticated_account_id"],
    "lists": !exists(json, "lists") ? void 0 : json["lists"],
    "phoneNumber": !exists(json, "phone_number") ? void 0 : json["phone_number"],
    "missingFields": json["missing_fields"].map(ProjectSettingsKycFromJSON),
    "scope": !exists(json, "scope") ? void 0 : json["scope"],
    "tShirtSize": !exists(json, "t_shirt_size") ? void 0 : json["t_shirt_size"],
    "team": !exists(json, "team") ? void 0 : json["team"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "policiesConsent": !exists(json, "policies_consent") ? void 0 : json["policies_consent"],
    "verifiedAccount": !exists(json, "verified_account") ? void 0 : JwtBlockchainAccountFromJSON(json["verified_account"]),
    "verifiedCredentials": json["verified_credentials"].map(JwtVerifiedCredentialFromJSON),
    "lastVerifiedCredentialId": json["last_verified_credential_id"],
    "firstVisit": !exists(json, "first_visit") ? void 0 : new Date(json["first_visit"]),
    "lastVisit": !exists(json, "last_visit") ? void 0 : new Date(json["last_visit"]),
    "newUser": !exists(json, "new_user") ? void 0 : json["new_user"],
    "btcWallet": !exists(json, "btc_wallet") ? void 0 : json["btc_wallet"],
    "kdaWallet": !exists(json, "kda_wallet") ? void 0 : json["kda_wallet"],
    "ltcWallet": !exists(json, "ltc_wallet") ? void 0 : json["ltc_wallet"],
    "ckbWallet": !exists(json, "ckb_wallet") ? void 0 : json["ckb_wallet"],
    "kasWallet": !exists(json, "kas_wallet") ? void 0 : json["kas_wallet"],
    "dogeWallet": !exists(json, "doge_wallet") ? void 0 : json["doge_wallet"],
    "emailNotification": !exists(json, "email_notification") ? void 0 : json["email_notification"],
    "discordNotification": !exists(json, "discord_notification") ? void 0 : json["discord_notification"],
    "newsletterNotification": !exists(json, "newsletter_notification") ? void 0 : json["newsletter_notification"],
    "metadata": !exists(json, "metadata") ? void 0 : json["metadata"],
    "verifiedCredentialsHashes": !exists(json, "verifiedCredentialsHashes") ? void 0 : JwtVerifiedCredentialHashesFromJSON(json["verifiedCredentialsHashes"]),
    "info": !exists(json, "info") ? void 0 : JwtPayloadDeprecatedInfoFromJSON(json["info"]),
    "serverAuth": !exists(json, "server_auth") ? void 0 : json["server_auth"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AccountBalances.js
function AccountBalancesFromJSON(json) {
  return AccountBalancesFromJSONTyped(json);
}
function AccountBalancesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "currency": json["currency"],
    "balance": json["balance"],
    "availableBalance": !exists(json, "availableBalance") ? void 0 : json["availableBalance"],
    "logoURI": !exists(json, "logoURI") ? void 0 : json["logoURI"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExchangeKeyEnum.js
var ExchangeKeyEnum;
(function(ExchangeKeyEnum2) {
  ExchangeKeyEnum2["Coinbase"] = "coinbase";
  ExchangeKeyEnum2["Kraken"] = "kraken";
})(ExchangeKeyEnum || (ExchangeKeyEnum = {}));
function ExchangeKeyEnumFromJSON(json) {
  return ExchangeKeyEnumFromJSONTyped(json);
}
function ExchangeKeyEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Account.js
function AccountFromJSON(json) {
  return AccountFromJSONTyped(json);
}
function AccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "exchange": ExchangeKeyEnumFromJSON(json["exchange"]),
    "type": !exists(json, "type") ? void 0 : json["type"],
    "balances": json["balances"].map(AccountBalancesFromJSON),
    "name": !exists(json, "name") ? void 0 : json["name"],
    "chain": !exists(json, "chain") ? void 0 : json["chain"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AttestationConveyancePreference.js
var AttestationConveyancePreference;
(function(AttestationConveyancePreference2) {
  AttestationConveyancePreference2["Direct"] = "direct";
  AttestationConveyancePreference2["Enterprise"] = "enterprise";
  AttestationConveyancePreference2["Indirect"] = "indirect";
  AttestationConveyancePreference2["None"] = "none";
})(AttestationConveyancePreference || (AttestationConveyancePreference = {}));
function AttestationConveyancePreferenceFromJSON(json) {
  return AttestationConveyancePreferenceFromJSONTyped(json);
}
function AttestationConveyancePreferenceFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthModeEnum.js
var AuthModeEnum;
(function(AuthModeEnum2) {
  AuthModeEnum2["Only"] = "connect-only";
  AuthModeEnum2["AndSign"] = "connect-and-sign";
})(AuthModeEnum || (AuthModeEnum = {}));
function AuthModeEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthStorageEnum.js
var AuthStorageEnum;
(function(AuthStorageEnum2) {
  AuthStorageEnum2["Localstorage"] = "localstorage";
  AuthStorageEnum2["Cookie"] = "cookie";
})(AuthStorageEnum || (AuthStorageEnum = {}));
function AuthStorageEnumFromJSON(json) {
  return AuthStorageEnumFromJSONTyped(json);
}
function AuthStorageEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorAttachment.js
var AuthenticatorAttachment;
(function(AuthenticatorAttachment2) {
  AuthenticatorAttachment2["CrossPlatform"] = "cross-platform";
  AuthenticatorAttachment2["Platform"] = "platform";
})(AuthenticatorAttachment || (AuthenticatorAttachment = {}));
function AuthenticatorAttachmentFromJSON(json) {
  return AuthenticatorAttachmentFromJSONTyped(json);
}
function AuthenticatorAttachmentFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function AuthenticatorAttachmentToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ResidentKeyRequirement.js
var ResidentKeyRequirement;
(function(ResidentKeyRequirement2) {
  ResidentKeyRequirement2["Discouraged"] = "discouraged";
  ResidentKeyRequirement2["Preferred"] = "preferred";
  ResidentKeyRequirement2["Required"] = "required";
})(ResidentKeyRequirement || (ResidentKeyRequirement = {}));
function ResidentKeyRequirementFromJSON(json) {
  return ResidentKeyRequirementFromJSONTyped(json);
}
function ResidentKeyRequirementFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserVerificationRequirement.js
var UserVerificationRequirement;
(function(UserVerificationRequirement2) {
  UserVerificationRequirement2["Discouraged"] = "discouraged";
  UserVerificationRequirement2["Preferred"] = "preferred";
  UserVerificationRequirement2["Required"] = "required";
})(UserVerificationRequirement || (UserVerificationRequirement = {}));
function UserVerificationRequirementFromJSON(json) {
  return UserVerificationRequirementFromJSONTyped(json);
}
function UserVerificationRequirementFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorTransportProtocol.js
var AuthenticatorTransportProtocol;
(function(AuthenticatorTransportProtocol2) {
  AuthenticatorTransportProtocol2["Internal"] = "AUTHENTICATOR_TRANSPORT_INTERNAL";
  AuthenticatorTransportProtocol2["Usb"] = "AUTHENTICATOR_TRANSPORT_USB";
  AuthenticatorTransportProtocol2["Nfc"] = "AUTHENTICATOR_TRANSPORT_NFC";
  AuthenticatorTransportProtocol2["Ble"] = "AUTHENTICATOR_TRANSPORT_BLE";
  AuthenticatorTransportProtocol2["Hybrid"] = "AUTHENTICATOR_TRANSPORT_HYBRID";
})(AuthenticatorTransportProtocol || (AuthenticatorTransportProtocol = {}));
function AuthenticatorTransportProtocolToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WaasBackupOptionsEnum.js
var WaasBackupOptionsEnum;
(function(WaasBackupOptionsEnum2) {
  WaasBackupOptionsEnum2["GoogleDrive"] = "googleDrive";
  WaasBackupOptionsEnum2["Icloud"] = "icloud";
  WaasBackupOptionsEnum2["Dynamic"] = "dynamic";
  WaasBackupOptionsEnum2["External"] = "external";
  WaasBackupOptionsEnum2["Delegated"] = "delegated";
})(WaasBackupOptionsEnum || (WaasBackupOptionsEnum = {}));
function WaasBackupOptionsEnumFromJSON(json) {
  return WaasBackupOptionsEnumFromJSONTyped(json);
}
function WaasBackupOptionsEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function WaasBackupOptionsEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupKeySharesToLocationRequest.js
function BackupKeySharesToLocationRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "location": WaasBackupOptionsEnumToJSON(value.location)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupKeySharesToLocationResponse.js
function BackupKeySharesToLocationResponseFromJSON(json) {
  return BackupKeySharesToLocationResponseFromJSONTyped(json);
}
function BackupKeySharesToLocationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "message": json["message"],
    "walletId": json["walletId"],
    "location": WaasBackupOptionsEnumFromJSON(json["location"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupKeySharesToLocationsRequestLocations.js
function BackupKeySharesToLocationsRequestLocationsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "location": WaasBackupOptionsEnumToJSON(value.location),
    "keygenId": value.keygenId,
    "thresholdSignatureScheme": ThresholdSignatureSchemeToJSON(value.thresholdSignatureScheme),
    "externalKeyShareId": value.externalKeyShareId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupKeySharesToLocationsRequest.js
function BackupKeySharesToLocationsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "locations": value.locations.map(BackupKeySharesToLocationsRequestLocationsToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupKeySharesToLocationsResponseLocationsWithKeyShares.js
function BackupKeySharesToLocationsResponseLocationsWithKeySharesFromJSON(json) {
  return BackupKeySharesToLocationsResponseLocationsWithKeySharesFromJSONTyped(json);
}
function BackupKeySharesToLocationsResponseLocationsWithKeySharesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "location": WaasBackupOptionsEnumFromJSON(json["location"]),
    "keyShareId": json["keyShareId"],
    "externalKeyShareId": json["externalKeyShareId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupKeySharesToLocationsResponse.js
function BackupKeySharesToLocationsResponseFromJSON(json) {
  return BackupKeySharesToLocationsResponseFromJSONTyped(json);
}
function BackupKeySharesToLocationsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "message": json["message"],
    "walletId": json["walletId"],
    "locationsWithKeyShares": json["locationsWithKeyShares"].map(BackupKeySharesToLocationsResponseLocationsWithKeySharesFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupMultipleClientKeySharesRequest.js
function BackupMultipleClientKeySharesRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "encryptedAccountCredentials": value.encryptedAccountCredentials,
    "passwordEncrypted": value.passwordEncrypted
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BackupMultipleClientKeySharesResponse.js
function BackupMultipleClientKeySharesResponseFromJSON(json) {
  return BackupMultipleClientKeySharesResponseFromJSONTyped(json);
}
function BackupMultipleClientKeySharesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "keyShares": json["keyShares"].map(WalletKeyShareInfoFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MfaBackupCodeAcknowledgement.js
var MfaBackupCodeAcknowledgement;
(function(MfaBackupCodeAcknowledgement2) {
  MfaBackupCodeAcknowledgement2["Pending"] = "pending";
  MfaBackupCodeAcknowledgement2["Complete"] = "complete";
})(MfaBackupCodeAcknowledgement || (MfaBackupCodeAcknowledgement = {}));
function MfaBackupCodeAcknowledgementFromJSON(json) {
  return MfaBackupCodeAcknowledgementFromJSONTyped(json);
}
function MfaBackupCodeAcknowledgementFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function MfaBackupCodeAcknowledgementToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRegistrationCredential.js
function PasskeyRegistrationCredentialToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "attestationObject": value.attestationObject,
    "clientDataJson": value.clientDataJson,
    "credentialId": value.credentialId,
    "transports": value.transports.map(AuthenticatorTransportProtocolToJSON),
    "publicKey": value.publicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CompletePasskeyRecoveryRequest.js
function CompletePasskeyRecoveryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "attestation": PasskeyRegistrationCredentialToJSON(value.attestation),
    "challenge": value.challenge
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ConnectRequest.js
function ConnectRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "chain": ChainEnumToJSON(value.chain),
    "provider": WalletProviderEnumToJSON(value.provider),
    "walletName": value.walletName,
    "authMode": AuthModeEnumToJSON(value.authMode)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletChainEnum.js
var EmbeddedWalletChainEnum;
(function(EmbeddedWalletChainEnum2) {
  EmbeddedWalletChainEnum2["Evm"] = "EVM";
  EmbeddedWalletChainEnum2["Sol"] = "SOL";
  EmbeddedWalletChainEnum2["Sui"] = "SUI";
  EmbeddedWalletChainEnum2["Btc"] = "BTC";
})(EmbeddedWalletChainEnum || (EmbeddedWalletChainEnum = {}));
function EmbeddedWalletChainEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletProviderEnum.js
var EmbeddedWalletProviderEnum;
(function(EmbeddedWalletProviderEnum2) {
  EmbeddedWalletProviderEnum2["Turnkey"] = "turnkey";
  EmbeddedWalletProviderEnum2["Turnkeyhd"] = "turnkeyhd";
  EmbeddedWalletProviderEnum2["DynamicWaas"] = "dynamicWaas";
})(EmbeddedWalletProviderEnum || (EmbeddedWalletProviderEnum = {}));
function EmbeddedWalletProviderEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateTurnkeyEmbeddedWalletSpecificOpts.js
function CreateTurnkeyEmbeddedWalletSpecificOptsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "attestation": PasskeyRegistrationCredentialToJSON(value.attestation),
    "challenge": value.challenge
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateEmbeddedWalletSpecificOpts.js
function CreateEmbeddedWalletSpecificOptsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return Object.assign({}, CreateTurnkeyEmbeddedWalletSpecificOptsToJSON(value));
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateEmbeddedWalletParams.js
function CreateEmbeddedWalletParamsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chains": value.chains === void 0 ? void 0 : value.chains.map(EmbeddedWalletChainEnumToJSON),
    "chain": EmbeddedWalletChainEnumToJSON(value.chain),
    "embeddedWalletProvider": EmbeddedWalletProviderEnumToJSON(value.embeddedWalletProvider),
    "embeddedWalletSpecificOpts": CreateEmbeddedWalletSpecificOptsToJSON(value.embeddedWalletSpecificOpts),
    "isAuthenticatorAttached": value.isAuthenticatorAttached,
    "passkeyAlias": value.passkeyAlias,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateEmbeddedWalletsRequest.js
function CreateEmbeddedWalletsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "embeddedWallets": value.embeddedWallets.map(CreateEmbeddedWalletParamsToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateExchangeTransferRequestNetworkObject.js
function CreateExchangeTransferRequestNetworkObjectToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "networkId": value.networkId,
    "chainName": ChainEnumToJSON(value.chainName)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateExchangeTransferRequest.js
function CreateExchangeTransferRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "to": value.to,
    "amount": value.amount,
    "currency": value.currency,
    "network": value.network,
    "networkObject": CreateExchangeTransferRequestNetworkObjectToJSON(value.networkObject),
    "id": value.id,
    "description": value.description,
    "mfaCode": value.mfaCode
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserIdentifierTypeEnum.js
var UserIdentifierTypeEnum;
(function(UserIdentifierTypeEnum2) {
  UserIdentifierTypeEnum2["Email"] = "email";
  UserIdentifierTypeEnum2["Id"] = "id";
  UserIdentifierTypeEnum2["ExternalUserId"] = "externalUserId";
  UserIdentifierTypeEnum2["PhoneNumber"] = "phoneNumber";
  UserIdentifierTypeEnum2["SocialUsername"] = "socialUsername";
  UserIdentifierTypeEnum2["SocialAccountId"] = "socialAccountId";
})(UserIdentifierTypeEnum || (UserIdentifierTypeEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/WaasChainEnum.js
var WaasChainEnum;
(function(WaasChainEnum2) {
  WaasChainEnum2["Evm"] = "EVM";
  WaasChainEnum2["Svm"] = "SVM";
  WaasChainEnum2["Sui"] = "SUI";
})(WaasChainEnum || (WaasChainEnum = {}));
function WaasChainEnumToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateWaasAccountRequest.js
function CreateWaasAccountRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": WaasChainEnumToJSON(value.chain),
    "clientKeygenIds": value.clientKeygenIds,
    "thresholdSignatureScheme": ThresholdSignatureSchemeToJSON(value.thresholdSignatureScheme),
    "skipLock": value.skipLock
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyStamp.js
function TurnkeyStampToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "stampHeaderName": value.stampHeaderName,
    "stampHeaderValue": value.stampHeaderValue
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeySignedRequest.js
function TurnkeySignedRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "body": value.body,
    "stamp": TurnkeyStampToJSON(value.stamp),
    "url": value.url
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateWalletAccountRequest.js
function CreateWalletAccountRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "turnkeySignedRequest": TurnkeySignedRequestToJSON(value.turnkeySignedRequest)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CurrencyType.js
var CurrencyType;
(function(CurrencyType2) {
  CurrencyType2["Fiat"] = "fiat";
  CurrencyType2["Crypto"] = "crypto";
})(CurrencyType || (CurrencyType = {}));
function CurrencyTypeFromJSON(json) {
  return CurrencyTypeFromJSONTyped(json);
}
function CurrencyTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Currency.js
function CurrencyFromJSON(json) {
  return CurrencyFromJSONTyped(json);
}
function CurrencyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "symbol": json["symbol"],
    "type": CurrencyTypeFromJSON(json["type"]),
    "code": json["code"],
    "value": json["value"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WaasDelegatedAccessEncryptionPublicKeyType.js
var WaasDelegatedAccessEncryptionPublicKeyType;
(function(WaasDelegatedAccessEncryptionPublicKeyType2) {
  WaasDelegatedAccessEncryptionPublicKeyType2["Dynamic"] = "dynamic";
  WaasDelegatedAccessEncryptionPublicKeyType2["External"] = "external";
})(WaasDelegatedAccessEncryptionPublicKeyType || (WaasDelegatedAccessEncryptionPublicKeyType = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/DelegatedAccessEncryptionPublicKey.js
var DelegatedAccessEncryptionPublicKeyAlgEnum;
(function(DelegatedAccessEncryptionPublicKeyAlgEnum2) {
  DelegatedAccessEncryptionPublicKeyAlgEnum2["RsaOaep256"] = "RSA-OAEP-256";
  DelegatedAccessEncryptionPublicKeyAlgEnum2["HybridRsaAes256"] = "HYBRID-RSA-AES-256";
})(DelegatedAccessEncryptionPublicKeyAlgEnum || (DelegatedAccessEncryptionPublicKeyAlgEnum = {}));
var DelegatedAccessEncryptionPublicKeyStatusEnum;
(function(DelegatedAccessEncryptionPublicKeyStatusEnum2) {
  DelegatedAccessEncryptionPublicKeyStatusEnum2["Pending"] = "pending";
  DelegatedAccessEncryptionPublicKeyStatusEnum2["Active"] = "active";
  DelegatedAccessEncryptionPublicKeyStatusEnum2["Revoked"] = "revoked";
})(DelegatedAccessEncryptionPublicKeyStatusEnum || (DelegatedAccessEncryptionPublicKeyStatusEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/DelegatedShareDeliveryRequestEncryptedDelegatedShare.js
function DelegatedShareDeliveryRequestEncryptedDelegatedShareToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "alg": value.alg,
    "iv": value.iv,
    "ct": value.ct,
    "tag": value.tag,
    "ek": value.ek,
    "kid": value.kid
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/DelegatedShareDeliveryRequest.js
function DelegatedShareDeliveryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "encryptedDelegatedShare": DelegatedShareDeliveryRequestEncryptedDelegatedShareToJSON(value.encryptedDelegatedShare)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/DelegatedShareDeliveryResponse.js
var DelegatedShareDeliveryResponseStatusEnum;
(function(DelegatedShareDeliveryResponseStatusEnum2) {
  DelegatedShareDeliveryResponseStatusEnum2["Accepted"] = "accepted";
  DelegatedShareDeliveryResponseStatusEnum2["Queued"] = "queued";
})(DelegatedShareDeliveryResponseStatusEnum || (DelegatedShareDeliveryResponseStatusEnum = {}));
function DelegatedShareDeliveryResponseFromJSON(json) {
  return DelegatedShareDeliveryResponseFromJSONTyped(json);
}
function DelegatedShareDeliveryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "delegatedShareDeliveryId": json["delegatedShareDeliveryId"],
    "status": json["status"],
    "message": !exists(json, "message") ? void 0 : json["message"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/DeleteEmbeddedWalletsRequest.js
function DeleteEmbeddedWalletsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "turnkeySignedRequest": TurnkeySignedRequestToJSON(value.turnkeySignedRequest)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/DeleteUserPasskeyRequest.js
function DeleteUserPasskeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "passkeyId": value.passkeyId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TimeUnitEnum.js
var TimeUnitEnum;
(function(TimeUnitEnum2) {
  TimeUnitEnum2["Days"] = "days";
  TimeUnitEnum2["Hours"] = "hours";
  TimeUnitEnum2["Minutes"] = "minutes";
})(TimeUnitEnum || (TimeUnitEnum = {}));
function TimeUnitEnumFromJSON(json) {
  return TimeUnitEnumFromJSONTyped(json);
}
function TimeUnitEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailProviderResponse.js
function EmailProviderResponseFromJSON(json) {
  return EmailProviderResponseFromJSONTyped(json);
}
function EmailProviderResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "emailProvider": ProviderEnumFromJSON(json["emailProvider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationCreateRequest.js
function EmailVerificationCreateRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "email": value.email,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationCreateResponse.js
function EmailVerificationCreateResponseFromJSON(json) {
  return EmailVerificationCreateResponseFromJSONTyped(json);
}
function EmailVerificationCreateResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "verificationUUID": json["verificationUUID"],
    "email": json["email"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/CreateMfaToken.js
function CreateMfaTokenToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "singleUse": value.singleUse
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationMfaRequest.js
function EmailVerificationMfaRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "verificationToken": value.verificationToken,
    "createMfaToken": CreateMfaTokenToJSON(value.createMfaToken)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationRetryRequest.js
function EmailVerificationRetryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "email": value.email,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmailVerificationVerifyRequest.js
function EmailVerificationVerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "verificationToken": value.verificationToken,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletAuthToken.js
function EmbeddedWalletAuthTokenFromJSON(json) {
  return EmbeddedWalletAuthTokenFromJSONTyped(json);
}
function EmbeddedWalletAuthTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "token": json["token"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletAuthType.js
var EmbeddedWalletAuthType;
(function(EmbeddedWalletAuthType2) {
  EmbeddedWalletAuthType2["Mpc"] = "mpc";
})(EmbeddedWalletAuthType || (EmbeddedWalletAuthType = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletPasscodeClaimRequest.js
function EmbeddedWalletPasscodeClaimRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletSecret.js
function EmbeddedWalletSecretFromJSON(json) {
  return EmbeddedWalletSecretFromJSONTyped(json);
}
function EmbeddedWalletSecretFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletId": json["walletId"],
    "secret": json["secret"],
    "source": !exists(json, "source") ? void 0 : PasswordSourceTypeEnumFromJSON(json["source"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkUser.js
function SdkUserFromJSON(json) {
  return SdkUserFromJSONTyped(json);
}
function SdkUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "projectEnvironmentId": json["projectEnvironmentId"],
    "verifiedCredentials": json["verifiedCredentials"].map(JwtVerifiedCredentialFromJSON),
    "lastVerifiedCredentialId": !exists(json, "lastVerifiedCredentialId") ? void 0 : json["lastVerifiedCredentialId"],
    "sessionId": !exists(json, "sessionId") ? void 0 : json["sessionId"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "country": !exists(json, "country") ? void 0 : json["country"],
    "email": !exists(json, "email") ? void 0 : json["email"],
    "firstName": !exists(json, "firstName") ? void 0 : json["firstName"],
    "jobTitle": !exists(json, "jobTitle") ? void 0 : json["jobTitle"],
    "lastName": !exists(json, "lastName") ? void 0 : json["lastName"],
    "phoneNumber": !exists(json, "phoneNumber") ? void 0 : json["phoneNumber"],
    "policiesConsent": !exists(json, "policiesConsent") ? void 0 : json["policiesConsent"],
    "tShirtSize": !exists(json, "tShirtSize") ? void 0 : json["tShirtSize"],
    "team": !exists(json, "team") ? void 0 : json["team"],
    "username": !exists(json, "username") ? void 0 : json["username"],
    "firstVisit": !exists(json, "firstVisit") ? void 0 : new Date(json["firstVisit"]),
    "lastVisit": !exists(json, "lastVisit") ? void 0 : new Date(json["lastVisit"]),
    "newUser": !exists(json, "newUser") ? void 0 : json["newUser"],
    "metadata": !exists(json, "metadata") ? void 0 : json["metadata"],
    "mfaBackupCodeAcknowledgement": !exists(json, "mfaBackupCodeAcknowledgement") ? void 0 : MfaBackupCodeAcknowledgementFromJSON(json["mfaBackupCodeAcknowledgement"]),
    "btcWallet": !exists(json, "btcWallet") ? void 0 : json["btcWallet"],
    "kdaWallet": !exists(json, "kdaWallet") ? void 0 : json["kdaWallet"],
    "ltcWallet": !exists(json, "ltcWallet") ? void 0 : json["ltcWallet"],
    "ckbWallet": !exists(json, "ckbWallet") ? void 0 : json["ckbWallet"],
    "kasWallet": !exists(json, "kasWallet") ? void 0 : json["kasWallet"],
    "dogeWallet": !exists(json, "dogeWallet") ? void 0 : json["dogeWallet"],
    "emailNotification": !exists(json, "emailNotification") ? void 0 : json["emailNotification"],
    "discordNotification": !exists(json, "discordNotification") ? void 0 : json["discordNotification"],
    "newsletterNotification": !exists(json, "newsletterNotification") ? void 0 : json["newsletterNotification"],
    "lists": !exists(json, "lists") ? void 0 : json["lists"],
    "scope": !exists(json, "scope") ? void 0 : json["scope"],
    "missingFields": !exists(json, "missingFields") ? void 0 : json["missingFields"].map(ProjectSettingsKycFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EmbeddedWalletSecurityMethod.js
var EmbeddedWalletSecurityMethod;
(function(EmbeddedWalletSecurityMethod2) {
  EmbeddedWalletSecurityMethod2["Passkey"] = "passkey";
  EmbeddedWalletSecurityMethod2["Passphrase"] = "passphrase";
})(EmbeddedWalletSecurityMethod || (EmbeddedWalletSecurityMethod = {}));
function EmbeddedWalletSecurityMethodFromJSON(json) {
  return EmbeddedWalletSecurityMethodFromJSONTyped(json);
}
function EmbeddedWalletSecurityMethodFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/EnvironmentEnum.js
var EnvironmentEnum;
(function(EnvironmentEnum2) {
  EnvironmentEnum2["Sandbox"] = "sandbox";
  EnvironmentEnum2["Live"] = "live";
})(EnvironmentEnum || (EnvironmentEnum = {}));
function EnvironmentEnumFromJSON(json) {
  return EnvironmentEnumFromJSONTyped(json);
}
function EnvironmentEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExchangeTransaction.js
function ExchangeTransactionFromJSON(json) {
  return ExchangeTransactionFromJSONTyped(json);
}
function ExchangeTransactionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transactionId": !exists(json, "transactionId") ? void 0 : json["transactionId"],
    "transactionHash": !exists(json, "transactionHash") ? void 0 : json["transactionHash"],
    "status": !exists(json, "status") ? void 0 : json["status"],
    "amount": !exists(json, "amount") ? void 0 : json["amount"],
    "currency": !exists(json, "currency") ? void 0 : json["currency"],
    "createdAt": !exists(json, "createdAt") ? void 0 : new Date(json["createdAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExchangeTransferResponse.js
function ExchangeTransferResponseFromJSON(json) {
  return ExchangeTransferResponseFromJSONTyped(json);
}
function ExchangeTransferResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "exchangeAccountId": !exists(json, "exchangeAccountId") ? void 0 : json["exchangeAccountId"],
    "status": !exists(json, "status") ? void 0 : json["status"],
    "amount": json["amount"],
    "currency": json["currency"],
    "createdAt": !exists(json, "createdAt") ? void 0 : new Date(json["createdAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExportEmbeddedWalletResponse.js
function ExportEmbeddedWalletResponseFromJSON(json) {
  return ExportEmbeddedWalletResponseFromJSONTyped(json);
}
function ExportEmbeddedWalletResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "exportBundle": json["exportBundle"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExportWaasWalletPrivateKeyRequest.js
function ExportWaasWalletPrivateKeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "exportId": value.exportId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalAuthSigninRequest.js
function ExternalAuthSigninRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "jwt": value.jwt,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalWalletFundingDefaultChain.js
var ExternalWalletFundingDefaultChain;
(function(ExternalWalletFundingDefaultChain2) {
  ExternalWalletFundingDefaultChain2["Ethereum"] = "ethereum";
  ExternalWalletFundingDefaultChain2["Solana"] = "solana";
})(ExternalWalletFundingDefaultChain || (ExternalWalletFundingDefaultChain = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalWalletFundingTokenRule.js
var ExternalWalletFundingTokenRule;
(function(ExternalWalletFundingTokenRule2) {
  ExternalWalletFundingTokenRule2["Recommended"] = "recommended";
  ExternalWalletFundingTokenRule2["Exact"] = "exact";
})(ExternalWalletFundingTokenRule || (ExternalWalletFundingTokenRule = {}));
function ExternalWalletFundingTokenRuleFromJSON(json) {
  return ExternalWalletFundingTokenRuleFromJSONTyped(json);
}
function ExternalWalletFundingTokenRuleFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FarcasterSignInRequest.js
function FarcasterSignInRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "domain": value.domain,
    "nonce": value.nonce,
    "message": value.message,
    "signature": value.signature,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OnrampProviders.js
var OnrampProviders;
(function(OnrampProviders2) {
  OnrampProviders2["Banxa"] = "banxa";
  OnrampProviders2["CoinbaseOnramp"] = "coinbaseOnramp";
  OnrampProviders2["CryptoDotCom"] = "cryptoDotCom";
})(OnrampProviders || (OnrampProviders = {}));
function OnrampProvidersFromJSON(json) {
  return OnrampProvidersFromJSONTyped(json);
}
function OnrampProvidersFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyTransport.js
var PasskeyTransport;
(function(PasskeyTransport2) {
  PasskeyTransport2["Usb"] = "usb";
  PasskeyTransport2["Nfc"] = "nfc";
  PasskeyTransport2["Ble"] = "ble";
  PasskeyTransport2["Internal"] = "internal";
  PasskeyTransport2["Hybrid"] = "hybrid";
})(PasskeyTransport || (PasskeyTransport = {}));
function PasskeyTransportFromJSON(json) {
  return PasskeyTransportFromJSONTyped(json);
}
function PasskeyTransportFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PasskeyTransportToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyAllowCredential.js
function PasskeyAllowCredentialFromJSON(json) {
  return PasskeyAllowCredentialFromJSONTyped(json);
}
function PasskeyAllowCredentialFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "transports": !exists(json, "transports") ? void 0 : json["transports"].map(PasskeyTransportFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyCredentialHint.js
var PasskeyCredentialHint;
(function(PasskeyCredentialHint2) {
  PasskeyCredentialHint2["Hybrid"] = "hybrid";
  PasskeyCredentialHint2["SecurityKey"] = "security-key";
  PasskeyCredentialHint2["ClientDevice"] = "client-device";
})(PasskeyCredentialHint || (PasskeyCredentialHint = {}));
function PasskeyCredentialHintFromJSON(json) {
  return PasskeyCredentialHintFromJSONTyped(json);
}
function PasskeyCredentialHintFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyExtension.js
function PasskeyExtensionFromJSON(json) {
  return PasskeyExtensionFromJSONTyped(json);
}
function PasskeyExtensionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "appid": !exists(json, "appid") ? void 0 : json["appid"],
    "appidExclude": !exists(json, "appidExclude") ? void 0 : json["appidExclude"],
    "credProps": !exists(json, "credProps") ? void 0 : json["credProps"],
    "uvm": !exists(json, "uvm") ? void 0 : json["uvm"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GetPasskeyAuthenticationOptionsResponse.js
function GetPasskeyAuthenticationOptionsResponseFromJSON(json) {
  return GetPasskeyAuthenticationOptionsResponseFromJSONTyped(json);
}
function GetPasskeyAuthenticationOptionsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "challenge": json["challenge"],
    "timeout": !exists(json, "timeout") ? void 0 : json["timeout"],
    "rpId": !exists(json, "rpId") ? void 0 : json["rpId"],
    "userVerification": !exists(json, "userVerification") ? void 0 : UserVerificationRequirementFromJSON(json["userVerification"]),
    "allowCredentials": !exists(json, "allowCredentials") ? void 0 : json["allowCredentials"].map(PasskeyAllowCredentialFromJSON),
    "extensions": !exists(json, "extensions") ? void 0 : PasskeyExtensionFromJSON(json["extensions"]),
    "hints": !exists(json, "hints") ? void 0 : PasskeyCredentialHintFromJSON(json["hints"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorSelectionCriteria.js
function AuthenticatorSelectionCriteriaFromJSON(json) {
  return AuthenticatorSelectionCriteriaFromJSONTyped(json);
}
function AuthenticatorSelectionCriteriaFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "authenticatorAttachment": !exists(json, "authenticatorAttachment") ? void 0 : AuthenticatorAttachmentFromJSON(json["authenticatorAttachment"]),
    "requireResidentKey": !exists(json, "requireResidentKey") ? void 0 : json["requireResidentKey"],
    "residentKey": !exists(json, "residentKey") ? void 0 : ResidentKeyRequirementFromJSON(json["residentKey"]),
    "userVerification": !exists(json, "userVerification") ? void 0 : UserVerificationRequirementFromJSON(json["userVerification"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyCredentialType.js
var PasskeyCredentialType;
(function(PasskeyCredentialType2) {
  PasskeyCredentialType2["PublicKey"] = "public-key";
})(PasskeyCredentialType || (PasskeyCredentialType = {}));
function PasskeyCredentialTypeFromJSON(json) {
  return PasskeyCredentialTypeFromJSONTyped(json);
}
function PasskeyCredentialTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PasskeyCredentialTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyExcludeCredential.js
function PasskeyExcludeCredentialFromJSON(json) {
  return PasskeyExcludeCredentialFromJSONTyped(json);
}
function PasskeyExcludeCredentialFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "transports": !exists(json, "transports") ? void 0 : json["transports"].map(PasskeyTransportFromJSON),
    "type": PasskeyCredentialTypeFromJSON(json["type"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRelyingParty.js
function PasskeyRelyingPartyFromJSON(json) {
  return PasskeyRelyingPartyFromJSONTyped(json);
}
function PasskeyRelyingPartyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyUser.js
function PasskeyUserFromJSON(json) {
  return PasskeyUserFromJSONTyped(json);
}
function PasskeyUserFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "displayName": json["displayName"],
    "id": json["id"],
    "name": json["name"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialType.js
var PublicKeyCredentialType;
(function(PublicKeyCredentialType2) {
  PublicKeyCredentialType2["PublicKey"] = "public-key";
})(PublicKeyCredentialType || (PublicKeyCredentialType = {}));
function PublicKeyCredentialTypeFromJSON(json) {
  return PublicKeyCredentialTypeFromJSONTyped(json);
}
function PublicKeyCredentialTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function PublicKeyCredentialTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialParameters.js
function PublicKeyCredentialParametersFromJSON(json) {
  return PublicKeyCredentialParametersFromJSONTyped(json);
}
function PublicKeyCredentialParametersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "alg": json["alg"],
    "type": PublicKeyCredentialTypeFromJSON(json["type"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GetPasskeyRegistrationOptionsResponse.js
function GetPasskeyRegistrationOptionsResponseFromJSON(json) {
  return GetPasskeyRegistrationOptionsResponseFromJSONTyped(json);
}
function GetPasskeyRegistrationOptionsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "attestation": AttestationConveyancePreferenceFromJSON(json["attestation"]),
    "authenticatorSelection": AuthenticatorSelectionCriteriaFromJSON(json["authenticatorSelection"]),
    "challenge": json["challenge"],
    "excludeCredentials": json["excludeCredentials"].map(PasskeyExcludeCredentialFromJSON),
    "extensions": !exists(json, "extensions") ? void 0 : PasskeyExtensionFromJSON(json["extensions"]),
    "hints": !exists(json, "hints") ? void 0 : json["hints"],
    "pubKeyCredParams": json["pubKeyCredParams"].map(PublicKeyCredentialParametersFromJSON),
    "rp": PasskeyRelyingPartyFromJSON(json["rp"]),
    "timeout": json["timeout"],
    "user": PasskeyUserFromJSON(json["user"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyStorage.js
function PasskeyStorageFromJSON(json) {
  return PasskeyStorageFromJSONTyped(json);
}
function PasskeyStorageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "icon": json["icon"],
    "updatedAt": !exists(json, "updatedAt") ? void 0 : new Date(json["updatedAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserPasskey.js
function UserPasskeyFromJSON(json) {
  return UserPasskeyFromJSONTyped(json);
}
function UserPasskeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"],
    "userAgent": !exists(json, "userAgent") ? void 0 : json["userAgent"],
    "origin": !exists(json, "origin") ? void 0 : json["origin"],
    "credentialId": json["credentialId"],
    "createdAt": new Date(json["createdAt"]),
    "updatedAt": !exists(json, "updatedAt") ? void 0 : new Date(json["updatedAt"]),
    "storage": !exists(json, "storage") ? void 0 : PasskeyStorageFromJSON(json["storage"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GetUserPasskeysResponse.js
function GetUserPasskeysResponseFromJSON(json) {
  return GetUserPasskeysResponseFromJSONTyped(json);
}
function GetUserPasskeysResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "passkeys": json["passkeys"].map(UserPasskeyFromJSON),
    "count": json["count"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GlobalWalletAccessControlTypeEnum.js
var GlobalWalletAccessControlTypeEnum;
(function(GlobalWalletAccessControlTypeEnum2) {
  GlobalWalletAccessControlTypeEnum2["Allow"] = "allow";
  GlobalWalletAccessControlTypeEnum2["Block"] = "block";
})(GlobalWalletAccessControlTypeEnum || (GlobalWalletAccessControlTypeEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/GlobalWalletConnectionStatusEnum.js
var GlobalWalletConnectionStatusEnum;
(function(GlobalWalletConnectionStatusEnum2) {
  GlobalWalletConnectionStatusEnum2["Connected"] = "connected";
  GlobalWalletConnectionStatusEnum2["Disconnected"] = "disconnected";
})(GlobalWalletConnectionStatusEnum || (GlobalWalletConnectionStatusEnum = {}));
function GlobalWalletConnectionStatusEnumFromJSON(json) {
  return GlobalWalletConnectionStatusEnumFromJSONTyped(json);
}
function GlobalWalletConnectionStatusEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GlobalWalletConnection.js
function GlobalWalletConnectionFromJSON(json) {
  return GlobalWalletConnectionFromJSONTyped(json);
}
function GlobalWalletConnectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "userId": json["userId"],
    "appUrl": json["appUrl"],
    "status": GlobalWalletConnectionStatusEnumFromJSON(json["status"]),
    "expiresAt": !exists(json, "expiresAt") ? void 0 : json["expiresAt"] === null ? null : new Date(json["expiresAt"]),
    "createdAt": new Date(json["createdAt"]),
    "updatedAt": !exists(json, "updatedAt") ? void 0 : new Date(json["updatedAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GlobalWalletConnectionCreateRequest.js
function GlobalWalletConnectionCreateRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "expiresAt": value.expiresAt.toISOString()
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GlobalWalletSettingsCustomMenuLinks.js
function GlobalWalletSettingsCustomMenuLinksFromJSON(json) {
  return GlobalWalletSettingsCustomMenuLinksFromJSONTyped(json);
}
function GlobalWalletSettingsCustomMenuLinksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "label": json["label"],
    "url": json["url"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/GlobalWalletSettings.js
function GlobalWalletSettingsFromJSON(json) {
  return GlobalWalletSettingsFromJSONTyped(json);
}
function GlobalWalletSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "walletName": json["walletName"],
    "popupPageTitle": !exists(json, "popupPageTitle") ? void 0 : json["popupPageTitle"],
    "walletIconUrl": !exists(json, "walletIconUrl") ? void 0 : json["walletIconUrl"],
    "customCssUrl": !exists(json, "customCssUrl") ? void 0 : json["customCssUrl"],
    "termsOfServiceUrl": !exists(json, "termsOfServiceUrl") ? void 0 : json["termsOfServiceUrl"],
    "privacyPolicyUrl": !exists(json, "privacyPolicyUrl") ? void 0 : json["privacyPolicyUrl"],
    "termsOfServiceAndPrivacyPolicyMarkdown": !exists(json, "termsOfServiceAndPrivacyPolicyMarkdown") ? void 0 : json["termsOfServiceAndPrivacyPolicyMarkdown"],
    "customMenuLinks": !exists(json, "customMenuLinks") ? void 0 : json["customMenuLinks"].map(GlobalWalletSettingsCustomMenuLinksFromJSON),
    "enableLoginWithExternalWallets": !exists(json, "enableLoginWithExternalWallets") ? void 0 : json["enableLoginWithExternalWallets"],
    "enabledAt": !exists(json, "enabledAt") ? void 0 : json["enabledAt"] === null ? null : new Date(json["enabledAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HealthcheckStatus.js
var HealthcheckStatus;
(function(HealthcheckStatus2) {
  HealthcheckStatus2["Healthy"] = "healthy";
  HealthcheckStatus2["Unhealthy"] = "unhealthy";
})(HealthcheckStatus || (HealthcheckStatus = {}));
function HealthcheckStatusFromJSON(json) {
  return HealthcheckStatusFromJSONTyped(json);
}
function HealthcheckStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HealthcheckResponse.js
function HealthcheckResponseFromJSON(json) {
  return HealthcheckResponseFromJSONTyped(json);
}
function HealthcheckResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "status": HealthcheckStatusFromJSON(json["status"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ImportWaasPrivateKeyRequest.js
function ImportWaasPrivateKeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": WaasChainEnumToJSON(value.chain),
    "clientKeygenIds": value.clientKeygenIds,
    "thresholdSignatureScheme": ThresholdSignatureSchemeToJSON(value.thresholdSignatureScheme)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitEmailAuthRequest.js
function InitEmailAuthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "turnkeyEmailAuthTargetPublicKey": value.turnkeyEmailAuthTargetPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitEmailAuthResponse.js
function InitEmailAuthResponseFromJSON(json) {
  return InitEmailAuthResponseFromJSONTyped(json);
}
function InitEmailAuthResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "turnkeyUserId": json["turnkeyUserId"],
    "turnkeyApiKeyId": json["turnkeyApiKeyId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitPasskeyRecoveryRequest.js
function InitPasskeyRecoveryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "turnkeyRecoveryTargetPublicKey": value.turnkeyRecoveryTargetPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/InitPasskeyRecoveryResponse.js
function InitPasskeyRecoveryResponseFromJSON(json) {
  return InitPasskeyRecoveryResponseFromJSONTyped(json);
}
function InitPasskeyRecoveryResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "turnkeyRecoveryUserId": json["turnkeyRecoveryUserId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwksKey.js
function JwksKeyFromJSON(json) {
  return JwksKeyFromJSONTyped(json);
}
function JwksKeyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "kid": !exists(json, "kid") ? void 0 : json["kid"],
    "alg": !exists(json, "alg") ? void 0 : json["alg"],
    "kty": !exists(json, "kty") ? void 0 : json["kty"],
    "use": !exists(json, "use") ? void 0 : json["use"],
    "e": !exists(json, "e") ? void 0 : json["e"],
    "n": !exists(json, "n") ? void 0 : json["n"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/JwksResponse.js
function JwksResponseFromJSON(json) {
  return JwksResponseFromJSONTyped(json);
}
function JwksResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "keys": json["keys"].map(JwksKeyFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFADeviceType.js
var MFADeviceType;
(function(MFADeviceType2) {
  MFADeviceType2["Totp"] = "totp";
  MFADeviceType2["Passkey"] = "passkey";
  MFADeviceType2["Email"] = "email";
})(MFADeviceType || (MFADeviceType = {}));
function MFADeviceTypeFromJSON(json) {
  return MFADeviceTypeFromJSONTyped(json);
}
function MFADeviceTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function MFADeviceTypeToJSON(value) {
  return value;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticationExtensionsClientOutputs.js
function AuthenticationExtensionsClientOutputsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "appid": value.appid,
    "credProps": value.credProps,
    "hmacCreateSecret": value.hmacCreateSecret
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorAssertionResponse.js
function AuthenticatorAssertionResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "clientDataJSON": value.clientDataJSON,
    "authenticatorData": value.authenticatorData,
    "signature": value.signature,
    "userHandle": value.userHandle
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyAuthRequest.js
function PasskeyAuthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "rawId": value.rawId,
    "response": AuthenticatorAssertionResponseToJSON(value.response),
    "authenticatorAttachment": AuthenticatorAttachmentToJSON(value.authenticatorAttachment),
    "clientExtensionResults": AuthenticationExtensionsClientOutputsToJSON(value.clientExtensionResults),
    "type": PublicKeyCredentialTypeToJSON(value.type),
    "createMfaToken": CreateMfaTokenToJSON(value.createMfaToken)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthRecoveryDevicePostRequest.js
function MFAAuthRecoveryDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "createMfaToken": CreateMfaTokenToJSON(value.createMfaToken),
    "code": value.code
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAAuthTotpDevicePostRequest.js
function MFAAuthTotpDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "createMfaToken": CreateMfaTokenToJSON(value.createMfaToken),
    "code": value.code
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFADevice.js
function MFADeviceFromJSON(json) {
  return MFADeviceFromJSONTyped(json);
}
function MFADeviceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": !exists(json, "type") ? void 0 : MFADeviceTypeFromJSON(json["type"]),
    "verified": !exists(json, "verified") ? void 0 : json["verified"],
    "id": !exists(json, "id") ? void 0 : json["id"],
    "createdAt": !exists(json, "createdAt") ? void 0 : new Date(json["createdAt"]),
    "verifiedAt": !exists(json, "verifiedAt") ? void 0 : json["verifiedAt"] === null ? null : new Date(json["verifiedAt"]),
    "_default": !exists(json, "default") ? void 0 : json["default"],
    "alias": !exists(json, "alias") ? void 0 : json["alias"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAGetRecoveryCodesResponse.js
function MFAGetRecoveryCodesResponseFromJSON(json) {
  return MFAGetRecoveryCodesResponseFromJSONTyped(json);
}
function MFAGetRecoveryCodesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "recoveryCodes": json["recoveryCodes"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAListDevicesResponse.js
function MFAListDevicesResponseFromJSON(json) {
  return MFAListDevicesResponseFromJSONTyped(json);
}
function MFAListDevicesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "devices": json["devices"].map(MFADeviceFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAMethodsResponse.js
function MFAMethodsResponseFromJSON(json) {
  return MFAMethodsResponseFromJSONTyped(json);
}
function MFAMethodsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "devices": json["devices"].map(MFADeviceFromJSON),
    "passkeys": json["passkeys"].map(UserPasskeyFromJSON),
    "userHasVerifiedMfaMethods": json["userHasVerifiedMfaMethods"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegenRecoveryCodesResponse.js
function MFARegenRecoveryCodesResponseFromJSON(json) {
  return MFARegenRecoveryCodesResponseFromJSONTyped(json);
}
function MFARegenRecoveryCodesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "count": json["count"],
    "recoveryCodes": json["recoveryCodes"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticationExtensionsClientInputs.js
function AuthenticationExtensionsClientInputsFromJSON(json) {
  return AuthenticationExtensionsClientInputsFromJSONTyped(json);
}
function AuthenticationExtensionsClientInputsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "appid": !exists(json, "appid") ? void 0 : json["appid"],
    "credProps": !exists(json, "credProps") ? void 0 : json["credProps"],
    "hmacCreateSecret": !exists(json, "hmacCreateSecret") ? void 0 : json["hmacCreateSecret"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialDescriptor.js
function PublicKeyCredentialDescriptorFromJSON(json) {
  return PublicKeyCredentialDescriptorFromJSONTyped(json);
}
function PublicKeyCredentialDescriptorFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": PublicKeyCredentialTypeFromJSON(json["type"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialRpEntity.js
function PublicKeyCredentialRpEntityFromJSON(json) {
  return PublicKeyCredentialRpEntityFromJSONTyped(json);
}
function PublicKeyCredentialRpEntityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": !exists(json, "id") ? void 0 : json["id"],
    "name": json["name"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublicKeyCredentialUserEntity.js
function PublicKeyCredentialUserEntityFromJSON(json) {
  return PublicKeyCredentialUserEntityFromJSONTyped(json);
}
function PublicKeyCredentialUserEntityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "name": json["name"],
    "displayName": json["displayName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterPasskeyDeviceGetResponseRegistration.js
function MFARegisterPasskeyDeviceGetResponseRegistrationFromJSON(json) {
  return MFARegisterPasskeyDeviceGetResponseRegistrationFromJSONTyped(json);
}
function MFARegisterPasskeyDeviceGetResponseRegistrationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "attestation": !exists(json, "attestation") ? void 0 : AttestationConveyancePreferenceFromJSON(json["attestation"]),
    "rp": PublicKeyCredentialRpEntityFromJSON(json["rp"]),
    "user": PublicKeyCredentialUserEntityFromJSON(json["user"]),
    "challenge": json["challenge"],
    "pubKeyCredParams": json["pubKeyCredParams"].map(PublicKeyCredentialParametersFromJSON),
    "timeout": !exists(json, "timeout") ? void 0 : json["timeout"],
    "authenticatorSelection": !exists(json, "authenticatorSelection") ? void 0 : AuthenticatorSelectionCriteriaFromJSON(json["authenticatorSelection"]),
    "excludeCredentials": !exists(json, "excludeCredentials") ? void 0 : json["excludeCredentials"].map(PublicKeyCredentialDescriptorFromJSON),
    "extensions": !exists(json, "extensions") ? void 0 : AuthenticationExtensionsClientInputsFromJSON(json["extensions"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterPasskeyDeviceGetResponse.js
function MFARegisterPasskeyDeviceGetResponseFromJSON(json) {
  return MFARegisterPasskeyDeviceGetResponseFromJSONTyped(json);
}
function MFARegisterPasskeyDeviceGetResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": MFADeviceTypeFromJSON(json["type"]),
    "registration": MFARegisterPasskeyDeviceGetResponseRegistrationFromJSON(json["registration"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthenticatorAttestationResponse.js
function AuthenticatorAttestationResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "clientDataJSON": value.clientDataJSON,
    "attestationObject": value.attestationObject,
    "authenticatorData": value.authenticatorData,
    "publicKeyAlgorithm": value.publicKeyAlgorithm,
    "publicKey": value.publicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRegisterVerifyRequest.js
function PasskeyRegisterVerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "rawId": value.rawId,
    "response": AuthenticatorAttestationResponseToJSON(value.response),
    "authenticatorAttachment": AuthenticatorAttachmentToJSON(value.authenticatorAttachment),
    "clientExtensionResults": AuthenticationExtensionsClientOutputsToJSON(value.clientExtensionResults),
    "type": PublicKeyCredentialTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterPasskeyDevicePostRequest.js
function MFARegisterPasskeyDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "attestation": PasskeyRegisterVerifyRequestToJSON(value.attestation)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterTotpDeviceGetResponse.js
function MFARegisterTotpDeviceGetResponseFromJSON(json) {
  return MFARegisterTotpDeviceGetResponseFromJSONTyped(json);
}
function MFARegisterTotpDeviceGetResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "type": MFADeviceTypeFromJSON(json["type"]),
    "secret": json["secret"],
    "uri": json["uri"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFARegisterTotpDevicePostRequest.js
function MFARegisterTotpDevicePostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "type": MFADeviceTypeToJSON(value.type),
    "code": value.code
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFAUpdateDeviceRequest.js
function MFAUpdateDeviceRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "default": value._default
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MergeUserConflictResolution.js
function MergeUserConflictResolutionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "userId": value.userId,
    "fieldKey": value.fieldKey,
    "type": KycFieldTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MergeUserConflictResolutions.js
function MergeUserConflictResolutionsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mergeUserResolutions": value.mergeUserResolutions === void 0 ? void 0 : value.mergeUserResolutions.map(MergeUserConflictResolutionToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TokenBalance.js
function TokenBalanceFromJSON(json) {
  return TokenBalanceFromJSONTyped(json);
}
function TokenBalanceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "networkId": !exists(json, "networkId") ? void 0 : json["networkId"],
    "address": json["address"],
    "name": json["name"],
    "symbol": json["symbol"],
    "decimals": json["decimals"],
    "logoURI": json["logoURI"],
    "balance": json["balance"],
    "rawBalance": json["rawBalance"],
    "price": !exists(json, "price") ? void 0 : json["price"],
    "marketValue": !exists(json, "marketValue") ? void 0 : json["marketValue"],
    "liquidityPoolSizeUsd": !exists(json, "liquidityPoolSizeUsd") ? void 0 : json["liquidityPoolSizeUsd"],
    "isNative": !exists(json, "isNative") ? void 0 : json["isNative"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MultichainAccountBalanceResponseNetworks.js
function MultichainAccountBalanceResponseNetworksFromJSON(json) {
  return MultichainAccountBalanceResponseNetworksFromJSONTyped(json);
}
function MultichainAccountBalanceResponseNetworksFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "networkId": !exists(json, "networkId") ? void 0 : json["networkId"],
    "balances": !exists(json, "balances") ? void 0 : json["balances"].map(TokenBalanceFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MultichainAccountBalanceResponseChainBalances.js
function MultichainAccountBalanceResponseChainBalancesFromJSON(json) {
  return MultichainAccountBalanceResponseChainBalancesFromJSONTyped(json);
}
function MultichainAccountBalanceResponseChainBalancesFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletAddress": json["walletAddress"],
    "chain": ChainEnumFromJSON(json["chain"]),
    "networks": json["networks"].map(MultichainAccountBalanceResponseNetworksFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MultichainAccountBalanceResponse.js
function MultichainAccountBalanceResponseFromJSON(json) {
  return MultichainAccountBalanceResponseFromJSONTyped(json);
}
function MultichainAccountBalanceResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainBalances": json["chainBalances"].map(MultichainAccountBalanceResponseChainBalancesFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MultichainAccountBalancesRequestBalanceRequests.js
function MultichainAccountBalancesRequestBalanceRequestsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "chain": ChainEnumToJSON(value.chain),
    "networkIds": value.networkIds,
    "whitelistedContracts": value.whitelistedContracts
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MultichainAccountBalancesRequest.js
function MultichainAccountBalancesRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "filterSpamTokens": value.filterSpamTokens,
    "balanceRequests": value.balanceRequests.map(MultichainAccountBalancesRequestBalanceRequestsToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Network.js
var NetworkTypeEnum;
(function(NetworkTypeEnum2) {
  NetworkTypeEnum2["Custom"] = "custom";
  NetworkTypeEnum2["Default"] = "default";
})(NetworkTypeEnum || (NetworkTypeEnum = {}));
function NetworkFromJSON(json) {
  return NetworkFromJSONTyped(json);
}
function NetworkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "networkId": json["networkId"],
    "chainName": json["chainName"],
    "enabled": json["enabled"],
    "rpcUrl": !exists(json, "rpcUrl") ? void 0 : json["rpcUrl"],
    "iconUrl": !exists(json, "iconUrl") ? void 0 : json["iconUrl"],
    "type": !exists(json, "type") ? void 0 : json["type"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NameService.js
function NameServiceFromJSON(json) {
  return NameServiceFromJSONTyped(json);
}
function NameServiceFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "registry": !exists(json, "registry") ? void 0 : json["registry"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NativeCurrency.js
function NativeCurrencyFromJSON(json) {
  return NativeCurrencyFromJSONTyped(json);
}
function NativeCurrencyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "decimals": json["decimals"],
    "name": json["name"],
    "symbol": json["symbol"],
    "denom": !exists(json, "denom") ? void 0 : json["denom"],
    "iconUrl": !exists(json, "iconUrl") ? void 0 : json["iconUrl"],
    "pricingProviderTokenId": !exists(json, "pricingProviderTokenId") ? void 0 : json["pricingProviderTokenId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NetworkConfiguration.js
function NetworkConfigurationFromJSON(json) {
  return NetworkConfigurationFromJSONTyped(json);
}
function NetworkConfigurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "lcdUrl": !exists(json, "lcdUrl") ? void 0 : json["lcdUrl"],
    "chainName": !exists(json, "chainName") ? void 0 : json["chainName"],
    "key": !exists(json, "key") ? void 0 : json["key"],
    "name": json["name"],
    "shortName": json["shortName"],
    "isTestnet": !exists(json, "isTestnet") ? void 0 : json["isTestnet"],
    "chain": json["chain"],
    "chainId": json["chainId"],
    "nameService": !exists(json, "nameService") ? void 0 : NameServiceFromJSON(json["nameService"]),
    "networkId": json["networkId"],
    "iconUrls": json["iconUrls"],
    "nativeCurrency": NativeCurrencyFromJSON(json["nativeCurrency"]),
    "rpcUrls": json["rpcUrls"],
    "privateCustomerRpcUrls": !exists(json, "privateCustomerRpcUrls") ? void 0 : json["privateCustomerRpcUrls"],
    "blockExplorerUrls": json["blockExplorerUrls"],
    "vanityName": !exists(json, "vanityName") ? void 0 : json["vanityName"],
    "bech32Prefix": !exists(json, "bech32Prefix") ? void 0 : json["bech32Prefix"],
    "genesisHash": !exists(json, "genesisHash") ? void 0 : json["genesisHash"],
    "cluster": !exists(json, "cluster") ? void 0 : json["cluster"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NetworkConfigurationResponse.js
function NetworkConfigurationResponseFromJSON(json) {
  return NetworkConfigurationResponseFromJSONTyped(json);
}
function NetworkConfigurationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainName": !exists(json, "chainName") ? void 0 : json["chainName"],
    "networks": !exists(json, "networks") ? void 0 : json["networks"].map(NetworkConfigurationFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NextViewEnum.js
var NextViewEnum;
(function(NextViewEnum2) {
  NextViewEnum2["Done"] = "done";
  NextViewEnum2["VerifyEmail"] = "verify-email";
  NextViewEnum2["VerifiedAndTransferred"] = "verified-and-transferred";
  NextViewEnum2["VerifySms"] = "verify-sms";
})(NextViewEnum || (NextViewEnum = {}));
function NextViewEnumFromJSON(json) {
  return NextViewEnumFromJSONTyped(json);
}
function NextViewEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NonceResponse.js
function NonceResponseFromJSON(json) {
  return NonceResponseFromJSONTyped(json);
}
function NonceResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nonce": !exists(json, "nonce") ? void 0 : json["nonce"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthInitAuthRequest.js
function OauthInitAuthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "state": value.state,
    "redirectUrl": value.redirectUrl,
    "ssoProviderId": value.ssoProviderId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthProviderLoginUrl.js
function OauthProviderLoginUrlFromJSON(json) {
  return OauthProviderLoginUrlFromJSONTyped(json);
}
function OauthProviderLoginUrlFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "url": json["url"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthRequest.js
function OauthRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "code": value.code,
    "codeVerifier": value.codeVerifier,
    "state": value.state,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey,
    "ssoProviderId": value.ssoProviderId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthResultRequest.js
function OauthResultRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "state": value.state,
    "telegramAuthToken": value.telegramAuthToken,
    "forceCreateUser": value.forceCreateUser,
    "code": value.code,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthResultStatus.js
var OauthResultStatus;
(function(OauthResultStatus2) {
  OauthResultStatus2["Pending"] = "pending";
  OauthResultStatus2["Completed"] = "completed";
})(OauthResultStatus || (OauthResultStatus = {}));
function OauthResultStatusFromJSON(json) {
  return OauthResultStatusFromJSONTyped(json);
}
function OauthResultStatusFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthResultResponse.js
function OauthResultResponseFromJSON(json) {
  return OauthResultResponseFromJSONTyped(json);
}
function OauthResultResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "code": !exists(json, "code") ? void 0 : json["code"],
    "error": !exists(json, "error") ? void 0 : json["error"],
    "status": OauthResultStatusFromJSON(json["status"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OpenRoomResponse.js
function OpenRoomResponseFromJSON(json) {
  return OpenRoomResponseFromJSONTyped(json);
}
function OpenRoomResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "roomId": json["roomId"],
    "serverKeygenIds": !exists(json, "serverKeygenIds") ? void 0 : json["serverKeygenIds"],
    "newServerKeygenIds": !exists(json, "newServerKeygenIds") ? void 0 : json["newServerKeygenIds"],
    "walletId": !exists(json, "walletId") ? void 0 : json["walletId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OpenRoomResponseForReshare.js
function OpenRoomResponseForReshareFromJSON(json) {
  return OpenRoomResponseForReshareFromJSONTyped(json);
}
function OpenRoomResponseForReshareFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "roomId": json["roomId"],
    "serverKeygenIds": json["serverKeygenIds"],
    "newServerKeygenIds": json["newServerKeygenIds"],
    "walletId": !exists(json, "walletId") ? void 0 : json["walletId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OpenRoomResponseWithServerKeygenIds.js
function OpenRoomResponseWithServerKeygenIdsFromJSON(json) {
  return OpenRoomResponseWithServerKeygenIdsFromJSONTyped(json);
}
function OpenRoomResponseWithServerKeygenIdsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "roomId": json["roomId"],
    "serverKeygenIds": json["serverKeygenIds"],
    "newServerKeygenIds": !exists(json, "newServerKeygenIds") ? void 0 : json["newServerKeygenIds"],
    "walletId": !exists(json, "walletId") ? void 0 : json["walletId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRegistrationCredentialV2.js
function PasskeyRegistrationCredentialV2ToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "attestationObject": value.attestationObject,
    "clientDataJson": value.clientDataJson,
    "transports": value.transports === void 0 ? void 0 : value.transports.map(PasskeyTransportToJSON),
    "publicKey": value.publicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PasskeyRegisterRequest.js
function PasskeyRegisterRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "rawId": value.rawId,
    "response": PasskeyRegistrationCredentialV2ToJSON(value.response),
    "clientExtensionResults": AuthenticationExtensionsClientOutputsToJSON(value.clientExtensionResults),
    "authenticatorAttachment": AuthenticatorAttachmentToJSON(value.authenticatorAttachment),
    "type": PasskeyCredentialTypeToJSON(value.type)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PrefetchRequest.js
function PrefetchRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": ChainEnumToJSON(value.chain),
    "publicWalletAddress": value.publicWalletAddress
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Exchange.js
function ExchangeFromJSON(json) {
  return ExchangeFromJSONTyped(json);
}
function ExchangeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": !exists(json, "id") ? void 0 : json["id"],
    "exchange": ExchangeKeyEnumFromJSON(json["exchange"]),
    "enabledAt": !exists(json, "enabledAt") ? void 0 : json["enabledAt"] === null ? null : new Date(json["enabledAt"]),
    "socialProvider": !exists(json, "socialProvider") ? void 0 : ProviderEnumFromJSON(json["socialProvider"]),
    "onRampProvider": !exists(json, "onRampProvider") ? void 0 : ProviderEnumFromJSON(json["onRampProvider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsChains.js
function ProjectSettingsChainsFromJSON(json) {
  return ProjectSettingsChainsFromJSONTyped(json);
}
function ProjectSettingsChainsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "enabled": json["enabled"],
    "networks": !exists(json, "networks") ? void 0 : json["networks"].map(NetworkFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesignButton.js
function ProjectSettingsDesignButtonFromJSON(json) {
  return ProjectSettingsDesignButtonFromJSONTyped(json);
}
function ProjectSettingsDesignButtonFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "background": !exists(json, "background") ? void 0 : json["background"],
    "fontColor": !exists(json, "fontColor") ? void 0 : json["fontColor"],
    "paddingHeight": !exists(json, "paddingHeight") ? void 0 : json["paddingHeight"],
    "paddingWidth": !exists(json, "paddingWidth") ? void 0 : json["paddingWidth"],
    "radius": !exists(json, "radius") ? void 0 : json["radius"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesignModal.js
function ProjectSettingsDesignModalFromJSON(json) {
  return ProjectSettingsDesignModalFromJSONTyped(json);
}
function ProjectSettingsDesignModalFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "border": !exists(json, "border") ? void 0 : json["border"],
    "brand": !exists(json, "brand") ? void 0 : json["brand"],
    "primaryColor": !exists(json, "primaryColor") ? void 0 : json["primaryColor"],
    "radius": !exists(json, "radius") ? void 0 : json["radius"],
    "theme": !exists(json, "theme") ? void 0 : json["theme"],
    "view": !exists(json, "view") ? void 0 : json["view"],
    "template": !exists(json, "template") ? void 0 : json["template"],
    "displayOrder": !exists(json, "displayOrder") ? void 0 : json["displayOrder"],
    "emailOnly": !exists(json, "emailOnly") ? void 0 : json["emailOnly"],
    "showWalletsButton": !exists(json, "showWalletsButton") ? void 0 : json["showWalletsButton"],
    "emailSubmitButtonInsideInput": !exists(json, "emailSubmitButtonInsideInput") ? void 0 : json["emailSubmitButtonInsideInput"],
    "splitEmailAndSocial": !exists(json, "splitEmailAndSocial") ? void 0 : json["splitEmailAndSocial"],
    "socialAboveEmail": !exists(json, "socialAboveEmail") ? void 0 : json["socialAboveEmail"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesignWidget.js
function ProjectSettingsDesignWidgetFromJSON(json) {
  return ProjectSettingsDesignWidgetFromJSONTyped(json);
}
function ProjectSettingsDesignWidgetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "backgroundColor": !exists(json, "backgroundColor") ? void 0 : json["backgroundColor"],
    "border": !exists(json, "border") ? void 0 : json["border"],
    "radius": !exists(json, "radius") ? void 0 : json["radius"],
    "textColor": !exists(json, "textColor") ? void 0 : json["textColor"],
    "theme": !exists(json, "theme") ? void 0 : json["theme"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsDesign.js
function ProjectSettingsDesignFromJSON(json) {
  return ProjectSettingsDesignFromJSONTyped(json);
}
function ProjectSettingsDesignFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "modal": !exists(json, "modal") ? void 0 : ProjectSettingsDesignModalFromJSON(json["modal"]),
    "button": !exists(json, "button") ? void 0 : ProjectSettingsDesignButtonFromJSON(json["button"]),
    "widget": !exists(json, "widget") ? void 0 : ProjectSettingsDesignWidgetFromJSON(json["widget"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsGeneral.js
function ProjectSettingsGeneralFromJSON(json) {
  return ProjectSettingsGeneralFromJSONTyped(json);
}
function ProjectSettingsGeneralFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "displayName": !exists(json, "displayName") ? void 0 : json["displayName"],
    "supportEmail": !exists(json, "supportEmail") ? void 0 : json["supportEmail"],
    "supportText": !exists(json, "supportText") ? void 0 : json["supportText"],
    "appLogo": !exists(json, "appLogo") ? void 0 : json["appLogo"],
    "imageUserNotInAccessList": !exists(json, "imageUserNotInAccessList") ? void 0 : json["imageUserNotInAccessList"],
    "imageUserInAccessList": !exists(json, "imageUserInAccessList") ? void 0 : json["imageUserInAccessList"],
    "supportUrls": !exists(json, "supportUrls") ? void 0 : json["supportUrls"],
    "collectUserDataWelcomeHeader": !exists(json, "collectUserDataWelcomeHeader") ? void 0 : json["collectUserDataWelcomeHeader"],
    "collectUserDataWelcomeMessage": !exists(json, "collectUserDataWelcomeMessage") ? void 0 : json["collectUserDataWelcomeMessage"],
    "skipOptionalKYCFieldDuringOnboarding": !exists(json, "skipOptionalKYCFieldDuringOnboarding") ? void 0 : json["skipOptionalKYCFieldDuringOnboarding"],
    "emailCompanyName": !exists(json, "emailCompanyName") ? void 0 : json["emailCompanyName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsPrivacy.js
function ProjectSettingsPrivacyFromJSON(json) {
  return ProjectSettingsPrivacyFromJSONTyped(json);
}
function ProjectSettingsPrivacyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "collectIp": !exists(json, "collectIp") ? void 0 : json["collectIp"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExchangeOption.js
function ExchangeOptionFromJSON(json) {
  return ExchangeOptionFromJSONTyped(json);
}
function ExchangeOptionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "exchange": ExchangeKeyEnumFromJSON(json["exchange"]),
    "socialProvider": !exists(json, "socialProvider") ? void 0 : ProviderEnumFromJSON(json["socialProvider"]),
    "onRampProvider": !exists(json, "onRampProvider") ? void 0 : ProviderEnumFromJSON(json["onRampProvider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FeatureFlags.js
function FeatureFlagsFromJSON(json) {
  return FeatureFlagsFromJSONTyped(json);
}
function FeatureFlagsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "connectOnlyMultiAsset": json["connectOnlyMultiAsset"],
    "enableExchanges": json["enableExchanges"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalWalletFundingDefaultSettingsToken.js
function ExternalWalletFundingDefaultSettingsTokenFromJSON(json) {
  return ExternalWalletFundingDefaultSettingsTokenFromJSONTyped(json);
}
function ExternalWalletFundingDefaultSettingsTokenFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "value": !exists(json, "value") ? void 0 : json["value"],
    "rule": !exists(json, "rule") ? void 0 : ExternalWalletFundingTokenRuleFromJSON(json["rule"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalWalletFundingDefaultSettings.js
function ExternalWalletFundingDefaultSettingsFromJSON(json) {
  return ExternalWalletFundingDefaultSettingsFromJSONTyped(json);
}
function ExternalWalletFundingDefaultSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chain": !exists(json, "chain") ? void 0 : ChainEnumFromJSON(json["chain"]),
    "token": !exists(json, "token") ? void 0 : ExternalWalletFundingDefaultSettingsTokenFromJSON(json["token"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FundingExternalWalletsDefaultSettings.js
function FundingExternalWalletsDefaultSettingsFromJSON(json) {
  return FundingExternalWalletsDefaultSettingsFromJSONTyped(json);
}
function FundingExternalWalletsDefaultSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "chainSettings": !exists(json, "chainSettings") ? void 0 : json["chainSettings"].map(ExternalWalletFundingDefaultSettingsFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FundingExternalWalletsMinAmount.js
function FundingExternalWalletsMinAmountFromJSON(json) {
  return FundingExternalWalletsMinAmountFromJSONTyped(json);
}
function FundingExternalWalletsMinAmountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": !exists(json, "amount") ? void 0 : json["amount"],
    "currency": !exists(json, "currency") ? void 0 : json["currency"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FundingExternalWallets.js
function FundingExternalWalletsFromJSON(json) {
  return FundingExternalWalletsFromJSONTyped(json);
}
function FundingExternalWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": json["enabled"],
    "minAmount": !exists(json, "minAmount") ? void 0 : FundingExternalWalletsMinAmountFromJSON(json["minAmount"]),
    "defaultSettings": !exists(json, "defaultSettings") ? void 0 : FundingExternalWalletsDefaultSettingsFromJSON(json["defaultSettings"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Funding.js
function FundingFromJSON(json) {
  return FundingFromJSONTyped(json);
}
function FundingFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "onramps": json["onramps"].map(OnrampProvidersFromJSON),
    "externalWallets": !exists(json, "externalWallets") ? void 0 : FundingExternalWalletsFromJSON(json["externalWallets"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MobileSettings.js
function MobileSettingsFromJSON(json) {
  return MobileSettingsFromJSONTyped(json);
}
function MobileSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "deeplinkUrlsEnabled": !exists(json, "deeplinkUrlsEnabled") ? void 0 : json["deeplinkUrlsEnabled"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NameServiceSdkSettingsEvm.js
function NameServiceSdkSettingsEvmFromJSON(json) {
  return NameServiceSdkSettingsEvmFromJSONTyped(json);
}
function NameServiceSdkSettingsEvmFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "domain": !exists(json, "domain") ? void 0 : json["domain"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NameServiceSdkSettings.js
function NameServiceSdkSettingsFromJSON(json) {
  return NameServiceSdkSettingsFromJSONTyped(json);
}
function NameServiceSdkSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "evm": NameServiceSdkSettingsEvmFromJSON(json["evm"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkAccountAbstraction.js
function ProjectSettingsSdkAccountAbstractionFromJSON(json) {
  return ProjectSettingsSdkAccountAbstractionFromJSONTyped(json);
}
function ProjectSettingsSdkAccountAbstractionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "allWallets": !exists(json, "allWallets") ? void 0 : json["allWallets"],
    "allUsers": !exists(json, "allUsers") ? void 0 : json["allUsers"],
    "separateSmartWalletAndSigner": !exists(json, "separateSmartWalletAndSigner") ? void 0 : json["separateSmartWalletAndSigner"],
    "enablePasskeys": !exists(json, "enablePasskeys") ? void 0 : json["enablePasskeys"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignInProviderEnum.js
var SignInProviderEnum;
(function(SignInProviderEnum2) {
  SignInProviderEnum2["Dynamic"] = "dynamic";
  SignInProviderEnum2["MagicLink"] = "magicLink";
  SignInProviderEnum2["Blocto"] = "blocto";
  SignInProviderEnum2["Turnkey"] = "turnkey";
  SignInProviderEnum2["CoinbaseWaas"] = "coinbaseWaas";
})(SignInProviderEnum || (SignInProviderEnum = {}));
function SignInProviderEnumFromJSON(json) {
  return SignInProviderEnumFromJSONTyped(json);
}
function SignInProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkEmailSignIn.js
function ProjectSettingsSdkEmailSignInFromJSON(json) {
  return ProjectSettingsSdkEmailSignInFromJSONTyped(json);
}
function ProjectSettingsSdkEmailSignInFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signInProvider": !exists(json, "signInProvider") ? void 0 : SignInProviderEnumFromJSON(json["signInProvider"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ChainConfiguration.js
function ChainConfigurationFromJSON(json) {
  return ChainConfigurationFromJSONTyped(json);
}
function ChainConfigurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "name": json["name"],
    "enabled": json["enabled"],
    "primary": json["primary"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Duration.js
function DurationFromJSON(json) {
  return DurationFromJSONTyped(json);
}
function DurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "unit": TimeUnitEnumFromJSON(json["unit"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedSecurityMethod.js
function SupportedSecurityMethodFromJSON(json) {
  return SupportedSecurityMethodFromJSONTyped(json);
}
function SupportedSecurityMethodFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isDefault": json["isDefault"],
    "isEnabled": json["isEnabled"],
    "isPermanentAuthenticator": json["isPermanentAuthenticator"],
    "listPosition": json["listPosition"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedSecurityMethods.js
function SupportedSecurityMethodsFromJSON(json) {
  return SupportedSecurityMethodsFromJSONTyped(json);
}
function SupportedSecurityMethodsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "passkey": !exists(json, "passkey") ? void 0 : SupportedSecurityMethodFromJSON(json["passkey"]),
    "email": !exists(json, "email") ? void 0 : SupportedSecurityMethodFromJSON(json["email"]),
    "password": !exists(json, "password") ? void 0 : SupportedSecurityMethodFromJSON(json["password"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkEmbeddedWallets.js
function ProjectSettingsSdkEmbeddedWalletsFromJSON(json) {
  return ProjectSettingsSdkEmbeddedWalletsFromJSONTyped(json);
}
function ProjectSettingsSdkEmbeddedWalletsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "automaticEmbeddedWalletCreation": !exists(json, "automaticEmbeddedWalletCreation") ? void 0 : json["automaticEmbeddedWalletCreation"],
    "automaticEmbeddedWalletCreationForExternal": !exists(json, "automaticEmbeddedWalletCreationForExternal") ? void 0 : json["automaticEmbeddedWalletCreationForExternal"],
    "showEmbeddedWalletActionsUI": !exists(json, "showEmbeddedWalletActionsUI") ? void 0 : json["showEmbeddedWalletActionsUI"],
    "emailRecoveryEnabled": !exists(json, "emailRecoveryEnabled") ? void 0 : json["emailRecoveryEnabled"],
    "forceAuthenticatorAtSignup": !exists(json, "forceAuthenticatorAtSignup") ? void 0 : json["forceAuthenticatorAtSignup"],
    "allowSkippingAuthenticatorAtSignup": !exists(json, "allowSkippingAuthenticatorAtSignup") ? void 0 : json["allowSkippingAuthenticatorAtSignup"],
    "sessionKeyDuration": !exists(json, "sessionKeyDuration") ? void 0 : DurationFromJSON(json["sessionKeyDuration"]),
    "supportedSecurityMethods": !exists(json, "supportedSecurityMethods") ? void 0 : SupportedSecurityMethodsFromJSON(json["supportedSecurityMethods"]),
    "chainConfigurations": !exists(json, "chainConfigurations") ? void 0 : json["chainConfigurations"].map(ChainConfigurationFromJSON),
    "domainEnabledByProvider": !exists(json, "domainEnabledByProvider") ? void 0 : json["domainEnabledByProvider"],
    "defaultWalletVersion": !exists(json, "defaultWalletVersion") ? void 0 : EmbeddedWalletVersionEnumFromJSON(json["defaultWalletVersion"]),
    "promptForKeyExport": !exists(json, "promptForKeyExport") ? void 0 : json["promptForKeyExport"],
    "transactionSimulation": !exists(json, "transactionSimulation") ? void 0 : json["transactionSimulation"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SocialSignInProviderEnum.js
var SocialSignInProviderEnum;
(function(SocialSignInProviderEnum2) {
  SocialSignInProviderEnum2["Apple"] = "apple";
  SocialSignInProviderEnum2["Bitbucket"] = "bitbucket";
  SocialSignInProviderEnum2["Coinbasesocial"] = "coinbasesocial";
  SocialSignInProviderEnum2["Discord"] = "discord";
  SocialSignInProviderEnum2["Epicgames"] = "epicgames";
  SocialSignInProviderEnum2["Facebook"] = "facebook";
  SocialSignInProviderEnum2["Farcaster"] = "farcaster";
  SocialSignInProviderEnum2["Github"] = "github";
  SocialSignInProviderEnum2["Gitlab"] = "gitlab";
  SocialSignInProviderEnum2["Google"] = "google";
  SocialSignInProviderEnum2["Instagram"] = "instagram";
  SocialSignInProviderEnum2["Linkedin"] = "linkedin";
  SocialSignInProviderEnum2["Microsoft"] = "microsoft";
  SocialSignInProviderEnum2["Twitch"] = "twitch";
  SocialSignInProviderEnum2["Twitter"] = "twitter";
  SocialSignInProviderEnum2["Telegram"] = "telegram";
  SocialSignInProviderEnum2["Spotify"] = "spotify";
  SocialSignInProviderEnum2["Tiktok"] = "tiktok";
  SocialSignInProviderEnum2["Line"] = "line";
  SocialSignInProviderEnum2["Steam"] = "steam";
  SocialSignInProviderEnum2["Shopify"] = "shopify";
  SocialSignInProviderEnum2["Kraken"] = "kraken";
  SocialSignInProviderEnum2["Okta"] = "okta";
})(SocialSignInProviderEnum || (SocialSignInProviderEnum = {}));
function SocialSignInProviderEnumFromJSON(json) {
  return SocialSignInProviderEnumFromJSONTyped(json);
}
function SocialSignInProviderEnumFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SocialSignInProvider.js
function SocialSignInProviderFromJSON(json) {
  return SocialSignInProviderFromJSONTyped(json);
}
function SocialSignInProviderFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "provider": SocialSignInProviderEnumFromJSON(json["provider"]),
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkSocialSignIn.js
function ProjectSettingsSdkSocialSignInFromJSON(json) {
  return ProjectSettingsSdkSocialSignInFromJSONTyped(json);
}
function ProjectSettingsSdkSocialSignInFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "signInProvider": !exists(json, "signInProvider") ? void 0 : SignInProviderEnumFromJSON(json["signInProvider"]),
    "providers": !exists(json, "providers") ? void 0 : json["providers"].map(SocialSignInProviderFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkWaasDelegatedAccess.js
function ProjectSettingsSdkWaasDelegatedAccessFromJSON(json) {
  return ProjectSettingsSdkWaasDelegatedAccessFromJSONTyped(json);
}
function ProjectSettingsSdkWaasDelegatedAccessFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "promptUsersOnSignIn": !exists(json, "promptUsersOnSignIn") ? void 0 : json["promptUsersOnSignIn"],
    "requiresDelegation": !exists(json, "requiresDelegation") ? void 0 : json["requiresDelegation"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkWaasOnSignUp.js
function ProjectSettingsSdkWaasOnSignUpFromJSON(json) {
  return ProjectSettingsSdkWaasOnSignUpFromJSONTyped(json);
}
function ProjectSettingsSdkWaasOnSignUpFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "promptBackupOptions": json["promptBackupOptions"],
    "promptClientShareExport": json["promptClientShareExport"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkWaas.js
function ProjectSettingsSdkWaasFromJSON(json) {
  return ProjectSettingsSdkWaasFromJSONTyped(json);
}
function ProjectSettingsSdkWaasFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "allowMultipleWaasWalletsPerChain": !exists(json, "allowMultipleWaasWalletsPerChain") ? void 0 : json["allowMultipleWaasWalletsPerChain"],
    "passcodeRequired": json["passcodeRequired"],
    "onSignUp": ProjectSettingsSdkWaasOnSignUpFromJSON(json["onSignUp"]),
    "backupOptions": json["backupOptions"].map(WaasBackupOptionsEnumFromJSON),
    "relayUrl": !exists(json, "relayUrl") ? void 0 : json["relayUrl"],
    "delegatedAccessEndpoint": !exists(json, "delegatedAccessEndpoint") ? void 0 : json["delegatedAccessEndpoint"],
    "delegatedAccess": !exists(json, "delegatedAccess") ? void 0 : ProjectSettingsSdkWaasDelegatedAccessFromJSON(json["delegatedAccess"]),
    "enableForwardMPCClient": !exists(json, "enableForwardMPCClient") ? void 0 : json["enableForwardMPCClient"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdkWalletConnect.js
function ProjectSettingsSdkWalletConnectFromJSON(json) {
  return ProjectSettingsSdkWalletConnectFromJSONTyped(json);
}
function ProjectSettingsSdkWalletConnectFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "projectId": !exists(json, "projectId") ? void 0 : json["projectId"],
    "v2Enabled": !exists(json, "v2Enabled") ? void 0 : json["v2Enabled"],
    "walletProjectId": !exists(json, "walletProjectId") ? void 0 : json["walletProjectId"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewSectionAlignment.js
var SdkViewSectionAlignment;
(function(SdkViewSectionAlignment2) {
  SdkViewSectionAlignment2["Center"] = "center";
  SdkViewSectionAlignment2["Left"] = "left";
  SdkViewSectionAlignment2["Right"] = "right";
})(SdkViewSectionAlignment || (SdkViewSectionAlignment = {}));
function SdkViewSectionAlignmentFromJSON(json) {
  return SdkViewSectionAlignmentFromJSONTyped(json);
}
function SdkViewSectionAlignmentFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewSectionType.js
var SdkViewSectionType;
(function(SdkViewSectionType2) {
  SdkViewSectionType2["Email"] = "email";
  SdkViewSectionType2["EmailAndPhone"] = "emailAndPhone";
  SdkViewSectionType2["Phone"] = "phone";
  SdkViewSectionType2["Separator"] = "separator";
  SdkViewSectionType2["Social"] = "social";
  SdkViewSectionType2["Text"] = "text";
  SdkViewSectionType2["Wallet"] = "wallet";
  SdkViewSectionType2["Passkey"] = "passkey";
})(SdkViewSectionType || (SdkViewSectionType = {}));
function SdkViewSectionTypeFromJSON(json) {
  return SdkViewSectionTypeFromJSONTyped(json);
}
function SdkViewSectionTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewSection.js
function SdkViewSectionFromJSON(json) {
  return SdkViewSectionFromJSONTyped(json);
}
function SdkViewSectionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": SdkViewSectionTypeFromJSON(json["type"]),
    "label": !exists(json, "label") ? void 0 : json["label"],
    "numOfItemsToDisplay": !exists(json, "numOfItemsToDisplay") ? void 0 : json["numOfItemsToDisplay"],
    "defaultItem": !exists(json, "defaultItem") ? void 0 : json["defaultItem"],
    "alignment": !exists(json, "alignment") ? void 0 : SdkViewSectionAlignmentFromJSON(json["alignment"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkViewType.js
var SdkViewType;
(function(SdkViewType2) {
  SdkViewType2["Login"] = "login";
})(SdkViewType || (SdkViewType = {}));
function SdkViewTypeFromJSON(json) {
  return SdkViewTypeFromJSONTyped(json);
}
function SdkViewTypeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkView.js
function SdkViewFromJSON(json) {
  return SdkViewFromJSONTyped(json);
}
function SdkViewFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": SdkViewTypeFromJSON(json["type"]),
    "sections": !exists(json, "sections") ? void 0 : json["sections"].map(SdkViewSectionFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSdk.js
function ProjectSettingsSdkFromJSON(json) {
  return ProjectSettingsSdkFromJSONTyped(json);
}
function ProjectSettingsSdkFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nameService": !exists(json, "nameService") ? void 0 : NameServiceSdkSettingsFromJSON(json["nameService"]),
    "featureFlags": !exists(json, "featureFlags") ? void 0 : FeatureFlagsFromJSON(json["featureFlags"]),
    "emailSignIn": !exists(json, "emailSignIn") ? void 0 : ProjectSettingsSdkEmailSignInFromJSON(json["emailSignIn"]),
    "socialSignIn": !exists(json, "socialSignIn") ? void 0 : ProjectSettingsSdkSocialSignInFromJSON(json["socialSignIn"]),
    "exchangeOptions": !exists(json, "exchangeOptions") ? void 0 : json["exchangeOptions"].map(ExchangeOptionFromJSON),
    "multiWallet": !exists(json, "multiWallet") ? void 0 : json["multiWallet"],
    "multiWalletUnlinkDisabled": !exists(json, "multiWalletUnlinkDisabled") ? void 0 : json["multiWalletUnlinkDisabled"],
    "mobile": !exists(json, "mobile") ? void 0 : MobileSettingsFromJSON(json["mobile"]),
    "confirmWalletTransfers": !exists(json, "confirmWalletTransfers") ? void 0 : json["confirmWalletTransfers"],
    "onrampFunding": !exists(json, "onrampFunding") ? void 0 : json["onrampFunding"],
    "passkeyEmbeddedWalletEnabled": !exists(json, "passkeyEmbeddedWalletEnabled") ? void 0 : json["passkeyEmbeddedWalletEnabled"],
    "automaticEmbeddedWalletCreation": !exists(json, "automaticEmbeddedWalletCreation") ? void 0 : json["automaticEmbeddedWalletCreation"],
    "passkeyEmbeddedWalletRecoveryEnabled": !exists(json, "passkeyEmbeddedWalletRecoveryEnabled") ? void 0 : json["passkeyEmbeddedWalletRecoveryEnabled"],
    "embeddedWalletSecurityMethods": !exists(json, "embeddedWalletSecurityMethods") ? void 0 : json["embeddedWalletSecurityMethods"].map(EmbeddedWalletSecurityMethodFromJSON),
    "embeddedWallets": !exists(json, "embeddedWallets") ? void 0 : ProjectSettingsSdkEmbeddedWalletsFromJSON(json["embeddedWallets"]),
    "waas": !exists(json, "waas") ? void 0 : ProjectSettingsSdkWaasFromJSON(json["waas"]),
    "walletConnect": !exists(json, "walletConnect") ? void 0 : ProjectSettingsSdkWalletConnectFromJSON(json["walletConnect"]),
    "confirmEmailProviderForVerify": !exists(json, "confirmEmailProviderForVerify") ? void 0 : json["confirmEmailProviderForVerify"],
    "displayDynamicMessaging": !exists(json, "displayDynamicMessaging") ? void 0 : json["displayDynamicMessaging"],
    "hideNetworkInDynamicWidget": !exists(json, "hideNetworkInDynamicWidget") ? void 0 : json["hideNetworkInDynamicWidget"],
    "preventOrphanedAccounts": !exists(json, "preventOrphanedAccounts") ? void 0 : json["preventOrphanedAccounts"],
    "views": !exists(json, "views") ? void 0 : json["views"].map(SdkViewFromJSON),
    "accountAbstraction": !exists(json, "accountAbstraction") ? void 0 : ProjectSettingsSdkAccountAbstractionFromJSON(json["accountAbstraction"]),
    "blockEmailSubaddresses": !exists(json, "blockEmailSubaddresses") ? void 0 : json["blockEmailSubaddresses"],
    "enableMultiAsset": !exists(json, "enableMultiAsset") ? void 0 : json["enableMultiAsset"],
    "showFiat": !exists(json, "showFiat") ? void 0 : json["showFiat"],
    "disabledWalletConnectors": !exists(json, "disabledWalletConnectors") ? void 0 : json["disabledWalletConnectors"],
    "funding": !exists(json, "funding") ? void 0 : FundingFromJSON(json["funding"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AuthSettings.js
function AuthSettingsFromJSON(json) {
  return AuthSettingsFromJSONTyped(json);
}
function AuthSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "storage": json["storage"].map(AuthStorageEnumFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ExternalAuth.js
function ExternalAuthFromJSON(json) {
  return ExternalAuthFromJSONTyped(json);
}
function ExternalAuthFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "iss": !exists(json, "iss") ? void 0 : json["iss"],
    "aud": !exists(json, "aud") ? void 0 : json["aud"],
    "jwksUrl": !exists(json, "jwksUrl") ? void 0 : json["jwksUrl"],
    "cookieName": !exists(json, "cookieName") ? void 0 : json["cookieName"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/HCaptchaSettings.js
function HCaptchaSettingsFromJSON(json) {
  return HCaptchaSettingsFromJSONTyped(json);
}
function HCaptchaSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "secretKey": !exists(json, "secretKey") ? void 0 : json["secretKey"],
    "siteKey": !exists(json, "siteKey") ? void 0 : json["siteKey"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFASettingsActions.js
function MFASettingsActionsFromJSON(json) {
  return MFASettingsActionsFromJSONTyped(json);
}
function MFASettingsActionsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "action": MFAActionFromJSON(json["action"]),
    "required": json["required"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFASettingsMethods.js
function MFASettingsMethodsFromJSON(json) {
  return MFASettingsMethodsFromJSONTyped(json);
}
function MFASettingsMethodsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": MFADeviceTypeFromJSON(json["type"]),
    "enabled": json["enabled"],
    "allowBackupCodes": !exists(json, "allowBackupCodes") ? void 0 : json["allowBackupCodes"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/MFASettings.js
function MFASettingsFromJSON(json) {
  return MFASettingsFromJSONTyped(json);
}
function MFASettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "enabled": !exists(json, "enabled") ? void 0 : json["enabled"],
    "required": !exists(json, "required") ? void 0 : json["required"],
    "availableMethods": !exists(json, "availableMethods") ? void 0 : json["availableMethods"].map(MFADeviceTypeFromJSON),
    "methods": !exists(json, "methods") ? void 0 : json["methods"].map(MFASettingsMethodsFromJSON),
    "actions": !exists(json, "actions") ? void 0 : json["actions"].map(MFASettingsActionsFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettingsSecurity.js
function ProjectSettingsSecurityFromJSON(json) {
  return ProjectSettingsSecurityFromJSONTyped(json);
}
function ProjectSettingsSecurityFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "jwtDuration": !exists(json, "jwtDuration") ? void 0 : DurationFromJSON(json["jwtDuration"]),
    "hCaptcha": !exists(json, "hCaptcha") ? void 0 : HCaptchaSettingsFromJSON(json["hCaptcha"]),
    "mfa": !exists(json, "mfa") ? void 0 : MFASettingsFromJSON(json["mfa"]),
    "auth": !exists(json, "auth") ? void 0 : AuthSettingsFromJSON(json["auth"]),
    "externalAuth": !exists(json, "externalAuth") ? void 0 : ExternalAuthFromJSON(json["externalAuth"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderAgreement.js
function ProviderAgreementFromJSON(json) {
  return ProviderAgreementFromJSONTyped(json);
}
function ProviderAgreementFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "termsUrl": json["termsUrl"],
    "email": json["email"],
    "userId": json["userId"],
    "createdAt": new Date(json["createdAt"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProviderMultichainAccountAbstractionProviders.js
function ProviderMultichainAccountAbstractionProvidersFromJSON(json) {
  return ProviderMultichainAccountAbstractionProvidersFromJSONTyped(json);
}
function ProviderMultichainAccountAbstractionProvidersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "clientId": json["clientId"],
    "chain": json["chain"],
    "_default": !exists(json, "default") ? void 0 : json["default"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsCountryCode.js
function SmsCountryCodeFromJSON(json) {
  return SmsCountryCodeFromJSONTyped(json);
}
function SmsCountryCodeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isoCountryCode": json["isoCountryCode"],
    "phoneCountryCode": json["phoneCountryCode"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ZerodevBundlerProvider.js
var ZerodevBundlerProvider;
(function(ZerodevBundlerProvider2) {
  ZerodevBundlerProvider2["Stackup"] = "STACKUP";
  ZerodevBundlerProvider2["Pimlico"] = "PIMLICO";
  ZerodevBundlerProvider2["Alchemy"] = "ALCHEMY";
  ZerodevBundlerProvider2["Gelato"] = "GELATO";
})(ZerodevBundlerProvider || (ZerodevBundlerProvider = {}));
function ZerodevBundlerProviderFromJSON(json) {
  return ZerodevBundlerProviderFromJSONTyped(json);
}
function ZerodevBundlerProviderFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Provider.js
function ProviderFromJSON(json) {
  return ProviderFromJSONTyped(json);
}
function ProviderFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": !exists(json, "id") ? void 0 : json["id"],
    "provider": ProviderEnumFromJSON(json["provider"]),
    "enabledAt": !exists(json, "enabledAt") ? void 0 : json["enabledAt"] === null ? null : new Date(json["enabledAt"]),
    "clientId": !exists(json, "clientId") ? void 0 : json["clientId"],
    "clientSecret": !exists(json, "clientSecret") ? void 0 : json["clientSecret"],
    "providerProjectId": !exists(json, "providerProjectId") ? void 0 : json["providerProjectId"],
    "authorizationUrl": !exists(json, "authorizationUrl") ? void 0 : json["authorizationUrl"],
    "redirectUrl": !exists(json, "redirectUrl") ? void 0 : json["redirectUrl"],
    "defaultChainId": !exists(json, "defaultChainId") ? void 0 : json["defaultChainId"],
    "defaultChain": !exists(json, "defaultChain") ? void 0 : json["defaultChain"],
    "keyExportUrl": !exists(json, "keyExportUrl") ? void 0 : json["keyExportUrl"],
    "termsAcceptedByUser": !exists(json, "termsAcceptedByUser") ? void 0 : ProviderAgreementFromJSON(json["termsAcceptedByUser"]),
    "scopes": !exists(json, "scopes") ? void 0 : json["scopes"],
    "baseAuthUrl": !exists(json, "baseAuthUrl") ? void 0 : json["baseAuthUrl"],
    "appleKeyId": !exists(json, "appleKeyId") ? void 0 : json["appleKeyId"],
    "appleTeamId": !exists(json, "appleTeamId") ? void 0 : json["appleTeamId"],
    "shopifyStore": !exists(json, "shopifyStore") ? void 0 : json["shopifyStore"],
    "domain": !exists(json, "domain") ? void 0 : json["domain"],
    "accountSid": !exists(json, "accountSid") ? void 0 : json["accountSid"],
    "twilioNumber": !exists(json, "twilioNumber") ? void 0 : json["twilioNumber"],
    "enabledCountries": !exists(json, "enabledCountries") ? void 0 : json["enabledCountries"].map(SmsCountryCodeFromJSON),
    "sendgridIpPoolName": !exists(json, "sendgridIpPoolName") ? void 0 : json["sendgridIpPoolName"],
    "entryPointVersion": !exists(json, "entryPointVersion") ? void 0 : ProviderEntryPointVersionEnumFromJSON(json["entryPointVersion"]),
    "kernelVersion": !exists(json, "kernelVersion") ? void 0 : ProviderKernelVersionEnumFromJSON(json["kernelVersion"]),
    "factoryAddress": !exists(json, "factoryAddress") ? void 0 : json["factoryAddress"],
    "paymasterAddress": !exists(json, "paymasterAddress") ? void 0 : json["paymasterAddress"],
    "passkeyAddress": !exists(json, "passkeyAddress") ? void 0 : json["passkeyAddress"],
    "sessionAddress": !exists(json, "sessionAddress") ? void 0 : json["sessionAddress"],
    "salt": !exists(json, "salt") ? void 0 : json["salt"],
    "multichainAccountAbstractionProviders": !exists(json, "multichainAccountAbstractionProviders") ? void 0 : json["multichainAccountAbstractionProviders"].map(ProviderMultichainAccountAbstractionProvidersFromJSON),
    "ecdsaProviderType": !exists(json, "ecdsaProviderType") ? void 0 : EcdsaValidatorOptionsFromJSON(json["ecdsaProviderType"]),
    "createNewAccounts": !exists(json, "createNewAccounts") ? void 0 : json["createNewAccounts"],
    "enableKernelV3Migration": !exists(json, "enableKernelV3Migration") ? void 0 : json["enableKernelV3Migration"],
    "enableEIP7702": !exists(json, "enableEIP7702") ? void 0 : json["enableEIP7702"],
    "zerodevBundlerProvider": !exists(json, "zerodevBundlerProvider") ? void 0 : ZerodevBundlerProviderFromJSON(json["zerodevBundlerProvider"]),
    "zerodevBundlerRpcUrl": !exists(json, "zerodevBundlerRpcUrl") ? void 0 : json["zerodevBundlerRpcUrl"],
    "zerodevPaymasterRpcUrl": !exists(json, "zerodevPaymasterRpcUrl") ? void 0 : json["zerodevPaymasterRpcUrl"],
    "zerodevKernelDelegationAddress": !exists(json, "zerodevKernelDelegationAddress") ? void 0 : json["zerodevKernelDelegationAddress"],
    "returnUrl": !exists(json, "returnUrl") ? void 0 : json["returnUrl"],
    "cancelUrl": !exists(json, "cancelUrl") ? void 0 : json["cancelUrl"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ProjectSettings.js
function ProjectSettingsFromJSON(json) {
  return ProjectSettingsFromJSONTyped(json);
}
function ProjectSettingsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "environmentName": !exists(json, "environmentName") ? void 0 : EnvironmentEnumFromJSON(json["environmentName"]),
    "chains": json["chains"].map(ProjectSettingsChainsFromJSON),
    "customFields": !exists(json, "customFields") ? void 0 : json["customFields"].map(ProjectSettingsKycFromJSON),
    "kyc": json["kyc"].map(ProjectSettingsKycFromJSON),
    "design": ProjectSettingsDesignFromJSON(json["design"]),
    "general": ProjectSettingsGeneralFromJSON(json["general"]),
    "privacy": ProjectSettingsPrivacyFromJSON(json["privacy"]),
    "providers": !exists(json, "providers") ? void 0 : json["providers"].map(ProviderFromJSON),
    "exchanges": !exists(json, "exchanges") ? void 0 : json["exchanges"].map(ExchangeFromJSON),
    "sdk": ProjectSettingsSdkFromJSON(json["sdk"]),
    "security": ProjectSettingsSecurityFromJSON(json["security"]),
    "networks": !exists(json, "networks") ? void 0 : json["networks"].map(NetworkConfigurationResponseFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublishEventsEvents.js
var PublishEventsEventsTypeEnum;
(function(PublishEventsEventsTypeEnum2) {
  PublishEventsEventsTypeEnum2["Track"] = "track";
})(PublishEventsEventsTypeEnum || (PublishEventsEventsTypeEnum = {}));
function PublishEventsEventsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "anonymousId": value.anonymousId,
    "event": value.event,
    "properties": value.properties,
    "type": value.type
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PublishEvents.js
function PublishEventsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "events": value.events.map(PublishEventsEventsToJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RecoverMultipleClientKeySharesRequest.js
function RecoverMultipleClientKeySharesRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "keyShareIds": value.keyShareIds
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/WalletKeyShareInfoWithEncryptedAccountCredential.js
function WalletKeyShareInfoWithEncryptedAccountCredentialFromJSON(json) {
  return WalletKeyShareInfoWithEncryptedAccountCredentialFromJSONTyped(json);
}
function WalletKeyShareInfoWithEncryptedAccountCredentialFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "id": json["id"],
    "backupLocation": json["backupLocation"],
    "passwordEncrypted": json["passwordEncrypted"],
    "externalKeyShareId": !exists(json, "externalKeyShareId") ? void 0 : json["externalKeyShareId"],
    "encryptedAccountCredential": !exists(json, "encryptedAccountCredential") ? void 0 : json["encryptedAccountCredential"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RecoverMultipleClientKeySharesResponse.js
function RecoverMultipleClientKeySharesResponseFromJSON(json) {
  return RecoverMultipleClientKeySharesResponseFromJSONTyped(json);
}
function RecoverMultipleClientKeySharesResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "keyShares": json["keyShares"].map(WalletKeyShareInfoWithEncryptedAccountCredentialFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RegisterEmbeddedWalletSessionKeyResponse.js
function RegisterEmbeddedWalletSessionKeyResponseFromJSON(json) {
  return RegisterEmbeddedWalletSessionKeyResponseFromJSONTyped(json);
}
function RegisterEmbeddedWalletSessionKeyResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "publicKey": json["publicKey"],
    "expiresAt": json["expiresAt"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RegisterSessionKeyRequest.js
function RegisterSessionKeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "publicKey": value.publicKey,
    "prevSessionKeySignature": value.prevSessionKeySignature,
    "walletId": value.walletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ReshareRequest.js
function ReshareRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "clientKeygenIds": value.clientKeygenIds,
    "oldThresholdSignatureScheme": ThresholdSignatureSchemeToJSON(value.oldThresholdSignatureScheme),
    "newThresholdSignatureScheme": ThresholdSignatureSchemeToJSON(value.newThresholdSignatureScheme),
    "delegateToProjectEnvironment": value.delegateToProjectEnvironment,
    "revokeDelegation": value.revokeDelegation
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ScanWebsiteUrlRequest.js
function ScanWebsiteUrlRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "url": value.url
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ScanWebsiteUrlResponse.js
function ScanWebsiteUrlResponseFromJSON(json) {
  return ScanWebsiteUrlResponseFromJSONTyped(json);
}
function ScanWebsiteUrlResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "isMalicious": !exists(json, "isMalicious") ? void 0 : json["isMalicious"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/NextJsSettings.js
function NextJsSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "version": value.version
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/ReactSettings.js
function ReactSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "version": value.version
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/FrameworkSettings.js
function FrameworkSettingsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "react": ReactSettingsToJSON(value.react),
    "nextjs": NextJsSettingsToJSON(value.nextjs)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SdkSettingsRequest.js
function SdkSettingsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "dynamicContextProps": value.dynamicContextProps,
    "dynamicWagmiSettings": value.dynamicWagmiSettings,
    "frameworkSettings": FrameworkSettingsToJSON(value.frameworkSettings)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageEip7702Auth.js
function SignMessageEip7702AuthToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "chainId": value.chainId,
    "nonce": value.nonce
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageEvmMessage.js
function SignMessageEvmMessageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "raw": value.raw
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageEvmTransaction.js
function SignMessageEvmTransactionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "to": value.to,
    "chainId": value.chainId,
    "data": value.data,
    "gas": value.gas,
    "gasPrice": value.gasPrice,
    "maxFeePerGas": value.maxFeePerGas,
    "maxPriorityFeePerGas": value.maxPriorityFeePerGas,
    "nonce": value.nonce,
    "value": value.value
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Eip712Domain.js
function Eip712DomainToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "name": value.name,
    "version": value.version,
    "chainId": value.chainId,
    "verifyingContract": value.verifyingContract
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageEvmTypedData.js
function SignMessageEvmTypedDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "domain": Eip712DomainToJSON(value.domain),
    "message": value.message,
    "primaryType": value.primaryType,
    "types": value.types
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageAuthorizationSignature.js
function SignMessageAuthorizationSignatureToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "address": value.address,
    "chainId": value.chainId,
    "nonce": value.nonce,
    "r": value.r,
    "s": value.s,
    "v": value.v,
    "yParity": value.yParity
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageUserOperationData.js
function SignMessageUserOperationDataToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "authorization": SignMessageAuthorizationSignatureToJSON(value.authorization),
    "callData": value.callData,
    "callGasLimit": value.callGasLimit,
    "factory": value.factory,
    "factoryData": value.factoryData,
    "maxFeePerGas": value.maxFeePerGas,
    "maxPriorityFeePerGas": value.maxPriorityFeePerGas,
    "nonce": value.nonce,
    "paymaster": value.paymaster,
    "paymasterData": value.paymasterData,
    "paymasterPostOpGasLimit": value.paymasterPostOpGasLimit,
    "paymasterVerificationGasLimit": value.paymasterVerificationGasLimit,
    "preVerificationGas": value.preVerificationGas,
    "sender": value.sender,
    "signature": value.signature,
    "verificationGasLimit": value.verificationGasLimit
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageEvmUserOperation.js
function SignMessageEvmUserOperationToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chainId": value.chainId,
    "entryPoint": value.entryPoint,
    "operation": SignMessageUserOperationDataToJSON(value.operation)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageSuiTransaction.js
function SignMessageSuiTransactionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chainId": value.chainId,
    "serializedTransaction": value.serializedTransaction
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageSvmTransaction.js
function SignMessageSvmTransactionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chainId": value.chainId,
    "method": value.method,
    "serializedTransactions": value.serializedTransactions
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageContext.js
function SignMessageContextToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "evmTransaction": SignMessageEvmTransactionToJSON(value.evmTransaction),
    "evmUserOperation": SignMessageEvmUserOperationToJSON(value.evmUserOperation),
    "svmTransaction": SignMessageSvmTransactionToJSON(value.svmTransaction),
    "suiTransaction": SignMessageSuiTransactionToJSON(value.suiTransaction),
    "eip7702Auth": SignMessageEip7702AuthToJSON(value.eip7702Auth),
    "evmMessage": SignMessageEvmMessageToJSON(value.evmMessage),
    "svmMessage": value.svmMessage,
    "suiMessage": value.suiMessage,
    "evmTypedData": SignMessageEvmTypedDataToJSON(value.evmTypedData),
    "domain": value.domain
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SignMessageWithWaasRequest.js
function SignMessageWithWaasRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "message": value.message,
    "isFormatted": value.isFormatted,
    "roomId": value.roomId,
    "context": SignMessageContextToJSON(value.context)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SimulateEVMTransactionRequest.js
function SimulateEVMTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chainId": value.chainId,
    "data": value.data,
    "from": value.from,
    "to": value.to,
    "value": value.value,
    "domain": value.domain
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SimulateSVMTransactionRequest.js
function SimulateSVMTransactionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chain": value.chain,
    "transactions": value.transactions,
    "accountAddress": value.accountAddress,
    "domain": value.domain,
    "method": value.method
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/Asset.js
function AssetFromJSON(json) {
  return AssetFromJSONTyped(json);
}
function AssetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "chainId": !exists(json, "chainId") ? void 0 : json["chainId"],
    "chainName": json["chainName"],
    "decimals": json["decimals"],
    "logoUrl": json["logoUrl"],
    "name": json["name"],
    "symbol": json["symbol"],
    "type": json["type"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AssetTransfer.js
function AssetTransferFromJSON(json) {
  return AssetTransferFromJSONTyped(json);
}
function AssetTransferFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "rawValue": !exists(json, "rawValue") ? void 0 : json["rawValue"],
    "summary": !exists(json, "summary") ? void 0 : json["summary"],
    "usdPrice": !exists(json, "usdPrice") ? void 0 : json["usdPrice"],
    "value": !exists(json, "value") ? void 0 : json["value"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AssetDiff.js
function AssetDiffFromJSON(json) {
  return AssetDiffFromJSONTyped(json);
}
function AssetDiffFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "asset": AssetFromJSON(json["asset"]),
    "transferIn": json["transferIn"].map(AssetTransferFromJSON),
    "transferOut": json["transferOut"].map(AssetTransferFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AssetExposureSpenderToInfo.js
function AssetExposureSpenderToInfoFromJSON(json) {
  return AssetExposureSpenderToInfoFromJSONTyped(json);
}
function AssetExposureSpenderToInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "spenderAlias": !exists(json, "spenderAlias") ? void 0 : json["spenderAlias"],
    "usdValue": !exists(json, "usdValue") ? void 0 : json["usdValue"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/AssetExposure.js
function AssetExposureFromJSON(json) {
  return AssetExposureFromJSONTyped(json);
}
function AssetExposureFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "asset": AssetFromJSON(json["asset"]),
    "spenderToInfo": mapValues(json["spenderToInfo"], AssetExposureSpenderToInfoFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/BlockaidValidation.js
function BlockaidValidationFromJSON(json) {
  return BlockaidValidationFromJSONTyped(json);
}
function BlockaidValidationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "result": json["result"],
    "description": !exists(json, "description") ? void 0 : json["description"],
    "reason": json["reason"],
    "classification": !exists(json, "classification") ? void 0 : json["classification"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/PriceData.js
function PriceDataFromJSON(json) {
  return PriceDataFromJSONTyped(json);
}
function PriceDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "nativeTokenUsdPrice": !exists(json, "nativeTokenUsdPrice") ? void 0 : json["nativeTokenUsdPrice"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SimulateTransactionResponse.js
function SimulateTransactionResponseFromJSON(json) {
  return SimulateTransactionResponseFromJSONTyped(json);
}
function SimulateTransactionResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "inAssets": json["inAssets"].map(AssetDiffFromJSON),
    "outAssets": json["outAssets"].map(AssetDiffFromJSON),
    "counterparties": !exists(json, "counterparties") ? void 0 : json["counterparties"],
    "priceData": PriceDataFromJSON(json["priceData"]),
    "showTotalFiat": json["showTotalFiat"],
    "validation": !exists(json, "validation") ? void 0 : BlockaidValidationFromJSON(json["validation"]),
    "assetExposures": !exists(json, "assetExposures") ? void 0 : json["assetExposures"].map(AssetExposureFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SimulateUserOpRequest.js
function SimulateUserOpRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "chainId": value.chainId,
    "operation": value.operation,
    "entryPoint": value.entryPoint,
    "domain": value.domain,
    "value": value.value
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationCreateRequest.js
function SmsVerificationCreateRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "phoneCountryCode": value.phoneCountryCode,
    "phoneNumber": value.phoneNumber,
    "isoCountryCode": value.isoCountryCode,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationCreateResponse.js
function SmsVerificationCreateResponseFromJSON(json) {
  return SmsVerificationCreateResponseFromJSONTyped(json);
}
function SmsVerificationCreateResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "verificationUUID": json["verificationUUID"],
    "phoneNumber": json["phoneNumber"],
    "phoneCountryCode": json["phoneCountryCode"],
    "isoCountryCode": json["isoCountryCode"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationRetryRequest.js
function SmsVerificationRetryRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "phoneCountryCode": value.phoneCountryCode,
    "phoneNumber": value.phoneNumber,
    "isoCountryCode": value.isoCountryCode,
    "captchaToken": value.captchaToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SmsVerificationVerifyRequest.js
function SmsVerificationVerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "verificationUUID": value.verificationUUID,
    "verificationToken": value.verificationToken,
    "captchaToken": value.captchaToken,
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SolanaTransactionOptimizationRequest.js
function SolanaTransactionOptimizationRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "transaction": value.transaction,
    "address": value.address
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SolanaTransactionOptimizationResponse.js
function SolanaTransactionOptimizationResponseFromJSON(json) {
  return SolanaTransactionOptimizationResponseFromJSONTyped(json);
}
function SolanaTransactionOptimizationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "transaction": json["transaction"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SsoProviderEnum.js
var SsoProviderEnum;
(function(SsoProviderEnum2) {
  SsoProviderEnum2["Okta"] = "okta";
})(SsoProviderEnum || (SsoProviderEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/SsoProviderCheckRequest.js
function SsoProviderCheckRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "email": value.email
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SsoProviderCheckResponse.js
var SsoProviderCheckResponseTypeEnum;
(function(SsoProviderCheckResponseTypeEnum2) {
  SsoProviderCheckResponseTypeEnum2["Otp"] = "otp";
  SsoProviderCheckResponseTypeEnum2["Sso"] = "sso";
})(SsoProviderCheckResponseTypeEnum || (SsoProviderCheckResponseTypeEnum = {}));
function SsoProviderCheckResponseFromJSON(json) {
  return SsoProviderCheckResponseFromJSONTyped(json);
}
function SsoProviderCheckResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "type": json["type"],
    "provider": !exists(json, "provider") ? void 0 : json["provider"],
    "ssoAuthUrl": !exists(json, "ssoAuthUrl") ? void 0 : json["ssoAuthUrl"],
    "id": !exists(json, "id") ? void 0 : json["id"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/RampConfiguration.js
function RampConfigurationFromJSON(json) {
  return RampConfigurationFromJSONTyped(json);
}
function RampConfigurationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "provider": ProviderEnumFromJSON(json["provider"]),
    "name": json["name"],
    "iconUrl": json["iconUrl"],
    "url": json["url"],
    "qrCode": !exists(json, "qrCode") ? void 0 : json["qrCode"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedOfframpsResponse.js
function SupportedOfframpsResponseFromJSON(json) {
  return SupportedOfframpsResponseFromJSONTyped(json);
}
function SupportedOfframpsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "offramps": !exists(json, "offramps") ? void 0 : json["offramps"].map(RampConfigurationFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/SupportedOnrampsResponse.js
function SupportedOnrampsResponseFromJSON(json) {
  return SupportedOnrampsResponseFromJSONTyped(json);
}
function SupportedOnrampsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "onramps": !exists(json, "onramps") ? void 0 : json["onramps"].map(RampConfigurationFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TelegramUser.js
function TelegramUserToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "firstName": value.firstName,
    "lastName": value.lastName,
    "hash": value.hash,
    "photoURL": value.photoURL,
    "username": value.username,
    "authDate": value.authDate
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TelegramPostRequest.js
function TelegramPostRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "state": value.state,
    "telegramUser": TelegramUserToJSON(value.telegramUser)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TransferDestination.js
function TransferDestinationFromJSON(json) {
  return TransferDestinationFromJSONTyped(json);
}
function TransferDestinationFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "address": json["address"],
    "tokens": !exists(json, "tokens") ? void 0 : json["tokens"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TransferDestinationResponse.js
function TransferDestinationResponseFromJSON(json) {
  return TransferDestinationResponseFromJSONTyped(json);
}
function TransferDestinationResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "destinations": json["destinations"].map(TransferDestinationFromJSON),
    "enforcesAddressWhitelist": json["enforcesAddressWhitelist"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyWalletAccount.js
function TurnkeyWalletAccountFromJSON(json) {
  return TurnkeyWalletAccountFromJSONTyped(json);
}
function TurnkeyWalletAccountFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "curve": json["curve"],
    "pathFormat": json["pathFormat"],
    "path": json["path"],
    "addressFormat": json["addressFormat"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyCreateWalletAccountsRequestBodyParameters.js
function TurnkeyCreateWalletAccountsRequestBodyParametersFromJSON(json) {
  return TurnkeyCreateWalletAccountsRequestBodyParametersFromJSONTyped(json);
}
function TurnkeyCreateWalletAccountsRequestBodyParametersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletId": json["walletId"],
    "accounts": json["accounts"].map(TurnkeyWalletAccountFromJSON)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyCreateWalletAccountsRequestBody.js
function TurnkeyCreateWalletAccountsRequestBodyFromJSON(json) {
  return TurnkeyCreateWalletAccountsRequestBodyFromJSONTyped(json);
}
function TurnkeyCreateWalletAccountsRequestBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "organizationId": json["organizationId"],
    "parameters": TurnkeyCreateWalletAccountsRequestBodyParametersFromJSON(json["parameters"]),
    "timestampMs": json["timestampMs"],
    "type": json["type"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyDeleteEmbeddedWalletsRequestBodyParameters.js
function TurnkeyDeleteEmbeddedWalletsRequestBodyParametersFromJSON(json) {
  return TurnkeyDeleteEmbeddedWalletsRequestBodyParametersFromJSONTyped(json);
}
function TurnkeyDeleteEmbeddedWalletsRequestBodyParametersFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletIds": json["walletIds"],
    "deleteWithoutExport": !exists(json, "deleteWithoutExport") ? void 0 : json["deleteWithoutExport"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/TurnkeyDeleteEmbeddedWalletsRequestBody.js
function TurnkeyDeleteEmbeddedWalletsRequestBodyFromJSON(json) {
  return TurnkeyDeleteEmbeddedWalletsRequestBodyFromJSONTyped(json);
}
function TurnkeyDeleteEmbeddedWalletsRequestBodyFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "organizationId": json["organizationId"],
    "parameters": TurnkeyDeleteEmbeddedWalletsRequestBodyParametersFromJSON(json["parameters"]),
    "timestampMs": json["timestampMs"],
    "type": json["type"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UnprocessableEntityErrorCode.js
var UnprocessableEntityErrorCode;
(function(UnprocessableEntityErrorCode2) {
  UnprocessableEntityErrorCode2["EmailCannotBeNull"] = "email_cannot_be_null";
  UnprocessableEntityErrorCode2["ExchangeCannotBeEnabled"] = "exchange_cannot_be_enabled";
  UnprocessableEntityErrorCode2["TransferAmountTooSmall"] = "transfer_amount_too_small";
  UnprocessableEntityErrorCode2["TransferAddressNotWhitelisted"] = "transfer_address_not_whitelisted";
  UnprocessableEntityErrorCode2["InvalidScopes"] = "invalid_scopes";
  UnprocessableEntityErrorCode2["UnknownTransferError"] = "unknown_transfer_error";
  UnprocessableEntityErrorCode2["TransferMfaRequired"] = "transfer_mfa_required";
  UnprocessableEntityErrorCode2["TransferMfaFailed"] = "transfer_mfa_failed";
  UnprocessableEntityErrorCode2["InvalidTransferFunds"] = "invalid_transfer_funds";
  UnprocessableEntityErrorCode2["InvalidTransferCurrency"] = "invalid_transfer_currency";
  UnprocessableEntityErrorCode2["InvalidExchangeProvider"] = "invalid_exchange_provider";
  UnprocessableEntityErrorCode2["InvalidTransferNetwork"] = "invalid_transfer_network";
  UnprocessableEntityErrorCode2["InvalidEmail"] = "invalid_email";
  UnprocessableEntityErrorCode2["EmailAlreadyExists"] = "email_already_exists";
  UnprocessableEntityErrorCode2["AllowlistAlreadyExists"] = "allowlist_already_exists";
  UnprocessableEntityErrorCode2["AllowlistEntryAlreadyExists"] = "allowlist_entry_already_exists";
  UnprocessableEntityErrorCode2["ReassignWalletError"] = "reassign_wallet_error";
  UnprocessableEntityErrorCode2["ReassignWalletConfirm"] = "reassign_wallet_confirm";
  UnprocessableEntityErrorCode2["MembersCannotDeleteThemself"] = "members_cannot_delete_themself";
  UnprocessableEntityErrorCode2["UsernameAlreadyExists"] = "username_already_exists";
  UnprocessableEntityErrorCode2["WrongEmailVerificationToken"] = "wrong_email_verification_token";
  UnprocessableEntityErrorCode2["WrongSmsVerificationToken"] = "wrong_sms_verification_token";
  UnprocessableEntityErrorCode2["InvalidEmailVerification"] = "invalid_email_verification";
  UnprocessableEntityErrorCode2["InvalidSmsVerification"] = "invalid_sms_verification";
  UnprocessableEntityErrorCode2["InvalidVerification"] = "invalid_verification";
  UnprocessableEntityErrorCode2["InvalidPosition"] = "invalid_position";
  UnprocessableEntityErrorCode2["TooManySmsVerificationAttempts"] = "too_many_sms_verification_attempts";
  UnprocessableEntityErrorCode2["TooManyEmailVerificationAttempts"] = "too_many_email_verification_attempts";
  UnprocessableEntityErrorCode2["TooManyVerificationAttempts"] = "too_many_verification_attempts";
  UnprocessableEntityErrorCode2["OrganizationNameAlreadyExists"] = "organization_name_already_exists";
  UnprocessableEntityErrorCode2["ProjectNameAlreadyExists"] = "project_name_already_exists";
  UnprocessableEntityErrorCode2["WalletNotDeployed"] = "wallet_not_deployed";
  UnprocessableEntityErrorCode2["EmailVerificationRequired"] = "email_verification_required";
  UnprocessableEntityErrorCode2["PhoneVerificationRequired"] = "phone_verification_required";
  UnprocessableEntityErrorCode2["InviteAddressRequired"] = "invite_address_required";
  UnprocessableEntityErrorCode2["ProviderNotAvailable"] = "provider_not_available";
  UnprocessableEntityErrorCode2["ForbiddenUnlinkRequest"] = "forbidden_unlink_request";
  UnprocessableEntityErrorCode2["InvalidUnlinkRequest"] = "invalid_unlink_request";
  UnprocessableEntityErrorCode2["TooManyApiTokens"] = "too_many_api_tokens";
  UnprocessableEntityErrorCode2["LockTimeout"] = "lock_timeout";
  UnprocessableEntityErrorCode2["LockTooManyAttempts"] = "lock_too_many_attempts";
  UnprocessableEntityErrorCode2["NftTokenGatingNotSupportedForChain"] = "nft_token_gating_not_supported_for_chain";
  UnprocessableEntityErrorCode2["EmptyChainName"] = "empty_chain_name";
  UnprocessableEntityErrorCode2["NoEnabledEmailProvider"] = "no_enabled_email_provider";
  UnprocessableEntityErrorCode2["NoEnabledSmsProvider"] = "no_enabled_sms_provider";
  UnprocessableEntityErrorCode2["InvalidKeyExportUrl"] = "invalid_key_export_url";
  UnprocessableEntityErrorCode2["InvalidDynamicProps"] = "invalid_dynamic_props";
  UnprocessableEntityErrorCode2["TooManyRequests"] = "too_many_requests";
  UnprocessableEntityErrorCode2["TooManyOrganizationsForUser"] = "too_many_organizations_for_user";
  UnprocessableEntityErrorCode2["TooManyProjectsForOrganization"] = "too_many_projects_for_organization";
  UnprocessableEntityErrorCode2["EmailAssociatedWithDifferentProvider"] = "email_associated_with_different_provider";
  UnprocessableEntityErrorCode2["UserHasAlreadyAccountWithEmail"] = "user_has_already_account_with_email";
  UnprocessableEntityErrorCode2["UserHasAlreadyAccountWithPhoneNumber"] = "user_has_already_account_with_phone_number";
  UnprocessableEntityErrorCode2["OtherVerifyFailure"] = "other_verify_failure";
  UnprocessableEntityErrorCode2["EmailTiedToEmbeddedWallet"] = "email_tied_to_embedded_wallet";
  UnprocessableEntityErrorCode2["InvalidInvite"] = "invalid_invite";
  UnprocessableEntityErrorCode2["SocialAccountAlreadyExists"] = "social_account_already_exists";
  UnprocessableEntityErrorCode2["InvalidEmailAddress"] = "invalid_email_address";
  UnprocessableEntityErrorCode2["InvalidGate"] = "invalid_gate";
  UnprocessableEntityErrorCode2["ConflictingEmbeddedWalletProviders"] = "conflicting_embedded_wallet_providers";
  UnprocessableEntityErrorCode2["InvalidUser"] = "invalid_user";
  UnprocessableEntityErrorCode2["InvalidCorsOrigins"] = "invalid_cors_origins";
  UnprocessableEntityErrorCode2["InvalidMobileDeeplinkUrls"] = "invalid_mobile_deeplink_urls";
  UnprocessableEntityErrorCode2["UnauthorizedMobileDeeplinkUrl"] = "unauthorized_mobile_deeplink_url";
  UnprocessableEntityErrorCode2["InvalidPrivateKeyFormat"] = "invalid_private_key_format";
  UnprocessableEntityErrorCode2["InvalidEmbeddedWalletSettings"] = "invalid_embedded_wallet_settings";
  UnprocessableEntityErrorCode2["WalletNotSupportPasskey"] = "wallet_not_support_passkey";
  UnprocessableEntityErrorCode2["RecoveryEmailUnavailableOrInvalid"] = "recovery_email_unavailable_or_invalid";
  UnprocessableEntityErrorCode2["ConnectError"] = "connect_error";
  UnprocessableEntityErrorCode2["InvalidWalletName"] = "invalid_wallet_name";
  UnprocessableEntityErrorCode2["InvalidWalletAddress"] = "invalid_wallet_address";
  UnprocessableEntityErrorCode2["EmailRecoveryDisabled"] = "email_recovery_disabled";
  UnprocessableEntityErrorCode2["NoCompatibleWalletServiceEnabled"] = "no_compatible_wallet_service_enabled";
  UnprocessableEntityErrorCode2["MissingAaProjectId"] = "missing_aa_project_id";
  UnprocessableEntityErrorCode2["LinkedEmbeddedWallet"] = "linked_embedded_wallet";
  UnprocessableEntityErrorCode2["InvalidMpcEnvironment"] = "invalid_mpc_environment";
  UnprocessableEntityErrorCode2["InvalidRegex"] = "invalid_regex";
  UnprocessableEntityErrorCode2["RepeatedOptions"] = "repeated_options";
  UnprocessableEntityErrorCode2["MissingPhoneNumberOrEmail"] = "missing_phone_number_or_email";
  UnprocessableEntityErrorCode2["DuplicateExists"] = "duplicate_exists";
  UnprocessableEntityErrorCode2["MfaDeviceNotFound"] = "mfa_device_not_found";
  UnprocessableEntityErrorCode2["MfaInvalidCode"] = "mfa_invalid_code";
  UnprocessableEntityErrorCode2["MfaInvalidRequest"] = "mfa_invalid_request";
  UnprocessableEntityErrorCode2["InvalidPhone"] = "invalid_phone";
  UnprocessableEntityErrorCode2["GateExists"] = "gate_exists";
  UnprocessableEntityErrorCode2["InvalidEmbeddedWalletChainsConfiguration"] = "invalid_embedded_wallet_chains_configuration";
  UnprocessableEntityErrorCode2["MergeAccountsConfirmation"] = "merge_accounts_confirmation";
  UnprocessableEntityErrorCode2["MergeAccountsInvalid"] = "merge_accounts_invalid";
  UnprocessableEntityErrorCode2["InvalidWalletId"] = "invalid_wallet_id";
  UnprocessableEntityErrorCode2["UnableToFetchBalances"] = "unable_to_fetch_balances";
  UnprocessableEntityErrorCode2["CannotSwitchToUnique"] = "cannot_switch_to_unique";
  UnprocessableEntityErrorCode2["CustomFieldDataNotUnique"] = "custom_field_data_not_unique";
  UnprocessableEntityErrorCode2["MetadataSizeExceeded"] = "metadata_size_exceeded";
  UnprocessableEntityErrorCode2["InvalidCustomHostname"] = "invalid_custom_hostname";
  UnprocessableEntityErrorCode2["BlockedUserCannotTransferWallet"] = "blocked_user_cannot_transfer_wallet";
  UnprocessableEntityErrorCode2["FeatureNotEnabledInSuborg"] = "feature_not_enabled_in_suborg";
  UnprocessableEntityErrorCode2["InvalidUsername"] = "invalid_username";
  UnprocessableEntityErrorCode2["InvalidExternalAuth"] = "invalid_external_auth";
  UnprocessableEntityErrorCode2["InvalidChainAddressMatch"] = "invalid_chain_address_match";
  UnprocessableEntityErrorCode2["InvalidUpdate"] = "invalid_update";
  UnprocessableEntityErrorCode2["CannotDeleteLastProject"] = "cannot_delete_last_project";
  UnprocessableEntityErrorCode2["NoHdWalletFound"] = "no_hd_wallet_found";
  UnprocessableEntityErrorCode2["WalletAccountExistsForChain"] = "wallet_account_exists_for_chain";
  UnprocessableEntityErrorCode2["TooManyEmbeddedWalletsForUser"] = "too_many_embedded_wallets_for_user";
  UnprocessableEntityErrorCode2["TooManyEmbeddedWalletsPerChainForUser"] = "too_many_embedded_wallets_per_chain_for_user";
  UnprocessableEntityErrorCode2["InvalidSessionPublicKey"] = "invalid_session_public_key";
  UnprocessableEntityErrorCode2["CustomFieldNotUnique"] = "custom_field_not_unique";
  UnprocessableEntityErrorCode2["InvalidAaProjectConfiguration"] = "invalid_aa_project_configuration";
  UnprocessableEntityErrorCode2["NoV1EmbeddedWalletFound"] = "no_v1_embedded_wallet_found";
  UnprocessableEntityErrorCode2["EmbeddedWalletAddressAlreadyLinked"] = "embedded_wallet_address_already_linked";
  UnprocessableEntityErrorCode2["KeyShareAlreadyBackedUp"] = "key_share_already_backed_up";
  UnprocessableEntityErrorCode2["InvalidKeySharesLength"] = "invalid_key_shares_length";
  UnprocessableEntityErrorCode2["WalletServiceConnectionError"] = "wallet_service_connection_error";
  UnprocessableEntityErrorCode2["NoGlobalWalletFound"] = "no_global_wallet_found";
  UnprocessableEntityErrorCode2["InvalidMetadataValue"] = "invalid_metadata_value";
  UnprocessableEntityErrorCode2["MaxPasskeysPerUser"] = "max_passkeys_per_user";
  UnprocessableEntityErrorCode2["PasskeyNotFound"] = "passkey_not_found";
  UnprocessableEntityErrorCode2["CannotDeletePasskeyLinkedToEmbeddedWallet"] = "cannot_delete_passkey_linked_to_embedded_wallet";
  UnprocessableEntityErrorCode2["CannotDeleteLastSignInVerifiedCredential"] = "cannot_delete_last_sign_in_verified_credential";
})(UnprocessableEntityErrorCode || (UnprocessableEntityErrorCode = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateRecoveryEmailRequest.js
function UpdateRecoveryEmailRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "turnkeySignedRequest": TurnkeySignedRequestToJSON(value.turnkeySignedRequest)
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateSelfResponse.js
function UpdateSelfResponseFromJSON(json) {
  return UpdateSelfResponseFromJSONTyped(json);
}
function UpdateSelfResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mfaToken": !exists(json, "mfaToken") ? void 0 : json["mfaToken"],
    "jwt": !exists(json, "jwt") ? void 0 : json["jwt"],
    "user": SdkUserFromJSON(json["user"]),
    "minifiedJwt": !exists(json, "minifiedJwt") ? void 0 : json["minifiedJwt"],
    "expiresAt": json["expiresAt"],
    "nextView": NextViewEnumFromJSON(json["nextView"]),
    "emailVerification": !exists(json, "emailVerification") ? void 0 : EmailVerificationCreateResponseFromJSON(json["emailVerification"]),
    "smsVerification": !exists(json, "smsVerification") ? void 0 : SmsVerificationCreateResponseFromJSON(json["smsVerification"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateUserPasskeyRequest.js
function UpdateUserPasskeyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "id": value.id,
    "alias": value.alias
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateWaasWalletSettingsRequest.js
function UpdateWaasWalletSettingsRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "hasDeniedDelegatedAccess": value.hasDeniedDelegatedAccess
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpdateWaasWalletSettingsResponse.js
function UpdateWaasWalletSettingsResponseFromJSON(json) {
  return UpdateWaasWalletSettingsResponseFromJSONTyped(json);
}
function UpdateWaasWalletSettingsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "walletId": json["walletId"],
    "settings": WaasWalletSettingsFromJSON(json["settings"])
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UpgradeEmbeddedWalletToV2Request.js
function UpgradeEmbeddedWalletToV2RequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserFields.js
function UserFieldsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "email": value.email,
    "alias": value.alias,
    "firstName": value.firstName,
    "lastName": value.lastName,
    "jobTitle": value.jobTitle,
    "phoneNumber": value.phoneNumber,
    "tShirtSize": value.tShirtSize,
    "team": value.team,
    "policiesConsent": value.policiesConsent,
    "country": value.country,
    "username": value.username,
    "captchaToken": value.captchaToken,
    "metadata": value.metadata,
    "mfaBackupCodeAcknowledgement": MfaBackupCodeAcknowledgementToJSON(value.mfaBackupCodeAcknowledgement),
    "btcWallet": value.btcWallet,
    "kdaWallet": value.kdaWallet,
    "ltcWallet": value.ltcWallet,
    "ckbWallet": value.ckbWallet,
    "kasWallet": value.kasWallet,
    "dogeWallet": value.dogeWallet,
    "emailNotification": value.emailNotification,
    "discordNotification": value.discordNotification,
    "newsletterNotification": value.newsletterNotification
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserFieldsCheckEnum.js
var UserFieldsCheckEnum;
(function(UserFieldsCheckEnum2) {
  UserFieldsCheckEnum2["Email"] = "email";
  UserFieldsCheckEnum2["Username"] = "username";
  UserFieldsCheckEnum2["NameServiceSubdomainHandle"] = "name-service-subdomain-handle";
})(UserFieldsCheckEnum || (UserFieldsCheckEnum = {}));

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserFieldsCheckResponse.js
function UserFieldsCheckResponseFromJSON(json) {
  return UserFieldsCheckResponseFromJSONTyped(json);
}
function UserFieldsCheckResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "field": json["field"],
    "value": json["value"],
    "available": json["available"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserOauthAccessTokenResponse.js
function UserOauthAccessTokenResponseFromJSON(json) {
  return UserOauthAccessTokenResponseFromJSONTyped(json);
}
function UserOauthAccessTokenResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "accessToken": json["accessToken"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/UserWalletSelectionRequest.js
function UserWalletSelectionRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/OauthProviderRequest.js
function OauthProviderRequestFromJSON(json) {
  return OauthProviderRequestFromJSONTyped(json);
}
function OauthProviderRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "provider": !exists(json, "provider") ? void 0 : ProviderEnumFromJSON(json["provider"]),
    "accessToken": !exists(json, "accessToken") ? void 0 : json["accessToken"],
    "didToken": !exists(json, "didToken") ? void 0 : json["didToken"]
  };
}
function OauthProviderRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "provider": ProviderEnumToJSON(value.provider),
    "accessToken": value.accessToken,
    "didToken": value.didToken
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/VerifyRequest.js
function VerifyRequestFromJSON(json) {
  return VerifyRequestFromJSONTyped(json);
}
function VerifyRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "oauth": !exists(json, "oauth") ? void 0 : OauthProviderRequestFromJSON(json["oauth"]),
    "signedMessage": json["signedMessage"],
    "messageToSign": json["messageToSign"],
    "publicWalletAddress": json["publicWalletAddress"],
    "chain": ChainEnumFromJSON(json["chain"]),
    "walletName": json["walletName"],
    "walletProvider": WalletProviderEnumFromJSON(json["walletProvider"]),
    "skipEmptyAccountCheck": !exists(json, "skipEmptyAccountCheck") ? void 0 : json["skipEmptyAccountCheck"],
    "captchaToken": !exists(json, "captchaToken") ? void 0 : json["captchaToken"],
    "network": !exists(json, "network") ? void 0 : json["network"],
    "additionalWalletAddresses": !exists(json, "additionalWalletAddresses") ? void 0 : json["additionalWalletAddresses"].map(WalletAdditionalAddressFromJSON),
    "backup": !exists(json, "backup") ? void 0 : json["backup"],
    "password": !exists(json, "password") ? void 0 : json["password"],
    "passwordSource": !exists(json, "passwordSource") ? void 0 : PasswordSourceTypeEnumFromJSON(json["passwordSource"]),
    "sessionPublicKey": !exists(json, "sessionPublicKey") ? void 0 : json["sessionPublicKey"]
  };
}
function VerifyRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "oauth": OauthProviderRequestToJSON(value.oauth),
    "signedMessage": value.signedMessage,
    "messageToSign": value.messageToSign,
    "publicWalletAddress": value.publicWalletAddress,
    "chain": ChainEnumToJSON(value.chain),
    "walletName": value.walletName,
    "walletProvider": WalletProviderEnumToJSON(value.walletProvider),
    "skipEmptyAccountCheck": value.skipEmptyAccountCheck,
    "captchaToken": value.captchaToken,
    "network": value.network,
    "additionalWalletAddresses": value.additionalWalletAddresses === void 0 ? void 0 : value.additionalWalletAddresses.map(WalletAdditionalAddressToJSON),
    "backup": value.backup,
    "password": value.password,
    "passwordSource": PasswordSourceTypeEnumToJSON(value.passwordSource),
    "sessionPublicKey": value.sessionPublicKey
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/VerifyResponse.js
function VerifyResponseFromJSON(json) {
  return VerifyResponseFromJSONTyped(json);
}
function VerifyResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mfaToken": !exists(json, "mfaToken") ? void 0 : json["mfaToken"],
    "jwt": !exists(json, "jwt") ? void 0 : json["jwt"],
    "user": SdkUserFromJSON(json["user"]),
    "minifiedJwt": !exists(json, "minifiedJwt") ? void 0 : json["minifiedJwt"],
    "expiresAt": json["expiresAt"]
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/models/VerifyUnlinkRequest.js
function VerifyUnlinkRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "walletId": value.walletId,
    "verifiedCrentialId": value.verifiedCrentialId,
    "verifiedCredentialId": value.verifiedCredentialId,
    "primaryWalletId": value.primaryWalletId
  };
}

// node_modules/@dynamic-labs/sdk-api-core/src/apis/SDKApi.js
var SDKApi = class extends BaseAPI {
  /**
   * Options call for this endpoint
   */
  authMfaEmailDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaEmailDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/email`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaEmailDeviceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.authMfaEmailDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaPasskeyDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaPasskeyDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaPasskeyDeviceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.authMfaPasskeyDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaRecoveryRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaRecovery.");
      }
      if (requestParameters.mFAAuthRecoveryDevicePostRequest === null || requestParameters.mFAAuthRecoveryDevicePostRequest === void 0) {
        throw new RequiredError("mFAAuthRecoveryDevicePostRequest", "Required parameter requestParameters.mFAAuthRecoveryDevicePostRequest was null or undefined when calling authMfaRecovery.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFAAuthRecoveryDevicePostRequestToJSON(requestParameters.mFAAuthRecoveryDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaRecovery(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.authMfaRecoveryRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaRecoveryOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaRecoveryOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaRecoveryOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.authMfaRecoveryOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaTotpDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaTotpDevice.");
      }
      if (requestParameters.mFAAuthTotpDevicePostRequest === null || requestParameters.mFAAuthTotpDevicePostRequest === void 0) {
        throw new RequiredError("mFAAuthTotpDevicePostRequest", "Required parameter requestParameters.mFAAuthTotpDevicePostRequest was null or undefined when calling authMfaTotpDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFAAuthTotpDevicePostRequestToJSON(requestParameters.mFAAuthTotpDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authMfaTotpDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.authMfaTotpDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaTotpDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authMfaTotpDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authMfaTotpDeviceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.authMfaTotpDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authenticateMfaEmailRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authenticateMfaEmail.");
      }
      if (requestParameters.emailVerificationMfaRequest === null || requestParameters.emailVerificationMfaRequest === void 0) {
        throw new RequiredError("emailVerificationMfaRequest", "Required parameter requestParameters.emailVerificationMfaRequest was null or undefined when calling authenticateMfaEmail.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/email`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationMfaRequestToJSON(requestParameters.emailVerificationMfaRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authenticateMfaEmail(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.authenticateMfaEmailRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authenticateMfaPasskeyDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authenticateMfaPasskeyDevice.");
      }
      if (requestParameters.passkeyAuthRequest === null || requestParameters.passkeyAuthRequest === void 0) {
        throw new RequiredError("passkeyAuthRequest", "Required parameter requestParameters.passkeyAuthRequest was null or undefined when calling authenticateMfaPasskeyDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/auth/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PasskeyAuthRequestToJSON(requestParameters.passkeyAuthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Upgrade JWT scope with valid MFA session
   */
  authenticateMfaPasskeyDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.authenticateMfaPasskeyDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  authenticatePasskeyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling authenticatePasskeyOptions.");
      }
      const queryParameters = {};
      if (requestParameters.relatedOriginRpId !== void 0) {
        queryParameters["relatedOriginRpId"] = requestParameters.relatedOriginRpId;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  authenticatePasskeyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.authenticatePasskeyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Backup multiple keyShares for a waaS wallet
   */
  backupKeySharesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeyShares.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeyShares.");
      }
      if (requestParameters.backupMultipleClientKeySharesRequest === null || requestParameters.backupMultipleClientKeySharesRequest === void 0) {
        throw new RequiredError("backupMultipleClientKeySharesRequest", "Required parameter requestParameters.backupMultipleClientKeySharesRequest was null or undefined when calling backupKeyShares.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: BackupMultipleClientKeySharesRequestToJSON(requestParameters.backupMultipleClientKeySharesRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => BackupMultipleClientKeySharesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Backup multiple keyShares for a waaS wallet
   */
  backupKeyShares(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.backupKeySharesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.backupKeySharesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Backup multiple keyShares for a waaS wallet to Google Drive
   */
  backupKeySharesToGoogleDriveRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesToGoogleDrive.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesToGoogleDrive.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup/googleDrive`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => BackupMultipleClientKeySharesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Backup multiple keyShares for a waaS wallet to Google Drive
   */
  backupKeySharesToGoogleDrive(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.backupKeySharesToGoogleDriveRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesToGoogleDriveOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesToGoogleDriveOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesToGoogleDriveOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup/googleDrive`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesToGoogleDriveOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.backupKeySharesToGoogleDriveOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Create backup action and event for a specified location without performing actual backup
   */
  backupKeySharesToLocationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesToLocation.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesToLocation.");
      }
      if (requestParameters.backupKeySharesToLocationRequest === null || requestParameters.backupKeySharesToLocationRequest === void 0) {
        throw new RequiredError("backupKeySharesToLocationRequest", "Required parameter requestParameters.backupKeySharesToLocationRequest was null or undefined when calling backupKeySharesToLocation.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup/location`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: BackupKeySharesToLocationRequestToJSON(requestParameters.backupKeySharesToLocationRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => BackupKeySharesToLocationResponseFromJSON(jsonValue));
    });
  }
  /**
   * Create backup action and event for a specified location without performing actual backup
   */
  backupKeySharesToLocation(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.backupKeySharesToLocationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesToLocationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesToLocationOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesToLocationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup/location`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesToLocationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.backupKeySharesToLocationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Create backup action and event for multiple locations without performing actual backup
   */
  backupKeySharesToLocationsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesToLocations.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesToLocations.");
      }
      if (requestParameters.backupKeySharesToLocationsRequest === null || requestParameters.backupKeySharesToLocationsRequest === void 0) {
        throw new RequiredError("backupKeySharesToLocationsRequest", "Required parameter requestParameters.backupKeySharesToLocationsRequest was null or undefined when calling backupKeySharesToLocations.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup/locations`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: BackupKeySharesToLocationsRequestToJSON(requestParameters.backupKeySharesToLocationsRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => BackupKeySharesToLocationsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Create backup action and event for multiple locations without performing actual backup
   */
  backupKeySharesToLocations(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.backupKeySharesToLocationsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesToLocationsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling backupKeySharesToLocationsOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling backupKeySharesToLocationsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/backup/locations`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  backupKeySharesToLocationsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.backupKeySharesToLocationsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * This endpoint proxies requests to `/sdk/{environmentId}/providers/coinbasesocial/redirect` because Coinbase does not allow the string `coinbase` on the redirect URL path
   * Redirect URL for sign-in with coinbase
   */
  cbOauthRedirectRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling cbOauthRedirect.");
      }
      const queryParameters = {};
      if (requestParameters.code !== void 0) {
        queryParameters["code"] = requestParameters.code;
      }
      if (requestParameters.scope !== void 0) {
        queryParameters["scope"] = requestParameters.scope;
      }
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      if (requestParameters.authuser !== void 0) {
        queryParameters["authuser"] = requestParameters.authuser;
      }
      if (requestParameters.prompt !== void 0) {
        queryParameters["prompt"] = requestParameters.prompt;
      }
      if (requestParameters.error !== void 0) {
        queryParameters["error"] = requestParameters.error;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/cbOauthRedirectUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * This endpoint proxies requests to `/sdk/{environmentId}/providers/coinbasesocial/redirect` because Coinbase does not allow the string `coinbase` on the redirect URL path
   * Redirect URL for sign-in with coinbase
   */
  cbOauthRedirect(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.cbOauthRedirectRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  cbOauthRedirectOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling cbOauthRedirectOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/cbOauthRedirectUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  cbOauthRedirectOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.cbOauthRedirectOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Check if an email domain has an associated SSO provider configuration. Returns the authentication type (otp or sso) and optionally the provider name.
   * Check SSO provider for email domain
   */
  checkSsoProviderRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling checkSsoProvider.");
      }
      if (requestParameters.ssoProviderCheckRequest === null || requestParameters.ssoProviderCheckRequest === void 0) {
        throw new RequiredError("ssoProviderCheckRequest", "Required parameter requestParameters.ssoProviderCheckRequest was null or undefined when calling checkSsoProvider.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/ssoProvider`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SsoProviderCheckRequestToJSON(requestParameters.ssoProviderCheckRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SsoProviderCheckResponseFromJSON(jsonValue));
    });
  }
  /**
   * Check if an email domain has an associated SSO provider configuration. Returns the authentication type (otp or sso) and optionally the provider name.
   * Check SSO provider for email domain
   */
  checkSsoProvider(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.checkSsoProviderRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Claim a pregenerated embedded wallet
   */
  claimEmbeddedWalletRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling claimEmbeddedWallet.");
      }
      if (requestParameters.embeddedWalletPasscodeClaimRequest === null || requestParameters.embeddedWalletPasscodeClaimRequest === void 0) {
        throw new RequiredError("embeddedWalletPasscodeClaimRequest", "Required parameter requestParameters.embeddedWalletPasscodeClaimRequest was null or undefined when calling claimEmbeddedWallet.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode/claim`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: EmbeddedWalletPasscodeClaimRequestToJSON(requestParameters.embeddedWalletPasscodeClaimRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Claim a pregenerated embedded wallet
   */
  claimEmbeddedWallet(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.claimEmbeddedWalletRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  claimEmbeddedWalletOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling claimEmbeddedWalletOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode/claim`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  claimEmbeddedWalletOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.claimEmbeddedWalletOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  coinbaseNetworksOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling coinbaseNetworksOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/onramps/coinbase/networks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  coinbaseNetworksOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.coinbaseNetworksOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   */
  completePasskeyRecoveryRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling completePasskeyRecovery.");
      }
      if (requestParameters.completePasskeyRecoveryRequest === null || requestParameters.completePasskeyRecoveryRequest === void 0) {
        throw new RequiredError("completePasskeyRecoveryRequest", "Required parameter requestParameters.completePasskeyRecoveryRequest was null or undefined when calling completePasskeyRecovery.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passkeyRecovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: CompletePasskeyRecoveryRequestToJSON(requestParameters.completePasskeyRecoveryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   * Completes the passkey recovery process for a user\'s passkey embedded wallet
   */
  completePasskeyRecovery(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.completePasskeyRecoveryRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Initialize email verification process
   */
  createEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmailVerification.");
      }
      if (requestParameters.emailVerificationCreateRequest === null || requestParameters.emailVerificationCreateRequest === void 0) {
        throw new RequiredError("emailVerificationCreateRequest", "Required parameter requestParameters.emailVerificationCreateRequest was null or undefined when calling createEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationCreateRequestToJSON(requestParameters.emailVerificationCreateRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmailVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize email verification process
   */
  createEmailVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.createEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Create one or more embedded wallets for a user
   * Create one or more new embedded wallets for a user
   */
  createEmbeddedWalletsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmbeddedWallets.");
      }
      if (requestParameters.createEmbeddedWalletsRequest === null || requestParameters.createEmbeddedWalletsRequest === void 0) {
        throw new RequiredError("createEmbeddedWalletsRequest", "Required parameter requestParameters.createEmbeddedWalletsRequest was null or undefined when calling createEmbeddedWallets.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateEmbeddedWalletsRequestToJSON(requestParameters.createEmbeddedWalletsRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Create one or more embedded wallets for a user
   * Create one or more new embedded wallets for a user
   */
  createEmbeddedWallets(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createEmbeddedWalletsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmbeddedWalletsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createEmbeddedWalletsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createEmbeddedWalletsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.createEmbeddedWalletsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Track a global wallet connection
   */
  createGlobalWalletConnectionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createGlobalWalletConnection.");
      }
      if (requestParameters.globalWalletConnectionCreateRequest === null || requestParameters.globalWalletConnectionCreateRequest === void 0) {
        throw new RequiredError("globalWalletConnectionCreateRequest", "Required parameter requestParameters.globalWalletConnectionCreateRequest was null or undefined when calling createGlobalWalletConnection.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/globalWallets/connections`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: GlobalWalletConnectionCreateRequestToJSON(requestParameters.globalWalletConnectionCreateRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GlobalWalletConnectionFromJSON(jsonValue));
    });
  }
  /**
   * Track a global wallet connection
   */
  createGlobalWalletConnection(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createGlobalWalletConnectionRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Generate new recovery codes for user
   */
  createNewRecoveryCodesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createNewRecoveryCodes.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFARegenRecoveryCodesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Generate new recovery codes for user
   */
  createNewRecoveryCodes(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createNewRecoveryCodesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Initialize sms verification process
   */
  createSmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createSmsVerification.");
      }
      if (requestParameters.smsVerificationCreateRequest === null || requestParameters.smsVerificationCreateRequest === void 0) {
        throw new RequiredError("smsVerificationCreateRequest", "Required parameter requestParameters.smsVerificationCreateRequest was null or undefined when calling createSmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationCreateRequestToJSON(requestParameters.smsVerificationCreateRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SmsVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize sms verification process
   */
  createSmsVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createSmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createSmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createSmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createSmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.createSmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to send minimal wallet information for a connect-only or connect-first visitor.
   * Create a visit
   */
  createVisitRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createVisit.");
      }
      if (requestParameters.connectRequest === null || requestParameters.connectRequest === void 0) {
        throw new RequiredError("connectRequest", "Required parameter requestParameters.connectRequest was null or undefined when calling createVisit.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/connect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ConnectRequestToJSON(requestParameters.connectRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Endpoint to send minimal wallet information for a connect-only or connect-first visitor.
   * Create a visit
   */
  createVisit(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.createVisitRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Create a new waas account
   * Create a new waas account
   */
  createWaasAccountRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createWaasAccount.");
      }
      if (requestParameters.createWaasAccountRequest === null || requestParameters.createWaasAccountRequest === void 0) {
        throw new RequiredError("createWaasAccountRequest", "Required parameter requestParameters.createWaasAccountRequest was null or undefined when calling createWaasAccount.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateWaasAccountRequestToJSON(requestParameters.createWaasAccountRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OpenRoomResponseWithServerKeygenIdsFromJSON(jsonValue));
    });
  }
  /**
   * Create a new waas account
   * Create a new waas account
   */
  createWaasAccount(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createWaasAccountRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  createWaasAccountOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createWaasAccountOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/create`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  createWaasAccountOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.createWaasAccountOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   */
  createWalletAccountRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling createWalletAccount.");
      }
      if (requestParameters.createWalletAccountRequest === null || requestParameters.createWalletAccountRequest === void 0) {
        throw new RequiredError("createWalletAccountRequest", "Required parameter requestParameters.createWalletAccountRequest was null or undefined when calling createWalletAccount.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateWalletAccountRequestToJSON(requestParameters.createWalletAccountRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   * Add a wallet account to a user\'s existing Turnkey HD wallet
   */
  createWalletAccount(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.createWalletAccountRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Deletes the embedded wallets for a user
   * Deletes the embedded wallets for a user
   */
  deleteEmbeddedWalletsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling deleteEmbeddedWallets.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
        body: DeleteEmbeddedWalletsRequestToJSON(requestParameters.deleteEmbeddedWalletsRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Deletes the embedded wallets for a user
   * Deletes the embedded wallets for a user
   */
  deleteEmbeddedWallets(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.deleteEmbeddedWalletsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Delete a device (if not default device)
   */
  deleteMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling deleteMfaDevice.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling deleteMfaDevice.");
      }
      if (requestParameters.xMfaAuthToken === null || requestParameters.xMfaAuthToken === void 0) {
        throw new RequiredError("xMfaAuthToken", "Required parameter requestParameters.xMfaAuthToken was null or undefined when calling deleteMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (requestParameters.xMfaAuthToken !== void 0 && requestParameters.xMfaAuthToken !== null) {
        headerParameters["x-mfa-auth-token"] = String(requestParameters.xMfaAuthToken);
      }
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Delete a device (if not default device)
   */
  deleteMfaDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.deleteMfaDeviceRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Delete a passkey
   */
  deletePasskeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling deletePasskey.");
      }
      if (requestParameters.deleteUserPasskeyRequest === null || requestParameters.deleteUserPasskeyRequest === void 0) {
        throw new RequiredError("deleteUserPasskeyRequest", "Required parameter requestParameters.deleteUserPasskeyRequest was null or undefined when calling deletePasskey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
        body: DeleteUserPasskeyRequestToJSON(requestParameters.deleteUserPasskeyRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Delete a passkey
   */
  deletePasskey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.deletePasskeyRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Accepts delivery of the encrypted delegated share.
   * Deliver encrypted delegated share
   */
  deliverDelegatedShareRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling deliverDelegatedShare.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling deliverDelegatedShare.");
      }
      if (requestParameters.delegatedShareDeliveryRequest === null || requestParameters.delegatedShareDeliveryRequest === void 0) {
        throw new RequiredError("delegatedShareDeliveryRequest", "Required parameter requestParameters.delegatedShareDeliveryRequest was null or undefined when calling deliverDelegatedShare.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/delegatedAccess/delivery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DelegatedShareDeliveryRequestToJSON(requestParameters.delegatedShareDeliveryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => DelegatedShareDeliveryResponseFromJSON(jsonValue));
    });
  }
  /**
   * Accepts delivery of the encrypted delegated share.
   * Deliver encrypted delegated share
   */
  deliverDelegatedShare(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.deliverDelegatedShareRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  deliverDelegatedShareOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling deliverDelegatedShareOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling deliverDelegatedShareOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/delegatedAccess/delivery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  deliverDelegatedShareOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.deliverDelegatedShareOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Set a global wallet connection as disconnected
   */
  disconnectGlobalWalletConnectionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling disconnectGlobalWalletConnection.");
      }
      if (requestParameters.globalWalletConnectionId === null || requestParameters.globalWalletConnectionId === void 0) {
        throw new RequiredError("globalWalletConnectionId", "Required parameter requestParameters.globalWalletConnectionId was null or undefined when calling disconnectGlobalWalletConnection.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/globalWallets/connections/{globalWalletConnectionId}/disconnect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"globalWalletConnectionId"}}`, encodeURIComponent(String(requestParameters.globalWalletConnectionId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GlobalWalletConnectionFromJSON(jsonValue));
    });
  }
  /**
   * Set a global wallet connection as disconnected
   */
  disconnectGlobalWalletConnection(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.disconnectGlobalWalletConnectionRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  disconnectGlobalWalletConnectionOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling disconnectGlobalWalletConnectionOptions.");
      }
      if (requestParameters.globalWalletConnectionId === null || requestParameters.globalWalletConnectionId === void 0) {
        throw new RequiredError("globalWalletConnectionId", "Required parameter requestParameters.globalWalletConnectionId was null or undefined when calling disconnectGlobalWalletConnectionOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/globalWallets/connections/{globalWalletConnectionId}/disconnect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"globalWalletConnectionId"}}`, encodeURIComponent(String(requestParameters.globalWalletConnectionId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  disconnectGlobalWalletConnectionOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.disconnectGlobalWalletConnectionOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling emailAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/emailAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailAuthOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.emailAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailProviderOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling emailProviderOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailProvider`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  emailProviderOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.emailProviderOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  embeddedWalletDeleteRequestOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling embeddedWalletDeleteRequestOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling embeddedWalletDeleteRequestOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/deleteRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  embeddedWalletDeleteRequestOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.embeddedWalletDeleteRequestOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Requests an export of an embedded wallet
   * Requests an export of an embedded wallet
   */
  embeddedWalletExportRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling embeddedWalletExport.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling embeddedWalletExport.");
      }
      if (requestParameters.activityId === null || requestParameters.activityId === void 0) {
        throw new RequiredError("activityId", "Required parameter requestParameters.activityId was null or undefined when calling embeddedWalletExport.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/activities/{activityId}/export`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))).replace(`{${"activityId"}}`, encodeURIComponent(String(requestParameters.activityId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ExportEmbeddedWalletResponseFromJSON(jsonValue));
    });
  }
  /**
   * Requests an export of an embedded wallet
   * Requests an export of an embedded wallet
   */
  embeddedWalletExport(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.embeddedWalletExportRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  embeddedWalletExportOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling embeddedWalletExportOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling embeddedWalletExportOptions.");
      }
      if (requestParameters.activityId === null || requestParameters.activityId === void 0) {
        throw new RequiredError("activityId", "Required parameter requestParameters.activityId was null or undefined when calling embeddedWalletExportOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/activities/{activityId}/export`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))).replace(`{${"activityId"}}`, encodeURIComponent(String(requestParameters.activityId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  embeddedWalletExportOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.embeddedWalletExportOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   */
  eventsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling eventsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/events`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   */
  eventsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.eventsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Export private Key of a waas account
   */
  exportPrivateKeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling exportPrivateKey.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling exportPrivateKey.");
      }
      if (requestParameters.exportWaasWalletPrivateKeyRequest === null || requestParameters.exportWaasWalletPrivateKeyRequest === void 0) {
        throw new RequiredError("exportWaasWalletPrivateKeyRequest", "Required parameter requestParameters.exportWaasWalletPrivateKeyRequest was null or undefined when calling exportPrivateKey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/privateKey/export`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ExportWaasWalletPrivateKeyRequestToJSON(requestParameters.exportWaasWalletPrivateKeyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OpenRoomResponseWithServerKeygenIdsFromJSON(jsonValue));
    });
  }
  /**
   * Export private Key of a waas account
   */
  exportPrivateKey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.exportPrivateKeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  exportPrivateKeyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling exportPrivateKeyOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling exportPrivateKeyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/privateKey/export`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  exportPrivateKeyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.exportPrivateKeyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to sign-in using a token issued by an external auth provider
   */
  externalAuthSigninRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthSignin.");
      }
      if (requestParameters.externalAuthSigninRequest === null || requestParameters.externalAuthSigninRequest === void 0) {
        throw new RequiredError("externalAuthSigninRequest", "Required parameter requestParameters.externalAuthSigninRequest was null or undefined when calling externalAuthSignin.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ExternalAuthSigninRequestToJSON(requestParameters.externalAuthSigninRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Endpoint to sign-in using a token issued by an external auth provider
   */
  externalAuthSignin(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.externalAuthSigninRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  externalAuthSigninOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthSigninOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  externalAuthSigninOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.externalAuthSigninOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * [DEPRECATED] Please use /externalAuth/signin instead
   */
  externalAuthVerifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthVerify.");
      }
      if (requestParameters.externalAuthSigninRequest === null || requestParameters.externalAuthSigninRequest === void 0) {
        throw new RequiredError("externalAuthSigninRequest", "Required parameter requestParameters.externalAuthSigninRequest was null or undefined when calling externalAuthVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ExternalAuthSigninRequestToJSON(requestParameters.externalAuthSigninRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * [DEPRECATED] Please use /externalAuth/signin instead
   */
  externalAuthVerify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.externalAuthVerifyRaw(requestParameters, initOverrides);
    });
  }
  /**
   * [DEPRECATED] Options call for this endpoint
   */
  externalAuthVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling externalAuthVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/externalAuth/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * [DEPRECATED] Options call for this endpoint
   */
  externalAuthVerifyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.externalAuthVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Farcaster SignIn endpoint to exchange SIWF data
   * Farcaster provider SignIn endpoint
   */
  farcasterSignInRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterSignIn.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: FarcasterSignInRequestToJSON(requestParameters.farcasterSignInRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Farcaster SignIn endpoint to exchange SIWF data
   * Farcaster provider SignIn endpoint
   */
  farcasterSignIn(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.farcasterSignInRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterSignInOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterSignInOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterSignInOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.farcasterSignInOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Farcaster Verify endpoint to exchange SIWF data
   * Farcaster provider Verify endpoint
   */
  farcasterVerifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: FarcasterSignInRequestToJSON(requestParameters.farcasterSignInRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Farcaster Verify endpoint to exchange SIWF data
   * Farcaster provider Verify endpoint
   */
  farcasterVerify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.farcasterVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling farcasterVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/farcaster/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  farcasterVerifyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.farcasterVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the token balances for an account
   */
  getAccountBalancesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAccountBalances.");
      }
      if (requestParameters.chainName === null || requestParameters.chainName === void 0) {
        throw new RequiredError("chainName", "Required parameter requestParameters.chainName was null or undefined when calling getAccountBalances.");
      }
      if (requestParameters.accountAddress === null || requestParameters.accountAddress === void 0) {
        throw new RequiredError("accountAddress", "Required parameter requestParameters.accountAddress was null or undefined when calling getAccountBalances.");
      }
      const queryParameters = {};
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.accountAddress !== void 0) {
        queryParameters["accountAddress"] = requestParameters.accountAddress;
      }
      if (requestParameters.includePrices !== void 0) {
        queryParameters["includePrices"] = requestParameters.includePrices;
      }
      if (requestParameters.includeNative !== void 0) {
        queryParameters["includeNative"] = requestParameters.includeNative;
      }
      if (requestParameters.filterSpamTokens !== void 0) {
        queryParameters["filterSpamTokens"] = requestParameters.filterSpamTokens;
      }
      if (requestParameters.whitelistedContracts) {
        queryParameters["whitelistedContracts"] = requestParameters.whitelistedContracts;
      }
      if (requestParameters.forceRefresh !== void 0) {
        queryParameters["forceRefresh"] = requestParameters.forceRefresh;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/chains/{chainName}/balances`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"chainName"}}`, encodeURIComponent(String(requestParameters.chainName))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenBalanceFromJSON));
    });
  }
  /**
   * Get the token balances for an account
   */
  getAccountBalances(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getAccountBalancesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getAccountBalancesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAccountBalancesOptions.");
      }
      if (requestParameters.chainName === null || requestParameters.chainName === void 0) {
        throw new RequiredError("chainName", "Required parameter requestParameters.chainName was null or undefined when calling getAccountBalancesOptions.");
      }
      if (requestParameters.networkId === null || requestParameters.networkId === void 0) {
        throw new RequiredError("networkId", "Required parameter requestParameters.networkId was null or undefined when calling getAccountBalancesOptions.");
      }
      if (requestParameters.accountAddress === null || requestParameters.accountAddress === void 0) {
        throw new RequiredError("accountAddress", "Required parameter requestParameters.accountAddress was null or undefined when calling getAccountBalancesOptions.");
      }
      const queryParameters = {};
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.accountAddress !== void 0) {
        queryParameters["accountAddress"] = requestParameters.accountAddress;
      }
      if (requestParameters.transactionHash !== void 0) {
        queryParameters["transactionHash"] = requestParameters.transactionHash;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/chains/{chainName}/balances`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"chainName"}}`, encodeURIComponent(String(requestParameters.chainName))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getAccountBalancesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getAccountBalancesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get auth token for given embedded wallet type
   */
  getAuthTokenRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAuthToken.");
      }
      const queryParameters = {};
      if (requestParameters.type !== void 0) {
        queryParameters["type"] = requestParameters.type;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/authToken`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmbeddedWalletAuthTokenFromJSON(jsonValue));
    });
  }
  /**
   * Get auth token for given embedded wallet type
   */
  getAuthToken(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getAuthTokenRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getAuthTokenOptsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAuthTokenOpts.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/authToken`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getAuthTokenOpts(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getAuthTokenOptsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Fetch user profile for the current authenticated user
   */
  getAuthenticatedUserRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getAuthenticatedUser.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SdkUserFromJSON(jsonValue));
    });
  }
  /**
   * Fetch user profile for the current authenticated user
   */
  getAuthenticatedUser(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getAuthenticatedUserRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get a list of all networks supported by Coinbase onramp
   * Get Coinbase supported networks
   */
  getCoinbaseSupportedNetworksRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getCoinbaseSupportedNetworks.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/onramps/coinbase/networks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response);
    });
  }
  /**
   * Get a list of all networks supported by Coinbase onramp
   * Get Coinbase supported networks
   */
  getCoinbaseSupportedNetworks(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getCoinbaseSupportedNetworksRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Generates the turnkey request body for a user\'s create wallet account request
   * Generates the turnkey request body for a user\'s create wallet account request
   */
  getCreateWalletAccountRequestRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getCreateWalletAccountRequest.");
      }
      if (requestParameters.chain === null || requestParameters.chain === void 0) {
        throw new RequiredError("chain", "Required parameter requestParameters.chain was null or undefined when calling getCreateWalletAccountRequest.");
      }
      const queryParameters = {};
      if (requestParameters.chain !== void 0) {
        queryParameters["chain"] = requestParameters.chain;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts/createRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => TurnkeyCreateWalletAccountsRequestBodyFromJSON(jsonValue));
    });
  }
  /**
   * Generates the turnkey request body for a user\'s create wallet account request
   * Generates the turnkey request body for a user\'s create wallet account request
   */
  getCreateWalletAccountRequest(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getCreateWalletAccountRequestRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Exchange rates for the given currency
   */
  getCurrencyExchangeRatesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getCurrencyExchangeRates.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchangeRates`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(CurrencyFromJSON));
    });
  }
  /**
   * Exchange rates for the given currency
   */
  getCurrencyExchangeRates(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getCurrencyExchangeRatesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getCurrencyExchangeRatesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getCurrencyExchangeRatesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchangeRates`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getCurrencyExchangeRatesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getCurrencyExchangeRatesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Return the email provider to be used for signing in with a given email. If an external provider such as magicLink is disabled, this endpoint would return emailOnly. If an external provider such as magicLink is enabled, it will return emailOnly when the email already exists in Dynamic and it is associated with a wallet, otherwise it will return magicLink.
   * Get signin email provider
   */
  getEmailProviderRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmailProvider.");
      }
      if (requestParameters.email === null || requestParameters.email === void 0) {
        throw new RequiredError("email", "Required parameter requestParameters.email was null or undefined when calling getEmailProvider.");
      }
      const queryParameters = {};
      if (requestParameters.email !== void 0) {
        queryParameters["email"] = requestParameters.email;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailProvider`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmailProviderResponseFromJSON(jsonValue));
    });
  }
  /**
   * Return the email provider to be used for signing in with a given email. If an external provider such as magicLink is disabled, this endpoint would return emailOnly. If an external provider such as magicLink is enabled, it will return emailOnly when the email already exists in Dynamic and it is associated with a wallet, otherwise it will return magicLink.
   * Get signin email provider
   */
  getEmailProvider(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getEmailProviderRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletBackupOptionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletBackupOption.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/backup`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletBackupOption(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getEmbeddedWalletBackupOptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Return the backup key for the embedded wallet of the authenticated user
   */
  getEmbeddedWalletBackupsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletBackups.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/backup`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmbeddedWalletSecretFromJSON(jsonValue));
    });
  }
  /**
   * Return the backup key for the embedded wallet of the authenticated user
   */
  getEmbeddedWalletBackups(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getEmbeddedWalletBackupsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Return the passcode for the pregenerated embedded wallet of the authenticated user
   */
  getEmbeddedWalletPasscodeRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletPasscode.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmbeddedWalletSecretFromJSON(jsonValue));
    });
  }
  /**
   * Return the passcode for the pregenerated embedded wallet of the authenticated user
   */
  getEmbeddedWalletPasscode(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getEmbeddedWalletPasscodeRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletPasscodeOptionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletPasscodeOption.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passcode`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getEmbeddedWalletPasscodeOption(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getEmbeddedWalletPasscodeOptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Generates the turnkey request body for a user\'s delete wallets request
   * Generates the turnkey request body for a user\'s delete wallets request
   */
  getEmbeddedWalletsDeleteRequestRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEmbeddedWalletsDeleteRequest.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling getEmbeddedWalletsDeleteRequest.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/deleteRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => TurnkeyDeleteEmbeddedWalletsRequestBodyFromJSON(jsonValue));
    });
  }
  /**
   * Generates the turnkey request body for a user\'s delete wallets request
   * Generates the turnkey request body for a user\'s delete wallets request
   */
  getEmbeddedWalletsDeleteRequest(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getEmbeddedWalletsDeleteRequestRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the access token for a user OAuth account
   */
  getEndUserOauthAccessTokenRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEndUserOauthAccessToken.");
      }
      if (requestParameters.oauthAccountId === null || requestParameters.oauthAccountId === void 0) {
        throw new RequiredError("oauthAccountId", "Required parameter requestParameters.oauthAccountId was null or undefined when calling getEndUserOauthAccessToken.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/oauthAccounts/{oauthAccountId}/accessToken`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"oauthAccountId"}}`, encodeURIComponent(String(requestParameters.oauthAccountId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UserOauthAccessTokenResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get the access token for a user OAuth account
   */
  getEndUserOauthAccessToken(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getEndUserOauthAccessTokenRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getEndUserOauthAccessTokenOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEndUserOauthAccessTokenOptions.");
      }
      if (requestParameters.oauthAccountId === null || requestParameters.oauthAccountId === void 0) {
        throw new RequiredError("oauthAccountId", "Required parameter requestParameters.oauthAccountId was null or undefined when calling getEndUserOauthAccessTokenOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/oauthAccounts/{oauthAccountId}/accessToken`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"oauthAccountId"}}`, encodeURIComponent(String(requestParameters.oauthAccountId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getEndUserOauthAccessTokenOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getEndUserOauthAccessTokenOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the environment\'s settings
   */
  getEnvironmentSettingsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getEnvironmentSettings.");
      }
      const queryParameters = {};
      if (requestParameters.sdkVersion !== void 0) {
        queryParameters["sdkVersion"] = requestParameters.sdkVersion;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ProjectSettingsFromJSON(jsonValue));
    });
  }
  /**
   * Get the environment\'s settings
   */
  getEnvironmentSettings(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getEnvironmentSettingsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the exchange account transactions for a given dynamic user
   */
  getExchangeTransactionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getExchangeTransactions.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling getExchangeTransactions.");
      }
      const queryParameters = {};
      if (requestParameters.accountId !== void 0) {
        queryParameters["accountId"] = requestParameters.accountId;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts/transactions`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(ExchangeTransactionFromJSON));
    });
  }
  /**
   * Get the exchange account transactions for a given dynamic user
   */
  getExchangeTransactions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getExchangeTransactionsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getExchangeTransactionsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getExchangeTransactionsOptions.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling getExchangeTransactionsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts/transactions`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getExchangeTransactionsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getExchangeTransactionsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the available exchange transfer destinations for account transactions for a given dynamic user
   */
  getExchangeTransferDestinationsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getExchangeTransferDestinations.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling getExchangeTransferDestinations.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts/transfer/destinations`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => TransferDestinationResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get the available exchange transfer destinations for account transactions for a given dynamic user
   */
  getExchangeTransferDestinations(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getExchangeTransferDestinationsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getExchangeTransferDestinationsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getExchangeTransferDestinationsOptions.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling getExchangeTransferDestinationsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts/transfer/destinations`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getExchangeTransferDestinationsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getExchangeTransferDestinationsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the global wallet settings for the environment
   */
  getGlobalWalletsSettingsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getGlobalWalletsSettings.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/globalWallets/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GlobalWalletSettingsFromJSON(jsonValue));
    });
  }
  /**
   * Get the global wallet settings for the environment
   */
  getGlobalWalletsSettings(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getGlobalWalletsSettingsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Health check endpoint to check for uptime of API.
   */
  getHealthcheckRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getHealthcheck.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/healthcheck`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => HealthcheckResponseFromJSON(jsonValue));
    });
  }
  /**
   * Health check endpoint to check for uptime of API.
   */
  getHealthcheck(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getHealthcheckRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getHealthcheckOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getHealthcheckOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/healthcheck`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getHealthcheckOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getHealthcheckOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Find jwks for public key
   */
  getJwksByEnvironmentIdRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getJwksByEnvironmentId.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/.well-known/jwks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => JwksResponseFromJSON(jsonValue));
    });
  }
  /**
   * Find jwks for public key
   */
  getJwksByEnvironmentId(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getJwksByEnvironmentIdRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Find jwks for public key (JSON format)
   */
  getJwksJsonByEnvironmentIdRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getJwksJsonByEnvironmentId.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/.well-known/jwks.json`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => JwksResponseFromJSON(jsonValue));
    });
  }
  /**
   * Find jwks for public key (JSON format)
   */
  getJwksJsonByEnvironmentId(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getJwksJsonByEnvironmentIdRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the current user\'s MFA by device id
   */
  getMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getMfaDevice.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling getMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFADeviceFromJSON(jsonValue));
    });
  }
  /**
   * Get the current user\'s MFA by device id
   */
  getMfaDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getMfaDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getMfaDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getMfaDeviceOptions.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling getMfaDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getMfaDeviceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getMfaDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Find the configuration for the enabled networks associated to an environment
   */
  getNetworksConfigurationByEnvIdRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getNetworksConfigurationByEnvId.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/networks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(NetworkConfigurationResponseFromJSON));
    });
  }
  /**
   * Find the configuration for the enabled networks associated to an environment
   */
  getNetworksConfigurationByEnvId(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getNetworksConfigurationByEnvIdRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Create nonce for authentication flow
   */
  getNonceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getNonce.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/nonce`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => NonceResponseFromJSON(jsonValue));
    });
  }
  /**
   * Create nonce for authentication flow
   */
  getNonce(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getNonceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Gets passkey authentication options
   */
  getPasskeyAuthenticationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getPasskeyAuthenticationOptions.");
      }
      const queryParameters = {};
      if (requestParameters.relatedOriginRpId !== void 0) {
        queryParameters["relatedOriginRpId"] = requestParameters.relatedOriginRpId;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/authenticate`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GetPasskeyAuthenticationOptionsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Gets passkey authentication options
   */
  getPasskeyAuthenticationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getPasskeyAuthenticationOptionsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getPasskeyAuthenticationOptionsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getPasskeyAuthenticationOptionsOptions.");
      }
      const queryParameters = {};
      if (requestParameters.relatedOriginRpId !== void 0) {
        queryParameters["relatedOriginRpId"] = requestParameters.relatedOriginRpId;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/authenticate`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getPasskeyAuthenticationOptionsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getPasskeyAuthenticationOptionsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Gets passkey authentication options
   */
  getPasskeyAuthenticationSigninOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getPasskeyAuthenticationSigninOptions.");
      }
      const queryParameters = {};
      if (requestParameters.relatedOriginRpId !== void 0) {
        queryParameters["relatedOriginRpId"] = requestParameters.relatedOriginRpId;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GetPasskeyAuthenticationOptionsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Gets passkey authentication options
   */
  getPasskeyAuthenticationSigninOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getPasskeyAuthenticationSigninOptionsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Gets passkey data associated with a user
   */
  getPasskeyRegistrationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getPasskeyRegistrationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/register`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GetPasskeyRegistrationOptionsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Gets passkey data associated with a user
   */
  getPasskeyRegistrationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getPasskeyRegistrationOptionsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getPasskeyRegistrationOptionsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getPasskeyRegistrationOptionsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/register`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getPasskeyRegistrationOptionsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getPasskeyRegistrationOptionsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get recovery codes
   */
  getRecoveryCodesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getRecoveryCodes.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFAGetRecoveryCodesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get recovery codes
   */
  getRecoveryCodes(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getRecoveryCodesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Find the configuration for the enabled offramps associated to an environment
   * Configuration for enabled offramps
   */
  getSupportedOfframpsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getSupportedOfframps.");
      }
      if (requestParameters.walletAddress === null || requestParameters.walletAddress === void 0) {
        throw new RequiredError("walletAddress", "Required parameter requestParameters.walletAddress was null or undefined when calling getSupportedOfframps.");
      }
      if (requestParameters.chain === null || requestParameters.chain === void 0) {
        throw new RequiredError("chain", "Required parameter requestParameters.chain was null or undefined when calling getSupportedOfframps.");
      }
      const queryParameters = {};
      if (requestParameters.walletAddress !== void 0) {
        queryParameters["walletAddress"] = requestParameters.walletAddress;
      }
      if (requestParameters.chain !== void 0) {
        queryParameters["chain"] = requestParameters.chain;
      }
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.token !== void 0) {
        queryParameters["token"] = requestParameters.token;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/offramps`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SupportedOfframpsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Find the configuration for the enabled offramps associated to an environment
   * Configuration for enabled offramps
   */
  getSupportedOfframps(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getSupportedOfframpsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Find the configuration for the enabled onramps associated to an environment
   * Configuration for enabled onramps
   */
  getSupportedOnrampsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getSupportedOnramps.");
      }
      if (requestParameters.walletAddress === null || requestParameters.walletAddress === void 0) {
        throw new RequiredError("walletAddress", "Required parameter requestParameters.walletAddress was null or undefined when calling getSupportedOnramps.");
      }
      if (requestParameters.chain === null || requestParameters.chain === void 0) {
        throw new RequiredError("chain", "Required parameter requestParameters.chain was null or undefined when calling getSupportedOnramps.");
      }
      const queryParameters = {};
      if (requestParameters.walletAddress !== void 0) {
        queryParameters["walletAddress"] = requestParameters.walletAddress;
      }
      if (requestParameters.chain !== void 0) {
        queryParameters["chain"] = requestParameters.chain;
      }
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.token !== void 0) {
        queryParameters["token"] = requestParameters.token;
      }
      if (requestParameters.tokenAmount !== void 0) {
        queryParameters["tokenAmount"] = requestParameters.tokenAmount;
      }
      if (requestParameters.includeDisabled !== void 0) {
        queryParameters["includeDisabled"] = requestParameters.includeDisabled;
      }
      if (requestParameters.currency !== void 0) {
        queryParameters["currency"] = requestParameters.currency;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/onramps`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SupportedOnrampsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Find the configuration for the enabled onramps associated to an environment
   * Configuration for enabled onramps
   */
  getSupportedOnramps(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getSupportedOnrampsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get HTML with rendered Telegram login widget
   */
  getTelegramAuthRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getTelegramAuth.");
      }
      if (requestParameters.state === null || requestParameters.state === void 0) {
        throw new RequiredError("state", "Required parameter requestParameters.state was null or undefined when calling getTelegramAuth.");
      }
      const queryParameters = {};
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/auth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Get HTML with rendered Telegram login widget
   */
  getTelegramAuth(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getTelegramAuthRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the exchange accounts for a given dynamic user
   */
  getUserAccountsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserAccounts.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling getUserAccounts.");
      }
      const queryParameters = {};
      if (requestParameters.networkId !== void 0) {
        queryParameters["networkId"] = requestParameters.networkId;
      }
      if (requestParameters.chainName !== void 0) {
        queryParameters["chainName"] = requestParameters.chainName;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => jsonValue.map(AccountFromJSON));
    });
  }
  /**
   * Get the exchange accounts for a given dynamic user
   */
  getUserAccounts(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getUserAccountsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getUserAccountsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserAccountsOptions.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling getUserAccountsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getUserAccountsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getUserAccountsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Check if the unique field value is already taken. For example, an enabled unique username or unique email. This also works with enabled unique custom fields.
   * Check user field uniqueness
   */
  getUserFieldsCheckRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserFieldsCheck.");
      }
      const queryParameters = {};
      if (requestParameters.filter !== void 0) {
        queryParameters["filter"] = requestParameters.filter;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/check`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UserFieldsCheckResponseFromJSON(jsonValue));
    });
  }
  /**
   * Check if the unique field value is already taken. For example, an enabled unique username or unique email. This also works with enabled unique custom fields.
   * Check user field uniqueness
   */
  getUserFieldsCheck(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getUserFieldsCheckRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getUserFieldsCheckOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserFieldsCheckOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/check`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getUserFieldsCheckOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getUserFieldsCheckOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get the current user\'s MFA Devices
   */
  getUserMfaDevicesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserMfaDevices.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFAListDevicesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get the current user\'s MFA Devices
   */
  getUserMfaDevices(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getUserMfaDevicesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Get the current user\'s MFA Methods
   */
  getUserMfaMethodsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserMfaMethods.");
      }
      const queryParameters = {};
      if (requestParameters.verifiedOnly !== void 0) {
        queryParameters["verifiedOnly"] = requestParameters.verifiedOnly;
      }
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/methods`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFAMethodsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get the current user\'s MFA Methods
   */
  getUserMfaMethods(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getUserMfaMethodsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Gets passkey data associated with a user
   */
  getUserPasskeysRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getUserPasskeys.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => GetUserPasskeysResponseFromJSON(jsonValue));
    });
  }
  /**
   * Gets passkey data associated with a user
   */
  getUserPasskeys(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getUserPasskeysRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Fetches a single WaaS wallet and returns it with the same payload structure as the users endpoint. This endpoint returns user information along with verified credentials filtered to only include the specified WaaS wallet.
   * Fetch a single WaaS wallet with verified credentials
   */
  getWaasWalletWithVerifiedCredentialsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getWaasWalletWithVerifiedCredentials.");
      }
      if (requestParameters.walletAddress === null || requestParameters.walletAddress === void 0) {
        throw new RequiredError("walletAddress", "Required parameter requestParameters.walletAddress was null or undefined when calling getWaasWalletWithVerifiedCredentials.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/byWalletAddress/{walletAddress}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SdkUserFromJSON(jsonValue));
    });
  }
  /**
   * Fetches a single WaaS wallet and returns it with the same payload structure as the users endpoint. This endpoint returns user information along with verified credentials filtered to only include the specified WaaS wallet.
   * Fetch a single WaaS wallet with verified credentials
   */
  getWaasWalletWithVerifiedCredentials(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.getWaasWalletWithVerifiedCredentialsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  getWaasWalletWithVerifiedCredentialsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling getWaasWalletWithVerifiedCredentialsOptions.");
      }
      if (requestParameters.walletAddress === null || requestParameters.walletAddress === void 0) {
        throw new RequiredError("walletAddress", "Required parameter requestParameters.walletAddress was null or undefined when calling getWaasWalletWithVerifiedCredentialsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/byWalletAddress/{walletAddress}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  getWaasWalletWithVerifiedCredentialsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.getWaasWalletWithVerifiedCredentialsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  globalWalletConnectionsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling globalWalletConnectionsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/globalWallets/connections`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  globalWalletConnectionsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.globalWalletConnectionsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  globalWalletsSettingsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling globalWalletsSettingsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/globalWallets/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  globalWalletsSettingsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.globalWalletsSettingsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Hard delete the authenticated user
   * Hard delete a user
   */
  hardDeleteUserRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling hardDeleteUser.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Hard delete the authenticated user
   * Hard delete a user
   */
  hardDeleteUser(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.hardDeleteUserRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Import a private key to create a waas account
   * Import an existing private key to create a waas account
   */
  importPrivateKeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling importPrivateKey.");
      }
      if (requestParameters.importWaasPrivateKeyRequest === null || requestParameters.importWaasPrivateKeyRequest === void 0) {
        throw new RequiredError("importWaasPrivateKeyRequest", "Required parameter requestParameters.importWaasPrivateKeyRequest was null or undefined when calling importPrivateKey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/privateKey/import`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ImportWaasPrivateKeyRequestToJSON(requestParameters.importWaasPrivateKeyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OpenRoomResponseWithServerKeygenIdsFromJSON(jsonValue));
    });
  }
  /**
   * Import a private key to create a waas account
   * Import an existing private key to create a waas account
   */
  importPrivateKey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.importPrivateKeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  importPrivateKeyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling importPrivateKeyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/privateKey/import`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  importPrivateKeyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.importPrivateKeyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * This endpoint initializes a secure oauth authentication sequence by providing the state and current url path to the API.
   * Initialize oauth auth sequence
   */
  initAuthRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initAuth.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling initAuth.");
      }
      if (requestParameters.oauthInitAuthRequest === null || requestParameters.oauthInitAuthRequest === void 0) {
        throw new RequiredError("oauthInitAuthRequest", "Required parameter requestParameters.oauthInitAuthRequest was null or undefined when calling initAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/initAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthInitAuthRequestToJSON(requestParameters.oauthInitAuthRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * This endpoint initializes a secure oauth authentication sequence by providing the state and current url path to the API.
   * Initialize oauth auth sequence
   */
  initAuth(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.initAuthRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  initAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initAuthOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling initAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/initAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  initAuthOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.initAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Initialize the email authentication process for a user\'s embedded wallet
   * Initialize the email authentication process for a user\'s embedded wallet
   */
  initEmailAuthRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initEmailAuth.");
      }
      if (requestParameters.initEmailAuthRequest === null || requestParameters.initEmailAuthRequest === void 0) {
        throw new RequiredError("initEmailAuthRequest", "Required parameter requestParameters.initEmailAuthRequest was null or undefined when calling initEmailAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/emailAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: InitEmailAuthRequestToJSON(requestParameters.initEmailAuthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => InitEmailAuthResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize the email authentication process for a user\'s embedded wallet
   * Initialize the email authentication process for a user\'s embedded wallet
   */
  initEmailAuth(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.initEmailAuthRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   */
  initPasskeyRecoveryRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling initPasskeyRecovery.");
      }
      if (requestParameters.initPasskeyRecoveryRequest === null || requestParameters.initPasskeyRecoveryRequest === void 0) {
        throw new RequiredError("initPasskeyRecoveryRequest", "Required parameter requestParameters.initPasskeyRecoveryRequest was null or undefined when calling initPasskeyRecovery.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passkeyRecovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: InitPasskeyRecoveryRequestToJSON(requestParameters.initPasskeyRecoveryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => InitPasskeyRecoveryResponseFromJSON(jsonValue));
    });
  }
  /**
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   * Initialize the passkey recovery process for a user\'s passkey embedded wallet
   */
  initPasskeyRecovery(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.initPasskeyRecoveryRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  jwksOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling jwksOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/.well-known/jwks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  jwksOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.jwksOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  legacyEmbeddedWalletDeleteRequestOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling legacyEmbeddedWalletDeleteRequestOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/deleteRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  legacyEmbeddedWalletDeleteRequestOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.legacyEmbeddedWalletDeleteRequestOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Generates the turnkey request body for a user\'s delete wallets request
   * Generates the turnkey request body for a user\'s delete wallets request
   */
  legacyGetEmbeddedWalletsDeleteRequestRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling legacyGetEmbeddedWalletsDeleteRequest.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/deleteRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => TurnkeyDeleteEmbeddedWalletsRequestBodyFromJSON(jsonValue));
    });
  }
  /**
   * Generates the turnkey request body for a user\'s delete wallets request
   * Generates the turnkey request body for a user\'s delete wallets request
   */
  legacyGetEmbeddedWalletsDeleteRequest(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.legacyGetEmbeddedWalletsDeleteRequestRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  listMfaDevicesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling listMfaDevicesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  listMfaDevicesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.listMfaDevicesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  listMfaMethodsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling listMfaMethodsOptions.");
      }
      const queryParameters = {};
      if (requestParameters.verifiedOnly !== void 0) {
        queryParameters["verifiedOnly"] = requestParameters.verifiedOnly;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/methods`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  listMfaMethodsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.listMfaMethodsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Update SDK settings for a specific environment
   */
  logDynamicSdkSettingsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling logDynamicSdkSettings.");
      }
      if (requestParameters.sdkSettingsRequest === null || requestParameters.sdkSettingsRequest === void 0) {
        throw new RequiredError("sdkSettingsRequest", "Required parameter requestParameters.sdkSettingsRequest was null or undefined when calling logDynamicSdkSettings.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/sdkSettings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SdkSettingsRequestToJSON(requestParameters.sdkSettingsRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Update SDK settings for a specific environment
   */
  logDynamicSdkSettings(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.logDynamicSdkSettingsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Used to merge two owned accounts connected by email address
   * After successful verification allow to merge two owned accounts
   */
  mergeUsersRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling mergeUsers.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Used to merge two owned accounts connected by email address
   * After successful verification allow to merge two owned accounts
   */
  mergeUsers(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.mergeUsersRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  mergeUsersOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling mergeUsersOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  mergeUsersOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.mergeUsersOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  networksOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling networksOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/networks`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  networksOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.networksOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  nonceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling nonceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/nonce`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  nonceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.nonceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint where an oauth provider would return authorization HTML used for mobile-friendly login, such as Apple ID with Touch ID on enabled devices.
   * Oauth provider authorization endpoint
   */
  oauthAuthorizeHtmlRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthAuthorizeHtml.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthAuthorizeHtml.");
      }
      const queryParameters = {};
      if (requestParameters.scope !== void 0) {
        queryParameters["scope"] = requestParameters.scope;
      }
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      if (requestParameters.redirectUri !== void 0) {
        queryParameters["redirect_uri"] = requestParameters.redirectUri;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/authorizeHtml`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Endpoint where an oauth provider would return authorization HTML used for mobile-friendly login, such as Apple ID with Touch ID on enabled devices.
   * Oauth provider authorization endpoint
   */
  oauthAuthorizeHtml(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthAuthorizeHtmlRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthAuthorizeHtmlOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthAuthorizeHtmlOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthAuthorizeHtmlOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/authorizeHtml`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthAuthorizeHtmlOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthAuthorizeHtmlOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get redirect URL for Oauth provider login
   */
  oauthLoginRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLogin.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLogin.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/login`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Get redirect URL for Oauth provider login
   */
  oauthLogin(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthLoginRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLoginOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLoginOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/login`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthLoginOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get redirect URL for Oauth provider login. This will return a string that the SDK can manipulate before redirecting the browser to.
   */
  oauthLoginUrlRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLoginUrl.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLoginUrl.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/loginUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OauthProviderLoginUrlFromJSON(jsonValue));
    });
  }
  /**
   * Get redirect URL for Oauth provider login. This will return a string that the SDK can manipulate before redirecting the browser to.
   */
  oauthLoginUrl(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthLoginUrlRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginUrlOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthLoginUrlOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthLoginUrlOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/loginUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthLoginUrlOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthLoginUrlOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint for apple ID
   */
  oauthRedirectAppleRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirectApple.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const consumes = [
        { contentType: "application/x-www-form-urlencoded" }
      ];
      canConsumeForm(consumes);
      let formParams;
      {
        formParams = new URLSearchParams();
      }
      if (requestParameters.code !== void 0) {
        formParams.append("code", requestParameters.code);
      }
      if (requestParameters.state !== void 0) {
        formParams.append("state", requestParameters.state);
      }
      if (requestParameters.idToken !== void 0) {
        formParams.append("id_token", requestParameters.idToken);
      }
      if (requestParameters.error !== void 0) {
        formParams.append("error", requestParameters.error);
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/apple/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint for apple ID
   */
  oauthRedirectApple(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthRedirectAppleRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthRedirectAppleOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirectAppleOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/apple/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthRedirectAppleOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthRedirectAppleOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint
   */
  oauthRedirectCodeRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirectCode.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthRedirectCode.");
      }
      const queryParameters = {};
      if (requestParameters.code !== void 0) {
        queryParameters["code"] = requestParameters.code;
      }
      if (requestParameters.scope !== void 0) {
        queryParameters["scope"] = requestParameters.scope;
      }
      if (requestParameters.state !== void 0) {
        queryParameters["state"] = requestParameters.state;
      }
      if (requestParameters.authuser !== void 0) {
        queryParameters["authuser"] = requestParameters.authuser;
      }
      if (requestParameters.prompt !== void 0) {
        queryParameters["prompt"] = requestParameters.prompt;
      }
      if (requestParameters.error !== void 0) {
        queryParameters["error"] = requestParameters.error;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new TextApiResponse(response);
    });
  }
  /**
   * Endpoint where an oauth provider would redirect after a successful user authorizing the oauth application.
   * Oauth provider redirect endpoint
   */
  oauthRedirectCode(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthRedirectCodeRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthRedirectOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthRedirectOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthRedirectOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/redirect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthRedirectOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthRedirectOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Returns the authorization code or error retuned by oauth provider
   */
  oauthResultRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthResult.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthResult.");
      }
      if (requestParameters.oauthResultRequest === null || requestParameters.oauthResultRequest === void 0) {
        throw new RequiredError("oauthResultRequest", "Required parameter requestParameters.oauthResultRequest was null or undefined when calling oauthResult.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/oauthResult`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OauthResultResponseFromJSON(jsonValue));
    });
  }
  /**
   * Returns the authorization code or error retuned by oauth provider
   */
  oauthResult(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthResultRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthResultOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthResultOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthResultOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/oauthResult`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthResultOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthResultOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Standard OAuth SignIn callback to exchange temproary code for oauth access and return a valid Dynamic JWT and user
   * Oauth provider SignIn endpoint
   */
  oauthSignInRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthSignIn.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthSignIn.");
      }
      if (requestParameters.oauthRequest === null || requestParameters.oauthRequest === void 0) {
        throw new RequiredError("oauthRequest", "Required parameter requestParameters.oauthRequest was null or undefined when calling oauthSignIn.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/signIn`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthRequestToJSON(requestParameters.oauthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Standard OAuth SignIn callback to exchange temproary code for oauth access and return a valid Dynamic JWT and user
   * Oauth provider SignIn endpoint
   */
  oauthSignIn(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthSignInRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthSignInOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthSignInOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthSignInOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/signIn`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthSignInOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthSignInOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Standard OAuth verify callback to exchange temproary code for oauth access
   * Oauth provider verify endpoint
   */
  oauthVerifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthVerify.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthVerify.");
      }
      if (requestParameters.oauthRequest === null || requestParameters.oauthRequest === void 0) {
        throw new RequiredError("oauthRequest", "Required parameter requestParameters.oauthRequest was null or undefined when calling oauthVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthRequestToJSON(requestParameters.oauthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Standard OAuth verify callback to exchange temproary code for oauth access
   * Oauth provider verify endpoint
   */
  oauthVerify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.oauthVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling oauthVerifyOptions.");
      }
      if (requestParameters.providerType === null || requestParameters.providerType === void 0) {
        throw new RequiredError("providerType", "Required parameter requestParameters.providerType was null or undefined when calling oauthVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/providers/{providerType}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"providerType"}}`, encodeURIComponent(String(requestParameters.providerType))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  oauthVerifyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.oauthVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  offrampsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling offrampsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/offramps`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  offrampsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.offrampsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  onrampsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling onrampsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/onramps`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  onrampsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.onrampsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Add fees to a Solana transaction
   */
  optimizeTransactionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling optimizeTransaction.");
      }
      if (requestParameters.solanaTransactionOptimizationRequest === null || requestParameters.solanaTransactionOptimizationRequest === void 0) {
        throw new RequiredError("solanaTransactionOptimizationRequest", "Required parameter requestParameters.solanaTransactionOptimizationRequest was null or undefined when calling optimizeTransaction.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/solana/optimizeTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SolanaTransactionOptimizationRequestToJSON(requestParameters.solanaTransactionOptimizationRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SolanaTransactionOptimizationResponseFromJSON(jsonValue));
    });
  }
  /**
   * Add fees to a Solana transaction
   */
  optimizeTransaction(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.optimizeTransactionRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  optimizeTransactionOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling optimizeTransactionOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/solana/optimizeTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  optimizeTransactionOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.optimizeTransactionOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  optionsConnectRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling optionsConnect.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/connect`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  optionsConnect(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.optionsConnectRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  passkeyRecoveryOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling passkeyRecoveryOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/passkeyRecovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  passkeyRecoveryOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.passkeyRecoveryOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Transfer funds from an exchange account to an external address or another Coinbase account
   */
  postExchangeAccountTransferRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling postExchangeAccountTransfer.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling postExchangeAccountTransfer.");
      }
      if (requestParameters.accountId === null || requestParameters.accountId === void 0) {
        throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling postExchangeAccountTransfer.");
      }
      if (requestParameters.createExchangeTransferRequest === null || requestParameters.createExchangeTransferRequest === void 0) {
        throw new RequiredError("createExchangeTransferRequest", "Required parameter requestParameters.createExchangeTransferRequest was null or undefined when calling postExchangeAccountTransfer.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts/{accountId}/transfer`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))).replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: CreateExchangeTransferRequestToJSON(requestParameters.createExchangeTransferRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ExchangeTransferResponseFromJSON(jsonValue));
    });
  }
  /**
   * Transfer funds from an exchange account to an external address or another Coinbase account
   */
  postExchangeAccountTransfer(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.postExchangeAccountTransferRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  postExchangeAccountTransferOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling postExchangeAccountTransferOptions.");
      }
      if (requestParameters.exchangeKey === null || requestParameters.exchangeKey === void 0) {
        throw new RequiredError("exchangeKey", "Required parameter requestParameters.exchangeKey was null or undefined when calling postExchangeAccountTransferOptions.");
      }
      if (requestParameters.accountId === null || requestParameters.accountId === void 0) {
        throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling postExchangeAccountTransferOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/exchange/{exchangeKey}/accounts/{accountId}/transfer`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"exchangeKey"}}`, encodeURIComponent(String(requestParameters.exchangeKey))).replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  postExchangeAccountTransferOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.postExchangeAccountTransferOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Get account balances for multiple addresses
   */
  postMultichainAccountBalancesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling postMultichainAccountBalances.");
      }
      if (requestParameters.multichainAccountBalancesRequest === null || requestParameters.multichainAccountBalancesRequest === void 0) {
        throw new RequiredError("multichainAccountBalancesRequest", "Required parameter requestParameters.multichainAccountBalancesRequest was null or undefined when calling postMultichainAccountBalances.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/balances`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MultichainAccountBalancesRequestToJSON(requestParameters.multichainAccountBalancesRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MultichainAccountBalanceResponseFromJSON(jsonValue));
    });
  }
  /**
   * Get account balances for multiple addresses
   */
  postMultichainAccountBalances(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.postMultichainAccountBalancesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  postMultichainAccountBalancesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling postMultichainAccountBalancesOptions.");
      }
      if (requestParameters.multichainAccountBalancesRequest === null || requestParameters.multichainAccountBalancesRequest === void 0) {
        throw new RequiredError("multichainAccountBalancesRequest", "Required parameter requestParameters.multichainAccountBalancesRequest was null or undefined when calling postMultichainAccountBalancesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/balances`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters,
        body: MultichainAccountBalancesRequestToJSON(requestParameters.multichainAccountBalancesRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  postMultichainAccountBalancesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.postMultichainAccountBalancesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Handle Telegram authentication
   */
  postTelegramAuthRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling postTelegramAuth.");
      }
      if (requestParameters.telegramPostRequest === null || requestParameters.telegramPostRequest === void 0) {
        throw new RequiredError("telegramPostRequest", "Required parameter requestParameters.telegramPostRequest was null or undefined when calling postTelegramAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/auth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: TelegramPostRequestToJSON(requestParameters.telegramPostRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Handle Telegram authentication
   */
  postTelegramAuth(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.postTelegramAuthRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to send minimal wallet information to the API to prefetch name service information for an address.
   * prefetch information for wallet address
   */
  prefetchRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling prefetch.");
      }
      if (requestParameters.prefetchRequest === null || requestParameters.prefetchRequest === void 0) {
        throw new RequiredError("prefetchRequest", "Required parameter requestParameters.prefetchRequest was null or undefined when calling prefetch.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/prefetch`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PrefetchRequestToJSON(requestParameters.prefetchRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Endpoint to send minimal wallet information to the API to prefetch name service information for an address.
   * prefetch information for wallet address
   */
  prefetch(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.prefetchRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Publish events for SDK
   */
  publishEventRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling publishEvent.");
      }
      if (requestParameters.publishEvents === null || requestParameters.publishEvents === void 0) {
        throw new RequiredError("publishEvents", "Required parameter requestParameters.publishEvents was null or undefined when calling publishEvent.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/events`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublishEventsToJSON(requestParameters.publishEvents)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Publish events for SDK
   */
  publishEvent(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.publishEventRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Recover multiple keyShares
   */
  recoverKeySharesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling recoverKeyShares.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling recoverKeyShares.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/recover`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RecoverMultipleClientKeySharesRequestToJSON(requestParameters.recoverMultipleClientKeySharesRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => RecoverMultipleClientKeySharesResponseFromJSON(jsonValue));
    });
  }
  /**
   * Recover multiple keyShares
   */
  recoverKeyShares(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.recoverKeySharesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  recoverKeySharesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling recoverKeySharesOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling recoverKeySharesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/keyShares/recover`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoverKeySharesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.recoverKeySharesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryCodesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling recoveryCodesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/recovery`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryCodesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.recoveryCodesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryEmailOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling recoveryEmailOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/recoveryEmail`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  recoveryEmailOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.recoveryEmailOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Endpoint to refresh the JWT auth token using the current valid JWT auth token in the authorization header
   */
  refreshAuthRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling refreshAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/refresh`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Endpoint to refresh the JWT auth token using the current valid JWT auth token in the authorization header
   */
  refreshAuth(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.refreshAuthRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Refresh keyshares
   */
  refreshKeySharesRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling refreshKeyShares.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling refreshKeyShares.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/refresh`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OpenRoomResponseWithServerKeygenIdsFromJSON(jsonValue));
    });
  }
  /**
   * Refresh keyshares
   */
  refreshKeyShares(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.refreshKeySharesRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  refreshKeySharesOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling refreshKeySharesOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling refreshKeySharesOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/refresh`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  refreshKeySharesOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.refreshKeySharesOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  refreshOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling refreshOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/refresh`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  refreshOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.refreshOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Register a new passkey
   */
  registerPasskeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskey.");
      }
      if (requestParameters.passkeyRegisterRequest === null || requestParameters.passkeyRegisterRequest === void 0) {
        throw new RequiredError("passkeyRegisterRequest", "Required parameter requestParameters.passkeyRegisterRequest was null or undefined when calling registerPasskey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/register`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PasskeyRegisterRequestToJSON(requestParameters.passkeyRegisterRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Register a new passkey
   */
  registerPasskey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.registerPasskeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Register a new Passkey MFA device
   */
  registerPasskeyMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskeyMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFARegisterPasskeyDeviceGetResponseFromJSON(jsonValue));
    });
  }
  /**
   * Register a new Passkey MFA device
   */
  registerPasskeyMfaDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.registerPasskeyMfaDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  registerPasskeyMfaDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskeyMfaDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  registerPasskeyMfaDeviceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.registerPasskeyMfaDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify Passkey MFA device
   */
  registerPasskeyMfaDeviceVerifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerPasskeyMfaDeviceVerify.");
      }
      if (requestParameters.mFARegisterPasskeyDevicePostRequest === null || requestParameters.mFARegisterPasskeyDevicePostRequest === void 0) {
        throw new RequiredError("mFARegisterPasskeyDevicePostRequest", "Required parameter requestParameters.mFARegisterPasskeyDevicePostRequest was null or undefined when calling registerPasskeyMfaDeviceVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/passkey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFARegisterPasskeyDevicePostRequestToJSON(requestParameters.mFARegisterPasskeyDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify Passkey MFA device
   */
  registerPasskeyMfaDeviceVerify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.registerPasskeyMfaDeviceVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Registers a session key for an embedded wallet
   * Registers a session key for an embedded wallet
   */
  registerSessionKeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerSessionKey.");
      }
      if (requestParameters.registerSessionKeyRequest === null || requestParameters.registerSessionKeyRequest === void 0) {
        throw new RequiredError("registerSessionKeyRequest", "Required parameter requestParameters.registerSessionKeyRequest was null or undefined when calling registerSessionKey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/sessionKey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: RegisterSessionKeyRequestToJSON(requestParameters.registerSessionKeyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => RegisterEmbeddedWalletSessionKeyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Registers a session key for an embedded wallet
   * Registers a session key for an embedded wallet
   */
  registerSessionKey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.registerSessionKeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Register a new TOTP MFA device and get Totp Secret
   */
  registerTotpMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerTotpMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFARegisterTotpDeviceGetResponseFromJSON(jsonValue));
    });
  }
  /**
   * Register a new TOTP MFA device and get Totp Secret
   */
  registerTotpMfaDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.registerTotpMfaDeviceRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  registerTotpMfaDeviceOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerTotpMfaDeviceOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  registerTotpMfaDeviceOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.registerTotpMfaDeviceOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify TOTP MFA device
   */
  registerTotpMfaDeviceVerifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling registerTotpMfaDeviceVerify.");
      }
      if (requestParameters.mFARegisterTotpDevicePostRequest === null || requestParameters.mFARegisterTotpDevicePostRequest === void 0) {
        throw new RequiredError("mFARegisterTotpDevicePostRequest", "Required parameter requestParameters.mFARegisterTotpDevicePostRequest was null or undefined when calling registerTotpMfaDeviceVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/register/totp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MFARegisterTotpDevicePostRequestToJSON(requestParameters.mFARegisterTotpDevicePostRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => MFADeviceFromJSON(jsonValue));
    });
  }
  /**
   * Verify TOTP MFA device
   */
  registerTotpMfaDeviceVerify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.registerTotpMfaDeviceVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Reshare secret shares and update the threshold
   */
  reshareRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling reshare.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling reshare.");
      }
      if (requestParameters.reshareRequest === null || requestParameters.reshareRequest === void 0) {
        throw new RequiredError("reshareRequest", "Required parameter requestParameters.reshareRequest was null or undefined when calling reshare.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/reshare`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ReshareRequestToJSON(requestParameters.reshareRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OpenRoomResponseForReshareFromJSON(jsonValue));
    });
  }
  /**
   * Reshare secret shares and update the threshold
   */
  reshare(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.reshareRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  reshareOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling reshareOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling reshareOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/reshare`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  reshareOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.reshareOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Restore an embedded wallet
   * Restore an embedded wallet
   */
  restoreEmbeddedWalletRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling restoreEmbeddedWallet.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling restoreEmbeddedWallet.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/restore`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Restore an embedded wallet
   * Restore an embedded wallet
   */
  restoreEmbeddedWallet(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.restoreEmbeddedWalletRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  restoreEmbeddedWalletOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling restoreEmbeddedWalletOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling restoreEmbeddedWalletOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/restore`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  restoreEmbeddedWalletOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.restoreEmbeddedWalletOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Send new code for email verification
   */
  retryEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retryEmailVerification.");
      }
      if (requestParameters.emailVerificationRetryRequest === null || requestParameters.emailVerificationRetryRequest === void 0) {
        throw new RequiredError("emailVerificationRetryRequest", "Required parameter requestParameters.emailVerificationRetryRequest was null or undefined when calling retryEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationRetryRequestToJSON(requestParameters.emailVerificationRetryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => EmailVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Send new code for email verification
   */
  retryEmailVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.retryEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  retryEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retryEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  retryEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.retryEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Send new code for sms verification
   */
  retrySmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retrySmsVerification.");
      }
      if (requestParameters.smsVerificationRetryRequest === null || requestParameters.smsVerificationRetryRequest === void 0) {
        throw new RequiredError("smsVerificationRetryRequest", "Required parameter requestParameters.smsVerificationRetryRequest was null or undefined when calling retrySmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationRetryRequestToJSON(requestParameters.smsVerificationRetryRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SmsVerificationCreateResponseFromJSON(jsonValue));
    });
  }
  /**
   * Send new code for sms verification
   */
  retrySmsVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.retrySmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  retrySmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling retrySmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/retry`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  retrySmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.retrySmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Revoke a session
   */
  revokeSessionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling revokeSession.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/revoke`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Revoke a session
   */
  revokeSession(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.revokeSessionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  revokeSessionOptionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling revokeSessionOption.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/revoke`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  revokeSessionOption(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.revokeSessionOptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Scan a URL for potential malicious activity
   */
  scanUrlRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling scanUrl.");
      }
      if (requestParameters.scanWebsiteUrlRequest === null || requestParameters.scanWebsiteUrlRequest === void 0) {
        throw new RequiredError("scanWebsiteUrlRequest", "Required parameter requestParameters.scanWebsiteUrlRequest was null or undefined when calling scanUrl.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/scan/websiteUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: ScanWebsiteUrlRequestToJSON(requestParameters.scanWebsiteUrlRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => ScanWebsiteUrlResponseFromJSON(jsonValue));
    });
  }
  /**
   * Scan a URL for potential malicious activity
   */
  scanUrl(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.scanUrlRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  scanUrlOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling scanUrlOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/scan/websiteUrl`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  scanUrlOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.scanUrlOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   */
  sdkSettingsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sdkSettingsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/sdkSettings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   */
  sdkSettingsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.sdkSettingsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * When a user selects a wallet to be the primary wallet in a multi-wallet enabled environment, this endpoint is called to record this on the backend.
   * Update wallet in a multi-wallet selection
   */
  selectUserWalletRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling selectUserWallet.");
      }
      if (requestParameters.userWalletSelectionRequest === null || requestParameters.userWalletSelectionRequest === void 0) {
        throw new RequiredError("userWalletSelectionRequest", "Required parameter requestParameters.userWalletSelectionRequest was null or undefined when calling selectUserWallet.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/wallets/selection`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UserWalletSelectionRequestToJSON(requestParameters.userWalletSelectionRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * When a user selects a wallet to be the primary wallet in a multi-wallet enabled environment, this endpoint is called to record this on the backend.
   * Update wallet in a multi-wallet selection
   */
  selectUserWallet(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.selectUserWalletRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  selectUserWalletOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling selectUserWalletOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/wallets/selection`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  selectUserWalletOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.selectUserWalletOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Check that session is valid
   */
  sessionCheckRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sessionCheck.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/session`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Check that session is valid
   */
  sessionCheck(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.sessionCheckRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionCheckOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sessionCheckOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/session`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionCheckOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.sessionCheckOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionKeyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling sessionKeyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/sessionKey`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  sessionKeyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.sessionKeyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  settingsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling settingsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  settingsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.settingsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify an email and sign in user
   */
  signInWithEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithEmailVerification.");
      }
      if (requestParameters.emailVerificationVerifyRequest === null || requestParameters.emailVerificationVerifyRequest === void 0) {
        throw new RequiredError("emailVerificationVerifyRequest", "Required parameter requestParameters.emailVerificationVerifyRequest was null or undefined when calling signInWithEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationVerifyRequestToJSON(requestParameters.emailVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify an email and sign in user
   */
  signInWithEmailVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.signInWithEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.signInWithEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify an sms and sign in user
   */
  signInWithSmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithSmsVerification.");
      }
      if (requestParameters.smsVerificationVerifyRequest === null || requestParameters.smsVerificationVerifyRequest === void 0) {
        throw new RequiredError("smsVerificationVerifyRequest", "Required parameter requestParameters.smsVerificationVerifyRequest was null or undefined when calling signInWithSmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationVerifyRequestToJSON(requestParameters.smsVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify an sms and sign in user
   */
  signInWithSmsVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.signInWithSmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithSmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signInWithSmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  signInWithSmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.signInWithSmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Sign a message with a waas account
   */
  signMessageRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signMessage.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling signMessage.");
      }
      if (requestParameters.signMessageWithWaasRequest === null || requestParameters.signMessageWithWaasRequest === void 0) {
        throw new RequiredError("signMessageWithWaasRequest", "Required parameter requestParameters.signMessageWithWaasRequest was null or undefined when calling signMessage.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/signMessage`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SignMessageWithWaasRequestToJSON(requestParameters.signMessageWithWaasRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => OpenRoomResponseFromJSON(jsonValue));
    });
  }
  /**
   * Sign a message with a waas account
   */
  signMessage(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.signMessageRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  signMessageOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signMessageOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling signMessageOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/signMessage`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  signMessageOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.signMessageOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Authenticate a passkey
   */
  signinWithPasskeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling signinWithPasskey.");
      }
      if (requestParameters.passkeyAuthRequest === null || requestParameters.passkeyAuthRequest === void 0) {
        throw new RequiredError("passkeyAuthRequest", "Required parameter requestParameters.passkeyAuthRequest was null or undefined when calling signinWithPasskey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PasskeyAuthRequestToJSON(requestParameters.passkeyAuthRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Authenticate a passkey
   */
  signinWithPasskey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.signinWithPasskeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Simulate an EVM transaction
   */
  simulateEVMTransactionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling simulateEVMTransaction.");
      }
      if (requestParameters.simulateEVMTransactionRequest === null || requestParameters.simulateEVMTransactionRequest === void 0) {
        throw new RequiredError("simulateEVMTransactionRequest", "Required parameter requestParameters.simulateEVMTransactionRequest was null or undefined when calling simulateEVMTransaction.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/evm/simulateTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SimulateEVMTransactionRequestToJSON(requestParameters.simulateEVMTransactionRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SimulateTransactionResponseFromJSON(jsonValue));
    });
  }
  /**
   * Simulate an EVM transaction
   */
  simulateEVMTransaction(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.simulateEVMTransactionRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  simulateEVMTransactionOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling simulateEVMTransactionOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/evm/simulateTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  simulateEVMTransactionOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.simulateEVMTransactionOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Simulate a Solana transaction
   */
  simulateSVMTransactionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling simulateSVMTransaction.");
      }
      if (requestParameters.simulateSVMTransactionRequest === null || requestParameters.simulateSVMTransactionRequest === void 0) {
        throw new RequiredError("simulateSVMTransactionRequest", "Required parameter requestParameters.simulateSVMTransactionRequest was null or undefined when calling simulateSVMTransaction.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/solana/simulateTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SimulateSVMTransactionRequestToJSON(requestParameters.simulateSVMTransactionRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SimulateTransactionResponseFromJSON(jsonValue));
    });
  }
  /**
   * Simulate a Solana transaction
   */
  simulateSVMTransaction(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.simulateSVMTransactionRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  simulateSVMTransactionOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling simulateSVMTransactionOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/solana/simulateTransaction`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  simulateSVMTransactionOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.simulateSVMTransactionOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Simulate an EVM AA UserOp
   */
  simulateUserOpRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling simulateUserOp.");
      }
      if (requestParameters.simulateUserOpRequest === null || requestParameters.simulateUserOpRequest === void 0) {
        throw new RequiredError("simulateUserOpRequest", "Required parameter requestParameters.simulateUserOpRequest was null or undefined when calling simulateUserOp.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/evm/simulateUserOp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SimulateUserOpRequestToJSON(requestParameters.simulateUserOpRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SimulateTransactionResponseFromJSON(jsonValue));
    });
  }
  /**
   * Simulate an EVM AA UserOp
   */
  simulateUserOp(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.simulateUserOpRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  simulateUserOpOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling simulateUserOpOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/evm/simulateUserOp`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  simulateUserOpOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.simulateUserOpOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Soft delete an embedded wallet
   * Soft delete an embedded wallet
   */
  softDeleteEmbeddedWalletRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling softDeleteEmbeddedWallet.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling softDeleteEmbeddedWallet.");
      }
      const queryParameters = {};
      const headerParameters = {};
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/softDelete`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Soft delete an embedded wallet
   * Soft delete an embedded wallet
   */
  softDeleteEmbeddedWallet(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.softDeleteEmbeddedWalletRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  softDeleteEmbeddedWalletOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling softDeleteEmbeddedWalletOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling softDeleteEmbeddedWalletOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/{walletId}/softDelete`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  softDeleteEmbeddedWalletOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.softDeleteEmbeddedWalletOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/auth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramAuthOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.telegramAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Telegram provider check auth
   */
  telegramCheckAuthRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramCheckAuth.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/checkTelegramAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Telegram provider check auth
   */
  telegramCheckAuth(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.telegramCheckAuthRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramCheckAuthOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramCheckAuthOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/checkTelegramAuth`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramCheckAuthOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.telegramCheckAuthOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Telegram provider SignIn endpoint
   */
  telegramSignInRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramSignIn.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Telegram provider SignIn endpoint
   */
  telegramSignIn(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.telegramSignInRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramSignInOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramSignInOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/signin`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramSignInOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.telegramSignInOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Telegram provider Verify endpoint
   */
  telegramVerifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramVerify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: OauthResultRequestToJSON(requestParameters.oauthResultRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Telegram provider Verify endpoint
   */
  telegramVerify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.telegramVerifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramVerifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling telegramVerifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/telegram/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  telegramVerifyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.telegramVerifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Update a user\'s Turnkey recovery email
   */
  updateEmbeddedWalletRecoveryEmailRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateEmbeddedWalletRecoveryEmail.");
      }
      if (requestParameters.updateRecoveryEmailRequest === null || requestParameters.updateRecoveryEmailRequest === void 0) {
        throw new RequiredError("updateRecoveryEmailRequest", "Required parameter requestParameters.updateRecoveryEmailRequest was null or undefined when calling updateEmbeddedWalletRecoveryEmail.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/recoveryEmail`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateRecoveryEmailRequestToJSON(requestParameters.updateRecoveryEmailRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Update a user\'s Turnkey recovery email
   */
  updateEmbeddedWalletRecoveryEmail(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.updateEmbeddedWalletRecoveryEmailRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Update a passkey\'s info
   */
  updatePasskeyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updatePasskey.");
      }
      if (requestParameters.updateUserPasskeyRequest === null || requestParameters.updateUserPasskeyRequest === void 0) {
        throw new RequiredError("updateUserPasskeyRequest", "Required parameter requestParameters.updateUserPasskeyRequest was null or undefined when calling updatePasskey.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateUserPasskeyRequestToJSON(requestParameters.updateUserPasskeyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UserPasskeyFromJSON(jsonValue));
    });
  }
  /**
   * Update a passkey\'s info
   */
  updatePasskey(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.updatePasskeyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Update a user\'s fields
   */
  updateSelfRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateSelf.");
      }
      if (requestParameters.userFields === null || requestParameters.userFields === void 0) {
        throw new RequiredError("userFields", "Required parameter requestParameters.userFields was null or undefined when calling updateSelf.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UserFieldsToJSON(requestParameters.userFields)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateSelfResponseFromJSON(jsonValue));
    });
  }
  /**
   * Update a user\'s fields
   */
  updateSelf(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.updateSelfRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Update a device
   */
  updateUserMfaDeviceRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateUserMfaDevice.");
      }
      if (requestParameters.mfaDeviceId === null || requestParameters.mfaDeviceId === void 0) {
        throw new RequiredError("mfaDeviceId", "Required parameter requestParameters.mfaDeviceId was null or undefined when calling updateUserMfaDevice.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/mfa/{mfaDeviceId}`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"mfaDeviceId"}}`, encodeURIComponent(String(requestParameters.mfaDeviceId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: MFAUpdateDeviceRequestToJSON(requestParameters.mFAUpdateDeviceRequest)
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Update a device
   */
  updateUserMfaDevice(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.updateUserMfaDeviceRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Updates the settings for a WAAS wallet
   * Update the WAAS wallet settings for the wallet
   */
  updateWaasWalletSettingsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling updateWaasWalletSettings.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling updateWaasWalletSettings.");
      }
      if (requestParameters.updateWaasWalletSettingsRequest === null || requestParameters.updateWaasWalletSettingsRequest === void 0) {
        throw new RequiredError("updateWaasWalletSettingsRequest", "Required parameter requestParameters.updateWaasWalletSettingsRequest was null or undefined when calling updateWaasWalletSettings.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: UpdateWaasWalletSettingsRequestToJSON(requestParameters.updateWaasWalletSettingsRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateWaasWalletSettingsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Updates the settings for a WAAS wallet
   * Update the WAAS wallet settings for the wallet
   */
  updateWaasWalletSettings(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.updateWaasWalletSettingsRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Update V1 embedded wallet to V2
   */
  upgradeEmbeddedWalletToV2Raw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling upgradeEmbeddedWalletToV2.");
      }
      if (requestParameters.upgradeEmbeddedWalletToV2Request === null || requestParameters.upgradeEmbeddedWalletToV2Request === void 0) {
        throw new RequiredError("upgradeEmbeddedWalletToV2Request", "Required parameter requestParameters.upgradeEmbeddedWalletToV2Request was null or undefined when calling upgradeEmbeddedWalletToV2.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/upgradeToV2`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: UpgradeEmbeddedWalletToV2RequestToJSON(requestParameters.upgradeEmbeddedWalletToV2Request)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Update V1 embedded wallet to V2
   */
  upgradeEmbeddedWalletToV2(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.upgradeEmbeddedWalletToV2Raw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  upgradeEmbeddedWalletToV2OptionRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling upgradeEmbeddedWalletToV2Option.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/upgradeToV2`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  upgradeEmbeddedWalletToV2Option(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.upgradeEmbeddedWalletToV2OptionRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  userPasskeysOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling userPasskeysOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/passkeys`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  userPasskeysOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.userPasskeysOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  usersOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling usersOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  usersOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.usersOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify payload and return JWT
   */
  verifyRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verify.");
      }
      if (requestParameters.verifyRequest === null || requestParameters.verifyRequest === void 0) {
        throw new RequiredError("verifyRequest", "Required parameter requestParameters.verifyRequest was null or undefined when calling verify.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyRequestToJSON(requestParameters.verifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify payload and return JWT
   */
  verify(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifyRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Verify email verification request
   */
  verifyEmailVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyEmailVerification.");
      }
      if (requestParameters.emailVerificationVerifyRequest === null || requestParameters.emailVerificationVerifyRequest === void 0) {
        throw new RequiredError("emailVerificationVerifyRequest", "Required parameter requestParameters.emailVerificationVerifyRequest was null or undefined when calling verifyEmailVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EmailVerificationVerifyRequestToJSON(requestParameters.emailVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateSelfResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify email verification request
   */
  verifyEmailVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifyEmailVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyEmailVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyEmailVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/emailVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyEmailVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyEmailVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Link a wallet to a valid environment user, and return an updated JWT
   * Link wallet to user
   */
  verifyLinkRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyLink.");
      }
      if (requestParameters.verifyRequest === null || requestParameters.verifyRequest === void 0) {
        throw new RequiredError("verifyRequest", "Required parameter requestParameters.verifyRequest was null or undefined when calling verifyLink.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/link`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyRequestToJSON(requestParameters.verifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Link a wallet to a valid environment user, and return an updated JWT
   * Link wallet to user
   */
  verifyLink(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifyLinkRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyLinkOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyLinkOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/link`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyLinkOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyLinkOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Used to merge two users with user-chosen resolutions to conflicting data between the two users to be merged
   * Merge users with conflict resolutions
   */
  verifyMergeUsersRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyMergeUsers.");
      }
      if (requestParameters.mergeUserConflictResolutions === null || requestParameters.mergeUserConflictResolutions === void 0) {
        throw new RequiredError("mergeUserConflictResolutions", "Required parameter requestParameters.mergeUserConflictResolutions was null or undefined when calling verifyMergeUsers.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: MergeUserConflictResolutionsToJSON(requestParameters.mergeUserConflictResolutions)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Used to merge two users with user-chosen resolutions to conflicting data between the two users to be merged
   * Merge users with conflict resolutions
   */
  verifyMergeUsers(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifyMergeUsersRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyMergeUsersOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyMergeUsersOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/merge`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyMergeUsersOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyMergeUsersOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyPrefetchRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyPrefetch.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/prefetch`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyPrefetch(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyPrefetchRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Verify sms verification request
   */
  verifySmsVerificationRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifySmsVerification.");
      }
      if (requestParameters.smsVerificationVerifyRequest === null || requestParameters.smsVerificationVerifyRequest === void 0) {
        throw new RequiredError("smsVerificationVerifyRequest", "Required parameter requestParameters.smsVerificationVerifyRequest was null or undefined when calling verifySmsVerification.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SmsVerificationVerifyRequestToJSON(requestParameters.smsVerificationVerifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => UpdateSelfResponseFromJSON(jsonValue));
    });
  }
  /**
   * Verify sms verification request
   */
  verifySmsVerification(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifySmsVerificationRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifySmsVerificationOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifySmsVerificationOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/smsVerifications/verify`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifySmsVerificationOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifySmsVerificationOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Used to link a wallet after user has confirmed transfer to the new account
   * Verify wallet transfer
   */
  verifyTransferRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyTransfer.");
      }
      if (requestParameters.verifyRequest === null || requestParameters.verifyRequest === void 0) {
        throw new RequiredError("verifyRequest", "Required parameter requestParameters.verifyRequest was null or undefined when calling verifyTransfer.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/transfer`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyRequestToJSON(requestParameters.verifyRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Used to link a wallet after user has confirmed transfer to the new account
   * Verify wallet transfer
   */
  verifyTransfer(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifyTransferRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyTransferOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyTransferOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/transfer`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyTransferOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyTransferOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Remove a link from to a valid environment user, and return an updated JWT
   * unlink wallet from user
   */
  verifyUnlinkRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyUnlink.");
      }
      if (requestParameters.verifyUnlinkRequest === null || requestParameters.verifyUnlinkRequest === void 0) {
        throw new RequiredError("verifyUnlinkRequest", "Required parameter requestParameters.verifyUnlinkRequest was null or undefined when calling verifyUnlink.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      if (this.configuration && this.configuration.accessToken) {
        const token = this.configuration.accessToken;
        const tokenString = yield token("bearerAuth", []);
        if (tokenString) {
          headerParameters["Authorization"] = `Bearer ${tokenString}`;
        }
      }
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/unlink`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: VerifyUnlinkRequestToJSON(requestParameters.verifyUnlinkRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => VerifyResponseFromJSON(jsonValue));
    });
  }
  /**
   * Remove a link from to a valid environment user, and return an updated JWT
   * unlink wallet from user
   */
  verifyUnlink(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      const response = yield this.verifyUnlinkRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyUnlinkOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling verifyUnlinkOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/verify/unlink`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  verifyUnlinkOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.verifyUnlinkOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  waasWalletSettingsOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling waasWalletSettingsOptions.");
      }
      if (requestParameters.walletId === null || requestParameters.walletId === void 0) {
        throw new RequiredError("walletId", "Required parameter requestParameters.walletId was null or undefined when calling waasWalletSettingsOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/waas/{walletId}/settings`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))).replace(`{${"walletId"}}`, encodeURIComponent(String(requestParameters.walletId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  waasWalletSettingsOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.waasWalletSettingsOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling walletAccountOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.walletAccountOptionsRaw(requestParameters, initOverrides);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountRequestOptionsRaw(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (requestParameters.environmentId === null || requestParameters.environmentId === void 0) {
        throw new RequiredError("environmentId", "Required parameter requestParameters.environmentId was null or undefined when calling walletAccountRequestOptions.");
      }
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/sdk/{environmentId}/users/embeddedWallets/walletAccounts/createRequest`.replace(`{${"environmentId"}}`, encodeURIComponent(String(requestParameters.environmentId))),
        method: "OPTIONS",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new VoidApiResponse(response);
    });
  }
  /**
   * Options call for this endpoint
   */
  walletAccountRequestOptions(requestParameters, initOverrides) {
    return __awaiter2(this, void 0, void 0, function* () {
      yield this.walletAccountRequestOptionsRaw(requestParameters, initOverrides);
    });
  }
};

// node_modules/@dynamic-labs/utils/package.js
var version = "4.43.0";

// node_modules/@dynamic-labs/utils/src/bufferToBase64/bufferPolyfill.js
var import_buffer = __toESM(require_buffer(), 1);
if (typeof window !== "undefined") {
  window.global = globalThis;
  if (!window.Buffer && typeof window.Buffer === "undefined") {
    Object.assign(window, { Buffer: import_buffer.Buffer });
  }
}

// node_modules/@dynamic-labs/utils/src/logger/logger.js
var logger2 = new Logger("utils");

// node_modules/@dynamic-labs/utils/src/ceil/ceil.js
var ceil = (value, precision = 0) => {
  const multiplier = Math.pow(10, precision);
  return Math.ceil(value * multiplier) / multiplier;
};

// node_modules/@dynamic-labs/utils/src/DeferredPromise/DeferredPromise.js
var DeferredPromise = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// node_modules/@dynamic-labs/utils/src/eip6963/eip6963Provider.js
var isEip9693Event = (event) => event.type === "eip6963:announceProvider" && event.detail !== void 0;
var listenToEip6963Events = (handler) => {
  const eventHandler = (event) => {
    if (!isEip9693Event(event)) {
      return;
    }
    handler(event);
  };
  window.addEventListener("eip6963:announceProvider", eventHandler);
  return () => {
    window.removeEventListener("eip6963:announceProvider", eventHandler);
  };
};
var Eip6963Provider = class {
  constructor() {
    this.providers = [];
  }
  registerProviders() {
    if (typeof window === "undefined") {
      return;
    }
    listenToEip6963Events((event) => {
      this.providers.push(event.detail);
    });
    window.dispatchEvent(new Event("eip6963:requestProvider"));
  }
};
var Eip6963ProviderSingleton = class _Eip6963ProviderSingleton {
  constructor() {
    this.eip6963Provider = new Eip6963Provider();
  }
  static get() {
    var _a5;
    if (!((_a5 = _Eip6963ProviderSingleton.instance) === null || _a5 === void 0 ? void 0 : _a5.eip6963Provider)) {
      _Eip6963ProviderSingleton.instance = new _Eip6963ProviderSingleton();
      _Eip6963ProviderSingleton.instance.eip6963Provider.registerProviders();
    }
    return _Eip6963ProviderSingleton.instance.eip6963Provider;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/CustomError.js
var CustomError = class extends Error {
  constructor(message, code) {
    super(message);
    this.code = void 0;
    this.code = code;
    Object.setPrototypeOf(this, this.constructor.prototype);
  }
  toJSON() {
    return {
      code: this.code,
      error: this.message
    };
  }
};

// node_modules/@dynamic-labs/utils/src/errors/DynamicError.js
var DynamicError = class extends CustomError {
};

// node_modules/@dynamic-labs/utils/src/errors/AccessBlockedError.js
var AccessBlockedError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/AccountExistsError.js
var AccountExistsError = class extends DynamicError {
  constructor(errorMessage, errorPayload) {
    super(errorMessage);
    this.errorMessage = errorMessage;
    this.errorPayload = errorPayload;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/ChainalysisError.js
var ChainalysisError = class extends DynamicError {
  constructor(walletPublicKey) {
    super("This address is not approved for access");
    this.walletPublicKey = walletPublicKey;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/CustomFieldNotUniqueError.js
var CustomFieldNotUniqueError = class extends DynamicError {
  constructor() {
    super("Custom Field for user must be unique within the environment", "custom_field_data_not_unique");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailAlreadyExistsError.js
var EmailAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Email already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmailVerificationError.js
var EmailVerificationError = class extends DynamicError {
  constructor(message, code) {
    super(message, code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmbeddedWalletException.js
var EmbeddedWalletException = class extends DynamicError {
  constructor(message) {
    super(message);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/EmbeddedWalletExistsError.js
var EmbeddedWalletExistsError = class extends DynamicError {
  constructor(code) {
    super("EmbeddedWalletExistsError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/ErrorCode.js
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["UNKNOWN"] = 0] = "UNKNOWN";
  ErrorCode2[ErrorCode2["DEFAULT"] = 1] = "DEFAULT";
  ErrorCode2[ErrorCode2["USER_REJECTED"] = 2] = "USER_REJECTED";
  ErrorCode2[ErrorCode2["MESSAGE_SIGNATURE_DENIED"] = 3] = "MESSAGE_SIGNATURE_DENIED";
  ErrorCode2[ErrorCode2["WALLET_LOCKED"] = 4] = "WALLET_LOCKED";
  ErrorCode2[ErrorCode2["INVALID_PARAMETERS"] = 5] = "INVALID_PARAMETERS";
  ErrorCode2[ErrorCode2["INTERNAL_ERROR"] = 6] = "INTERNAL_ERROR";
  ErrorCode2[ErrorCode2["ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE"] = 7] = "ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE";
  ErrorCode2[ErrorCode2["CONNECTION_REJECTED"] = 8] = "CONNECTION_REJECTED";
  ErrorCode2[ErrorCode2["MISSING_PUBLIC_ADDRESS"] = 9] = "MISSING_PUBLIC_ADDRESS";
  ErrorCode2[ErrorCode2["CONNECTION_PROPOSAL_EXPIRED"] = 10] = "CONNECTION_PROPOSAL_EXPIRED";
  ErrorCode2[ErrorCode2["SEI_NOT_ENABLED_IN_KEPLR_WALLET"] = 11] = "SEI_NOT_ENABLED_IN_KEPLR_WALLET";
})(ErrorCode || (ErrorCode = {}));

// node_modules/@dynamic-labs/utils/src/errors/GateBlockedError.js
var GateBlockedError = class extends DynamicError {
  constructor(walletPublicKey) {
    super("This address is blocked by the gate");
    this.walletPublicKey = walletPublicKey;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/GetAddressCancelledError.js
var GetAddressCancelledError = class extends CustomError {
  constructor() {
    super("Get address call was cancelled");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InsufficientFundsError.js
var InsufficientFundsError = class _InsufficientFundsError extends DynamicError {
  constructor() {
    super(_InsufficientFundsError.message);
  }
  static isInstance(err) {
    var _a5;
    const error40 = ((_a5 = err === null || err === void 0 ? void 0 : err.walk) === null || _a5 === void 0 ? void 0 : _a5.call(err)) || err;
    return error40 instanceof _InsufficientFundsError;
  }
  static isErrorMessage(err) {
    var _a5;
    const errorWithMessage = err;
    return ((_a5 = errorWithMessage === null || errorWithMessage === void 0 ? void 0 : errorWithMessage.message) === null || _a5 === void 0 ? void 0 : _a5.includes("AA21 didn't pay prefund")) || false;
  }
};
InsufficientFundsError.message = "Insufficient funds.";

// node_modules/@dynamic-labs/utils/src/errors/InvalidEmbeddedWalletSessionKeyError.js
var InvalidEmbeddedWalletSessionKeyError = class extends DynamicError {
  constructor(error40) {
    super(error40 !== null && error40 !== void 0 ? error40 : "Invalid embedded wallet session key.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InvalidPhoneNumberError.js
var InvalidPhoneNumberError = class extends DynamicError {
  constructor(error40) {
    super(error40 !== null && error40 !== void 0 ? error40 : "Invalid phone number.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/InvalidPrimaryWalletOrConnectorError.js
var InvalidPrimaryWalletOrConnectorError = class extends DynamicError {
  constructor(code) {
    super("Primary wallet is not properly set or the wallet connector is missing from DynamicContextProvider settings.", code);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MergeAccountsConfirmationError.js
var MergeAccountsConfirmationError = class extends DynamicError {
  constructor({ code, mergeConflicts, walletAddress }) {
    super("MergeAccountsConfirmationError", code);
    this.mergeConflicts = mergeConflicts;
    this.walletAddress = walletAddress;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MetaMaskError.js
var metaMaskErrorMap = {
  4001: ErrorCode.USER_REJECTED
};
var MetaMaskError = class _MetaMaskError extends CustomError {
  constructor(message, code) {
    super(message, code);
  }
  /**
   * Creates a [MetaMaskError] from an unknown error (thrown by MetaMask)
   *
   * @param error - The error to create the [MetaMaskError] from
   * @returns A new [MetaMaskError]
   */
  static fromError(error40) {
    var _a5, _b;
    if (error40 instanceof Object) {
      const errorObject = error40;
      const dynamicErrorCode = (_b = metaMaskErrorMap[(_a5 = errorObject.code) !== null && _a5 !== void 0 ? _a5 : ""]) !== null && _b !== void 0 ? _b : ErrorCode.DEFAULT;
      return new _MetaMaskError(errorObject.message, dynamicErrorCode);
    }
    return new _MetaMaskError(String(error40), ErrorCode.DEFAULT);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MissingEnvironmentIdError.js
var MissingEnvironmentIdError = class extends DynamicError {
  constructor() {
    super("You are missing the environmentId field in yours DynamicContextProvider settings prop");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/MissingPublicAddressError.js
var MissingPublicAddressError = class extends DynamicError {
  constructor() {
    super("Missing public address", "missing-public-address");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/NoAccessError.js
var NoAccessError = class extends DynamicError {
  constructor({ walletPublicKey, email: email2, phoneNumber, socialProvider, socialUsername }) {
    super("User does not have access");
    this.email = email2;
    this.walletPublicKey = walletPublicKey;
    this.phoneNumber = phoneNumber;
    this.socialProvider = socialProvider;
    this.socialUsername = socialUsername;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/RequestChannelNotHandledError.js
var RequestChannelNotHandledError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/_virtual/_tslib.js
function __awaiter3(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}

// node_modules/@dynamic-labs/utils/src/errors/ResponseError.js
var ResponseError = class _ResponseError extends CustomError {
  constructor({ message, cause, jsonData }) {
    const messageError = `
    Message: ${message !== null && message !== void 0 ? message : "Unknown"}
    URL: ${cause.url}
    Status: ${cause.status}
    Status Text: ${cause.statusText}
    Type: ${cause.type}
    Redirect: ${cause.redirected}

    Json data:${jsonData ? "\n" + JSON.stringify(jsonData, null, 2) : " No data"}
    `.trim();
    super(messageError);
    this.jsonData = jsonData;
    this.response = cause;
    this.cause = cause;
  }
  get json() {
    return this.jsonData;
  }
  static fromResponse(_a5) {
    return __awaiter3(this, arguments, void 0, function* ({ cause, message }) {
      const jsonData = yield cause.json();
      return new _ResponseError({
        cause,
        jsonData,
        message
      });
    });
  }
};

// node_modules/@dynamic-labs/utils/src/errors/SandboxMaximumThresholdReachedError.js
var SandboxMaximumThresholdReachedError = class extends DynamicError {
  constructor(errorMessage) {
    super(errorMessage);
    this.errorMessage = errorMessage;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/SmsVerificationError.js
var SmsVerificationError = class extends DynamicError {
};

// node_modules/@dynamic-labs/utils/src/errors/SocialAccountAlreadyExistsError.js
var SocialAccountAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Social account already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/TooManyEmailVerificationsError.js
var TooManyEmailVerificationsError = class extends DynamicError {
  constructor() {
    super("Too many email verification attempts.");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/TransactionGasCannotBeSponsoredError.js
var TransactionGasCannotBeSponsoredError = class _TransactionGasCannotBeSponsoredError extends DynamicError {
  constructor() {
    super(_TransactionGasCannotBeSponsoredError.message);
  }
  static isInstance(err) {
    var _a5;
    const error40 = ((_a5 = err === null || err === void 0 ? void 0 : err.walk) === null || _a5 === void 0 ? void 0 : _a5.call(err)) || err;
    return error40 instanceof _TransactionGasCannotBeSponsoredError;
  }
  static isErrorMessage(err) {
    var _a5;
    const errorWithMessage = err;
    return ((_a5 = errorWithMessage === null || errorWithMessage === void 0 ? void 0 : errorWithMessage.message) === null || _a5 === void 0 ? void 0 : _a5.includes("userOp did not match any gas sponsoring policies")) || false;
  }
};
TransactionGasCannotBeSponsoredError.message = "Transaction gas cannot be sponsored.";

// node_modules/@dynamic-labs/utils/src/errors/UserHasAccountWithEmailError.js
var UserHasAccountWithEmailError = class extends DynamicError {
  constructor(error40) {
    super(error40);
    this.error = error40;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UsernameAlreadyExistsError.js
var UsernameAlreadyExistsError = class extends DynamicError {
  constructor() {
    super("Username already exists");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UserRejectedRequestError.js
var UserRejectedRequestError = class extends DynamicError {
  constructor() {
    super("User rejected request", "user_rejected_request");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/UserRejectedTransactionError.js
var UserRejectedTransactionError = class extends DynamicError {
  constructor() {
    super("user rejected transaction");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/VerificationDataCollectionError.js
var VerificationDataCollectionError = class extends DynamicError {
  constructor(message) {
    super("Failed to get verification data: " + message);
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletAddressMismatchError.js
var WalletAddressMismatchError = class extends DynamicError {
  constructor(message, { activeAddress, expectedAddress, walletName }) {
    super(message, "wallet_address_mismatch_error");
    this.expectedAddress = expectedAddress;
    this.activeAddress = activeAddress;
    this.walletName = walletName;
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletNotDeployedError.js
var WalletNotDeployedError = class extends DynamicError {
  constructor() {
    super("Wallet has not been deployed", "wallet_not_deployed");
  }
};

// node_modules/@dynamic-labs/utils/src/errors/WalletUsedError.js
var WalletUsedError = class extends DynamicError {
  constructor(code) {
    super("WalletUsedError", code);
  }
};

// node_modules/@dynamic-labs/utils/src/eventTimeline/eventTimeline.js
var createEventTimeline = () => {
  const eventTimelines = /* @__PURE__ */ new Map();
  return {
    clear: () => {
      eventTimelines.clear();
    },
    isEventRecent: (eventName, timeSince) => {
      const now = Date.now();
      let timestamps = eventTimelines.get(eventName);
      if (!timestamps) {
        return false;
      }
      const cutoff = now - timeSince;
      timestamps = timestamps.filter((timestamp) => timestamp >= cutoff);
      return timestamps.length > 0;
    },
    postEvent: (event) => {
      var _a5;
      const now = Date.now();
      if (!eventTimelines.has(event)) {
        eventTimelines.set(event, []);
      }
      (_a5 = eventTimelines.get(event)) === null || _a5 === void 0 ? void 0 : _a5.push(now);
    }
  };
};

// node_modules/@dynamic-labs/utils/src/trimEnd/trimEnd.js
var trimEnd = (text, char = "") => {
  let endIndex = text.length - 1;
  while (endIndex >= 0 && text[endIndex] === char) {
    endIndex--;
  }
  return text.slice(0, endIndex + 1);
};

// node_modules/@dynamic-labs/utils/src/formatNumberText/formatNumberText.js
var formatNumberText = (value, { precision = 0 } = {}) => {
  if (!precision) {
    return value;
  }
  const floatValue = parseFloat(value);
  const formattedAtPrecision = ceil(floatValue, precision).toFixed(precision);
  const [integerPart, decimalPart] = formattedAtPrecision.split(".");
  const decimalPartTrimmed = trimEnd(decimalPart, "0");
  return `${integerPart}.${decimalPartTrimmed || "0"}`;
};

// node_modules/@dynamic-labs/utils/src/getProvidersFromWindow/getProvidersFromWindow.js
var getProvidersFromWindow = (path) => {
  const splitPath = path.split(".");
  let result = window;
  const foundProviders = [];
  for (const [index, p] of Object.entries(splitPath)) {
    result = result[p];
    if (typeof result !== "object" || result === null) {
      return [];
    }
    if (Number(index) === splitPath.length - 1) {
      if (Array.isArray(result)) {
        result.forEach((p2) => foundProviders.push(p2));
      } else {
        if (result.providers) {
          result.providers.forEach((p2) => foundProviders.push(p2));
        } else {
          foundProviders.push(result);
        }
      }
    }
  }
  return foundProviders;
};

// node_modules/tldts-core/dist/es6/src/domain.js
function shareSameDomainSuffix(hostname2, vhost) {
  if (hostname2.endsWith(vhost)) {
    return hostname2.length === vhost.length || hostname2[hostname2.length - vhost.length - 1] === ".";
  }
  return false;
}
function extractDomainWithSuffix(hostname2, publicSuffix) {
  const publicSuffixIndex = hostname2.length - publicSuffix.length - 2;
  const lastDotBeforeSuffixIndex = hostname2.lastIndexOf(".", publicSuffixIndex);
  if (lastDotBeforeSuffixIndex === -1) {
    return hostname2;
  }
  return hostname2.slice(lastDotBeforeSuffixIndex + 1);
}
function getDomain(suffix, hostname2, options) {
  if (options.validHosts !== null) {
    const validHosts = options.validHosts;
    for (const vhost of validHosts) {
      if (
        /*@__INLINE__*/
        shareSameDomainSuffix(hostname2, vhost)
      ) {
        return vhost;
      }
    }
  }
  let numberOfLeadingDots = 0;
  if (hostname2.startsWith(".")) {
    while (numberOfLeadingDots < hostname2.length && hostname2[numberOfLeadingDots] === ".") {
      numberOfLeadingDots += 1;
    }
  }
  if (suffix.length === hostname2.length - numberOfLeadingDots) {
    return null;
  }
  return (
    /*@__INLINE__*/
    extractDomainWithSuffix(hostname2, suffix)
  );
}

// node_modules/tldts-core/dist/es6/src/domain-without-suffix.js
function getDomainWithoutSuffix(domain2, suffix) {
  return domain2.slice(0, -suffix.length - 1);
}

// node_modules/tldts-core/dist/es6/src/extract-hostname.js
function extractHostname(url, urlIsValidHostname) {
  let start = 0;
  let end = url.length;
  let hasUpper = false;
  if (!urlIsValidHostname) {
    if (url.startsWith("data:")) {
      return null;
    }
    while (start < url.length && url.charCodeAt(start) <= 32) {
      start += 1;
    }
    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {
      end -= 1;
    }
    if (url.charCodeAt(start) === 47 && url.charCodeAt(start + 1) === 47) {
      start += 2;
    } else {
      const indexOfProtocol = url.indexOf(":/", start);
      if (indexOfProtocol !== -1) {
        const protocolSize = indexOfProtocol - start;
        const c0 = url.charCodeAt(start);
        const c1 = url.charCodeAt(start + 1);
        const c2 = url.charCodeAt(start + 2);
        const c3 = url.charCodeAt(start + 3);
        const c4 = url.charCodeAt(start + 4);
        if (protocolSize === 5 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112 && c4 === 115) {
        } else if (protocolSize === 4 && c0 === 104 && c1 === 116 && c2 === 116 && c3 === 112) {
        } else if (protocolSize === 3 && c0 === 119 && c1 === 115 && c2 === 115) {
        } else if (protocolSize === 2 && c0 === 119 && c1 === 115) {
        } else {
          for (let i = start; i < indexOfProtocol; i += 1) {
            const lowerCaseCode = url.charCodeAt(i) | 32;
            if (!(lowerCaseCode >= 97 && lowerCaseCode <= 122 || // [a, z]
            lowerCaseCode >= 48 && lowerCaseCode <= 57 || // [0, 9]
            lowerCaseCode === 46 || // '.'
            lowerCaseCode === 45 || // '-'
            lowerCaseCode === 43)) {
              return null;
            }
          }
        }
        start = indexOfProtocol + 2;
        while (url.charCodeAt(start) === 47) {
          start += 1;
        }
      }
    }
    let indexOfIdentifier = -1;
    let indexOfClosingBracket = -1;
    let indexOfPort = -1;
    for (let i = start; i < end; i += 1) {
      const code = url.charCodeAt(i);
      if (code === 35 || // '#'
      code === 47 || // '/'
      code === 63) {
        end = i;
        break;
      } else if (code === 64) {
        indexOfIdentifier = i;
      } else if (code === 93) {
        indexOfClosingBracket = i;
      } else if (code === 58) {
        indexOfPort = i;
      } else if (code >= 65 && code <= 90) {
        hasUpper = true;
      }
    }
    if (indexOfIdentifier !== -1 && indexOfIdentifier > start && indexOfIdentifier < end) {
      start = indexOfIdentifier + 1;
    }
    if (url.charCodeAt(start) === 91) {
      if (indexOfClosingBracket !== -1) {
        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();
      }
      return null;
    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {
      end = indexOfPort;
    }
  }
  while (end > start + 1 && url.charCodeAt(end - 1) === 46) {
    end -= 1;
  }
  const hostname2 = start !== 0 || end !== url.length ? url.slice(start, end) : url;
  if (hasUpper) {
    return hostname2.toLowerCase();
  }
  return hostname2;
}

// node_modules/tldts-core/dist/es6/src/is-ip.js
function isProbablyIpv4(hostname2) {
  if (hostname2.length < 7) {
    return false;
  }
  if (hostname2.length > 15) {
    return false;
  }
  let numberOfDots = 0;
  for (let i = 0; i < hostname2.length; i += 1) {
    const code = hostname2.charCodeAt(i);
    if (code === 46) {
      numberOfDots += 1;
    } else if (code < 48 || code > 57) {
      return false;
    }
  }
  return numberOfDots === 3 && hostname2.charCodeAt(0) !== 46 && hostname2.charCodeAt(hostname2.length - 1) !== 46;
}
function isProbablyIpv6(hostname2) {
  if (hostname2.length < 3) {
    return false;
  }
  let start = hostname2.startsWith("[") ? 1 : 0;
  let end = hostname2.length;
  if (hostname2[end - 1] === "]") {
    end -= 1;
  }
  if (end - start > 39) {
    return false;
  }
  let hasColon = false;
  for (; start < end; start += 1) {
    const code = hostname2.charCodeAt(start);
    if (code === 58) {
      hasColon = true;
    } else if (!(code >= 48 && code <= 57 || // 0-9
    code >= 97 && code <= 102 || // a-f
    code >= 65 && code <= 90)) {
      return false;
    }
  }
  return hasColon;
}
function isIp(hostname2) {
  return isProbablyIpv6(hostname2) || isProbablyIpv4(hostname2);
}

// node_modules/tldts-core/dist/es6/src/is-valid.js
function isValidAscii(code) {
  return code >= 97 && code <= 122 || code >= 48 && code <= 57 || code > 127;
}
function is_valid_default(hostname2) {
  if (hostname2.length > 255) {
    return false;
  }
  if (hostname2.length === 0) {
    return false;
  }
  if (
    /*@__INLINE__*/
    !isValidAscii(hostname2.charCodeAt(0)) && hostname2.charCodeAt(0) !== 46 && // '.' (dot)
    hostname2.charCodeAt(0) !== 95
  ) {
    return false;
  }
  let lastDotIndex = -1;
  let lastCharCode = -1;
  const len = hostname2.length;
  for (let i = 0; i < len; i += 1) {
    const code = hostname2.charCodeAt(i);
    if (code === 46) {
      if (
        // Check that previous label is < 63 bytes long (64 = 63 + '.')
        i - lastDotIndex > 64 || // Check that previous character was not already a '.'
        lastCharCode === 46 || // Check that the previous label does not end with a '-' (dash)
        lastCharCode === 45 || // Check that the previous label does not end with a '_' (underscore)
        lastCharCode === 95
      ) {
        return false;
      }
      lastDotIndex = i;
    } else if (!/*@__INLINE__*/
    (isValidAscii(code) || code === 45 || code === 95)) {
      return false;
    }
    lastCharCode = code;
  }
  return (
    // Check that last label is shorter than 63 chars
    len - lastDotIndex - 1 <= 63 && // Check that the last character is an allowed trailing label character.
    // Since we already checked that the char is a valid hostname character,
    // we only need to check that it's different from '-'.
    lastCharCode !== 45
  );
}

// node_modules/tldts-core/dist/es6/src/options.js
function setDefaultsImpl({ allowIcannDomains = true, allowPrivateDomains = false, detectIp = true, extractHostname: extractHostname2 = true, mixedInputs = true, validHosts = null, validateHostname = true }) {
  return {
    allowIcannDomains,
    allowPrivateDomains,
    detectIp,
    extractHostname: extractHostname2,
    mixedInputs,
    validHosts,
    validateHostname
  };
}
var DEFAULT_OPTIONS = (
  /*@__INLINE__*/
  setDefaultsImpl({})
);
function setDefaults(options) {
  if (options === void 0) {
    return DEFAULT_OPTIONS;
  }
  return (
    /*@__INLINE__*/
    setDefaultsImpl(options)
  );
}

// node_modules/tldts-core/dist/es6/src/subdomain.js
function getSubdomain(hostname2, domain2) {
  if (domain2.length === hostname2.length) {
    return "";
  }
  return hostname2.slice(0, -domain2.length - 1);
}

// node_modules/tldts-core/dist/es6/src/factory.js
function getEmptyResult() {
  return {
    domain: null,
    domainWithoutSuffix: null,
    hostname: null,
    isIcann: null,
    isIp: null,
    isPrivate: null,
    publicSuffix: null,
    subdomain: null
  };
}
function parseImpl(url, step, suffixLookup2, partialOptions, result) {
  const options = (
    /*@__INLINE__*/
    setDefaults(partialOptions)
  );
  if (typeof url !== "string") {
    return result;
  }
  if (!options.extractHostname) {
    result.hostname = url;
  } else if (options.mixedInputs) {
    result.hostname = extractHostname(url, is_valid_default(url));
  } else {
    result.hostname = extractHostname(url, false);
  }
  if (step === 0 || result.hostname === null) {
    return result;
  }
  if (options.detectIp) {
    result.isIp = isIp(result.hostname);
    if (result.isIp) {
      return result;
    }
  }
  if (options.validateHostname && options.extractHostname && !is_valid_default(result.hostname)) {
    result.hostname = null;
    return result;
  }
  suffixLookup2(result.hostname, options, result);
  if (step === 2 || result.publicSuffix === null) {
    return result;
  }
  result.domain = getDomain(result.publicSuffix, result.hostname, options);
  if (step === 3 || result.domain === null) {
    return result;
  }
  result.subdomain = getSubdomain(result.hostname, result.domain);
  if (step === 4) {
    return result;
  }
  result.domainWithoutSuffix = getDomainWithoutSuffix(result.domain, result.publicSuffix);
  return result;
}

// node_modules/tldts-core/dist/es6/src/lookup/fast-path.js
function fast_path_default(hostname2, options, out) {
  if (!options.allowPrivateDomains && hostname2.length > 3) {
    const last2 = hostname2.length - 1;
    const c3 = hostname2.charCodeAt(last2);
    const c2 = hostname2.charCodeAt(last2 - 1);
    const c1 = hostname2.charCodeAt(last2 - 2);
    const c0 = hostname2.charCodeAt(last2 - 3);
    if (c3 === 109 && c2 === 111 && c1 === 99 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "com";
      return true;
    } else if (c3 === 103 && c2 === 114 && c1 === 111 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "org";
      return true;
    } else if (c3 === 117 && c2 === 100 && c1 === 101 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "edu";
      return true;
    } else if (c3 === 118 && c2 === 111 && c1 === 103 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "gov";
      return true;
    } else if (c3 === 116 && c2 === 101 && c1 === 110 && c0 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "net";
      return true;
    } else if (c3 === 101 && c2 === 100 && c1 === 46) {
      out.isIcann = true;
      out.isPrivate = false;
      out.publicSuffix = "de";
      return true;
    }
  }
  return false;
}

// node_modules/tldts/dist/es6/src/data/trie.js
var exceptions = /* @__PURE__ */ function() {
  const _0 = [1, {}], _1 = [0, { "city": _0 }];
  const exceptions2 = [0, { "ck": [0, { "www": _0 }], "jp": [0, { "kawasaki": _1, "kitakyushu": _1, "kobe": _1, "nagoya": _1, "sapporo": _1, "sendai": _1, "yokohama": _1 }] }];
  return exceptions2;
}();
var rules = /* @__PURE__ */ function() {
  const _2 = [1, {}], _3 = [2, {}], _4 = [1, { "gov": _2, "com": _2, "org": _2, "net": _2, "edu": _2 }], _5 = [0, { "*": _3 }], _6 = [1, { "blogspot": _3 }], _7 = [1, { "gov": _2 }], _8 = [0, { "*": _2 }], _9 = [0, { "cloud": _3 }], _10 = [1, { "co": _3 }], _11 = [2, { "nodes": _3 }], _12 = [0, { "s3": _3 }], _13 = [0, { "direct": _3 }], _14 = [2, { "id": _3 }], _15 = [0, { "webview-assets": _3 }], _16 = [0, { "vfs": _3, "webview-assets": _3 }], _17 = [0, { "aws-cloud9": _15, "cloud9": _16 }], _18 = [0, { "dualstack": _12, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], _19 = [0, { "dualstack": _12, "s3": _3, "s3-website": _3, "aws-cloud9": _15, "cloud9": _16 }], _20 = [0, { "dualstack": _12, "aws-cloud9": _15, "cloud9": _16 }], _21 = [0, { "apps": _3 }], _22 = [0, { "paas": _3 }], _23 = [0, { "app": _3 }], _24 = [2, { "eu": _3 }], _25 = [0, { "site": _3 }], _26 = [0, { "pages": _3 }], _27 = [1, { "com": _2, "edu": _2, "net": _2, "org": _2 }], _28 = [0, { "j": _3 }], _29 = [0, { "jelastic": _3 }], _30 = [0, { "user": _3 }], _31 = [1, { "ybo": _3 }], _32 = [0, { "cust": _3, "reservd": _3 }], _33 = [0, { "cust": _3 }], _34 = [1, { "gov": _2, "edu": _2, "mil": _2, "com": _2, "org": _2, "net": _2 }], _35 = [1, { "edu": _2, "biz": _2, "net": _2, "org": _2, "gov": _2, "info": _2, "com": _2 }], _36 = [1, { "gov": _2, "blogspot": _3 }], _37 = [1, { "framer": _3 }], _38 = [1, { "barsy": _3 }], _39 = [0, { "forgot": _3 }], _40 = [1, { "gs": _2 }], _41 = [0, { "nes": _2 }], _42 = [1, { "k12": _2, "cc": _2, "lib": _2 }], _43 = [1, { "cc": _2, "lib": _2 }];
  const rules2 = [0, { "ac": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "mil": _2, "org": _2, "drr": _3 }], "ad": [1, { "nom": _2 }], "ae": [1, { "co": _2, "net": _2, "org": _2, "sch": _2, "ac": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "aero": [1, { "accident-investigation": _2, "accident-prevention": _2, "aerobatic": _2, "aeroclub": _2, "aerodrome": _2, "agents": _2, "aircraft": _2, "airline": _2, "airport": _2, "air-surveillance": _2, "airtraffic": _2, "air-traffic-control": _2, "ambulance": _2, "amusement": _2, "association": _2, "author": _2, "ballooning": _2, "broker": _2, "caa": _2, "cargo": _2, "catering": _2, "certification": _2, "championship": _2, "charter": _2, "civilaviation": _2, "club": _2, "conference": _2, "consultant": _2, "consulting": _2, "control": _2, "council": _2, "crew": _2, "design": _2, "dgca": _2, "educator": _2, "emergency": _2, "engine": _2, "engineer": _2, "entertainment": _2, "equipment": _2, "exchange": _2, "express": _2, "federation": _2, "flight": _2, "fuel": _2, "gliding": _2, "government": _2, "groundhandling": _2, "group": _2, "hanggliding": _2, "homebuilt": _2, "insurance": _2, "journal": _2, "journalist": _2, "leasing": _2, "logistics": _2, "magazine": _2, "maintenance": _2, "media": _2, "microlight": _2, "modelling": _2, "navigation": _2, "parachuting": _2, "paragliding": _2, "passenger-association": _2, "pilot": _2, "press": _2, "production": _2, "recreation": _2, "repbody": _2, "res": _2, "research": _2, "rotorcraft": _2, "safety": _2, "scientist": _2, "services": _2, "show": _2, "skydiving": _2, "software": _2, "student": _2, "trader": _2, "trading": _2, "trainer": _2, "union": _2, "workinggroup": _2, "works": _2 }], "af": _4, "ag": [1, { "com": _2, "org": _2, "net": _2, "co": _2, "nom": _2 }], "ai": [1, { "off": _2, "com": _2, "net": _2, "org": _2, "uwu": _3 }], "al": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "blogspot": _3 }], "am": [1, { "co": _2, "com": _2, "commune": _2, "net": _2, "org": _2, "radio": _3, "blogspot": _3, "neko": _3, "nyaa": _3 }], "ao": [1, { "ed": _2, "gv": _2, "og": _2, "co": _2, "pb": _2, "it": _2 }], "aq": _2, "ar": [1, { "bet": _2, "com": _6, "coop": _2, "edu": _2, "gob": _2, "gov": _2, "int": _2, "mil": _2, "musica": _2, "mutual": _2, "net": _2, "org": _2, "senasa": _2, "tur": _2 }], "arpa": [1, { "e164": _2, "in-addr": _2, "ip6": _2, "iris": _2, "uri": _2, "urn": _2 }], "as": _7, "asia": [1, { "cloudns": _3 }], "at": [1, { "ac": [1, { "sth": _2 }], "co": _6, "gv": _2, "or": _2, "funkfeuer": [0, { "wien": _3 }], "futurecms": [0, { "*": _3, "ex": _5, "in": _5 }], "futurehosting": _3, "futuremailing": _3, "ortsinfo": [0, { "ex": _5, "kunden": _5 }], "biz": _3, "info": _3, "123webseite": _3, "priv": _3, "myspreadshop": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "au": [1, { "com": [1, { "blogspot": _3, "cloudlets": [0, { "mel": _3 }], "myspreadshop": _3 }], "net": _2, "org": _2, "edu": [1, { "act": _2, "catholic": _2, "nsw": [1, { "schools": _2 }], "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "gov": [1, { "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "asn": _2, "id": _2, "info": _2, "conf": _2, "oz": _2, "act": _2, "nsw": _2, "nt": _2, "qld": _2, "sa": _2, "tas": _2, "vic": _2, "wa": _2 }], "aw": [1, { "com": _2 }], "ax": [1, { "be": _3, "cat": _3, "es": _3, "eu": _3, "gg": _3, "mc": _3, "us": _3, "xy": _3 }], "az": [1, { "com": _2, "net": _2, "int": _2, "gov": _2, "org": _2, "edu": _2, "info": _2, "pp": _2, "mil": _2, "name": _2, "pro": _2, "biz": _2 }], "ba": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "rs": _3, "blogspot": _3 }], "bb": [1, { "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "store": _2, "tv": _2 }], "bd": _8, "be": [1, { "ac": _2, "webhosting": _3, "blogspot": _3, "interhostsolutions": _9, "kuleuven": [0, { "ezproxy": _3 }], "123website": _3, "myspreadshop": _3, "transurl": _5 }], "bf": _7, "bg": [1, { "0": _2, "1": _2, "2": _2, "3": _2, "4": _2, "5": _2, "6": _2, "7": _2, "8": _2, "9": _2, "a": _2, "b": _2, "c": _2, "d": _2, "e": _2, "f": _2, "g": _2, "h": _2, "i": _2, "j": _2, "k": _2, "l": _2, "m": _2, "n": _2, "o": _2, "p": _2, "q": _2, "r": _2, "s": _2, "t": _2, "u": _2, "v": _2, "w": _2, "x": _2, "y": _2, "z": _2, "blogspot": _3, "barsy": _3 }], "bh": _4, "bi": [1, { "co": _2, "com": _2, "edu": _2, "or": _2, "org": _2 }], "biz": [1, { "activetrail": _3, "cloudns": _3, "jozi": _3, "dyndns": _3, "for-better": _3, "for-more": _3, "for-some": _3, "for-the": _3, "selfip": _3, "webhop": _3, "orx": _3, "mmafan": _3, "myftp": _3, "no-ip": _3, "dscloud": _3 }], "bj": [1, { "africa": _2, "agro": _2, "architectes": _2, "assur": _2, "avocats": _2, "co": _2, "com": _2, "eco": _2, "econo": _2, "edu": _2, "info": _2, "loisirs": _2, "money": _2, "net": _2, "org": _2, "ote": _2, "resto": _2, "restaurant": _2, "tourism": _2, "univ": _2, "blogspot": _3 }], "bm": _4, "bn": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "co": _3 }], "bo": [1, { "com": _2, "edu": _2, "gob": _2, "int": _2, "org": _2, "net": _2, "mil": _2, "tv": _2, "web": _2, "academia": _2, "agro": _2, "arte": _2, "blog": _2, "bolivia": _2, "ciencia": _2, "cooperativa": _2, "democracia": _2, "deporte": _2, "ecologia": _2, "economia": _2, "empresa": _2, "indigena": _2, "industria": _2, "info": _2, "medicina": _2, "movimiento": _2, "musica": _2, "natural": _2, "nombre": _2, "noticias": _2, "patria": _2, "politica": _2, "profesional": _2, "plurinacional": _2, "pueblo": _2, "revista": _2, "salud": _2, "tecnologia": _2, "tksat": _2, "transporte": _2, "wiki": _2 }], "br": [1, { "9guacu": _2, "abc": _2, "adm": _2, "adv": _2, "agr": _2, "aju": _2, "am": _2, "anani": _2, "aparecida": _2, "app": _2, "arq": _2, "art": _2, "ato": _2, "b": _2, "barueri": _2, "belem": _2, "bhz": _2, "bib": _2, "bio": _2, "blog": _2, "bmd": _2, "boavista": _2, "bsb": _2, "campinagrande": _2, "campinas": _2, "caxias": _2, "cim": _2, "cng": _2, "cnt": _2, "com": [1, { "blogspot": _3, "simplesite": _3 }], "contagem": _2, "coop": _2, "coz": _2, "cri": _2, "cuiaba": _2, "curitiba": _2, "def": _2, "des": _2, "det": _2, "dev": _2, "ecn": _2, "eco": _2, "edu": _2, "emp": _2, "enf": _2, "eng": _2, "esp": _2, "etc": _2, "eti": _2, "far": _2, "feira": _2, "flog": _2, "floripa": _2, "fm": _2, "fnd": _2, "fortal": _2, "fot": _2, "foz": _2, "fst": _2, "g12": _2, "geo": _2, "ggf": _2, "goiania": _2, "gov": [1, { "ac": _2, "al": _2, "am": _2, "ap": _2, "ba": _2, "ce": _2, "df": _2, "es": _2, "go": _2, "ma": _2, "mg": _2, "ms": _2, "mt": _2, "pa": _2, "pb": _2, "pe": _2, "pi": _2, "pr": _2, "rj": _2, "rn": _2, "ro": _2, "rr": _2, "rs": _2, "sc": _2, "se": _2, "sp": _2, "to": _2 }], "gru": _2, "imb": _2, "ind": _2, "inf": _2, "jab": _2, "jampa": _2, "jdf": _2, "joinville": _2, "jor": _2, "jus": _2, "leg": [1, { "ac": _3, "al": _3, "am": _3, "ap": _3, "ba": _3, "ce": _3, "df": _3, "es": _3, "go": _3, "ma": _3, "mg": _3, "ms": _3, "mt": _3, "pa": _3, "pb": _3, "pe": _3, "pi": _3, "pr": _3, "rj": _3, "rn": _3, "ro": _3, "rr": _3, "rs": _3, "sc": _3, "se": _3, "sp": _3, "to": _3 }], "lel": _2, "log": _2, "londrina": _2, "macapa": _2, "maceio": _2, "manaus": _2, "maringa": _2, "mat": _2, "med": _2, "mil": _2, "morena": _2, "mp": _2, "mus": _2, "natal": _2, "net": _2, "niteroi": _2, "nom": _8, "not": _2, "ntr": _2, "odo": _2, "ong": _2, "org": _2, "osasco": _2, "palmas": _2, "poa": _2, "ppg": _2, "pro": _2, "psc": _2, "psi": _2, "pvh": _2, "qsl": _2, "radio": _2, "rec": _2, "recife": _2, "rep": _2, "ribeirao": _2, "rio": _2, "riobranco": _2, "riopreto": _2, "salvador": _2, "sampa": _2, "santamaria": _2, "santoandre": _2, "saobernardo": _2, "saogonca": _2, "seg": _2, "sjc": _2, "slg": _2, "slz": _2, "sorocaba": _2, "srv": _2, "taxi": _2, "tc": _2, "tec": _2, "teo": _2, "the": _2, "tmp": _2, "trd": _2, "tur": _2, "tv": _2, "udi": _2, "vet": _2, "vix": _2, "vlog": _2, "wiki": _2, "zlg": _2 }], "bs": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "we": _3 }], "bt": _4, "bv": _2, "bw": [1, { "co": _2, "org": _2 }], "by": [1, { "gov": _2, "mil": _2, "com": _6, "of": _2, "mycloud": _3, "mediatech": _3 }], "bz": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "gov": _2, "za": _3, "gsj": _3 }], "ca": [1, { "ab": _2, "bc": _2, "mb": _2, "nb": _2, "nf": _2, "nl": _2, "ns": _2, "nt": _2, "nu": _2, "on": _2, "pe": _2, "qc": _2, "sk": _2, "yk": _2, "gc": _2, "barsy": _3, "awdev": _5, "co": _3, "blogspot": _3, "no-ip": _3, "myspreadshop": _3 }], "cat": _2, "cc": [1, { "cloudns": _3, "ftpaccess": _3, "game-server": _3, "myphotos": _3, "scrapping": _3, "twmail": _3, "csx": _3, "fantasyleague": _3, "spawn": [0, { "instances": _3 }] }], "cd": _7, "cf": _6, "cg": _2, "ch": [1, { "square7": _3, "blogspot": _3, "flow": [0, { "ae": [0, { "alp1": _3 }], "appengine": _3 }], "linkyard-cloud": _3, "dnsking": _3, "gotdns": _3, "123website": _3, "myspreadshop": _3, "firenet": [0, { "*": _3, "svc": _5 }], "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3 }], "ci": [1, { "org": _2, "or": _2, "com": _2, "co": _2, "edu": _2, "ed": _2, "ac": _2, "net": _2, "go": _2, "asso": _2, "xn--aroport-bya": _2, "aroport": _2, "int": _2, "presse": _2, "md": _2, "gouv": _2, "fin": _3, "nl": _3 }], "ck": _8, "cl": [1, { "co": _2, "gob": _2, "gov": _2, "mil": _2, "blogspot": _3 }], "cm": [1, { "co": _2, "com": _2, "gov": _2, "net": _2 }], "cn": [1, { "ac": _2, "com": [1, { "amazonaws": [0, { "compute": _5, "cn-north-1": _12, "eb": [0, { "cn-north-1": _3, "cn-northwest-1": _3 }], "elb": _5 }] }], "edu": _2, "gov": _2, "net": _2, "org": _2, "mil": _2, "xn--55qx5d": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--od0alg": _2, "": _2, "ah": _2, "bj": _2, "cq": _2, "fj": _2, "gd": _2, "gs": _2, "gz": _2, "gx": _2, "ha": _2, "hb": _2, "he": _2, "hi": _2, "hl": _2, "hn": _2, "jl": _2, "js": _2, "jx": _2, "ln": _2, "nm": _2, "nx": _2, "qh": _2, "sc": _2, "sd": _2, "sh": _2, "sn": _2, "sx": _2, "tj": _2, "xj": _2, "xz": _2, "yn": _2, "zj": _2, "hk": _2, "mo": _2, "tw": _2, "canva-apps": _3, "instantcloud": _3, "quickconnect": _13 }], "co": [1, { "arts": _2, "com": _6, "edu": _2, "firm": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rec": _2, "web": _2, "carrd": _3, "crd": _3, "otap": _5, "leadpages": _3, "lpages": _3, "mypi": _3, "n4t": _3, "firewalledreplit": _14, "repl": _14, "supabase": _3 }], "com": [1, { "devcdnaccesso": _5, "adobeaemcloud": [2, { "dev": _5 }], "airkitapps": _3, "airkitapps-au": _3, "aivencloud": _3, "kasserver": _3, "amazonaws": [0, { "compute": _5, "compute-1": _5, "us-east-1": [2, { "dualstack": _12, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "ap-northeast-1": _18, "ap-northeast-2": _19, "ap-south-1": _19, "ap-southeast-1": _20, "ap-southeast-2": _20, "ca-central-1": _19, "eu-central-1": _19, "eu-west-1": _18, "eu-west-2": _19, "eu-west-3": _19, "s3": _3, "s3-ap-northeast-1": _3, "s3-ap-northeast-2": _3, "s3-ap-south-1": _3, "s3-ap-southeast-1": _3, "s3-ap-southeast-2": _3, "s3-ca-central-1": _3, "s3-eu-central-1": _3, "s3-eu-west-1": _3, "s3-eu-west-2": _3, "s3-eu-west-3": _3, "s3-external-1": _3, "s3-fips-us-gov-west-1": _3, "s3-sa-east-1": _3, "s3-us-east-2": _3, "s3-us-gov-west-1": _3, "s3-us-west-1": _3, "s3-us-west-2": _3, "s3-website-ap-northeast-1": _3, "s3-website-ap-southeast-1": _3, "s3-website-ap-southeast-2": _3, "s3-website-eu-west-1": _3, "s3-website-sa-east-1": _3, "s3-website-us-east-1": _3, "s3-website-us-west-1": _3, "s3-website-us-west-2": _3, "sa-east-1": _20, "us-east-2": [0, { "dualstack": _12, "s3": _3, "s3-website": _3, "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "us-west-2": [0, { "analytics-gateway": _3, "aws-cloud9": _15, "cloud9": _16 }], "af-south-1": _17, "ap-east-1": _17, "ap-northeast-3": _17, "eu-north-1": _17, "eu-south-1": _17, "me-south-1": _17, "us-west-1": _17, "elb": _5 }], "elasticbeanstalk": [2, { "ap-northeast-1": _3, "ap-northeast-2": _3, "ap-northeast-3": _3, "ap-south-1": _3, "ap-southeast-1": _3, "ap-southeast-2": _3, "ca-central-1": _3, "eu-central-1": _3, "eu-west-1": _3, "eu-west-2": _3, "eu-west-3": _3, "sa-east-1": _3, "us-east-1": _3, "us-east-2": _3, "us-gov-west-1": _3, "us-west-1": _3, "us-west-2": _3 }], "awsglobalaccelerator": _3, "siiites": _3, "appspacehosted": _3, "appspaceusercontent": _3, "on-aptible": _3, "myasustor": _3, "balena-devices": _3, "betainabox": _3, "boutir": _3, "bplaced": _3, "cafjs": _3, "canva-apps": _3, "br": _3, "cn": _3, "de": _3, "eu": _3, "jpn": _3, "mex": _3, "ru": _3, "sa": _3, "uk": _3, "us": _3, "za": _3, "ar": _3, "hu": _3, "kr": _3, "no": _3, "qc": _3, "uy": _3, "africa": _3, "gr": _3, "co": _3, "jdevcloud": _3, "wpdevcloud": _3, "cloudcontrolled": _3, "cloudcontrolapp": _3, "cf-ipfs": _3, "cloudflare-ipfs": _3, "trycloudflare": _3, "customer-oci": [0, { "*": _3, "oci": _5, "ocp": _5, "ocs": _5 }], "dattolocal": _3, "dattorelay": _3, "dattoweb": _3, "mydatto": _3, "builtwithdark": _3, "datadetect": [0, { "demo": _3, "instance": _3 }], "ddns5": _3, "discordsays": _3, "discordsez": _3, "drayddns": _3, "dreamhosters": _3, "mydrobo": _3, "dyndns-at-home": _3, "dyndns-at-work": _3, "dyndns-blog": _3, "dyndns-free": _3, "dyndns-home": _3, "dyndns-ip": _3, "dyndns-mail": _3, "dyndns-office": _3, "dyndns-pics": _3, "dyndns-remote": _3, "dyndns-server": _3, "dyndns-web": _3, "dyndns-wiki": _3, "dyndns-work": _3, "blogdns": _3, "cechire": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dyn-o-saur": _3, "dynalias": _3, "est-a-la-maison": _3, "est-a-la-masion": _3, "est-le-patron": _3, "est-mon-blogueur": _3, "from-ak": _3, "from-al": _3, "from-ar": _3, "from-ca": _3, "from-ct": _3, "from-dc": _3, "from-de": _3, "from-fl": _3, "from-ga": _3, "from-hi": _3, "from-ia": _3, "from-id": _3, "from-il": _3, "from-in": _3, "from-ks": _3, "from-ky": _3, "from-ma": _3, "from-md": _3, "from-mi": _3, "from-mn": _3, "from-mo": _3, "from-ms": _3, "from-mt": _3, "from-nc": _3, "from-nd": _3, "from-ne": _3, "from-nh": _3, "from-nj": _3, "from-nm": _3, "from-nv": _3, "from-oh": _3, "from-ok": _3, "from-or": _3, "from-pa": _3, "from-pr": _3, "from-ri": _3, "from-sc": _3, "from-sd": _3, "from-tn": _3, "from-tx": _3, "from-ut": _3, "from-va": _3, "from-vt": _3, "from-wa": _3, "from-wi": _3, "from-wv": _3, "from-wy": _3, "getmyip": _3, "gotdns": _3, "hobby-site": _3, "homelinux": _3, "homeunix": _3, "iamallama": _3, "is-a-anarchist": _3, "is-a-blogger": _3, "is-a-bookkeeper": _3, "is-a-bulls-fan": _3, "is-a-caterer": _3, "is-a-chef": _3, "is-a-conservative": _3, "is-a-cpa": _3, "is-a-cubicle-slave": _3, "is-a-democrat": _3, "is-a-designer": _3, "is-a-doctor": _3, "is-a-financialadvisor": _3, "is-a-geek": _3, "is-a-green": _3, "is-a-guru": _3, "is-a-hard-worker": _3, "is-a-hunter": _3, "is-a-landscaper": _3, "is-a-lawyer": _3, "is-a-liberal": _3, "is-a-libertarian": _3, "is-a-llama": _3, "is-a-musician": _3, "is-a-nascarfan": _3, "is-a-nurse": _3, "is-a-painter": _3, "is-a-personaltrainer": _3, "is-a-photographer": _3, "is-a-player": _3, "is-a-republican": _3, "is-a-rockstar": _3, "is-a-socialist": _3, "is-a-student": _3, "is-a-teacher": _3, "is-a-techie": _3, "is-a-therapist": _3, "is-an-accountant": _3, "is-an-actor": _3, "is-an-actress": _3, "is-an-anarchist": _3, "is-an-artist": _3, "is-an-engineer": _3, "is-an-entertainer": _3, "is-certified": _3, "is-gone": _3, "is-into-anime": _3, "is-into-cars": _3, "is-into-cartoons": _3, "is-into-games": _3, "is-leet": _3, "is-not-certified": _3, "is-slick": _3, "is-uberleet": _3, "is-with-theband": _3, "isa-geek": _3, "isa-hockeynut": _3, "issmarterthanyou": _3, "likes-pie": _3, "likescandy": _3, "neat-url": _3, "saves-the-whales": _3, "selfip": _3, "sells-for-less": _3, "sells-for-u": _3, "servebbs": _3, "simple-url": _3, "space-to-rent": _3, "teaches-yoga": _3, "writesthisblog": _3, "digitaloceanspaces": _5, "ddnsfree": _3, "ddnsgeek": _3, "giize": _3, "gleeze": _3, "kozow": _3, "loseyourip": _3, "ooguy": _3, "theworkpc": _3, "mytuleap": _3, "tuleap-partners": _3, "encoreapi": _3, "evennode": [0, { "eu-1": _3, "eu-2": _3, "eu-3": _3, "eu-4": _3, "us-1": _3, "us-2": _3, "us-3": _3, "us-4": _3 }], "onfabrica": _3, "fbsbx": _21, "fastly-edge": _3, "fastly-terrarium": _3, "fastvps-server": _3, "mydobiss": _3, "firebaseapp": _3, "fldrv": _3, "forgeblocks": _3, "framercanvas": _3, "freebox-os": _3, "freeboxos": _3, "freemyip": _3, "gentapps": _3, "gentlentapis": _3, "githubusercontent": _3, "0emm": _5, "appspot": [2, { "r": _5 }], "codespot": _3, "googleapis": _3, "googlecode": _3, "pagespeedmobilizer": _3, "publishproxy": _3, "withgoogle": _3, "withyoutube": _3, "blogspot": _3, "awsmppl": _3, "herokuapp": _3, "herokussl": _3, "impertrixcdn": _3, "impertrix": _3, "smushcdn": _3, "wphostedmail": _3, "wpmucdn": _3, "pixolino": _3, "amscompute": _3, "dopaas": _3, "hosted-by-previder": _22, "hosteur": [0, { "rag-cloud": _3, "rag-cloud-ch": _3 }], "ik-server": [0, { "jcloud": _3, "jcloud-ver-jpc": _3 }], "jelastic": [0, { "demo": _3 }], "kilatiron": _3, "massivegrid": _22, "wafaicloud": [0, { "jed": _3, "lon": _3, "ryd": _3 }], "joyent": [0, { "cns": _5 }], "ktistory": _3, "lpusercontent": _3, "lmpm": _23, "linode": [0, { "members": _3, "nodebalancer": _5 }], "linodeobjects": _5, "linodeusercontent": [0, { "ip": _3 }], "barsycenter": _3, "barsyonline": _3, "mazeplay": _3, "miniserver": _3, "meteorapp": _24, "hostedpi": _3, "mythic-beasts": [0, { "customer": _3, "caracal": _3, "fentiger": _3, "lynx": _3, "ocelot": _3, "oncilla": _3, "onza": _3, "sphinx": _3, "vs": _3, "x": _3, "yali": _3 }], "nospamproxy": _9, "4u": _3, "nfshost": _3, "001www": _3, "ddnslive": _3, "myiphost": _3, "blogsyte": _3, "ciscofreak": _3, "damnserver": _3, "ditchyourip": _3, "dnsiskinky": _3, "dynns": _3, "geekgalaxy": _3, "health-carereform": _3, "homesecuritymac": _3, "homesecuritypc": _3, "myactivedirectory": _3, "mysecuritycamera": _3, "net-freaks": _3, "onthewifi": _3, "point2this": _3, "quicksytes": _3, "securitytactics": _3, "serveexchange": _3, "servehumour": _3, "servep2p": _3, "servesarcasm": _3, "stufftoread": _3, "unusualperson": _3, "workisboring": _3, "3utilities": _3, "ddnsking": _3, "myvnc": _3, "servebeer": _3, "servecounterstrike": _3, "serveftp": _3, "servegame": _3, "servehalflife": _3, "servehttp": _3, "serveirc": _3, "servemp3": _3, "servepics": _3, "servequake": _3, "observableusercontent": [0, { "static": _3 }], "simplesite": _3, "orsites": _3, "operaunite": _3, "authgear-staging": _3, "authgearapps": _3, "skygearapp": _3, "outsystemscloud": _3, "ownprovider": _3, "pgfog": _3, "pagefrontapp": _3, "pagexl": _3, "paywhirl": _5, "gotpantheon": _3, "platter-app": _3, "pleskns": _3, "postman-echo": _3, "prgmr": [0, { "xen": _3 }], "pythonanywhere": _24, "qualifioapp": _3, "ladesk": _3, "qbuser": _3, "qa2": _3, "dev-myqnapcloud": _3, "alpha-myqnapcloud": _3, "myqnapcloud": _3, "quipelements": _5, "rackmaze": _3, "rhcloud": _3, "render": _23, "onrender": _3, "180r": _3, "dojin": _3, "sakuratan": _3, "sakuraweb": _3, "x0": _3, "code": [0, { "builder": _5, "dev-builder": _5, "stg-builder": _5 }], "logoip": _3, "scrysec": _3, "firewall-gateway": _3, "myshopblocks": _3, "myshopify": _3, "shopitsite": _3, "1kapp": _3, "appchizi": _3, "applinzi": _3, "sinaapp": _3, "vipsinaapp": _3, "bounty-full": [2, { "alpha": _3, "beta": _3 }], "streamlitapp": _3, "try-snowplow": _3, "stackhero-network": _3, "playstation-cloud": _3, "myspreadshop": _3, "stdlib": [0, { "api": _3 }], "temp-dns": _3, "dsmynas": _3, "familyds": _3, "mytabit": _3, "tb-hosting": _25, "reservd": _3, "thingdustdata": _3, "bloxcms": _3, "townnews-staging": _3, "typeform": [0, { "pro": _3 }], "hk": _3, "it": _3, "vultrobjects": _5, "wafflecell": _3, "reserve-online": _3, "hotelwithflight": _3, "remotewd": _3, "wiardweb": _26, "messwithdns": _3, "woltlab-demo": _3, "wpenginepowered": [2, { "js": _3 }], "wixsite": _3, "xnbay": [2, { "u2": _3, "u2-local": _3 }], "yolasite": _3 }], "coop": _2, "cr": [1, { "ac": _2, "co": _2, "ed": _2, "fi": _2, "go": _2, "or": _2, "sa": _2 }], "cu": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "gov": _2, "inf": _2 }], "cv": [1, { "com": _2, "edu": _2, "int": _2, "nome": _2, "org": _2, "blogspot": _3 }], "cw": _27, "cx": [1, { "gov": _2, "ath": _3, "info": _3 }], "cy": [1, { "ac": _2, "biz": _2, "com": [1, { "blogspot": _3, "scaleforce": _28 }], "ekloges": _2, "gov": _2, "ltd": _2, "mil": _2, "net": _2, "org": _2, "press": _2, "pro": _2, "tm": _2 }], "cz": [1, { "co": _3, "realm": _3, "e4": _3, "blogspot": _3, "metacentrum": [0, { "cloud": _5, "custom": _3 }], "muni": [0, { "cloud": [0, { "flt": _3, "usr": _3 }] }] }], "de": [1, { "bplaced": _3, "square7": _3, "com": _3, "cosidns": [0, { "dyn": _3 }], "dynamisches-dns": _3, "dnsupdater": _3, "internet-dns": _3, "l-o-g-i-n": _3, "dnshome": _3, "fuettertdasnetz": _3, "isteingeek": _3, "istmein": _3, "lebtimnetz": _3, "leitungsen": _3, "traeumtgerade": _3, "ddnss": [2, { "dyn": _3, "dyndns": _3 }], "dyndns1": _3, "dyn-ip24": _3, "home-webserver": [2, { "dyn": _3 }], "myhome-server": _3, "frusky": _5, "goip": _3, "blogspot": _3, "xn--gnstigbestellen-zvb": _3, "gnstigbestellen": _3, "xn--gnstigliefern-wob": _3, "gnstigliefern": _3, "hs-heilbronn": [0, { "it": _26 }], "dyn-berlin": _3, "in-berlin": _3, "in-brb": _3, "in-butter": _3, "in-dsl": _3, "in-vpn": _3, "iservschule": _3, "mein-iserv": _3, "schulplattform": _3, "schulserver": _3, "test-iserv": _3, "keymachine": _3, "git-repos": _3, "lcube-server": _3, "svn-repos": _3, "barsy": _3, "123webseite": _3, "logoip": _3, "firewall-gateway": _3, "my-gateway": _3, "my-router": _3, "spdns": _3, "speedpartner": [0, { "customer": _3 }], "myspreadshop": _3, "taifun-dns": _3, "12hp": _3, "2ix": _3, "4lima": _3, "lima-city": _3, "dd-dns": _3, "dray-dns": _3, "draydns": _3, "dyn-vpn": _3, "dynvpn": _3, "mein-vigor": _3, "my-vigor": _3, "my-wan": _3, "syno-ds": _3, "synology-diskstation": _3, "synology-ds": _3, "uberspace": _5, "virtualuser": _3, "virtual-user": _3, "community-pro": _3, "diskussionsbereich": _3 }], "dj": _2, "dk": [1, { "biz": _3, "co": _3, "firm": _3, "reg": _3, "store": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "dm": _4, "do": [1, { "art": _2, "com": _2, "edu": _2, "gob": _2, "gov": _2, "mil": _2, "net": _2, "org": _2, "sld": _2, "web": _2 }], "dz": [1, { "art": _2, "asso": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2, "pol": _2, "soc": _2, "tm": _2 }], "ec": [1, { "com": _2, "info": _2, "net": _2, "fin": _2, "k12": _2, "med": _2, "pro": _2, "org": _2, "edu": _2, "gov": _2, "gob": _2, "mil": _2, "base": _3, "official": _3 }], "edu": [1, { "rit": [0, { "git-pages": _3 }] }], "ee": [1, { "edu": _2, "gov": _2, "riik": _2, "lib": _2, "med": _2, "com": _6, "pri": _2, "aip": _2, "org": _2, "fie": _2 }], "eg": [1, { "com": _6, "edu": _2, "eun": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sci": _2 }], "er": _8, "es": [1, { "com": _6, "nom": _2, "org": _2, "gob": _2, "edu": _2, "123miweb": _3, "myspreadshop": _3 }], "et": [1, { "com": _2, "gov": _2, "org": _2, "edu": _2, "biz": _2, "name": _2, "info": _2, "net": _2 }], "eu": [1, { "airkitapps": _3, "mycd": _3, "cloudns": _3, "dogado": _29, "barsy": _3, "wellbeingzone": _3, "spdns": _3, "transurl": _5, "diskstation": _3 }], "fi": [1, { "aland": _2, "dy": _3, "blogspot": _3, "xn--hkkinen-5wa": _3, "hkkinen": _3, "iki": _3, "cloudplatform": [0, { "fi": _3 }], "datacenter": [0, { "demo": _3, "paas": _3 }], "kapsi": _3, "123kotisivu": _3, "myspreadshop": _3 }], "fj": [1, { "ac": _2, "biz": _2, "com": _2, "gov": _2, "info": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "fk": _8, "fm": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "radio": _3, "user": _5 }], "fo": _2, "fr": [1, { "asso": _2, "com": _2, "gouv": _2, "nom": _2, "prd": _2, "tm": _2, "avoues": _2, "cci": _2, "greta": _2, "huissier-justice": _2, "en-root": _3, "fbx-os": _3, "fbxos": _3, "freebox-os": _3, "freeboxos": _3, "blogspot": _3, "goupile": _3, "123siteweb": _3, "on-web": _3, "chirurgiens-dentistes-en-france": _3, "dedibox": _3, "aeroport": _3, "avocat": _3, "chambagri": _3, "chirurgiens-dentistes": _3, "experts-comptables": _3, "medecin": _3, "notaires": _3, "pharmacien": _3, "port": _3, "veterinaire": _3, "myspreadshop": _3, "ynh": _3 }], "ga": _2, "gb": _2, "gd": [1, { "edu": _2, "gov": _2 }], "ge": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "net": _2, "pvt": _2 }], "gf": _2, "gg": [1, { "co": _2, "net": _2, "org": _2, "kaas": _3, "cya": _3, "panel": [2, { "daemon": _3 }] }], "gh": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2 }], "gi": [1, { "com": _2, "ltd": _2, "gov": _2, "mod": _2, "edu": _2, "org": _2 }], "gl": [1, { "co": _2, "com": _2, "edu": _2, "net": _2, "org": _2, "biz": _3, "xx": _3 }], "gm": _2, "gn": [1, { "ac": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "net": _2 }], "gov": _2, "gp": [1, { "com": _2, "net": _2, "mobi": _2, "edu": _2, "org": _2, "asso": _2, "app": _3 }], "gq": _2, "gr": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "gov": _2, "blogspot": _3, "simplesite": _3 }], "gs": _2, "gt": [1, { "com": _2, "edu": _2, "gob": _2, "ind": _2, "mil": _2, "net": _2, "org": _2, "blog": _3, "de": _3, "to": _3 }], "gu": [1, { "com": _2, "edu": _2, "gov": _2, "guam": _2, "info": _2, "net": _2, "org": _2, "web": _2 }], "gw": _2, "gy": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "be": _3 }], "hk": [1, { "com": _2, "edu": _2, "gov": _2, "idv": _2, "net": _2, "org": _2, "xn--55qx5d": _2, "": _2, "xn--wcvs22d": _2, "": _2, "xn--lcvr32d": _2, "": _2, "xn--mxtq1m": _2, "": _2, "xn--gmqw5a": _2, "": _2, "xn--ciqpn": _2, "": _2, "xn--gmq050i": _2, "": _2, "xn--zf0avx": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--mk0axi": _2, "": _2, "xn--od0alg": _2, "": _2, "xn--od0aq3b": _2, "": _2, "xn--tn0ag": _2, "": _2, "xn--uc0atv": _2, "": _2, "xn--uc0ay4a": _2, "": _2, "blogspot": _3, "secaas": _3, "ltd": _3, "inc": _3 }], "hm": _2, "hn": [1, { "com": _2, "edu": _2, "org": _2, "net": _2, "mil": _2, "gob": _2, "cc": _3 }], "hr": [1, { "iz": _2, "from": _2, "name": _2, "com": _2, "blogspot": _3, "free": _3 }], "ht": [1, { "com": _2, "shop": _2, "firm": _2, "info": _2, "adult": _2, "net": _2, "pro": _2, "org": _2, "med": _2, "art": _2, "coop": _2, "pol": _2, "asso": _2, "edu": _2, "rel": _2, "gouv": _2, "perso": _2 }], "hu": [1, { "2000": _2, "co": _2, "info": _2, "org": _2, "priv": _2, "sport": _2, "tm": _2, "agrar": _2, "bolt": _2, "casino": _2, "city": _2, "erotica": _2, "erotika": _2, "film": _2, "forum": _2, "games": _2, "hotel": _2, "ingatlan": _2, "jogasz": _2, "konyvelo": _2, "lakas": _2, "media": _2, "news": _2, "reklam": _2, "sex": _2, "shop": _2, "suli": _2, "szex": _2, "tozsde": _2, "utazas": _2, "video": _2, "blogspot": _3 }], "id": [1, { "ac": _2, "biz": _2, "co": _6, "desa": _2, "go": _2, "mil": _2, "my": [1, { "rss": _5 }], "net": _2, "or": _2, "ponpes": _2, "sch": _2, "web": _2, "flap": _3, "forte": _3 }], "ie": [1, { "gov": _2, "blogspot": _3, "myspreadshop": _3 }], "il": [1, { "ac": _2, "co": [1, { "ravpage": _3, "blogspot": _3, "tabitorder": _3, "mytabit": _3 }], "gov": _2, "idf": _2, "k12": _2, "muni": _2, "net": _2, "org": _2 }], "xn--4dbrk0ce": [1, { "xn--4dbgdty6c": _2, "xn--5dbhl8d": _2, "xn--8dbq2a": _2, "xn--hebda8b": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2 }], "im": [1, { "ac": _2, "co": [1, { "ltd": _2, "plc": _2 }], "com": _2, "net": _2, "org": _2, "tt": _2, "tv": _2, "ro": _3 }], "in": [1, { "5g": _2, "6g": _2, "ac": _2, "ai": _2, "am": _2, "bihar": _2, "biz": _2, "business": _2, "ca": _2, "cn": _2, "co": _2, "com": _2, "coop": _2, "cs": _2, "delhi": _2, "dr": _2, "edu": _2, "er": _2, "firm": _2, "gen": _2, "gov": _2, "gujarat": _2, "ind": _2, "info": _2, "int": _2, "internet": _2, "io": _2, "me": _2, "mil": _2, "net": _2, "nic": _2, "org": _2, "pg": _2, "post": _2, "pro": _2, "res": _2, "travel": _2, "tv": _2, "uk": _2, "up": _2, "us": _2, "web": _3, "cloudns": _3, "blogspot": _3, "barsy": _3, "supabase": _3 }], "info": [1, { "cloudns": _3, "dynamic-dns": _3, "dyndns": _3, "barrel-of-knowledge": _3, "barrell-of-knowledge": _3, "for-our": _3, "groks-the": _3, "groks-this": _3, "here-for-more": _3, "knowsitall": _3, "selfip": _3, "webhop": _3, "barsy": _3, "mayfirst": _3, "forumz": _3, "nsupdate": _3, "dvrcam": _3, "ilovecollege": _3, "no-ip": _3, "dnsupdate": _3, "v-info": _3 }], "int": [1, { "eu": _2 }], "io": [1, { "2038": _3, "com": _2, "on-acorn": _5, "apigee": _3, "b-data": _3, "backplaneapp": _3, "banzaicloud": [0, { "app": _3, "backyards": _5 }], "beagleboard": _3, "bitbucket": _3, "bluebite": _3, "boxfuse": _3, "browsersafetymark": _3, "bigv": [0, { "uk0": _3 }], "cleverapps": _3, "dappnode": [0, { "dyndns": _3 }], "dedyn": _3, "drud": _3, "definima": _3, "fh-muenster": _3, "shw": _3, "forgerock": [0, { "id": _3 }], "ghost": _3, "github": _3, "gitlab": _3, "lolipop": _3, "hasura-app": _3, "hostyhosting": _3, "moonscale": _5, "beebyte": _22, "beebyteapp": [0, { "sekd1": _3 }], "jele": _3, "unispace": [0, { "cloud-fr1": _3 }], "webthings": _3, "loginline": _3, "barsy": _3, "azurecontainer": _5, "ngrok": [2, { "ap": _3, "au": _3, "eu": _3, "in": _3, "jp": _3, "sa": _3, "us": _3 }], "nodeart": [0, { "stage": _3 }], "nid": _3, "pantheonsite": _3, "dyn53": _3, "pstmn": [2, { "mock": _3 }], "protonet": _3, "qoto": _3, "qcx": [2, { "sys": _5 }], "vaporcloud": _3, "vbrplsbx": [0, { "g": _3 }], "on-k3s": _5, "on-rio": _5, "readthedocs": _3, "resindevice": _3, "resinstaging": [0, { "devices": _3 }], "hzc": _3, "sandcats": _3, "shiftcrypto": _3, "shiftedit": _3, "mo-siemens": _3, "musician": _3, "lair": _21, "stolos": _5, "spacekit": _3, "utwente": _3, "s5y": _5, "edugit": _3, "telebit": _3, "thingdust": [0, { "dev": _32, "disrec": _32, "prod": _33, "testing": _32 }], "tickets": _3, "upli": _3, "wedeploy": _3, "editorx": _3, "wixstudio": _3, "basicserver": _3, "virtualserver": _3 }], "iq": _34, "ir": [1, { "ac": _2, "co": _2, "gov": _2, "id": _2, "net": _2, "org": _2, "sch": _2, "xn--mgba3a4f16a": _2, "": _2, "xn--mgba3a4fra": _2, "": _2 }], "is": [1, { "net": _2, "com": _2, "edu": _2, "gov": _2, "org": _2, "int": _2, "cupcake": _3, "blogspot": _3 }], "it": [1, { "gov": _2, "edu": _2, "abr": _2, "abruzzo": _2, "aosta-valley": _2, "aostavalley": _2, "bas": _2, "basilicata": _2, "cal": _2, "calabria": _2, "cam": _2, "campania": _2, "emilia-romagna": _2, "emiliaromagna": _2, "emr": _2, "friuli-v-giulia": _2, "friuli-ve-giulia": _2, "friuli-vegiulia": _2, "friuli-venezia-giulia": _2, "friuli-veneziagiulia": _2, "friuli-vgiulia": _2, "friuliv-giulia": _2, "friulive-giulia": _2, "friulivegiulia": _2, "friulivenezia-giulia": _2, "friuliveneziagiulia": _2, "friulivgiulia": _2, "fvg": _2, "laz": _2, "lazio": _2, "lig": _2, "liguria": _2, "lom": _2, "lombardia": _2, "lombardy": _2, "lucania": _2, "mar": _2, "marche": _2, "mol": _2, "molise": _2, "piedmont": _2, "piemonte": _2, "pmn": _2, "pug": _2, "puglia": _2, "sar": _2, "sardegna": _2, "sardinia": _2, "sic": _2, "sicilia": _2, "sicily": _2, "taa": _2, "tos": _2, "toscana": _2, "trentin-sud-tirol": _2, "xn--trentin-sd-tirol-rzb": _2, "trentin-sd-tirol": _2, "trentin-sudtirol": _2, "xn--trentin-sdtirol-7vb": _2, "trentin-sdtirol": _2, "trentin-sued-tirol": _2, "trentin-suedtirol": _2, "trentino-a-adige": _2, "trentino-aadige": _2, "trentino-alto-adige": _2, "trentino-altoadige": _2, "trentino-s-tirol": _2, "trentino-stirol": _2, "trentino-sud-tirol": _2, "xn--trentino-sd-tirol-c3b": _2, "trentino-sd-tirol": _2, "trentino-sudtirol": _2, "xn--trentino-sdtirol-szb": _2, "trentino-sdtirol": _2, "trentino-sued-tirol": _2, "trentino-suedtirol": _2, "trentino": _2, "trentinoa-adige": _2, "trentinoaadige": _2, "trentinoalto-adige": _2, "trentinoaltoadige": _2, "trentinos-tirol": _2, "trentinostirol": _2, "trentinosud-tirol": _2, "xn--trentinosd-tirol-rzb": _2, "trentinosd-tirol": _2, "trentinosudtirol": _2, "xn--trentinosdtirol-7vb": _2, "trentinosdtirol": _2, "trentinosued-tirol": _2, "trentinosuedtirol": _2, "trentinsud-tirol": _2, "xn--trentinsd-tirol-6vb": _2, "trentinsd-tirol": _2, "trentinsudtirol": _2, "xn--trentinsdtirol-nsb": _2, "trentinsdtirol": _2, "trentinsued-tirol": _2, "trentinsuedtirol": _2, "tuscany": _2, "umb": _2, "umbria": _2, "val-d-aosta": _2, "val-daosta": _2, "vald-aosta": _2, "valdaosta": _2, "valle-aosta": _2, "valle-d-aosta": _2, "valle-daosta": _2, "valleaosta": _2, "valled-aosta": _2, "valledaosta": _2, "vallee-aoste": _2, "xn--valle-aoste-ebb": _2, "valle-aoste": _2, "vallee-d-aoste": _2, "xn--valle-d-aoste-ehb": _2, "valle-d-aoste": _2, "valleeaoste": _2, "xn--valleaoste-e7a": _2, "valleaoste": _2, "valleedaoste": _2, "xn--valledaoste-ebb": _2, "valledaoste": _2, "vao": _2, "vda": _2, "ven": _2, "veneto": _2, "ag": _2, "agrigento": _2, "al": _2, "alessandria": _2, "alto-adige": _2, "altoadige": _2, "an": _2, "ancona": _2, "andria-barletta-trani": _2, "andria-trani-barletta": _2, "andriabarlettatrani": _2, "andriatranibarletta": _2, "ao": _2, "aosta": _2, "aoste": _2, "ap": _2, "aq": _2, "aquila": _2, "ar": _2, "arezzo": _2, "ascoli-piceno": _2, "ascolipiceno": _2, "asti": _2, "at": _2, "av": _2, "avellino": _2, "ba": _2, "balsan-sudtirol": _2, "xn--balsan-sdtirol-nsb": _2, "balsan-sdtirol": _2, "balsan-suedtirol": _2, "balsan": _2, "bari": _2, "barletta-trani-andria": _2, "barlettatraniandria": _2, "belluno": _2, "benevento": _2, "bergamo": _2, "bg": _2, "bi": _2, "biella": _2, "bl": _2, "bn": _2, "bo": _2, "bologna": _2, "bolzano-altoadige": _2, "bolzano": _2, "bozen-sudtirol": _2, "xn--bozen-sdtirol-2ob": _2, "bozen-sdtirol": _2, "bozen-suedtirol": _2, "bozen": _2, "br": _2, "brescia": _2, "brindisi": _2, "bs": _2, "bt": _2, "bulsan-sudtirol": _2, "xn--bulsan-sdtirol-nsb": _2, "bulsan-sdtirol": _2, "bulsan-suedtirol": _2, "bulsan": _2, "bz": _2, "ca": _2, "cagliari": _2, "caltanissetta": _2, "campidano-medio": _2, "campidanomedio": _2, "campobasso": _2, "carbonia-iglesias": _2, "carboniaiglesias": _2, "carrara-massa": _2, "carraramassa": _2, "caserta": _2, "catania": _2, "catanzaro": _2, "cb": _2, "ce": _2, "cesena-forli": _2, "xn--cesena-forl-mcb": _2, "cesena-forl": _2, "cesenaforli": _2, "xn--cesenaforl-i8a": _2, "cesenaforl": _2, "ch": _2, "chieti": _2, "ci": _2, "cl": _2, "cn": _2, "co": _2, "como": _2, "cosenza": _2, "cr": _2, "cremona": _2, "crotone": _2, "cs": _2, "ct": _2, "cuneo": _2, "cz": _2, "dell-ogliastra": _2, "dellogliastra": _2, "en": _2, "enna": _2, "fc": _2, "fe": _2, "fermo": _2, "ferrara": _2, "fg": _2, "fi": _2, "firenze": _2, "florence": _2, "fm": _2, "foggia": _2, "forli-cesena": _2, "xn--forl-cesena-fcb": _2, "forl-cesena": _2, "forlicesena": _2, "xn--forlcesena-c8a": _2, "forlcesena": _2, "fr": _2, "frosinone": _2, "ge": _2, "genoa": _2, "genova": _2, "go": _2, "gorizia": _2, "gr": _2, "grosseto": _2, "iglesias-carbonia": _2, "iglesiascarbonia": _2, "im": _2, "imperia": _2, "is": _2, "isernia": _2, "kr": _2, "la-spezia": _2, "laquila": _2, "laspezia": _2, "latina": _2, "lc": _2, "le": _2, "lecce": _2, "lecco": _2, "li": _2, "livorno": _2, "lo": _2, "lodi": _2, "lt": _2, "lu": _2, "lucca": _2, "macerata": _2, "mantova": _2, "massa-carrara": _2, "massacarrara": _2, "matera": _2, "mb": _2, "mc": _2, "me": _2, "medio-campidano": _2, "mediocampidano": _2, "messina": _2, "mi": _2, "milan": _2, "milano": _2, "mn": _2, "mo": _2, "modena": _2, "monza-brianza": _2, "monza-e-della-brianza": _2, "monza": _2, "monzabrianza": _2, "monzaebrianza": _2, "monzaedellabrianza": _2, "ms": _2, "mt": _2, "na": _2, "naples": _2, "napoli": _2, "no": _2, "novara": _2, "nu": _2, "nuoro": _2, "og": _2, "ogliastra": _2, "olbia-tempio": _2, "olbiatempio": _2, "or": _2, "oristano": _2, "ot": _2, "pa": _2, "padova": _2, "padua": _2, "palermo": _2, "parma": _2, "pavia": _2, "pc": _2, "pd": _2, "pe": _2, "perugia": _2, "pesaro-urbino": _2, "pesarourbino": _2, "pescara": _2, "pg": _2, "pi": _2, "piacenza": _2, "pisa": _2, "pistoia": _2, "pn": _2, "po": _2, "pordenone": _2, "potenza": _2, "pr": _2, "prato": _2, "pt": _2, "pu": _2, "pv": _2, "pz": _2, "ra": _2, "ragusa": _2, "ravenna": _2, "rc": _2, "re": _2, "reggio-calabria": _2, "reggio-emilia": _2, "reggiocalabria": _2, "reggioemilia": _2, "rg": _2, "ri": _2, "rieti": _2, "rimini": _2, "rm": _2, "rn": _2, "ro": _2, "roma": _2, "rome": _2, "rovigo": _2, "sa": _2, "salerno": _2, "sassari": _2, "savona": _2, "si": _2, "siena": _2, "siracusa": _2, "so": _2, "sondrio": _2, "sp": _2, "sr": _2, "ss": _2, "suedtirol": _2, "xn--sdtirol-n2a": _2, "sdtirol": _2, "sv": _2, "ta": _2, "taranto": _2, "te": _2, "tempio-olbia": _2, "tempioolbia": _2, "teramo": _2, "terni": _2, "tn": _2, "to": _2, "torino": _2, "tp": _2, "tr": _2, "trani-andria-barletta": _2, "trani-barletta-andria": _2, "traniandriabarletta": _2, "tranibarlettaandria": _2, "trapani": _2, "trento": _2, "treviso": _2, "trieste": _2, "ts": _2, "turin": _2, "tv": _2, "ud": _2, "udine": _2, "urbino-pesaro": _2, "urbinopesaro": _2, "va": _2, "varese": _2, "vb": _2, "vc": _2, "ve": _2, "venezia": _2, "venice": _2, "verbania": _2, "vercelli": _2, "verona": _2, "vi": _2, "vibo-valentia": _2, "vibovalentia": _2, "vicenza": _2, "viterbo": _2, "vr": _2, "vs": _2, "vt": _2, "vv": _2, "blogspot": _3, "ibxos": _3, "iliadboxos": _3, "neen": [0, { "jc": _3 }], "tim": [0, { "open": [0, { "jelastic": _9 }] }], "16-b": _3, "32-b": _3, "64-b": _3, "123homepage": _3, "myspreadshop": _3, "syncloud": _3 }], "je": [1, { "co": _2, "net": _2, "org": _2, "of": _3 }], "jm": _8, "jo": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "sch": _2, "gov": _2, "mil": _2, "name": _2 }], "jobs": _2, "jp": [1, { "ac": _2, "ad": _2, "co": _2, "ed": _2, "go": _2, "gr": _2, "lg": _2, "ne": [1, { "aseinet": _30, "gehirn": _3, "ivory": _3, "mail-box": _3, "mints": _3, "mokuren": _3, "opal": _3, "sakura": _3, "sumomo": _3, "topaz": _3 }], "or": _2, "aichi": [1, { "aisai": _2, "ama": _2, "anjo": _2, "asuke": _2, "chiryu": _2, "chita": _2, "fuso": _2, "gamagori": _2, "handa": _2, "hazu": _2, "hekinan": _2, "higashiura": _2, "ichinomiya": _2, "inazawa": _2, "inuyama": _2, "isshiki": _2, "iwakura": _2, "kanie": _2, "kariya": _2, "kasugai": _2, "kira": _2, "kiyosu": _2, "komaki": _2, "konan": _2, "kota": _2, "mihama": _2, "miyoshi": _2, "nishio": _2, "nisshin": _2, "obu": _2, "oguchi": _2, "oharu": _2, "okazaki": _2, "owariasahi": _2, "seto": _2, "shikatsu": _2, "shinshiro": _2, "shitara": _2, "tahara": _2, "takahama": _2, "tobishima": _2, "toei": _2, "togo": _2, "tokai": _2, "tokoname": _2, "toyoake": _2, "toyohashi": _2, "toyokawa": _2, "toyone": _2, "toyota": _2, "tsushima": _2, "yatomi": _2 }], "akita": [1, { "akita": _2, "daisen": _2, "fujisato": _2, "gojome": _2, "hachirogata": _2, "happou": _2, "higashinaruse": _2, "honjo": _2, "honjyo": _2, "ikawa": _2, "kamikoani": _2, "kamioka": _2, "katagami": _2, "kazuno": _2, "kitaakita": _2, "kosaka": _2, "kyowa": _2, "misato": _2, "mitane": _2, "moriyoshi": _2, "nikaho": _2, "noshiro": _2, "odate": _2, "oga": _2, "ogata": _2, "semboku": _2, "yokote": _2, "yurihonjo": _2 }], "aomori": [1, { "aomori": _2, "gonohe": _2, "hachinohe": _2, "hashikami": _2, "hiranai": _2, "hirosaki": _2, "itayanagi": _2, "kuroishi": _2, "misawa": _2, "mutsu": _2, "nakadomari": _2, "noheji": _2, "oirase": _2, "owani": _2, "rokunohe": _2, "sannohe": _2, "shichinohe": _2, "shingo": _2, "takko": _2, "towada": _2, "tsugaru": _2, "tsuruta": _2 }], "chiba": [1, { "abiko": _2, "asahi": _2, "chonan": _2, "chosei": _2, "choshi": _2, "chuo": _2, "funabashi": _2, "futtsu": _2, "hanamigawa": _2, "ichihara": _2, "ichikawa": _2, "ichinomiya": _2, "inzai": _2, "isumi": _2, "kamagaya": _2, "kamogawa": _2, "kashiwa": _2, "katori": _2, "katsuura": _2, "kimitsu": _2, "kisarazu": _2, "kozaki": _2, "kujukuri": _2, "kyonan": _2, "matsudo": _2, "midori": _2, "mihama": _2, "minamiboso": _2, "mobara": _2, "mutsuzawa": _2, "nagara": _2, "nagareyama": _2, "narashino": _2, "narita": _2, "noda": _2, "oamishirasato": _2, "omigawa": _2, "onjuku": _2, "otaki": _2, "sakae": _2, "sakura": _2, "shimofusa": _2, "shirako": _2, "shiroi": _2, "shisui": _2, "sodegaura": _2, "sosa": _2, "tako": _2, "tateyama": _2, "togane": _2, "tohnosho": _2, "tomisato": _2, "urayasu": _2, "yachimata": _2, "yachiyo": _2, "yokaichiba": _2, "yokoshibahikari": _2, "yotsukaido": _2 }], "ehime": [1, { "ainan": _2, "honai": _2, "ikata": _2, "imabari": _2, "iyo": _2, "kamijima": _2, "kihoku": _2, "kumakogen": _2, "masaki": _2, "matsuno": _2, "matsuyama": _2, "namikata": _2, "niihama": _2, "ozu": _2, "saijo": _2, "seiyo": _2, "shikokuchuo": _2, "tobe": _2, "toon": _2, "uchiko": _2, "uwajima": _2, "yawatahama": _2 }], "fukui": [1, { "echizen": _2, "eiheiji": _2, "fukui": _2, "ikeda": _2, "katsuyama": _2, "mihama": _2, "minamiechizen": _2, "obama": _2, "ohi": _2, "ono": _2, "sabae": _2, "sakai": _2, "takahama": _2, "tsuruga": _2, "wakasa": _2 }], "fukuoka": [1, { "ashiya": _2, "buzen": _2, "chikugo": _2, "chikuho": _2, "chikujo": _2, "chikushino": _2, "chikuzen": _2, "chuo": _2, "dazaifu": _2, "fukuchi": _2, "hakata": _2, "higashi": _2, "hirokawa": _2, "hisayama": _2, "iizuka": _2, "inatsuki": _2, "kaho": _2, "kasuga": _2, "kasuya": _2, "kawara": _2, "keisen": _2, "koga": _2, "kurate": _2, "kurogi": _2, "kurume": _2, "minami": _2, "miyako": _2, "miyama": _2, "miyawaka": _2, "mizumaki": _2, "munakata": _2, "nakagawa": _2, "nakama": _2, "nishi": _2, "nogata": _2, "ogori": _2, "okagaki": _2, "okawa": _2, "oki": _2, "omuta": _2, "onga": _2, "onojo": _2, "oto": _2, "saigawa": _2, "sasaguri": _2, "shingu": _2, "shinyoshitomi": _2, "shonai": _2, "soeda": _2, "sue": _2, "tachiarai": _2, "tagawa": _2, "takata": _2, "toho": _2, "toyotsu": _2, "tsuiki": _2, "ukiha": _2, "umi": _2, "usui": _2, "yamada": _2, "yame": _2, "yanagawa": _2, "yukuhashi": _2 }], "fukushima": [1, { "aizubange": _2, "aizumisato": _2, "aizuwakamatsu": _2, "asakawa": _2, "bandai": _2, "date": _2, "fukushima": _2, "furudono": _2, "futaba": _2, "hanawa": _2, "higashi": _2, "hirata": _2, "hirono": _2, "iitate": _2, "inawashiro": _2, "ishikawa": _2, "iwaki": _2, "izumizaki": _2, "kagamiishi": _2, "kaneyama": _2, "kawamata": _2, "kitakata": _2, "kitashiobara": _2, "koori": _2, "koriyama": _2, "kunimi": _2, "miharu": _2, "mishima": _2, "namie": _2, "nango": _2, "nishiaizu": _2, "nishigo": _2, "okuma": _2, "omotego": _2, "ono": _2, "otama": _2, "samegawa": _2, "shimogo": _2, "shirakawa": _2, "showa": _2, "soma": _2, "sukagawa": _2, "taishin": _2, "tamakawa": _2, "tanagura": _2, "tenei": _2, "yabuki": _2, "yamato": _2, "yamatsuri": _2, "yanaizu": _2, "yugawa": _2 }], "gifu": [1, { "anpachi": _2, "ena": _2, "gifu": _2, "ginan": _2, "godo": _2, "gujo": _2, "hashima": _2, "hichiso": _2, "hida": _2, "higashishirakawa": _2, "ibigawa": _2, "ikeda": _2, "kakamigahara": _2, "kani": _2, "kasahara": _2, "kasamatsu": _2, "kawaue": _2, "kitagata": _2, "mino": _2, "minokamo": _2, "mitake": _2, "mizunami": _2, "motosu": _2, "nakatsugawa": _2, "ogaki": _2, "sakahogi": _2, "seki": _2, "sekigahara": _2, "shirakawa": _2, "tajimi": _2, "takayama": _2, "tarui": _2, "toki": _2, "tomika": _2, "wanouchi": _2, "yamagata": _2, "yaotsu": _2, "yoro": _2 }], "gunma": [1, { "annaka": _2, "chiyoda": _2, "fujioka": _2, "higashiagatsuma": _2, "isesaki": _2, "itakura": _2, "kanna": _2, "kanra": _2, "katashina": _2, "kawaba": _2, "kiryu": _2, "kusatsu": _2, "maebashi": _2, "meiwa": _2, "midori": _2, "minakami": _2, "naganohara": _2, "nakanojo": _2, "nanmoku": _2, "numata": _2, "oizumi": _2, "ora": _2, "ota": _2, "shibukawa": _2, "shimonita": _2, "shinto": _2, "showa": _2, "takasaki": _2, "takayama": _2, "tamamura": _2, "tatebayashi": _2, "tomioka": _2, "tsukiyono": _2, "tsumagoi": _2, "ueno": _2, "yoshioka": _2 }], "hiroshima": [1, { "asaminami": _2, "daiwa": _2, "etajima": _2, "fuchu": _2, "fukuyama": _2, "hatsukaichi": _2, "higashihiroshima": _2, "hongo": _2, "jinsekikogen": _2, "kaita": _2, "kui": _2, "kumano": _2, "kure": _2, "mihara": _2, "miyoshi": _2, "naka": _2, "onomichi": _2, "osakikamijima": _2, "otake": _2, "saka": _2, "sera": _2, "seranishi": _2, "shinichi": _2, "shobara": _2, "takehara": _2 }], "hokkaido": [1, { "abashiri": _2, "abira": _2, "aibetsu": _2, "akabira": _2, "akkeshi": _2, "asahikawa": _2, "ashibetsu": _2, "ashoro": _2, "assabu": _2, "atsuma": _2, "bibai": _2, "biei": _2, "bifuka": _2, "bihoro": _2, "biratori": _2, "chippubetsu": _2, "chitose": _2, "date": _2, "ebetsu": _2, "embetsu": _2, "eniwa": _2, "erimo": _2, "esan": _2, "esashi": _2, "fukagawa": _2, "fukushima": _2, "furano": _2, "furubira": _2, "haboro": _2, "hakodate": _2, "hamatonbetsu": _2, "hidaka": _2, "higashikagura": _2, "higashikawa": _2, "hiroo": _2, "hokuryu": _2, "hokuto": _2, "honbetsu": _2, "horokanai": _2, "horonobe": _2, "ikeda": _2, "imakane": _2, "ishikari": _2, "iwamizawa": _2, "iwanai": _2, "kamifurano": _2, "kamikawa": _2, "kamishihoro": _2, "kamisunagawa": _2, "kamoenai": _2, "kayabe": _2, "kembuchi": _2, "kikonai": _2, "kimobetsu": _2, "kitahiroshima": _2, "kitami": _2, "kiyosato": _2, "koshimizu": _2, "kunneppu": _2, "kuriyama": _2, "kuromatsunai": _2, "kushiro": _2, "kutchan": _2, "kyowa": _2, "mashike": _2, "matsumae": _2, "mikasa": _2, "minamifurano": _2, "mombetsu": _2, "moseushi": _2, "mukawa": _2, "muroran": _2, "naie": _2, "nakagawa": _2, "nakasatsunai": _2, "nakatombetsu": _2, "nanae": _2, "nanporo": _2, "nayoro": _2, "nemuro": _2, "niikappu": _2, "niki": _2, "nishiokoppe": _2, "noboribetsu": _2, "numata": _2, "obihiro": _2, "obira": _2, "oketo": _2, "okoppe": _2, "otaru": _2, "otobe": _2, "otofuke": _2, "otoineppu": _2, "oumu": _2, "ozora": _2, "pippu": _2, "rankoshi": _2, "rebun": _2, "rikubetsu": _2, "rishiri": _2, "rishirifuji": _2, "saroma": _2, "sarufutsu": _2, "shakotan": _2, "shari": _2, "shibecha": _2, "shibetsu": _2, "shikabe": _2, "shikaoi": _2, "shimamaki": _2, "shimizu": _2, "shimokawa": _2, "shinshinotsu": _2, "shintoku": _2, "shiranuka": _2, "shiraoi": _2, "shiriuchi": _2, "sobetsu": _2, "sunagawa": _2, "taiki": _2, "takasu": _2, "takikawa": _2, "takinoue": _2, "teshikaga": _2, "tobetsu": _2, "tohma": _2, "tomakomai": _2, "tomari": _2, "toya": _2, "toyako": _2, "toyotomi": _2, "toyoura": _2, "tsubetsu": _2, "tsukigata": _2, "urakawa": _2, "urausu": _2, "uryu": _2, "utashinai": _2, "wakkanai": _2, "wassamu": _2, "yakumo": _2, "yoichi": _2 }], "hyogo": [1, { "aioi": _2, "akashi": _2, "ako": _2, "amagasaki": _2, "aogaki": _2, "asago": _2, "ashiya": _2, "awaji": _2, "fukusaki": _2, "goshiki": _2, "harima": _2, "himeji": _2, "ichikawa": _2, "inagawa": _2, "itami": _2, "kakogawa": _2, "kamigori": _2, "kamikawa": _2, "kasai": _2, "kasuga": _2, "kawanishi": _2, "miki": _2, "minamiawaji": _2, "nishinomiya": _2, "nishiwaki": _2, "ono": _2, "sanda": _2, "sannan": _2, "sasayama": _2, "sayo": _2, "shingu": _2, "shinonsen": _2, "shiso": _2, "sumoto": _2, "taishi": _2, "taka": _2, "takarazuka": _2, "takasago": _2, "takino": _2, "tamba": _2, "tatsuno": _2, "toyooka": _2, "yabu": _2, "yashiro": _2, "yoka": _2, "yokawa": _2 }], "ibaraki": [1, { "ami": _2, "asahi": _2, "bando": _2, "chikusei": _2, "daigo": _2, "fujishiro": _2, "hitachi": _2, "hitachinaka": _2, "hitachiomiya": _2, "hitachiota": _2, "ibaraki": _2, "ina": _2, "inashiki": _2, "itako": _2, "iwama": _2, "joso": _2, "kamisu": _2, "kasama": _2, "kashima": _2, "kasumigaura": _2, "koga": _2, "miho": _2, "mito": _2, "moriya": _2, "naka": _2, "namegata": _2, "oarai": _2, "ogawa": _2, "omitama": _2, "ryugasaki": _2, "sakai": _2, "sakuragawa": _2, "shimodate": _2, "shimotsuma": _2, "shirosato": _2, "sowa": _2, "suifu": _2, "takahagi": _2, "tamatsukuri": _2, "tokai": _2, "tomobe": _2, "tone": _2, "toride": _2, "tsuchiura": _2, "tsukuba": _2, "uchihara": _2, "ushiku": _2, "yachiyo": _2, "yamagata": _2, "yawara": _2, "yuki": _2 }], "ishikawa": [1, { "anamizu": _2, "hakui": _2, "hakusan": _2, "kaga": _2, "kahoku": _2, "kanazawa": _2, "kawakita": _2, "komatsu": _2, "nakanoto": _2, "nanao": _2, "nomi": _2, "nonoichi": _2, "noto": _2, "shika": _2, "suzu": _2, "tsubata": _2, "tsurugi": _2, "uchinada": _2, "wajima": _2 }], "iwate": [1, { "fudai": _2, "fujisawa": _2, "hanamaki": _2, "hiraizumi": _2, "hirono": _2, "ichinohe": _2, "ichinoseki": _2, "iwaizumi": _2, "iwate": _2, "joboji": _2, "kamaishi": _2, "kanegasaki": _2, "karumai": _2, "kawai": _2, "kitakami": _2, "kuji": _2, "kunohe": _2, "kuzumaki": _2, "miyako": _2, "mizusawa": _2, "morioka": _2, "ninohe": _2, "noda": _2, "ofunato": _2, "oshu": _2, "otsuchi": _2, "rikuzentakata": _2, "shiwa": _2, "shizukuishi": _2, "sumita": _2, "tanohata": _2, "tono": _2, "yahaba": _2, "yamada": _2 }], "kagawa": [1, { "ayagawa": _2, "higashikagawa": _2, "kanonji": _2, "kotohira": _2, "manno": _2, "marugame": _2, "mitoyo": _2, "naoshima": _2, "sanuki": _2, "tadotsu": _2, "takamatsu": _2, "tonosho": _2, "uchinomi": _2, "utazu": _2, "zentsuji": _2 }], "kagoshima": [1, { "akune": _2, "amami": _2, "hioki": _2, "isa": _2, "isen": _2, "izumi": _2, "kagoshima": _2, "kanoya": _2, "kawanabe": _2, "kinko": _2, "kouyama": _2, "makurazaki": _2, "matsumoto": _2, "minamitane": _2, "nakatane": _2, "nishinoomote": _2, "satsumasendai": _2, "soo": _2, "tarumizu": _2, "yusui": _2 }], "kanagawa": [1, { "aikawa": _2, "atsugi": _2, "ayase": _2, "chigasaki": _2, "ebina": _2, "fujisawa": _2, "hadano": _2, "hakone": _2, "hiratsuka": _2, "isehara": _2, "kaisei": _2, "kamakura": _2, "kiyokawa": _2, "matsuda": _2, "minamiashigara": _2, "miura": _2, "nakai": _2, "ninomiya": _2, "odawara": _2, "oi": _2, "oiso": _2, "sagamihara": _2, "samukawa": _2, "tsukui": _2, "yamakita": _2, "yamato": _2, "yokosuka": _2, "yugawara": _2, "zama": _2, "zushi": _2 }], "kochi": [1, { "aki": _2, "geisei": _2, "hidaka": _2, "higashitsuno": _2, "ino": _2, "kagami": _2, "kami": _2, "kitagawa": _2, "kochi": _2, "mihara": _2, "motoyama": _2, "muroto": _2, "nahari": _2, "nakamura": _2, "nankoku": _2, "nishitosa": _2, "niyodogawa": _2, "ochi": _2, "okawa": _2, "otoyo": _2, "otsuki": _2, "sakawa": _2, "sukumo": _2, "susaki": _2, "tosa": _2, "tosashimizu": _2, "toyo": _2, "tsuno": _2, "umaji": _2, "yasuda": _2, "yusuhara": _2 }], "kumamoto": [1, { "amakusa": _2, "arao": _2, "aso": _2, "choyo": _2, "gyokuto": _2, "kamiamakusa": _2, "kikuchi": _2, "kumamoto": _2, "mashiki": _2, "mifune": _2, "minamata": _2, "minamioguni": _2, "nagasu": _2, "nishihara": _2, "oguni": _2, "ozu": _2, "sumoto": _2, "takamori": _2, "uki": _2, "uto": _2, "yamaga": _2, "yamato": _2, "yatsushiro": _2 }], "kyoto": [1, { "ayabe": _2, "fukuchiyama": _2, "higashiyama": _2, "ide": _2, "ine": _2, "joyo": _2, "kameoka": _2, "kamo": _2, "kita": _2, "kizu": _2, "kumiyama": _2, "kyotamba": _2, "kyotanabe": _2, "kyotango": _2, "maizuru": _2, "minami": _2, "minamiyamashiro": _2, "miyazu": _2, "muko": _2, "nagaokakyo": _2, "nakagyo": _2, "nantan": _2, "oyamazaki": _2, "sakyo": _2, "seika": _2, "tanabe": _2, "uji": _2, "ujitawara": _2, "wazuka": _2, "yamashina": _2, "yawata": _2 }], "mie": [1, { "asahi": _2, "inabe": _2, "ise": _2, "kameyama": _2, "kawagoe": _2, "kiho": _2, "kisosaki": _2, "kiwa": _2, "komono": _2, "kumano": _2, "kuwana": _2, "matsusaka": _2, "meiwa": _2, "mihama": _2, "minamiise": _2, "misugi": _2, "miyama": _2, "nabari": _2, "shima": _2, "suzuka": _2, "tado": _2, "taiki": _2, "taki": _2, "tamaki": _2, "toba": _2, "tsu": _2, "udono": _2, "ureshino": _2, "watarai": _2, "yokkaichi": _2 }], "miyagi": [1, { "furukawa": _2, "higashimatsushima": _2, "ishinomaki": _2, "iwanuma": _2, "kakuda": _2, "kami": _2, "kawasaki": _2, "marumori": _2, "matsushima": _2, "minamisanriku": _2, "misato": _2, "murata": _2, "natori": _2, "ogawara": _2, "ohira": _2, "onagawa": _2, "osaki": _2, "rifu": _2, "semine": _2, "shibata": _2, "shichikashuku": _2, "shikama": _2, "shiogama": _2, "shiroishi": _2, "tagajo": _2, "taiwa": _2, "tome": _2, "tomiya": _2, "wakuya": _2, "watari": _2, "yamamoto": _2, "zao": _2 }], "miyazaki": [1, { "aya": _2, "ebino": _2, "gokase": _2, "hyuga": _2, "kadogawa": _2, "kawaminami": _2, "kijo": _2, "kitagawa": _2, "kitakata": _2, "kitaura": _2, "kobayashi": _2, "kunitomi": _2, "kushima": _2, "mimata": _2, "miyakonojo": _2, "miyazaki": _2, "morotsuka": _2, "nichinan": _2, "nishimera": _2, "nobeoka": _2, "saito": _2, "shiiba": _2, "shintomi": _2, "takaharu": _2, "takanabe": _2, "takazaki": _2, "tsuno": _2 }], "nagano": [1, { "achi": _2, "agematsu": _2, "anan": _2, "aoki": _2, "asahi": _2, "azumino": _2, "chikuhoku": _2, "chikuma": _2, "chino": _2, "fujimi": _2, "hakuba": _2, "hara": _2, "hiraya": _2, "iida": _2, "iijima": _2, "iiyama": _2, "iizuna": _2, "ikeda": _2, "ikusaka": _2, "ina": _2, "karuizawa": _2, "kawakami": _2, "kiso": _2, "kisofukushima": _2, "kitaaiki": _2, "komagane": _2, "komoro": _2, "matsukawa": _2, "matsumoto": _2, "miasa": _2, "minamiaiki": _2, "minamimaki": _2, "minamiminowa": _2, "minowa": _2, "miyada": _2, "miyota": _2, "mochizuki": _2, "nagano": _2, "nagawa": _2, "nagiso": _2, "nakagawa": _2, "nakano": _2, "nozawaonsen": _2, "obuse": _2, "ogawa": _2, "okaya": _2, "omachi": _2, "omi": _2, "ookuwa": _2, "ooshika": _2, "otaki": _2, "otari": _2, "sakae": _2, "sakaki": _2, "saku": _2, "sakuho": _2, "shimosuwa": _2, "shinanomachi": _2, "shiojiri": _2, "suwa": _2, "suzaka": _2, "takagi": _2, "takamori": _2, "takayama": _2, "tateshina": _2, "tatsuno": _2, "togakushi": _2, "togura": _2, "tomi": _2, "ueda": _2, "wada": _2, "yamagata": _2, "yamanouchi": _2, "yasaka": _2, "yasuoka": _2 }], "nagasaki": [1, { "chijiwa": _2, "futsu": _2, "goto": _2, "hasami": _2, "hirado": _2, "iki": _2, "isahaya": _2, "kawatana": _2, "kuchinotsu": _2, "matsuura": _2, "nagasaki": _2, "obama": _2, "omura": _2, "oseto": _2, "saikai": _2, "sasebo": _2, "seihi": _2, "shimabara": _2, "shinkamigoto": _2, "togitsu": _2, "tsushima": _2, "unzen": _2 }], "nara": [1, { "ando": _2, "gose": _2, "heguri": _2, "higashiyoshino": _2, "ikaruga": _2, "ikoma": _2, "kamikitayama": _2, "kanmaki": _2, "kashiba": _2, "kashihara": _2, "katsuragi": _2, "kawai": _2, "kawakami": _2, "kawanishi": _2, "koryo": _2, "kurotaki": _2, "mitsue": _2, "miyake": _2, "nara": _2, "nosegawa": _2, "oji": _2, "ouda": _2, "oyodo": _2, "sakurai": _2, "sango": _2, "shimoichi": _2, "shimokitayama": _2, "shinjo": _2, "soni": _2, "takatori": _2, "tawaramoto": _2, "tenkawa": _2, "tenri": _2, "uda": _2, "yamatokoriyama": _2, "yamatotakada": _2, "yamazoe": _2, "yoshino": _2 }], "niigata": [1, { "aga": _2, "agano": _2, "gosen": _2, "itoigawa": _2, "izumozaki": _2, "joetsu": _2, "kamo": _2, "kariwa": _2, "kashiwazaki": _2, "minamiuonuma": _2, "mitsuke": _2, "muika": _2, "murakami": _2, "myoko": _2, "nagaoka": _2, "niigata": _2, "ojiya": _2, "omi": _2, "sado": _2, "sanjo": _2, "seiro": _2, "seirou": _2, "sekikawa": _2, "shibata": _2, "tagami": _2, "tainai": _2, "tochio": _2, "tokamachi": _2, "tsubame": _2, "tsunan": _2, "uonuma": _2, "yahiko": _2, "yoita": _2, "yuzawa": _2 }], "oita": [1, { "beppu": _2, "bungoono": _2, "bungotakada": _2, "hasama": _2, "hiji": _2, "himeshima": _2, "hita": _2, "kamitsue": _2, "kokonoe": _2, "kuju": _2, "kunisaki": _2, "kusu": _2, "oita": _2, "saiki": _2, "taketa": _2, "tsukumi": _2, "usa": _2, "usuki": _2, "yufu": _2 }], "okayama": [1, { "akaiwa": _2, "asakuchi": _2, "bizen": _2, "hayashima": _2, "ibara": _2, "kagamino": _2, "kasaoka": _2, "kibichuo": _2, "kumenan": _2, "kurashiki": _2, "maniwa": _2, "misaki": _2, "nagi": _2, "niimi": _2, "nishiawakura": _2, "okayama": _2, "satosho": _2, "setouchi": _2, "shinjo": _2, "shoo": _2, "soja": _2, "takahashi": _2, "tamano": _2, "tsuyama": _2, "wake": _2, "yakage": _2 }], "okinawa": [1, { "aguni": _2, "ginowan": _2, "ginoza": _2, "gushikami": _2, "haebaru": _2, "higashi": _2, "hirara": _2, "iheya": _2, "ishigaki": _2, "ishikawa": _2, "itoman": _2, "izena": _2, "kadena": _2, "kin": _2, "kitadaito": _2, "kitanakagusuku": _2, "kumejima": _2, "kunigami": _2, "minamidaito": _2, "motobu": _2, "nago": _2, "naha": _2, "nakagusuku": _2, "nakijin": _2, "nanjo": _2, "nishihara": _2, "ogimi": _2, "okinawa": _2, "onna": _2, "shimoji": _2, "taketomi": _2, "tarama": _2, "tokashiki": _2, "tomigusuku": _2, "tonaki": _2, "urasoe": _2, "uruma": _2, "yaese": _2, "yomitan": _2, "yonabaru": _2, "yonaguni": _2, "zamami": _2 }], "osaka": [1, { "abeno": _2, "chihayaakasaka": _2, "chuo": _2, "daito": _2, "fujiidera": _2, "habikino": _2, "hannan": _2, "higashiosaka": _2, "higashisumiyoshi": _2, "higashiyodogawa": _2, "hirakata": _2, "ibaraki": _2, "ikeda": _2, "izumi": _2, "izumiotsu": _2, "izumisano": _2, "kadoma": _2, "kaizuka": _2, "kanan": _2, "kashiwara": _2, "katano": _2, "kawachinagano": _2, "kishiwada": _2, "kita": _2, "kumatori": _2, "matsubara": _2, "minato": _2, "minoh": _2, "misaki": _2, "moriguchi": _2, "neyagawa": _2, "nishi": _2, "nose": _2, "osakasayama": _2, "sakai": _2, "sayama": _2, "sennan": _2, "settsu": _2, "shijonawate": _2, "shimamoto": _2, "suita": _2, "tadaoka": _2, "taishi": _2, "tajiri": _2, "takaishi": _2, "takatsuki": _2, "tondabayashi": _2, "toyonaka": _2, "toyono": _2, "yao": _2 }], "saga": [1, { "ariake": _2, "arita": _2, "fukudomi": _2, "genkai": _2, "hamatama": _2, "hizen": _2, "imari": _2, "kamimine": _2, "kanzaki": _2, "karatsu": _2, "kashima": _2, "kitagata": _2, "kitahata": _2, "kiyama": _2, "kouhoku": _2, "kyuragi": _2, "nishiarita": _2, "ogi": _2, "omachi": _2, "ouchi": _2, "saga": _2, "shiroishi": _2, "taku": _2, "tara": _2, "tosu": _2, "yoshinogari": _2 }], "saitama": [1, { "arakawa": _2, "asaka": _2, "chichibu": _2, "fujimi": _2, "fujimino": _2, "fukaya": _2, "hanno": _2, "hanyu": _2, "hasuda": _2, "hatogaya": _2, "hatoyama": _2, "hidaka": _2, "higashichichibu": _2, "higashimatsuyama": _2, "honjo": _2, "ina": _2, "iruma": _2, "iwatsuki": _2, "kamiizumi": _2, "kamikawa": _2, "kamisato": _2, "kasukabe": _2, "kawagoe": _2, "kawaguchi": _2, "kawajima": _2, "kazo": _2, "kitamoto": _2, "koshigaya": _2, "kounosu": _2, "kuki": _2, "kumagaya": _2, "matsubushi": _2, "minano": _2, "misato": _2, "miyashiro": _2, "miyoshi": _2, "moroyama": _2, "nagatoro": _2, "namegawa": _2, "niiza": _2, "ogano": _2, "ogawa": _2, "ogose": _2, "okegawa": _2, "omiya": _2, "otaki": _2, "ranzan": _2, "ryokami": _2, "saitama": _2, "sakado": _2, "satte": _2, "sayama": _2, "shiki": _2, "shiraoka": _2, "soka": _2, "sugito": _2, "toda": _2, "tokigawa": _2, "tokorozawa": _2, "tsurugashima": _2, "urawa": _2, "warabi": _2, "yashio": _2, "yokoze": _2, "yono": _2, "yorii": _2, "yoshida": _2, "yoshikawa": _2, "yoshimi": _2 }], "shiga": [1, { "aisho": _2, "gamo": _2, "higashiomi": _2, "hikone": _2, "koka": _2, "konan": _2, "kosei": _2, "koto": _2, "kusatsu": _2, "maibara": _2, "moriyama": _2, "nagahama": _2, "nishiazai": _2, "notogawa": _2, "omihachiman": _2, "otsu": _2, "ritto": _2, "ryuoh": _2, "takashima": _2, "takatsuki": _2, "torahime": _2, "toyosato": _2, "yasu": _2 }], "shimane": [1, { "akagi": _2, "ama": _2, "gotsu": _2, "hamada": _2, "higashiizumo": _2, "hikawa": _2, "hikimi": _2, "izumo": _2, "kakinoki": _2, "masuda": _2, "matsue": _2, "misato": _2, "nishinoshima": _2, "ohda": _2, "okinoshima": _2, "okuizumo": _2, "shimane": _2, "tamayu": _2, "tsuwano": _2, "unnan": _2, "yakumo": _2, "yasugi": _2, "yatsuka": _2 }], "shizuoka": [1, { "arai": _2, "atami": _2, "fuji": _2, "fujieda": _2, "fujikawa": _2, "fujinomiya": _2, "fukuroi": _2, "gotemba": _2, "haibara": _2, "hamamatsu": _2, "higashiizu": _2, "ito": _2, "iwata": _2, "izu": _2, "izunokuni": _2, "kakegawa": _2, "kannami": _2, "kawanehon": _2, "kawazu": _2, "kikugawa": _2, "kosai": _2, "makinohara": _2, "matsuzaki": _2, "minamiizu": _2, "mishima": _2, "morimachi": _2, "nishiizu": _2, "numazu": _2, "omaezaki": _2, "shimada": _2, "shimizu": _2, "shimoda": _2, "shizuoka": _2, "susono": _2, "yaizu": _2, "yoshida": _2 }], "tochigi": [1, { "ashikaga": _2, "bato": _2, "haga": _2, "ichikai": _2, "iwafune": _2, "kaminokawa": _2, "kanuma": _2, "karasuyama": _2, "kuroiso": _2, "mashiko": _2, "mibu": _2, "moka": _2, "motegi": _2, "nasu": _2, "nasushiobara": _2, "nikko": _2, "nishikata": _2, "nogi": _2, "ohira": _2, "ohtawara": _2, "oyama": _2, "sakura": _2, "sano": _2, "shimotsuke": _2, "shioya": _2, "takanezawa": _2, "tochigi": _2, "tsuga": _2, "ujiie": _2, "utsunomiya": _2, "yaita": _2 }], "tokushima": [1, { "aizumi": _2, "anan": _2, "ichiba": _2, "itano": _2, "kainan": _2, "komatsushima": _2, "matsushige": _2, "mima": _2, "minami": _2, "miyoshi": _2, "mugi": _2, "nakagawa": _2, "naruto": _2, "sanagochi": _2, "shishikui": _2, "tokushima": _2, "wajiki": _2 }], "tokyo": [1, { "adachi": _2, "akiruno": _2, "akishima": _2, "aogashima": _2, "arakawa": _2, "bunkyo": _2, "chiyoda": _2, "chofu": _2, "chuo": _2, "edogawa": _2, "fuchu": _2, "fussa": _2, "hachijo": _2, "hachioji": _2, "hamura": _2, "higashikurume": _2, "higashimurayama": _2, "higashiyamato": _2, "hino": _2, "hinode": _2, "hinohara": _2, "inagi": _2, "itabashi": _2, "katsushika": _2, "kita": _2, "kiyose": _2, "kodaira": _2, "koganei": _2, "kokubunji": _2, "komae": _2, "koto": _2, "kouzushima": _2, "kunitachi": _2, "machida": _2, "meguro": _2, "minato": _2, "mitaka": _2, "mizuho": _2, "musashimurayama": _2, "musashino": _2, "nakano": _2, "nerima": _2, "ogasawara": _2, "okutama": _2, "ome": _2, "oshima": _2, "ota": _2, "setagaya": _2, "shibuya": _2, "shinagawa": _2, "shinjuku": _2, "suginami": _2, "sumida": _2, "tachikawa": _2, "taito": _2, "tama": _2, "toshima": _2 }], "tottori": [1, { "chizu": _2, "hino": _2, "kawahara": _2, "koge": _2, "kotoura": _2, "misasa": _2, "nanbu": _2, "nichinan": _2, "sakaiminato": _2, "tottori": _2, "wakasa": _2, "yazu": _2, "yonago": _2 }], "toyama": [1, { "asahi": _2, "fuchu": _2, "fukumitsu": _2, "funahashi": _2, "himi": _2, "imizu": _2, "inami": _2, "johana": _2, "kamiichi": _2, "kurobe": _2, "nakaniikawa": _2, "namerikawa": _2, "nanto": _2, "nyuzen": _2, "oyabe": _2, "taira": _2, "takaoka": _2, "tateyama": _2, "toga": _2, "tonami": _2, "toyama": _2, "unazuki": _2, "uozu": _2, "yamada": _2 }], "wakayama": [1, { "arida": _2, "aridagawa": _2, "gobo": _2, "hashimoto": _2, "hidaka": _2, "hirogawa": _2, "inami": _2, "iwade": _2, "kainan": _2, "kamitonda": _2, "katsuragi": _2, "kimino": _2, "kinokawa": _2, "kitayama": _2, "koya": _2, "koza": _2, "kozagawa": _2, "kudoyama": _2, "kushimoto": _2, "mihama": _2, "misato": _2, "nachikatsuura": _2, "shingu": _2, "shirahama": _2, "taiji": _2, "tanabe": _2, "wakayama": _2, "yuasa": _2, "yura": _2 }], "yamagata": [1, { "asahi": _2, "funagata": _2, "higashine": _2, "iide": _2, "kahoku": _2, "kaminoyama": _2, "kaneyama": _2, "kawanishi": _2, "mamurogawa": _2, "mikawa": _2, "murayama": _2, "nagai": _2, "nakayama": _2, "nanyo": _2, "nishikawa": _2, "obanazawa": _2, "oe": _2, "oguni": _2, "ohkura": _2, "oishida": _2, "sagae": _2, "sakata": _2, "sakegawa": _2, "shinjo": _2, "shirataka": _2, "shonai": _2, "takahata": _2, "tendo": _2, "tozawa": _2, "tsuruoka": _2, "yamagata": _2, "yamanobe": _2, "yonezawa": _2, "yuza": _2 }], "yamaguchi": [1, { "abu": _2, "hagi": _2, "hikari": _2, "hofu": _2, "iwakuni": _2, "kudamatsu": _2, "mitou": _2, "nagato": _2, "oshima": _2, "shimonoseki": _2, "shunan": _2, "tabuse": _2, "tokuyama": _2, "toyota": _2, "ube": _2, "yuu": _2 }], "yamanashi": [1, { "chuo": _2, "doshi": _2, "fuefuki": _2, "fujikawa": _2, "fujikawaguchiko": _2, "fujiyoshida": _2, "hayakawa": _2, "hokuto": _2, "ichikawamisato": _2, "kai": _2, "kofu": _2, "koshu": _2, "kosuge": _2, "minami-alps": _2, "minobu": _2, "nakamichi": _2, "nanbu": _2, "narusawa": _2, "nirasaki": _2, "nishikatsura": _2, "oshino": _2, "otsuki": _2, "showa": _2, "tabayama": _2, "tsuru": _2, "uenohara": _2, "yamanakako": _2, "yamanashi": _2 }], "xn--4pvxs": _2, "": _2, "xn--vgu402c": _2, "": _2, "xn--c3s14m": _2, "": _2, "xn--f6qx53a": _2, "": _2, "xn--8pvr4u": _2, "": _2, "xn--uist22h": _2, "": _2, "xn--djrs72d6uy": _2, "": _2, "xn--mkru45i": _2, "": _2, "xn--0trq7p7nn": _2, "": _2, "xn--8ltr62k": _2, "": _2, "xn--2m4a15e": _2, "": _2, "xn--efvn9s": _2, "": _2, "xn--32vp30h": _2, "": _2, "xn--4it797k": _2, "": _2, "xn--1lqs71d": _2, "": _2, "xn--5rtp49c": _2, "": _2, "xn--5js045d": _2, "": _2, "xn--ehqz56n": _2, "": _2, "xn--1lqs03n": _2, "": _2, "xn--qqqt11m": _2, "": _2, "xn--kbrq7o": _2, "": _2, "xn--pssu33l": _2, "": _2, "xn--ntsq17g": _2, "": _2, "xn--uisz3g": _2, "": _2, "xn--6btw5a": _2, "": _2, "xn--1ctwo": _2, "": _2, "xn--6orx2r": _2, "": _2, "xn--rht61e": _2, "": _2, "xn--rht27z": _2, "": _2, "xn--djty4k": _2, "": _2, "xn--nit225k": _2, "": _2, "xn--rht3d": _2, "": _2, "xn--klty5x": _2, "": _2, "xn--kltx9a": _2, "": _2, "xn--kltp7d": _2, "": _2, "xn--uuwu58a": _2, "": _2, "xn--zbx025d": _2, "": _2, "xn--ntso0iqx3a": _2, "": _2, "xn--elqq16h": _2, "": _2, "xn--4it168d": _2, "": _2, "xn--klt787d": _2, "": _2, "xn--rny31h": _2, "": _2, "xn--7t0a264c": _2, "": _2, "xn--5rtq34k": _2, "": _2, "xn--k7yn95e": _2, "": _2, "xn--tor131o": _2, "": _2, "xn--d5qv7z876c": _2, "": _2, "kawasaki": _8, "kitakyushu": _8, "kobe": _8, "nagoya": _8, "sapporo": _8, "sendai": _8, "yokohama": _8, "buyshop": _3, "fashionstore": _3, "handcrafted": _3, "kawaiishop": _3, "supersale": _3, "theshop": _3, "usercontent": _3, "angry": _3, "babyblue": _3, "babymilk": _3, "backdrop": _3, "bambina": _3, "bitter": _3, "blush": _3, "boo": _3, "boy": _3, "boyfriend": _3, "but": _3, "candypop": _3, "capoo": _3, "catfood": _3, "cheap": _3, "chicappa": _3, "chillout": _3, "chips": _3, "chowder": _3, "chu": _3, "ciao": _3, "cocotte": _3, "coolblog": _3, "cranky": _3, "cutegirl": _3, "daa": _3, "deca": _3, "deci": _3, "digick": _3, "egoism": _3, "fakefur": _3, "fem": _3, "flier": _3, "floppy": _3, "fool": _3, "frenchkiss": _3, "girlfriend": _3, "girly": _3, "gloomy": _3, "gonna": _3, "greater": _3, "hacca": _3, "heavy": _3, "her": _3, "hiho": _3, "hippy": _3, "holy": _3, "hungry": _3, "icurus": _3, "itigo": _3, "jellybean": _3, "kikirara": _3, "kill": _3, "kilo": _3, "kuron": _3, "littlestar": _3, "lolipopmc": _3, "lolitapunk": _3, "lomo": _3, "lovepop": _3, "lovesick": _3, "main": _3, "mods": _3, "mond": _3, "mongolian": _3, "moo": _3, "namaste": _3, "nikita": _3, "nobushi": _3, "noor": _3, "oops": _3, "parallel": _3, "parasite": _3, "pecori": _3, "peewee": _3, "penne": _3, "pepper": _3, "perma": _3, "pigboat": _3, "pinoko": _3, "punyu": _3, "pupu": _3, "pussycat": _3, "pya": _3, "raindrop": _3, "readymade": _3, "sadist": _3, "schoolbus": _3, "secret": _3, "staba": _3, "stripper": _3, "sub": _3, "sunnyday": _3, "thick": _3, "tonkotsu": _3, "under": _3, "upper": _3, "velvet": _3, "verse": _3, "versus": _3, "vivian": _3, "watson": _3, "weblike": _3, "whitesnow": _3, "zombie": _3, "blogspot": _3, "2-d": _3, "bona": _3, "crap": _3, "daynight": _3, "eek": _3, "flop": _3, "halfmoon": _3, "jeez": _3, "matrix": _3, "mimoza": _3, "netgamers": _3, "nyanta": _3, "o0o0": _3, "rdy": _3, "rgr": _3, "rulez": _3, "sakurastorage": [0, { "isk01": _12, "isk02": _12 }], "saloon": _3, "sblo": _3, "skr": _3, "tank": _3, "uh-oh": _3, "undo": _3, "webaccel": [0, { "rs": _3, "user": _3 }], "websozai": _3, "xii": _3 }], "ke": [1, { "ac": _2, "co": _6, "go": _2, "info": _2, "me": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2 }], "kg": [1, { "org": _2, "net": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "blog": _3, "io": _3, "jp": _3, "tv": _3, "uk": _3, "us": _3 }], "kh": _8, "ki": _35, "km": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "ass": _2, "com": _2, "coop": _2, "asso": _2, "presse": _2, "medecin": _2, "notaires": _2, "pharmaciens": _2, "veterinaire": _2, "gouv": _2 }], "kn": [1, { "net": _2, "org": _2, "edu": _2, "gov": _2 }], "kp": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "rep": _2, "tra": _2 }], "kr": [1, { "ac": _2, "co": _2, "es": _2, "go": _2, "hs": _2, "kg": _2, "mil": _2, "ms": _2, "ne": _2, "or": _2, "pe": _2, "re": _2, "sc": _2, "busan": _2, "chungbuk": _2, "chungnam": _2, "daegu": _2, "daejeon": _2, "gangwon": _2, "gwangju": _2, "gyeongbuk": _2, "gyeonggi": _2, "gyeongnam": _2, "incheon": _2, "jeju": _2, "jeonbuk": _2, "jeonnam": _2, "seoul": _2, "ulsan": _2, "blogspot": _3 }], "kw": [1, { "com": _2, "edu": _2, "emb": _2, "gov": _2, "ind": _2, "net": _2, "org": _2 }], "ky": _27, "kz": [1, { "org": _2, "edu": _2, "net": _2, "gov": _2, "mil": _2, "com": _2, "jcloud": _3, "kazteleport": [0, { "upaas": _3 }] }], "la": [1, { "int": _2, "net": _2, "info": _2, "edu": _2, "gov": _2, "per": _2, "com": _2, "org": _2, "bnr": _3, "c": _3 }], "lb": _4, "lc": [1, { "com": _2, "net": _2, "co": _2, "org": _2, "edu": _2, "gov": _2, "oy": _3 }], "li": [1, { "blogspot": _3, "caa": _3 }], "lk": [1, { "gov": _2, "sch": _2, "net": _2, "int": _2, "com": _2, "org": _2, "edu": _2, "ngo": _2, "soc": _2, "web": _2, "ltd": _2, "assn": _2, "grp": _2, "hotel": _2, "ac": _2 }], "lr": _4, "ls": [1, { "ac": _2, "biz": _2, "co": _2, "edu": _2, "gov": _2, "info": _2, "net": _2, "org": _2, "sc": _2, "de": _3 }], "lt": _36, "lu": [1, { "blogspot": _3, "123website": _3 }], "lv": [1, { "com": _2, "edu": _2, "gov": _2, "org": _2, "mil": _2, "id": _2, "net": _2, "asn": _2, "conf": _2 }], "ly": [1, { "com": _2, "net": _2, "gov": _2, "plc": _2, "edu": _2, "sch": _2, "med": _2, "org": _2, "id": _2 }], "ma": [1, { "co": _2, "net": _2, "gov": _2, "org": _2, "ac": _2, "press": _2 }], "mc": [1, { "tm": _2, "asso": _2 }], "md": [1, { "blogspot": _3, "at": _3, "de": _3, "jp": _3, "to": _3 }], "me": [1, { "co": _2, "net": _2, "org": _2, "edu": _2, "ac": _2, "gov": _2, "its": _2, "priv": _2, "c66": _3, "daplie": [2, { "localhost": _3 }], "edgestack": _3, "filegear": _3, "filegear-au": _3, "filegear-de": _3, "filegear-gb": _3, "filegear-ie": _3, "filegear-jp": _3, "filegear-sg": _3, "glitch": _3, "ravendb": _3, "lohmus": _3, "barsy": _3, "mcpe": _3, "mcdir": _3, "soundcast": _3, "tcp4": _3, "brasilia": _3, "ddns": _3, "dnsfor": _3, "hopto": _3, "loginto": _3, "noip": _3, "webhop": _3, "vp4": _3, "diskstation": _3, "dscloud": _3, "i234": _3, "myds": _3, "synology": _3, "transip": _25, "wedeploy": _3, "yombo": _3, "nohost": _3 }], "mg": [1, { "org": _2, "nom": _2, "gov": _2, "prd": _2, "tm": _2, "edu": _2, "mil": _2, "com": _2, "co": _2 }], "mh": _2, "mil": _2, "mk": [1, { "com": _2, "org": _2, "net": _2, "edu": _2, "gov": _2, "inf": _2, "name": _2, "blogspot": _3 }], "ml": [1, { "com": _2, "edu": _2, "gouv": _2, "gov": _2, "net": _2, "org": _2, "presse": _2 }], "mm": _8, "mn": [1, { "gov": _2, "edu": _2, "org": _2, "nyc": _3 }], "mo": _4, "mobi": [1, { "barsy": _3, "dscloud": _3 }], "mp": [1, { "ju": _3 }], "mq": _2, "mr": _36, "ms": [1, { "com": _2, "edu": _2, "gov": _2, "net": _2, "org": _2, "lab": _3, "minisite": _3 }], "mt": [1, { "com": _6, "edu": _2, "net": _2, "org": _2 }], "mu": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "ac": _2, "co": _2, "or": _2 }], "museum": _2, "mv": [1, { "aero": _2, "biz": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "museum": _2, "name": _2, "net": _2, "org": _2, "pro": _2 }], "mw": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "coop": _2, "edu": _2, "gov": _2, "int": _2, "museum": _2, "net": _2, "org": _2 }], "mx": [1, { "com": _2, "org": _2, "gob": _2, "edu": _2, "net": _2, "blogspot": _3 }], "my": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "blogspot": _3 }], "mz": [1, { "ac": _2, "adv": _2, "co": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "na": [1, { "info": _2, "pro": _2, "name": _2, "school": _2, "or": _2, "dr": _2, "us": _2, "mx": _2, "ca": _2, "in": _2, "cc": _2, "tv": _2, "ws": _2, "mobi": _2, "co": _2, "com": _2, "org": _2 }], "name": [1, { "her": _39, "his": _39 }], "nc": [1, { "asso": _2, "nom": _2 }], "ne": _2, "net": [1, { "adobeaemcloud": _3, "adobeio-static": _3, "adobeioruntime": _3, "akadns": _3, "akamai": _3, "akamai-staging": _3, "akamaiedge": _3, "akamaiedge-staging": _3, "akamaihd": _3, "akamaihd-staging": _3, "akamaiorigin": _3, "akamaiorigin-staging": _3, "akamaized": _3, "akamaized-staging": _3, "edgekey": _3, "edgekey-staging": _3, "edgesuite": _3, "edgesuite-staging": _3, "alwaysdata": _3, "myamaze": _3, "cloudfront": _3, "t3l3p0rt": _3, "appudo": _3, "atlassian-dev": [0, { "prod": [0, { "cdn": _3 }] }], "myfritz": _3, "onavstack": _3, "shopselect": _3, "blackbaudcdn": _3, "boomla": _3, "bplaced": _3, "square7": _3, "gb": _3, "hu": _3, "jp": _3, "se": _3, "uk": _3, "in": _3, "clickrising": _3, "cloudaccess": _3, "cdn77-ssl": _3, "cdn77": [0, { "r": _3 }], "feste-ip": _3, "knx-server": _3, "static-access": _3, "cryptonomic": _5, "dattolocal": _3, "mydatto": _3, "debian": _3, "bitbridge": _3, "at-band-camp": _3, "blogdns": _3, "broke-it": _3, "buyshouses": _3, "dnsalias": _3, "dnsdojo": _3, "does-it": _3, "dontexist": _3, "dynalias": _3, "dynathome": _3, "endofinternet": _3, "from-az": _3, "from-co": _3, "from-la": _3, "from-ny": _3, "gets-it": _3, "ham-radio-op": _3, "homeftp": _3, "homeip": _3, "homelinux": _3, "homeunix": _3, "in-the-band": _3, "is-a-chef": _3, "is-a-geek": _3, "isa-geek": _3, "kicks-ass": _3, "office-on-the": _3, "podzone": _3, "scrapper-site": _3, "selfip": _3, "sells-it": _3, "servebbs": _3, "serveftp": _3, "thruhere": _3, "webhop": _3, "definima": _3, "casacam": _3, "dynu": _3, "dynv6": _3, "twmail": _3, "ru": _3, "channelsdvr": [2, { "u": _3 }], "fastlylb": [2, { "map": _3 }], "fastly": [0, { "freetls": _3, "map": _3, "prod": [0, { "a": _3, "global": _3 }], "ssl": [0, { "a": _3, "b": _3, "global": _3 }] }], "edgeapp": _3, "flynnhosting": _3, "cdn-edges": _3, "heteml": _3, "cloudfunctions": _3, "moonscale": _3, "in-dsl": _3, "in-vpn": _3, "ipifony": _3, "iobb": _3, "cloudjiffy": [2, { "fra1-de": _3, "west1-us": _3 }], "elastx": [0, { "jls-sto1": _3, "jls-sto2": _3, "jls-sto3": _3 }], "faststacks": _3, "massivegrid": [0, { "paas": [0, { "fr-1": _3, "lon-1": _3, "lon-2": _3, "ny-1": _3, "ny-2": _3, "sg-1": _3 }] }], "saveincloud": [0, { "jelastic": _3, "nordeste-idc": _3 }], "scaleforce": _28, "tsukaeru": _29, "kinghost": _3, "uni5": _3, "krellian": _3, "barsy": _3, "memset": _3, "azurewebsites": _3, "azure-mobile": _3, "cloudapp": _3, "azurestaticapps": [2, { "1": _3, "2": _3, "3": _3, "centralus": _3, "eastasia": _3, "eastus2": _3, "westeurope": _3, "westus2": _3 }], "dnsup": _3, "hicam": _3, "now-dns": _3, "ownip": _3, "vpndns": _3, "eating-organic": _3, "mydissent": _3, "myeffect": _3, "mymediapc": _3, "mypsx": _3, "mysecuritycamera": _3, "nhlfan": _3, "no-ip": _3, "pgafan": _3, "privatizehealthinsurance": _3, "bounceme": _3, "ddns": _3, "redirectme": _3, "serveblog": _3, "serveminecraft": _3, "sytes": _3, "cloudycluster": _3, "ovh": [0, { "webpaas": _5, "hosting": _5 }], "bar0": _3, "bar1": _3, "bar2": _3, "rackmaze": _3, "squares": _3, "schokokeks": _3, "firewall-gateway": _3, "seidat": _3, "senseering": _3, "siteleaf": _3, "vps-host": [2, { "jelastic": [0, { "atl": _3, "njs": _3, "ric": _3 }] }], "myspreadshop": _3, "srcf": [0, { "soc": _3, "user": _3 }], "supabase": _3, "dsmynas": _3, "familyds": _3, "tailscale": [0, { "beta": _3 }], "ts": _3, "torproject": [2, { "pages": _3 }], "reserve-online": _3, "community-pro": _3, "meinforum": _3, "yandexcloud": [2, { "storage": _3, "website": _3 }], "za": _3 }], "nf": [1, { "com": _2, "net": _2, "per": _2, "rec": _2, "web": _2, "arts": _2, "firm": _2, "info": _2, "other": _2, "store": _2 }], "ng": [1, { "com": _6, "edu": _2, "gov": _2, "i": _2, "mil": _2, "mobi": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "col": _3, "firm": _3, "gen": _3, "ltd": _3, "ngo": _3 }], "ni": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gob": _2, "in": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "web": _2 }], "nl": [1, { "co": _3, "hosting-cluster": _3, "blogspot": _3, "gov": _3, "khplay": _3, "123website": _3, "myspreadshop": _3, "transurl": _5, "cistron": _3, "demon": _3 }], "no": [1, { "fhs": _2, "vgs": _2, "fylkesbibl": _2, "folkebibl": _2, "museum": _2, "idrett": _2, "priv": _2, "mil": _2, "stat": _2, "dep": _2, "kommune": _2, "herad": _2, "aa": _40, "ah": _40, "bu": _40, "fm": _40, "hl": _40, "hm": _40, "jan-mayen": _40, "mr": _40, "nl": _40, "nt": _40, "of": _40, "ol": _40, "oslo": _40, "rl": _40, "sf": _40, "st": _40, "svalbard": _40, "tm": _40, "tr": _40, "va": _40, "vf": _40, "akrehamn": _2, "xn--krehamn-dxa": _2, "krehamn": _2, "algard": _2, "xn--lgrd-poac": _2, "lgrd": _2, "arna": _2, "brumunddal": _2, "bryne": _2, "bronnoysund": _2, "xn--brnnysund-m8ac": _2, "brnnysund": _2, "drobak": _2, "xn--drbak-wua": _2, "drbak": _2, "egersund": _2, "fetsund": _2, "floro": _2, "xn--flor-jra": _2, "flor": _2, "fredrikstad": _2, "hokksund": _2, "honefoss": _2, "xn--hnefoss-q1a": _2, "hnefoss": _2, "jessheim": _2, "jorpeland": _2, "xn--jrpeland-54a": _2, "jrpeland": _2, "kirkenes": _2, "kopervik": _2, "krokstadelva": _2, "langevag": _2, "xn--langevg-jxa": _2, "langevg": _2, "leirvik": _2, "mjondalen": _2, "xn--mjndalen-64a": _2, "mjndalen": _2, "mo-i-rana": _2, "mosjoen": _2, "xn--mosjen-eya": _2, "mosjen": _2, "nesoddtangen": _2, "orkanger": _2, "osoyro": _2, "xn--osyro-wua": _2, "osyro": _2, "raholt": _2, "xn--rholt-mra": _2, "rholt": _2, "sandnessjoen": _2, "xn--sandnessjen-ogb": _2, "sandnessjen": _2, "skedsmokorset": _2, "slattum": _2, "spjelkavik": _2, "stathelle": _2, "stavern": _2, "stjordalshalsen": _2, "xn--stjrdalshalsen-sqb": _2, "stjrdalshalsen": _2, "tananger": _2, "tranby": _2, "vossevangen": _2, "afjord": _2, "xn--fjord-lra": _2, "fjord": _2, "agdenes": _2, "al": _2, "xn--l-1fa": _2, "l": _2, "alesund": _2, "xn--lesund-hua": _2, "lesund": _2, "alstahaug": _2, "alta": _2, "xn--lt-liac": _2, "lt": _2, "alaheadju": _2, "xn--laheadju-7ya": _2, "laheadju": _2, "alvdal": _2, "amli": _2, "xn--mli-tla": _2, "mli": _2, "amot": _2, "xn--mot-tla": _2, "mot": _2, "andebu": _2, "andoy": _2, "xn--andy-ira": _2, "andy": _2, "andasuolo": _2, "ardal": _2, "xn--rdal-poa": _2, "rdal": _2, "aremark": _2, "arendal": _2, "xn--s-1fa": _2, "s": _2, "aseral": _2, "xn--seral-lra": _2, "seral": _2, "asker": _2, "askim": _2, "askvoll": _2, "askoy": _2, "xn--asky-ira": _2, "asky": _2, "asnes": _2, "xn--snes-poa": _2, "snes": _2, "audnedaln": _2, "aukra": _2, "aure": _2, "aurland": _2, "aurskog-holand": _2, "xn--aurskog-hland-jnb": _2, "aurskog-hland": _2, "austevoll": _2, "austrheim": _2, "averoy": _2, "xn--avery-yua": _2, "avery": _2, "balestrand": _2, "ballangen": _2, "balat": _2, "xn--blt-elab": _2, "blt": _2, "balsfjord": _2, "bahccavuotna": _2, "xn--bhccavuotna-k7a": _2, "bhccavuotna": _2, "bamble": _2, "bardu": _2, "beardu": _2, "beiarn": _2, "bajddar": _2, "xn--bjddar-pta": _2, "bjddar": _2, "baidar": _2, "xn--bidr-5nac": _2, "bidr": _2, "berg": _2, "bergen": _2, "berlevag": _2, "xn--berlevg-jxa": _2, "berlevg": _2, "bearalvahki": _2, "xn--bearalvhki-y4a": _2, "bearalvhki": _2, "bindal": _2, "birkenes": _2, "bjarkoy": _2, "xn--bjarky-fya": _2, "bjarky": _2, "bjerkreim": _2, "bjugn": _2, "bodo": _2, "xn--bod-2na": _2, "bod": _2, "badaddja": _2, "xn--bdddj-mrabd": _2, "bdddj": _2, "budejju": _2, "bokn": _2, "bremanger": _2, "bronnoy": _2, "xn--brnny-wuac": _2, "brnny": _2, "bygland": _2, "bykle": _2, "barum": _2, "xn--brum-voa": _2, "brum": _2, "telemark": [0, { "bo": _2, "xn--b-5ga": _2, "b": _2 }], "nordland": [0, { "bo": _2, "xn--b-5ga": _2, "b": _2, "heroy": _2, "xn--hery-ira": _2, "hery": _2 }], "bievat": _2, "xn--bievt-0qa": _2, "bievt": _2, "bomlo": _2, "xn--bmlo-gra": _2, "bmlo": _2, "batsfjord": _2, "xn--btsfjord-9za": _2, "btsfjord": _2, "bahcavuotna": _2, "xn--bhcavuotna-s4a": _2, "bhcavuotna": _2, "dovre": _2, "drammen": _2, "drangedal": _2, "dyroy": _2, "xn--dyry-ira": _2, "dyry": _2, "donna": _2, "xn--dnna-gra": _2, "dnna": _2, "eid": _2, "eidfjord": _2, "eidsberg": _2, "eidskog": _2, "eidsvoll": _2, "eigersund": _2, "elverum": _2, "enebakk": _2, "engerdal": _2, "etne": _2, "etnedal": _2, "evenes": _2, "evenassi": _2, "xn--eveni-0qa01ga": _2, "eveni": _2, "evje-og-hornnes": _2, "farsund": _2, "fauske": _2, "fuossko": _2, "fuoisku": _2, "fedje": _2, "fet": _2, "finnoy": _2, "xn--finny-yua": _2, "finny": _2, "fitjar": _2, "fjaler": _2, "fjell": _2, "flakstad": _2, "flatanger": _2, "flekkefjord": _2, "flesberg": _2, "flora": _2, "fla": _2, "xn--fl-zia": _2, "fl": _2, "folldal": _2, "forsand": _2, "fosnes": _2, "frei": _2, "frogn": _2, "froland": _2, "frosta": _2, "frana": _2, "xn--frna-woa": _2, "frna": _2, "froya": _2, "xn--frya-hra": _2, "frya": _2, "fusa": _2, "fyresdal": _2, "forde": _2, "xn--frde-gra": _2, "frde": _2, "gamvik": _2, "gangaviika": _2, "xn--ggaviika-8ya47h": _2, "ggaviika": _2, "gaular": _2, "gausdal": _2, "gildeskal": _2, "xn--gildeskl-g0a": _2, "gildeskl": _2, "giske": _2, "gjemnes": _2, "gjerdrum": _2, "gjerstad": _2, "gjesdal": _2, "gjovik": _2, "xn--gjvik-wua": _2, "gjvik": _2, "gloppen": _2, "gol": _2, "gran": _2, "grane": _2, "granvin": _2, "gratangen": _2, "grimstad": _2, "grong": _2, "kraanghke": _2, "xn--kranghke-b0a": _2, "kranghke": _2, "grue": _2, "gulen": _2, "hadsel": _2, "halden": _2, "halsa": _2, "hamar": _2, "hamaroy": _2, "habmer": _2, "xn--hbmer-xqa": _2, "hbmer": _2, "hapmir": _2, "xn--hpmir-xqa": _2, "hpmir": _2, "hammerfest": _2, "hammarfeasta": _2, "xn--hmmrfeasta-s4ac": _2, "hmmrfeasta": _2, "haram": _2, "hareid": _2, "harstad": _2, "hasvik": _2, "aknoluokta": _2, "xn--koluokta-7ya57h": _2, "koluokta": _2, "hattfjelldal": _2, "aarborte": _2, "haugesund": _2, "hemne": _2, "hemnes": _2, "hemsedal": _2, "more-og-romsdal": [0, { "heroy": _2, "sande": _2 }], "xn--mre-og-romsdal-qqb": [0, { "xn--hery-ira": _2, "sande": _2 }], "mre-og-romsdal": [0, { "hery": _2, "sande": _2 }], "hitra": _2, "hjartdal": _2, "hjelmeland": _2, "hobol": _2, "xn--hobl-ira": _2, "hobl": _2, "hof": _2, "hol": _2, "hole": _2, "holmestrand": _2, "holtalen": _2, "xn--holtlen-hxa": _2, "holtlen": _2, "hornindal": _2, "horten": _2, "hurdal": _2, "hurum": _2, "hvaler": _2, "hyllestad": _2, "hagebostad": _2, "xn--hgebostad-g3a": _2, "hgebostad": _2, "hoyanger": _2, "xn--hyanger-q1a": _2, "hyanger": _2, "hoylandet": _2, "xn--hylandet-54a": _2, "hylandet": _2, "ha": _2, "xn--h-2fa": _2, "h": _2, "ibestad": _2, "inderoy": _2, "xn--indery-fya": _2, "indery": _2, "iveland": _2, "jevnaker": _2, "jondal": _2, "jolster": _2, "xn--jlster-bya": _2, "jlster": _2, "karasjok": _2, "karasjohka": _2, "xn--krjohka-hwab49j": _2, "krjohka": _2, "karlsoy": _2, "galsa": _2, "xn--gls-elac": _2, "gls": _2, "karmoy": _2, "xn--karmy-yua": _2, "karmy": _2, "kautokeino": _2, "guovdageaidnu": _2, "klepp": _2, "klabu": _2, "xn--klbu-woa": _2, "klbu": _2, "kongsberg": _2, "kongsvinger": _2, "kragero": _2, "xn--krager-gya": _2, "krager": _2, "kristiansand": _2, "kristiansund": _2, "krodsherad": _2, "xn--krdsherad-m8a": _2, "krdsherad": _2, "kvalsund": _2, "rahkkeravju": _2, "xn--rhkkervju-01af": _2, "rhkkervju": _2, "kvam": _2, "kvinesdal": _2, "kvinnherad": _2, "kviteseid": _2, "kvitsoy": _2, "xn--kvitsy-fya": _2, "kvitsy": _2, "kvafjord": _2, "xn--kvfjord-nxa": _2, "kvfjord": _2, "giehtavuoatna": _2, "kvanangen": _2, "xn--kvnangen-k0a": _2, "kvnangen": _2, "navuotna": _2, "xn--nvuotna-hwa": _2, "nvuotna": _2, "kafjord": _2, "xn--kfjord-iua": _2, "kfjord": _2, "gaivuotna": _2, "xn--givuotna-8ya": _2, "givuotna": _2, "larvik": _2, "lavangen": _2, "lavagis": _2, "loabat": _2, "xn--loabt-0qa": _2, "loabt": _2, "lebesby": _2, "davvesiida": _2, "leikanger": _2, "leirfjord": _2, "leka": _2, "leksvik": _2, "lenvik": _2, "leangaviika": _2, "xn--leagaviika-52b": _2, "leagaviika": _2, "lesja": _2, "levanger": _2, "lier": _2, "lierne": _2, "lillehammer": _2, "lillesand": _2, "lindesnes": _2, "lindas": _2, "xn--linds-pra": _2, "linds": _2, "lom": _2, "loppa": _2, "lahppi": _2, "xn--lhppi-xqa": _2, "lhppi": _2, "lund": _2, "lunner": _2, "luroy": _2, "xn--lury-ira": _2, "lury": _2, "luster": _2, "lyngdal": _2, "lyngen": _2, "ivgu": _2, "lardal": _2, "lerdal": _2, "xn--lrdal-sra": _2, "lrdal": _2, "lodingen": _2, "xn--ldingen-q1a": _2, "ldingen": _2, "lorenskog": _2, "xn--lrenskog-54a": _2, "lrenskog": _2, "loten": _2, "xn--lten-gra": _2, "lten": _2, "malvik": _2, "masoy": _2, "xn--msy-ula0h": _2, "msy": _2, "muosat": _2, "xn--muost-0qa": _2, "muost": _2, "mandal": _2, "marker": _2, "marnardal": _2, "masfjorden": _2, "meland": _2, "meldal": _2, "melhus": _2, "meloy": _2, "xn--mely-ira": _2, "mely": _2, "meraker": _2, "xn--merker-kua": _2, "merker": _2, "moareke": _2, "xn--moreke-jua": _2, "moreke": _2, "midsund": _2, "midtre-gauldal": _2, "modalen": _2, "modum": _2, "molde": _2, "moskenes": _2, "moss": _2, "mosvik": _2, "malselv": _2, "xn--mlselv-iua": _2, "mlselv": _2, "malatvuopmi": _2, "xn--mlatvuopmi-s4a": _2, "mlatvuopmi": _2, "namdalseid": _2, "aejrie": _2, "namsos": _2, "namsskogan": _2, "naamesjevuemie": _2, "xn--nmesjevuemie-tcba": _2, "nmesjevuemie": _2, "laakesvuemie": _2, "nannestad": _2, "narvik": _2, "narviika": _2, "naustdal": _2, "nedre-eiker": _2, "akershus": _41, "buskerud": _41, "nesna": _2, "nesodden": _2, "nesseby": _2, "unjarga": _2, "xn--unjrga-rta": _2, "unjrga": _2, "nesset": _2, "nissedal": _2, "nittedal": _2, "nord-aurdal": _2, "nord-fron": _2, "nord-odal": _2, "norddal": _2, "nordkapp": _2, "davvenjarga": _2, "xn--davvenjrga-y4a": _2, "davvenjrga": _2, "nordre-land": _2, "nordreisa": _2, "raisa": _2, "xn--risa-5na": _2, "risa": _2, "nore-og-uvdal": _2, "notodden": _2, "naroy": _2, "xn--nry-yla5g": _2, "nry": _2, "notteroy": _2, "xn--nttery-byae": _2, "nttery": _2, "odda": _2, "oksnes": _2, "xn--ksnes-uua": _2, "ksnes": _2, "oppdal": _2, "oppegard": _2, "xn--oppegrd-ixa": _2, "oppegrd": _2, "orkdal": _2, "orland": _2, "xn--rland-uua": _2, "rland": _2, "orskog": _2, "xn--rskog-uua": _2, "rskog": _2, "orsta": _2, "xn--rsta-fra": _2, "rsta": _2, "hedmark": [0, { "os": _2, "valer": _2, "xn--vler-qoa": _2, "vler": _2 }], "hordaland": [0, { "os": _2 }], "osen": _2, "osteroy": _2, "xn--ostery-fya": _2, "ostery": _2, "ostre-toten": _2, "xn--stre-toten-zcb": _2, "stre-toten": _2, "overhalla": _2, "ovre-eiker": _2, "xn--vre-eiker-k8a": _2, "vre-eiker": _2, "oyer": _2, "xn--yer-zna": _2, "yer": _2, "oygarden": _2, "xn--ygarden-p1a": _2, "ygarden": _2, "oystre-slidre": _2, "xn--ystre-slidre-ujb": _2, "ystre-slidre": _2, "porsanger": _2, "porsangu": _2, "xn--porsgu-sta26f": _2, "porsgu": _2, "porsgrunn": _2, "radoy": _2, "xn--rady-ira": _2, "rady": _2, "rakkestad": _2, "rana": _2, "ruovat": _2, "randaberg": _2, "rauma": _2, "rendalen": _2, "rennebu": _2, "rennesoy": _2, "xn--rennesy-v1a": _2, "rennesy": _2, "rindal": _2, "ringebu": _2, "ringerike": _2, "ringsaker": _2, "rissa": _2, "risor": _2, "xn--risr-ira": _2, "risr": _2, "roan": _2, "rollag": _2, "rygge": _2, "ralingen": _2, "xn--rlingen-mxa": _2, "rlingen": _2, "rodoy": _2, "xn--rdy-0nab": _2, "rdy": _2, "romskog": _2, "xn--rmskog-bya": _2, "rmskog": _2, "roros": _2, "xn--rros-gra": _2, "rros": _2, "rost": _2, "xn--rst-0na": _2, "rst": _2, "royken": _2, "xn--ryken-vua": _2, "ryken": _2, "royrvik": _2, "xn--ryrvik-bya": _2, "ryrvik": _2, "rade": _2, "xn--rde-ula": _2, "rde": _2, "salangen": _2, "siellak": _2, "saltdal": _2, "salat": _2, "xn--slt-elab": _2, "slt": _2, "xn--slat-5na": _2, "slat": _2, "samnanger": _2, "vestfold": [0, { "sande": _2 }], "sandefjord": _2, "sandnes": _2, "sandoy": _2, "xn--sandy-yua": _2, "sandy": _2, "sarpsborg": _2, "sauda": _2, "sauherad": _2, "sel": _2, "selbu": _2, "selje": _2, "seljord": _2, "sigdal": _2, "siljan": _2, "sirdal": _2, "skaun": _2, "skedsmo": _2, "ski": _2, "skien": _2, "skiptvet": _2, "skjervoy": _2, "xn--skjervy-v1a": _2, "skjervy": _2, "skierva": _2, "xn--skierv-uta": _2, "skierv": _2, "skjak": _2, "xn--skjk-soa": _2, "skjk": _2, "skodje": _2, "skanland": _2, "xn--sknland-fxa": _2, "sknland": _2, "skanit": _2, "xn--sknit-yqa": _2, "sknit": _2, "smola": _2, "xn--smla-hra": _2, "smla": _2, "snillfjord": _2, "snasa": _2, "xn--snsa-roa": _2, "snsa": _2, "snoasa": _2, "snaase": _2, "xn--snase-nra": _2, "snase": _2, "sogndal": _2, "sokndal": _2, "sola": _2, "solund": _2, "songdalen": _2, "sortland": _2, "spydeberg": _2, "stange": _2, "stavanger": _2, "steigen": _2, "steinkjer": _2, "stjordal": _2, "xn--stjrdal-s1a": _2, "stjrdal": _2, "stokke": _2, "stor-elvdal": _2, "stord": _2, "stordal": _2, "storfjord": _2, "omasvuotna": _2, "strand": _2, "stranda": _2, "stryn": _2, "sula": _2, "suldal": _2, "sund": _2, "sunndal": _2, "surnadal": _2, "sveio": _2, "svelvik": _2, "sykkylven": _2, "sogne": _2, "xn--sgne-gra": _2, "sgne": _2, "somna": _2, "xn--smna-gra": _2, "smna": _2, "sondre-land": _2, "xn--sndre-land-0cb": _2, "sndre-land": _2, "sor-aurdal": _2, "xn--sr-aurdal-l8a": _2, "sr-aurdal": _2, "sor-fron": _2, "xn--sr-fron-q1a": _2, "sr-fron": _2, "sor-odal": _2, "xn--sr-odal-q1a": _2, "sr-odal": _2, "sor-varanger": _2, "xn--sr-varanger-ggb": _2, "sr-varanger": _2, "matta-varjjat": _2, "xn--mtta-vrjjat-k7af": _2, "mtta-vrjjat": _2, "sorfold": _2, "xn--srfold-bya": _2, "srfold": _2, "sorreisa": _2, "xn--srreisa-q1a": _2, "srreisa": _2, "sorum": _2, "xn--srum-gra": _2, "srum": _2, "tana": _2, "deatnu": _2, "time": _2, "tingvoll": _2, "tinn": _2, "tjeldsund": _2, "dielddanuorri": _2, "tjome": _2, "xn--tjme-hra": _2, "tjme": _2, "tokke": _2, "tolga": _2, "torsken": _2, "tranoy": _2, "xn--trany-yua": _2, "trany": _2, "tromso": _2, "xn--troms-zua": _2, "troms": _2, "tromsa": _2, "romsa": _2, "trondheim": _2, "troandin": _2, "trysil": _2, "trana": _2, "xn--trna-woa": _2, "trna": _2, "trogstad": _2, "xn--trgstad-r1a": _2, "trgstad": _2, "tvedestrand": _2, "tydal": _2, "tynset": _2, "tysfjord": _2, "divtasvuodna": _2, "divttasvuotna": _2, "tysnes": _2, "tysvar": _2, "xn--tysvr-vra": _2, "tysvr": _2, "tonsberg": _2, "xn--tnsberg-q1a": _2, "tnsberg": _2, "ullensaker": _2, "ullensvang": _2, "ulvik": _2, "utsira": _2, "vadso": _2, "xn--vads-jra": _2, "vads": _2, "cahcesuolo": _2, "xn--hcesuolo-7ya35b": _2, "hcesuolo": _2, "vaksdal": _2, "valle": _2, "vang": _2, "vanylven": _2, "vardo": _2, "xn--vard-jra": _2, "vard": _2, "varggat": _2, "xn--vrggt-xqad": _2, "vrggt": _2, "vefsn": _2, "vaapste": _2, "vega": _2, "vegarshei": _2, "xn--vegrshei-c0a": _2, "vegrshei": _2, "vennesla": _2, "verdal": _2, "verran": _2, "vestby": _2, "vestnes": _2, "vestre-slidre": _2, "vestre-toten": _2, "vestvagoy": _2, "xn--vestvgy-ixa6o": _2, "vestvgy": _2, "vevelstad": _2, "vik": _2, "vikna": _2, "vindafjord": _2, "volda": _2, "voss": _2, "varoy": _2, "xn--vry-yla5g": _2, "vry": _2, "vagan": _2, "xn--vgan-qoa": _2, "vgan": _2, "voagat": _2, "vagsoy": _2, "xn--vgsy-qoa0j": _2, "vgsy": _2, "vaga": _2, "xn--vg-yiab": _2, "vg": _2, "ostfold": [0, { "valer": _2 }], "xn--stfold-9xa": [0, { "xn--vler-qoa": _2 }], "stfold": [0, { "vler": _2 }], "co": _3, "blogspot": _3, "123hjemmeside": _3, "myspreadshop": _3 }], "np": _8, "nr": _35, "nu": [1, { "merseine": _3, "mine": _3, "shacknet": _3, "enterprisecloud": _3 }], "nz": [1, { "ac": _2, "co": _6, "cri": _2, "geek": _2, "gen": _2, "govt": _2, "health": _2, "iwi": _2, "kiwi": _2, "maori": _2, "mil": _2, "xn--mori-qsa": _2, "mori": _2, "net": _2, "org": _2, "parliament": _2, "school": _2 }], "om": [1, { "co": _2, "com": _2, "edu": _2, "gov": _2, "med": _2, "museum": _2, "net": _2, "org": _2, "pro": _2 }], "onion": _2, "org": [1, { "altervista": _3, "amune": [0, { "tele": _3 }], "pimienta": _3, "poivron": _3, "potager": _3, "sweetpepper": _3, "ae": _3, "us": _3, "certmgr": _3, "cdn77": [0, { "c": _3, "rsc": _3 }], "cdn77-secure": [0, { "origin": [0, { "ssl": _3 }] }], "cloudns": _3, "duckdns": _3, "tunk": _3, "dyndns": [2, { "go": _3, "home": _3 }], "blogdns": _3, "blogsite": _3, "boldlygoingnowhere": _3, "dnsalias": _3, "dnsdojo": _3, "doesntexist": _3, "dontexist": _3, "doomdns": _3, "dvrdns": _3, "dynalias": _3, "endofinternet": _3, "endoftheinternet": _3, "from-me": _3, "game-host": _3, "gotdns": _3, "hobby-site": _3, "homedns": _3, "homeftp": _3, "homelinux": _3, "homeunix": _3, "is-a-bruinsfan": _3, "is-a-candidate": _3, "is-a-celticsfan": _3, "is-a-chef": _3, "is-a-geek": _3, "is-a-knight": _3, "is-a-linux-user": _3, "is-a-patsfan": _3, "is-a-soxfan": _3, "is-found": _3, "is-lost": _3, "is-saved": _3, "is-very-bad": _3, "is-very-evil": _3, "is-very-good": _3, "is-very-nice": _3, "is-very-sweet": _3, "isa-geek": _3, "kicks-ass": _3, "misconfused": _3, "podzone": _3, "readmyblog": _3, "selfip": _3, "sellsyourhome": _3, "servebbs": _3, "serveftp": _3, "servegame": _3, "stuff-4-sale": _3, "webhop": _3, "ddnss": _3, "accesscam": _3, "camdvr": _3, "freeddns": _3, "mywire": _3, "webredirect": _3, "eu": [2, { "al": _3, "asso": _3, "at": _3, "au": _3, "be": _3, "bg": _3, "ca": _3, "cd": _3, "ch": _3, "cn": _3, "cy": _3, "cz": _3, "de": _3, "dk": _3, "edu": _3, "ee": _3, "es": _3, "fi": _3, "fr": _3, "gr": _3, "hr": _3, "hu": _3, "ie": _3, "il": _3, "in": _3, "int": _3, "is": _3, "it": _3, "jp": _3, "kr": _3, "lt": _3, "lu": _3, "lv": _3, "mc": _3, "me": _3, "mk": _3, "mt": _3, "my": _3, "net": _3, "ng": _3, "nl": _3, "no": _3, "nz": _3, "paris": _3, "pl": _3, "pt": _3, "q-a": _3, "ro": _3, "ru": _3, "se": _3, "si": _3, "sk": _3, "tr": _3, "uk": _3, "us": _3 }], "twmail": _3, "fedorainfracloud": _3, "fedorapeople": _3, "fedoraproject": [0, { "cloud": _3, "os": _23, "stg": [0, { "os": _23 }] }], "freedesktop": _3, "hepforge": _3, "in-dsl": _3, "in-vpn": _3, "js": _3, "barsy": _3, "mayfirst": _3, "mozilla-iot": _3, "bmoattachments": _3, "dynserv": _3, "now-dns": _3, "cable-modem": _3, "collegefan": _3, "couchpotatofries": _3, "mlbfan": _3, "mysecuritycamera": _3, "nflfan": _3, "read-books": _3, "ufcfan": _3, "hopto": _3, "myftp": _3, "no-ip": _3, "zapto": _3, "httpbin": _3, "pubtls": _3, "jpn": _3, "my-firewall": _3, "myfirewall": _3, "spdns": _3, "small-web": _3, "dsmynas": _3, "familyds": _3, "teckids": _12, "tuxfamily": _3, "diskstation": _3, "hk": _3, "wmflabs": _3, "toolforge": _3, "wmcloud": _3, "za": _3 }], "pa": [1, { "ac": _2, "gob": _2, "com": _2, "org": _2, "sld": _2, "edu": _2, "net": _2, "ing": _2, "abo": _2, "med": _2, "nom": _2 }], "pe": [1, { "edu": _2, "gob": _2, "nom": _2, "mil": _2, "org": _2, "com": _2, "net": _2, "blogspot": _3 }], "pf": [1, { "com": _2, "org": _2, "edu": _2 }], "pg": _8, "ph": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "ngo": _2, "mil": _2, "i": _2 }], "pk": [1, { "com": _2, "net": _2, "edu": _2, "org": _2, "fam": _2, "biz": _2, "web": _2, "gov": _2, "gob": _2, "gok": _2, "gon": _2, "gop": _2, "gos": _2, "info": _2 }], "pl": [1, { "com": _2, "net": _2, "org": _2, "aid": _2, "agro": _2, "atm": _2, "auto": _2, "biz": _2, "edu": _2, "gmina": _2, "gsm": _2, "info": _2, "mail": _2, "miasta": _2, "media": _2, "mil": _2, "nieruchomosci": _2, "nom": _2, "pc": _2, "powiat": _2, "priv": _2, "realestate": _2, "rel": _2, "sex": _2, "shop": _2, "sklep": _2, "sos": _2, "szkola": _2, "targi": _2, "tm": _2, "tourism": _2, "travel": _2, "turystyka": _2, "gov": [1, { "ap": _2, "griw": _2, "ic": _2, "is": _2, "kmpsp": _2, "konsulat": _2, "kppsp": _2, "kwp": _2, "kwpsp": _2, "mup": _2, "mw": _2, "oia": _2, "oirm": _2, "oke": _2, "oow": _2, "oschr": _2, "oum": _2, "pa": _2, "pinb": _2, "piw": _2, "po": _2, "pr": _2, "psp": _2, "psse": _2, "pup": _2, "rzgw": _2, "sa": _2, "sdn": _2, "sko": _2, "so": _2, "sr": _2, "starostwo": _2, "ug": _2, "ugim": _2, "um": _2, "umig": _2, "upow": _2, "uppo": _2, "us": _2, "uw": _2, "uzs": _2, "wif": _2, "wiih": _2, "winb": _2, "wios": _2, "witd": _2, "wiw": _2, "wkz": _2, "wsa": _2, "wskr": _2, "wsse": _2, "wuoz": _2, "wzmiuw": _2, "zp": _2, "zpisdn": _2 }], "augustow": _2, "babia-gora": _2, "bedzin": _2, "beskidy": _2, "bialowieza": _2, "bialystok": _2, "bielawa": _2, "bieszczady": _2, "boleslawiec": _2, "bydgoszcz": _2, "bytom": _2, "cieszyn": _2, "czeladz": _2, "czest": _2, "dlugoleka": _2, "elblag": _2, "elk": _2, "glogow": _2, "gniezno": _2, "gorlice": _2, "grajewo": _2, "ilawa": _2, "jaworzno": _2, "jelenia-gora": _2, "jgora": _2, "kalisz": _2, "kazimierz-dolny": _2, "karpacz": _2, "kartuzy": _2, "kaszuby": _2, "katowice": _2, "kepno": _2, "ketrzyn": _2, "klodzko": _2, "kobierzyce": _2, "kolobrzeg": _2, "konin": _2, "konskowola": _2, "kutno": _2, "lapy": _2, "lebork": _2, "legnica": _2, "lezajsk": _2, "limanowa": _2, "lomza": _2, "lowicz": _2, "lubin": _2, "lukow": _2, "malbork": _2, "malopolska": _2, "mazowsze": _2, "mazury": _2, "mielec": _2, "mielno": _2, "mragowo": _2, "naklo": _2, "nowaruda": _2, "nysa": _2, "olawa": _2, "olecko": _2, "olkusz": _2, "olsztyn": _2, "opoczno": _2, "opole": _2, "ostroda": _2, "ostroleka": _2, "ostrowiec": _2, "ostrowwlkp": _2, "pila": _2, "pisz": _2, "podhale": _2, "podlasie": _2, "polkowice": _2, "pomorze": _2, "pomorskie": _2, "prochowice": _2, "pruszkow": _2, "przeworsk": _2, "pulawy": _2, "radom": _2, "rawa-maz": _2, "rybnik": _2, "rzeszow": _2, "sanok": _2, "sejny": _2, "slask": _2, "slupsk": _2, "sosnowiec": _2, "stalowa-wola": _2, "skoczow": _2, "starachowice": _2, "stargard": _2, "suwalki": _2, "swidnica": _2, "swiebodzin": _2, "swinoujscie": _2, "szczecin": _2, "szczytno": _2, "tarnobrzeg": _2, "tgory": _2, "turek": _2, "tychy": _2, "ustka": _2, "walbrzych": _2, "warmia": _2, "warszawa": _2, "waw": _2, "wegrow": _2, "wielun": _2, "wlocl": _2, "wloclawek": _2, "wodzislaw": _2, "wolomin": _2, "wroclaw": _2, "zachpomor": _2, "zagan": _2, "zarow": _2, "zgora": _2, "zgorzelec": _2, "beep": _3, "ecommerce-shop": _3, "shoparena": _3, "homesklep": _3, "sdscloud": _3, "unicloud": _3, "krasnik": _3, "leczna": _3, "lubartow": _3, "lublin": _3, "poniatowa": _3, "swidnik": _3, "co": _3, "simplesite": _3, "art": _3, "gliwice": _3, "krakow": _3, "poznan": _3, "wroc": _3, "zakopane": _3, "myspreadshop": _3, "gda": _3, "gdansk": _3, "gdynia": _3, "med": _3, "sopot": _3 }], "pm": [1, { "own": _3, "name": _3 }], "pn": [1, { "gov": _2, "co": _2, "org": _2, "edu": _2, "net": _2 }], "post": _2, "pr": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "isla": _2, "pro": _2, "biz": _2, "info": _2, "name": _2, "est": _2, "prof": _2, "ac": _2 }], "pro": [1, { "aaa": _2, "aca": _2, "acct": _2, "avocat": _2, "bar": _2, "cpa": _2, "eng": _2, "jur": _2, "law": _2, "med": _2, "recht": _2, "cloudns": _3, "dnstrace": [0, { "bci": _3 }], "barsy": _3 }], "ps": [1, { "edu": _2, "gov": _2, "sec": _2, "plo": _2, "com": _2, "org": _2, "net": _2 }], "pt": [1, { "net": _2, "gov": _2, "org": _2, "edu": _2, "int": _2, "publ": _2, "com": _2, "nome": _2, "blogspot": _3, "123paginaweb": _3 }], "pw": [1, { "co": _2, "ne": _2, "or": _2, "ed": _2, "go": _2, "belau": _2, "cloudns": _3, "x443": _3 }], "py": [1, { "com": _2, "coop": _2, "edu": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "qa": [1, { "com": _2, "edu": _2, "gov": _2, "mil": _2, "name": _2, "net": _2, "org": _2, "sch": _2, "blogspot": _3 }], "re": [1, { "asso": _2, "com": _2, "nom": _2, "blogspot": _3 }], "ro": [1, { "arts": _2, "com": _2, "firm": _2, "info": _2, "nom": _2, "nt": _2, "org": _2, "rec": _2, "store": _2, "tm": _2, "www": _2, "co": _3, "shop": _3, "blogspot": _3, "barsy": _3 }], "rs": [1, { "ac": _2, "co": _2, "edu": _2, "gov": _2, "in": _2, "org": _2, "brendly": [0, { "shop": _3 }], "blogspot": _3, "ua": _3, "ox": _3 }], "ru": [1, { "ac": _3, "edu": _3, "gov": _3, "int": _3, "mil": _3, "test": _3, "eurodir": _3, "adygeya": _3, "bashkiria": _3, "bir": _3, "cbg": _3, "com": _3, "dagestan": _3, "grozny": _3, "kalmykia": _3, "kustanai": _3, "marine": _3, "mordovia": _3, "msk": _3, "mytis": _3, "nalchik": _3, "nov": _3, "pyatigorsk": _3, "spb": _3, "vladikavkaz": _3, "vladimir": _3, "blogspot": _3, "na4u": _3, "mircloud": _3, "regruhosting": _29, "myjino": [2, { "hosting": _5, "landing": _5, "spectrum": _5, "vps": _5 }], "cldmail": [0, { "hb": _3 }], "mcdir": [2, { "vps": _3 }], "mcpre": _3, "net": _3, "org": _3, "pp": _3, "123sait": _3, "lk3": _3, "ras": _3 }], "rw": [1, { "ac": _2, "co": _2, "coop": _2, "gov": _2, "mil": _2, "net": _2, "org": _2 }], "sa": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "med": _2, "pub": _2, "edu": _2, "sch": _2 }], "sb": _4, "sc": _4, "sd": [1, { "com": _2, "net": _2, "org": _2, "edu": _2, "med": _2, "tv": _2, "gov": _2, "info": _2 }], "se": [1, { "a": _2, "ac": _2, "b": _2, "bd": _2, "brand": _2, "c": _2, "d": _2, "e": _2, "f": _2, "fh": _2, "fhsk": _2, "fhv": _2, "g": _2, "h": _2, "i": _2, "k": _2, "komforb": _2, "kommunalforbund": _2, "komvux": _2, "l": _2, "lanbib": _2, "m": _2, "n": _2, "naturbruksgymn": _2, "o": _2, "org": _2, "p": _2, "parti": _2, "pp": _2, "press": _2, "r": _2, "s": _2, "t": _2, "tm": _2, "u": _2, "w": _2, "x": _2, "y": _2, "z": _2, "com": _3, "blogspot": _3, "conf": _3, "iopsys": _3, "123minsida": _3, "itcouldbewor": _3, "myspreadshop": _3, "paba": [0, { "su": _3 }] }], "sg": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "per": _2, "blogspot": _3, "enscaled": _3 }], "sh": [1, { "com": _2, "net": _2, "gov": _2, "org": _2, "mil": _2, "bip": _3, "hashbang": _3, "platform": [0, { "bc": _3, "ent": _3, "eu": _3, "us": _3 }], "now": _3, "vxl": _3, "wedeploy": _3 }], "si": [1, { "gitapp": _3, "gitpage": _3, "blogspot": _3 }], "sj": _2, "sk": _6, "sl": _4, "sm": _2, "sn": [1, { "art": _2, "com": _2, "edu": _2, "gouv": _2, "org": _2, "perso": _2, "univ": _2, "blogspot": _3 }], "so": [1, { "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _3 }], "sr": _2, "ss": [1, { "biz": _2, "com": _2, "edu": _2, "gov": _2, "me": _2, "net": _2, "org": _2, "sch": _2 }], "st": [1, { "co": _2, "com": _2, "consulado": _2, "edu": _2, "embaixada": _2, "mil": _2, "net": _2, "org": _2, "principe": _2, "saotome": _2, "store": _2, "kirara": _3, "noho": _3 }], "su": [1, { "abkhazia": _3, "adygeya": _3, "aktyubinsk": _3, "arkhangelsk": _3, "armenia": _3, "ashgabad": _3, "azerbaijan": _3, "balashov": _3, "bashkiria": _3, "bryansk": _3, "bukhara": _3, "chimkent": _3, "dagestan": _3, "east-kazakhstan": _3, "exnet": _3, "georgia": _3, "grozny": _3, "ivanovo": _3, "jambyl": _3, "kalmykia": _3, "kaluga": _3, "karacol": _3, "karaganda": _3, "karelia": _3, "khakassia": _3, "krasnodar": _3, "kurgan": _3, "kustanai": _3, "lenug": _3, "mangyshlak": _3, "mordovia": _3, "msk": _3, "murmansk": _3, "nalchik": _3, "navoi": _3, "north-kazakhstan": _3, "nov": _3, "obninsk": _3, "penza": _3, "pokrovsk": _3, "sochi": _3, "spb": _3, "tashkent": _3, "termez": _3, "togliatti": _3, "troitsk": _3, "tselinograd": _3, "tula": _3, "tuva": _3, "vladikavkaz": _3, "vladimir": _3, "vologda": _3 }], "sv": [1, { "com": _2, "edu": _2, "gob": _2, "org": _2, "red": _2 }], "sx": _7, "sy": _34, "sz": [1, { "co": _2, "ac": _2, "org": _2 }], "tc": [1, { "ch": _3, "me": _3, "we": _3 }], "td": _6, "tel": _2, "tf": [1, { "sch": _3 }], "tg": _2, "th": [1, { "ac": _2, "co": _2, "go": _2, "in": _2, "mi": _2, "net": _2, "or": _2, "online": _3, "shop": _3 }], "tj": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "go": _2, "gov": _2, "int": _2, "mil": _2, "name": _2, "net": _2, "nic": _2, "org": _2, "test": _2, "web": _2 }], "tk": _2, "tl": _7, "tm": [1, { "com": _2, "co": _2, "org": _2, "net": _2, "nom": _2, "gov": _2, "mil": _2, "edu": _2 }], "tn": [1, { "com": _2, "ens": _2, "fin": _2, "gov": _2, "ind": _2, "info": _2, "intl": _2, "mincom": _2, "nat": _2, "net": _2, "org": _2, "perso": _2, "tourism": _2, "orangecloud": _3 }], "to": [1, { "611": _3, "com": _2, "gov": _2, "net": _2, "org": _2, "edu": _2, "mil": _2, "oya": _3, "rdv": _3, "x0": _3, "vpnplus": _3, "quickconnect": _13, "nyan": _3 }], "tr": [1, { "av": _2, "bbs": _2, "bel": _2, "biz": _2, "com": _6, "dr": _2, "edu": _2, "gen": _2, "gov": _2, "info": _2, "mil": _2, "k12": _2, "kep": _2, "name": _2, "net": _2, "org": _2, "pol": _2, "tel": _2, "tsk": _2, "tv": _2, "web": _2, "nc": _7 }], "tt": [1, { "co": _2, "com": _2, "org": _2, "net": _2, "biz": _2, "info": _2, "pro": _2, "int": _2, "coop": _2, "jobs": _2, "mobi": _2, "travel": _2, "museum": _2, "aero": _2, "name": _2, "gov": _2, "edu": _2 }], "tv": [1, { "dyndns": _3, "better-than": _3, "on-the-web": _3, "worse-than": _3, "from": _3, "sakura": _3 }], "tw": [1, { "edu": _2, "gov": _2, "mil": _2, "com": [1, { "mymailer": _3 }], "net": _2, "org": _2, "idv": _2, "game": _2, "ebiz": _2, "club": _2, "xn--zf0ao64a": _2, "": _2, "xn--uc0atv": _2, "": _2, "xn--czrw28b": _2, "": _2, "url": _3, "blogspot": _3 }], "tz": [1, { "ac": _2, "co": _2, "go": _2, "hotel": _2, "info": _2, "me": _2, "mil": _2, "mobi": _2, "ne": _2, "or": _2, "sc": _2, "tv": _2 }], "ua": [1, { "com": _2, "edu": _2, "gov": _2, "in": _2, "net": _2, "org": _2, "cherkassy": _2, "cherkasy": _2, "chernigov": _2, "chernihiv": _2, "chernivtsi": _2, "chernovtsy": _2, "ck": _2, "cn": _2, "cr": _2, "crimea": _2, "cv": _2, "dn": _2, "dnepropetrovsk": _2, "dnipropetrovsk": _2, "donetsk": _2, "dp": _2, "if": _2, "ivano-frankivsk": _2, "kh": _2, "kharkiv": _2, "kharkov": _2, "kherson": _2, "khmelnitskiy": _2, "khmelnytskyi": _2, "kiev": _2, "kirovograd": _2, "km": _2, "kr": _2, "kropyvnytskyi": _2, "krym": _2, "ks": _2, "kv": _2, "kyiv": _2, "lg": _2, "lt": _2, "lugansk": _2, "luhansk": _2, "lutsk": _2, "lv": _2, "lviv": _2, "mk": _2, "mykolaiv": _2, "nikolaev": _2, "od": _2, "odesa": _2, "odessa": _2, "pl": _2, "poltava": _2, "rivne": _2, "rovno": _2, "rv": _2, "sb": _2, "sebastopol": _2, "sevastopol": _2, "sm": _2, "sumy": _2, "te": _2, "ternopil": _2, "uz": _2, "uzhgorod": _2, "uzhhorod": _2, "vinnica": _2, "vinnytsia": _2, "vn": _2, "volyn": _2, "yalta": _2, "zakarpattia": _2, "zaporizhzhe": _2, "zaporizhzhia": _2, "zhitomir": _2, "zhytomyr": _2, "zp": _2, "zt": _2, "cc": _3, "inf": _3, "ltd": _3, "cx": _3, "ie": _3, "biz": _3, "co": _3, "pp": _3, "v": _3 }], "ug": [1, { "co": _2, "or": _2, "ac": _2, "sc": _2, "go": _2, "ne": _2, "com": _2, "org": _2, "blogspot": _3 }], "uk": [1, { "ac": _2, "co": [1, { "bytemark": [0, { "dh": _3, "vm": _3 }], "blogspot": _3, "layershift": _28, "barsy": _3, "barsyonline": _3, "retrosnub": _33, "nh-serv": _3, "no-ip": _3, "wellbeingzone": _3, "adimo": _3, "myspreadshop": _3 }], "gov": [1, { "campaign": _3, "service": _3, "api": _3, "homeoffice": _3 }], "ltd": _2, "me": _2, "net": _2, "nhs": _2, "org": [1, { "glug": _3, "lug": _3, "lugs": _3, "affinitylottery": _3, "raffleentry": _3, "weeklylottery": _3 }], "plc": _2, "police": _2, "sch": _8, "conn": _3, "copro": _3, "hosp": _3, "independent-commission": _3, "independent-inquest": _3, "independent-inquiry": _3, "independent-panel": _3, "independent-review": _3, "public-inquiry": _3, "royal-commission": _3, "pymnt": _3, "barsy": _3 }], "us": [1, { "dni": _2, "fed": _2, "isa": _2, "kids": _2, "nsn": _2, "ak": _42, "al": _42, "ar": _42, "as": _42, "az": _42, "ca": _42, "co": _42, "ct": _42, "dc": _42, "de": [1, { "cc": _2, "lib": _3 }], "fl": _42, "ga": _42, "gu": _42, "hi": _43, "ia": _42, "id": _42, "il": _42, "in": _42, "ks": _42, "ky": _42, "la": _42, "ma": [1, { "k12": [1, { "pvt": _2, "chtr": _2, "paroch": _2 }], "cc": _2, "lib": _2 }], "md": _42, "me": _42, "mi": [1, { "k12": _2, "cc": _2, "lib": _2, "ann-arbor": _2, "cog": _2, "dst": _2, "eaton": _2, "gen": _2, "mus": _2, "tec": _2, "washtenaw": _2 }], "mn": _42, "mo": _42, "ms": _42, "mt": _42, "nc": _42, "nd": _43, "ne": _42, "nh": _42, "nj": _42, "nm": _42, "nv": _42, "ny": _42, "oh": _42, "ok": _42, "or": _42, "pa": _42, "pr": _42, "ri": _43, "sc": _42, "sd": _43, "tn": _42, "tx": _42, "ut": _42, "vi": _42, "vt": _42, "va": _42, "wa": _42, "wi": _42, "wv": [1, { "cc": _2 }], "wy": _42, "graphox": _3, "cloudns": _3, "drud": _3, "is-by": _3, "land-4-sale": _3, "stuff-4-sale": _3, "enscaled": [0, { "phx": _3 }], "mircloud": _3, "freeddns": _3, "golffan": _3, "noip": _3, "pointto": _3, "platterp": _3 }], "uy": [1, { "com": _6, "edu": _2, "gub": _2, "mil": _2, "net": _2, "org": _2 }], "uz": [1, { "co": _2, "com": _2, "net": _2, "org": _2 }], "va": _2, "vc": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "mil": _2, "edu": _2, "gv": [2, { "d": _3 }], "0e": _3 }], "ve": [1, { "arts": _2, "bib": _2, "co": _2, "com": _2, "e12": _2, "edu": _2, "firm": _2, "gob": _2, "gov": _2, "info": _2, "int": _2, "mil": _2, "net": _2, "nom": _2, "org": _2, "rar": _2, "rec": _2, "store": _2, "tec": _2, "web": _2 }], "vg": [1, { "at": _3 }], "vi": [1, { "co": _2, "com": _2, "k12": _2, "net": _2, "org": _2 }], "vn": [1, { "ac": _2, "ai": _2, "biz": _2, "com": _2, "edu": _2, "gov": _2, "health": _2, "id": _2, "info": _2, "int": _2, "io": _2, "name": _2, "net": _2, "org": _2, "pro": _2, "angiang": _2, "bacgiang": _2, "backan": _2, "baclieu": _2, "bacninh": _2, "baria-vungtau": _2, "bentre": _2, "binhdinh": _2, "binhduong": _2, "binhphuoc": _2, "binhthuan": _2, "camau": _2, "cantho": _2, "caobang": _2, "daklak": _2, "daknong": _2, "danang": _2, "dienbien": _2, "dongnai": _2, "dongthap": _2, "gialai": _2, "hagiang": _2, "haiduong": _2, "haiphong": _2, "hanam": _2, "hanoi": _2, "hatinh": _2, "haugiang": _2, "hoabinh": _2, "hungyen": _2, "khanhhoa": _2, "kiengiang": _2, "kontum": _2, "laichau": _2, "lamdong": _2, "langson": _2, "laocai": _2, "longan": _2, "namdinh": _2, "nghean": _2, "ninhbinh": _2, "ninhthuan": _2, "phutho": _2, "phuyen": _2, "quangbinh": _2, "quangnam": _2, "quangngai": _2, "quangninh": _2, "quangtri": _2, "soctrang": _2, "sonla": _2, "tayninh": _2, "thaibinh": _2, "thainguyen": _2, "thanhhoa": _2, "thanhphohochiminh": _2, "thuathienhue": _2, "tiengiang": _2, "travinh": _2, "tuyenquang": _2, "vinhlong": _2, "vinhphuc": _2, "yenbai": _2, "blogspot": _3 }], "vu": [1, { "com": _2, "edu": _2, "net": _2, "org": _2, "cn": _3, "blog": _3, "dev": _3, "me": _3 }], "wf": [1, { "biz": _3, "sch": _3 }], "ws": [1, { "com": _2, "net": _2, "org": _2, "gov": _2, "edu": _2, "advisor": _5, "cloud66": _3, "dyndns": _3, "mypets": _3 }], "yt": [1, { "org": _3 }], "xn--mgbaam7a8h": _2, "": _2, "xn--y9a3aq": _2, "": _2, "xn--54b7fta0cc": _2, "": _2, "xn--90ae": _2, "": _2, "xn--mgbcpq6gpa1a": _2, "": _2, "xn--90ais": _2, "": _2, "xn--fiqs8s": _2, "": _2, "xn--fiqz9s": _2, "": _2, "xn--lgbbat1ad8j": _2, "": _2, "xn--wgbh1c": _2, "": _2, "xn--e1a4c": _2, "": _2, "xn--qxa6a": _2, "": _2, "xn--mgbah1a3hjkrd": _2, "": _2, "xn--node": _2, "": _2, "xn--qxam": _2, "": _2, "xn--j6w193g": [1, { "xn--55qx5d": _2, "xn--wcvs22d": _2, "xn--mxtq1m": _2, "xn--gmqw5a": _2, "xn--od0alg": _2, "xn--uc0atv": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 }], "xn--2scrj9c": _2, "": _2, "xn--3hcrj9c": _2, "": _2, "xn--45br5cyl": _2, "": _2, "xn--h2breg3eve": _2, "": _2, "xn--h2brj9c8c": _2, "": _2, "xn--mgbgu82a": _2, "": _2, "xn--rvc1e0am3e": _2, "": _2, "xn--h2brj9c": _2, "": _2, "xn--mgbbh1a": _2, "": _2, "xn--mgbbh1a71e": _2, "": _2, "xn--fpcrj9c3d": _2, "": _2, "xn--gecrj9c": _2, "": _2, "xn--s9brj9c": _2, "": _2, "xn--45brj9c": _2, "": _2, "xn--xkc2dl3a5ee0h": _2, "": _2, "xn--mgba3a4f16a": _2, "": _2, "xn--mgba3a4fra": _2, "": _2, "xn--mgbtx2b": _2, "": _2, "xn--mgbayh7gpa": _2, "": _2, "xn--3e0b707e": _2, "": _2, "xn--80ao21a": _2, "": _2, "xn--q7ce6a": _2, "": _2, "xn--fzc2c9e2c": _2, "": _2, "xn--xkc2al3hye2a": _2, "": _2, "xn--mgbc0a9azcg": _2, "": _2, "xn--d1alf": _2, "": _2, "xn--l1acc": _2, "": _2, "xn--mix891f": _2, "": _2, "xn--mix082f": _2, "": _2, "xn--mgbx4cd0ab": _2, "": _2, "xn--mgb9awbf": _2, "": _2, "xn--mgbai9azgqp6j": _2, "": _2, "xn--mgbai9a5eva00b": _2, "": _2, "xn--ygbi2ammx": _2, "": _2, "xn--90a3ac": [1, { "xn--o1ac": _2, "xn--c1avg": _2, "xn--90azh": _2, "xn--d1at": _2, "xn--o1ach": _2, "xn--80au": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 }], "xn--p1ai": _2, "": _2, "xn--wgbl6a": _2, "": _2, "xn--mgberp4a5d4ar": _2, "": _2, "xn--mgberp4a5d4a87g": _2, "": _2, "xn--mgbqly7c0a67fbc": _2, "": _2, "xn--mgbqly7cvafr": _2, "": _2, "xn--mgbpl2fh": _2, "": _2, "xn--yfro4i67o": _2, "": _2, "xn--clchc0ea0b2g2a9gcd": _2, "": _2, "xn--ogbpf8fl": _2, "": _2, "xn--mgbtf8fl": _2, "": _2, "xn--o3cw4h": [1, { "xn--12c1fe0br": _2, "xn--12co0c3b4eva": _2, "xn--h3cuzk1di": _2, "xn--o3cyx2a": _2, "xn--m3ch0j3a": _2, "xn--12cfi8ixb8l": _2 }], "": [1, { "": _2, "": _2, "": _2, "": _2, "": _2, "": _2 }], "xn--pgbs0dh": _2, "": _2, "xn--kpry57d": _2, "": _2, "xn--kprw13d": _2, "": _2, "xn--nnx388a": _2, "": _2, "xn--j1amh": _2, "": _2, "xn--mgb2ddes": _2, "": _2, "xxx": _2, "ye": _34, "za": [0, { "ac": _2, "agric": _2, "alt": _2, "co": _6, "edu": _2, "gov": _2, "grondar": _2, "law": _2, "mil": _2, "net": _2, "ngo": _2, "nic": _2, "nis": _2, "nom": _2, "org": _2, "school": _2, "tm": _2, "web": _2 }], "zm": [1, { "ac": _2, "biz": _2, "co": _2, "com": _2, "edu": _2, "gov": _2, "info": _2, "mil": _2, "net": _2, "org": _2, "sch": _2 }], "zw": [1, { "ac": _2, "co": _2, "gov": _2, "mil": _2, "org": _2 }], "aaa": _2, "aarp": _2, "abb": _2, "abbott": _2, "abbvie": _2, "abc": _2, "able": _2, "abogado": _2, "abudhabi": _2, "academy": [1, { "official": _3 }], "accenture": _2, "accountant": _2, "accountants": _2, "aco": _2, "actor": _2, "ads": _2, "adult": _2, "aeg": _2, "aetna": _2, "afl": _2, "africa": _2, "agakhan": _2, "agency": _2, "aig": _2, "airbus": _2, "airforce": _2, "airtel": _2, "akdn": _2, "alibaba": _2, "alipay": _2, "allfinanz": _2, "allstate": _2, "ally": _2, "alsace": _2, "alstom": _2, "amazon": _2, "americanexpress": _2, "americanfamily": _2, "amex": _2, "amfam": _2, "amica": _2, "amsterdam": _2, "analytics": _2, "android": _2, "anquan": _2, "anz": _2, "aol": _2, "apartments": _2, "app": [1, { "beget": _5, "clerk": _3, "clerkstage": _3, "wnext": _3, "platform0": _3, "deta": _3, "ondigitalocean": _3, "easypanel": _3, "encr": _3, "edgecompute": _3, "fireweb": _3, "onflashdrive": _3, "framer": _3, "run": [2, { "a": _3 }], "web": _3, "hasura": _3, "loginline": _3, "messerli": _3, "netlify": _3, "ngrok": _3, "ngrok-free": _3, "developer": _5, "noop": _3, "northflank": _5, "snowflake": [2, { "privatelink": _3 }], "streamlit": _3, "storipress": _3, "telebit": _3, "typedream": _3, "vercel": _3, "bookonline": _3 }], "apple": _2, "aquarelle": _2, "arab": _2, "aramco": _2, "archi": _2, "army": _2, "art": _2, "arte": _2, "asda": _2, "associates": _2, "athleta": _2, "attorney": _2, "auction": _2, "audi": _2, "audible": _2, "audio": _2, "auspost": _2, "author": _2, "auto": _2, "autos": _2, "avianca": _2, "aws": _2, "axa": _2, "azure": _2, "baby": _2, "baidu": _2, "banamex": _2, "bananarepublic": _2, "band": _2, "bank": _2, "bar": _2, "barcelona": _2, "barclaycard": _2, "barclays": _2, "barefoot": _2, "bargains": _2, "baseball": _2, "basketball": [1, { "aus": _3, "nz": _3 }], "bauhaus": _2, "bayern": _2, "bbc": _2, "bbt": _2, "bbva": _2, "bcg": _2, "bcn": _2, "beats": _2, "beauty": _2, "beer": _2, "bentley": _2, "berlin": _2, "best": _2, "bestbuy": _2, "bet": _2, "bharti": _2, "bible": _2, "bid": _2, "bike": _2, "bing": _2, "bingo": _2, "bio": _2, "black": _2, "blackfriday": _2, "blockbuster": _2, "blog": _2, "bloomberg": _2, "blue": _2, "bms": _2, "bmw": _2, "bnpparibas": _2, "boats": _2, "boehringer": _2, "bofa": _2, "bom": _2, "bond": _2, "boo": _2, "book": _2, "booking": _2, "bosch": _2, "bostik": _2, "boston": _2, "bot": _2, "boutique": _2, "box": _2, "bradesco": _2, "bridgestone": _2, "broadway": _2, "broker": _2, "brother": _2, "brussels": _2, "build": _2, "builders": [1, { "cloudsite": _3 }], "business": _10, "buy": _2, "buzz": _2, "bzh": _2, "cab": _2, "cafe": _2, "cal": _2, "call": _2, "calvinklein": _2, "cam": _2, "camera": _2, "camp": _2, "canon": _2, "capetown": _2, "capital": _2, "capitalone": _2, "car": _2, "caravan": _2, "cards": _2, "care": _2, "career": _2, "careers": _2, "cars": _2, "casa": [1, { "nabu": [0, { "ui": _3 }] }], "case": _2, "cash": _2, "casino": _2, "catering": _2, "catholic": _2, "cba": _2, "cbn": _2, "cbre": _2, "cbs": _2, "center": _2, "ceo": _2, "cern": _2, "cfa": _2, "cfd": _2, "chanel": _2, "channel": _2, "charity": _2, "chase": _2, "chat": _2, "cheap": _2, "chintai": _2, "christmas": _2, "chrome": _2, "church": _2, "cipriani": _2, "circle": _2, "cisco": _2, "citadel": _2, "citi": _2, "citic": _2, "city": _2, "cityeats": _2, "claims": _2, "cleaning": _2, "click": _2, "clinic": _2, "clinique": _2, "clothing": _2, "cloud": [1, { "banzai": _5, "elementor": _3, "encoway": [0, { "eu": _3 }], "statics": _5, "ravendb": _3, "axarnet": [0, { "es-1": _3 }], "diadem": _3, "jelastic": [0, { "vip": _3 }], "jele": _3, "jenv-aruba": [0, { "aruba": [0, { "eur": [0, { "it1": _3 }] }], "it1": _3 }], "keliweb": [2, { "cs": _3 }], "oxa": [2, { "tn": _3, "uk": _3 }], "primetel": [2, { "uk": _3 }], "reclaim": [0, { "ca": _3, "uk": _3, "us": _3 }], "trendhosting": [0, { "ch": _3, "de": _3 }], "jotelulu": _3, "kuleuven": _3, "linkyard": _3, "magentosite": _5, "perspecta": _3, "vapor": _3, "on-rancher": _5, "scw": [0, { "baremetal": [0, { "fr-par-1": _3, "fr-par-2": _3, "nl-ams-1": _3 }], "fr-par": [0, { "fnc": [2, { "functions": _3 }], "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 }], "instances": [0, { "priv": _3, "pub": _3 }], "k8s": _3, "nl-ams": [0, { "k8s": _11, "s3": _3, "s3-website": _3, "whm": _3 }], "pl-waw": [0, { "k8s": _11, "s3": _3, "s3-website": _3 }], "scalebook": _3, "smartlabeling": _3 }], "sensiosite": _5, "trafficplex": _3, "urown": _3, "voorloper": _3 }], "club": [1, { "cloudns": _3, "jele": _3, "barsy": _3 }], "clubmed": _2, "coach": _2, "codes": [1, { "owo": _5 }], "coffee": _2, "college": _2, "cologne": _2, "comcast": _2, "commbank": _2, "community": [1, { "nog": _3, "ravendb": _3, "myforum": _3 }], "company": _2, "compare": _2, "computer": _2, "comsec": _2, "condos": _2, "construction": _2, "consulting": _2, "contact": _2, "contractors": _2, "cooking": _2, "cool": [1, { "elementor": _3, "de": _3 }], "corsica": _2, "country": _2, "coupon": _2, "coupons": _2, "courses": _2, "cpa": _2, "credit": _2, "creditcard": _2, "creditunion": _2, "cricket": _2, "crown": _2, "crs": _2, "cruise": _2, "cruises": _2, "cuisinella": _2, "cymru": _2, "cyou": _2, "dabur": _2, "dad": _2, "dance": _2, "data": _2, "date": _2, "dating": _2, "datsun": _2, "day": _2, "dclk": _2, "dds": _2, "deal": _2, "dealer": _2, "deals": _2, "degree": _2, "delivery": _2, "dell": _2, "deloitte": _2, "delta": _2, "democrat": _2, "dental": _2, "dentist": _2, "desi": _2, "design": [1, { "bss": _3 }], "dev": [1, { "autocode": _3, "lcl": _5, "lclstage": _5, "stg": _5, "stgstage": _5, "pages": _3, "r2": _3, "workers": _3, "curv": _3, "deno": _3, "deno-staging": _3, "deta": _3, "fly": _3, "githubpreview": _3, "gateway": _5, "iserv": _3, "localcert": [0, { "user": _5 }], "loginline": _3, "mediatech": _3, "ngrok": _3, "ngrok-free": _3, "platter-app": _3, "shiftcrypto": _3, "vercel": _3, "webhare": _5 }], "dhl": _2, "diamonds": _2, "diet": _2, "digital": [1, { "cloudapps": [2, { "london": _3 }] }], "direct": _2, "directory": _2, "discount": _2, "discover": _2, "dish": _2, "diy": _2, "dnp": _2, "docs": _2, "doctor": _2, "dog": _2, "domains": _2, "dot": _2, "download": _2, "drive": _2, "dtv": _2, "dubai": _2, "dunlop": _2, "dupont": _2, "durban": _2, "dvag": _2, "dvr": _2, "earth": [1, { "dapps": [0, { "*": _3, "bzz": _5 }] }], "eat": _2, "eco": _2, "edeka": _2, "education": _10, "email": _2, "emerck": _2, "energy": _2, "engineer": _2, "engineering": _2, "enterprises": _2, "epson": _2, "equipment": _2, "ericsson": _2, "erni": _2, "esq": _2, "estate": [1, { "compute": _5 }], "etisalat": _2, "eurovision": _2, "eus": [1, { "party": _30 }], "events": [1, { "koobin": _3, "co": _3 }], "exchange": _2, "expert": _2, "exposed": _2, "express": _2, "extraspace": _2, "fage": _2, "fail": _2, "fairwinds": _2, "faith": _31, "family": _2, "fan": _2, "fans": _2, "farm": [1, { "storj": _3 }], "farmers": _2, "fashion": _2, "fast": _2, "fedex": _2, "feedback": _2, "ferrari": _2, "ferrero": _2, "fidelity": _2, "fido": _2, "film": _2, "final": _2, "finance": _2, "financial": _10, "fire": _2, "firestone": _2, "firmdale": _2, "fish": _2, "fishing": _2, "fit": _2, "fitness": _2, "flickr": _2, "flights": _2, "flir": _2, "florist": _2, "flowers": _2, "fly": _2, "foo": _2, "food": _2, "football": _2, "ford": _2, "forex": _2, "forsale": _2, "forum": _2, "foundation": _2, "fox": _2, "free": _2, "fresenius": _2, "frl": _2, "frogans": _2, "frontdoor": _2, "frontier": _2, "ftr": _2, "fujitsu": _2, "fun": _2, "fund": _2, "furniture": _2, "futbol": _2, "fyi": _2, "gal": _2, "gallery": _2, "gallo": _2, "gallup": _2, "game": _2, "games": _2, "gap": _2, "garden": _2, "gay": _2, "gbiz": _2, "gdn": [1, { "cnpy": _3 }], "gea": _2, "gent": _2, "genting": _2, "george": _2, "ggee": _2, "gift": _2, "gifts": _2, "gives": _2, "giving": _2, "glass": _2, "gle": _2, "global": _2, "globo": _2, "gmail": _2, "gmbh": _2, "gmo": _2, "gmx": _2, "godaddy": _2, "gold": _2, "goldpoint": _2, "golf": _2, "goo": _2, "goodyear": _2, "goog": [1, { "cloud": _3, "translate": _3, "usercontent": _5 }], "google": _2, "gop": _2, "got": _2, "grainger": _2, "graphics": _2, "gratis": _2, "green": _2, "gripe": _2, "grocery": _2, "group": [1, { "discourse": _3 }], "guardian": _2, "gucci": _2, "guge": _2, "guide": _2, "guitars": _2, "guru": _2, "hair": _2, "hamburg": _2, "hangout": _2, "haus": _2, "hbo": _2, "hdfc": _2, "hdfcbank": _2, "health": [1, { "hra": _3 }], "healthcare": _2, "help": _2, "helsinki": _2, "here": _2, "hermes": _2, "hiphop": _2, "hisamitsu": _2, "hitachi": _2, "hiv": _2, "hkt": _2, "hockey": _2, "holdings": _2, "holiday": _2, "homedepot": _2, "homegoods": _2, "homes": _2, "homesense": _2, "honda": _2, "horse": _2, "hospital": _2, "host": [1, { "cloudaccess": _3, "freesite": _3, "easypanel": _3, "fastvps": _3, "myfast": _3, "tempurl": _3, "wpmudev": _3, "jele": _3, "mircloud": _3, "pcloud": _3, "half": _3 }], "hosting": [1, { "opencraft": _3 }], "hot": _2, "hotels": _2, "hotmail": _2, "house": _2, "how": _2, "hsbc": _2, "hughes": _2, "hyatt": _2, "hyundai": _2, "ibm": _2, "icbc": _2, "ice": _2, "icu": _2, "ieee": _2, "ifm": _2, "ikano": _2, "imamat": _2, "imdb": _2, "immo": _2, "immobilien": _2, "inc": _2, "industries": _2, "infiniti": _2, "ing": _2, "ink": _2, "institute": _2, "insurance": _2, "insure": _2, "international": _2, "intuit": _2, "investments": _2, "ipiranga": _2, "irish": _2, "ismaili": _2, "ist": _2, "istanbul": _2, "itau": _2, "itv": _2, "jaguar": _2, "java": _2, "jcb": _2, "jeep": _2, "jetzt": _2, "jewelry": _2, "jio": _2, "jll": _2, "jmp": _2, "jnj": _2, "joburg": _2, "jot": _2, "joy": _2, "jpmorgan": _2, "jprs": _2, "juegos": _2, "juniper": _2, "kaufen": _2, "kddi": _2, "kerryhotels": _2, "kerrylogistics": _2, "kerryproperties": _2, "kfh": _2, "kia": _2, "kids": _2, "kim": _2, "kinder": _2, "kindle": _2, "kitchen": _2, "kiwi": _2, "koeln": _2, "komatsu": _2, "kosher": _2, "kpmg": _2, "kpn": _2, "krd": [1, { "co": _3, "edu": _3 }], "kred": _2, "kuokgroup": _2, "kyoto": _2, "lacaixa": _2, "lamborghini": _2, "lamer": _2, "lancaster": _2, "land": [1, { "static": [2, { "dev": _3, "sites": _3 }] }], "landrover": _2, "lanxess": _2, "lasalle": _2, "lat": _2, "latino": _2, "latrobe": _2, "law": _2, "lawyer": _2, "lds": _2, "lease": _2, "leclerc": _2, "lefrak": _2, "legal": _2, "lego": _2, "lexus": _2, "lgbt": _2, "lidl": _2, "life": _2, "lifeinsurance": _2, "lifestyle": _2, "lighting": _2, "like": _2, "lilly": _2, "limited": _2, "limo": _2, "lincoln": _2, "link": [1, { "cyon": _3, "mypep": _3, "dweb": _5 }], "lipsy": _2, "live": [1, { "hlx": _3 }], "living": _2, "llc": _2, "llp": _2, "loan": _2, "loans": _2, "locker": _2, "locus": _2, "lol": [1, { "omg": _3 }], "london": _2, "lotte": _2, "lotto": _2, "love": _2, "lpl": _2, "lplfinancial": _2, "ltd": _2, "ltda": _2, "lundbeck": _2, "luxe": _2, "luxury": _2, "madrid": _2, "maif": _2, "maison": _2, "makeup": _2, "man": _2, "management": [1, { "router": _3 }], "mango": _2, "map": _2, "market": _2, "marketing": _2, "markets": _2, "marriott": _2, "marshalls": _2, "mattel": _2, "mba": _2, "mckinsey": _2, "med": _2, "media": _37, "meet": _2, "melbourne": _2, "meme": _2, "memorial": _2, "men": _2, "menu": _38, "merckmsd": _2, "miami": _2, "microsoft": _2, "mini": _2, "mint": _2, "mit": _2, "mitsubishi": _2, "mlb": _2, "mls": _2, "mma": _2, "mobile": _2, "moda": _2, "moe": _2, "moi": _2, "mom": _2, "monash": _2, "money": _2, "monster": _2, "mormon": _2, "mortgage": _2, "moscow": _2, "moto": _2, "motorcycles": _2, "mov": _2, "movie": _2, "msd": _2, "mtn": _2, "mtr": _2, "music": _2, "nab": _2, "nagoya": _2, "natura": _2, "navy": _2, "nba": _2, "nec": _2, "netbank": _2, "netflix": _2, "network": [1, { "alces": _5, "co": _3, "arvo": _3, "azimuth": _3, "tlon": _3 }], "neustar": _2, "new": _2, "news": [1, { "noticeable": _3 }], "next": _2, "nextdirect": _2, "nexus": _2, "nfl": _2, "ngo": _2, "nhk": _2, "nico": _2, "nike": _2, "nikon": _2, "ninja": _2, "nissan": _2, "nissay": _2, "nokia": _2, "norton": _2, "now": _2, "nowruz": _2, "nowtv": _2, "nra": _2, "nrw": _2, "ntt": _2, "nyc": _2, "obi": _2, "observer": _2, "office": _2, "okinawa": _2, "olayan": _2, "olayangroup": _2, "oldnavy": _2, "ollo": _2, "omega": _2, "one": [1, { "onred": [2, { "staging": _3 }], "service": _3, "homelink": _3 }], "ong": _2, "onl": _2, "online": [1, { "eero": _3, "eero-stage": _3, "barsy": _3 }], "ooo": _2, "open": _2, "oracle": _2, "orange": [1, { "tech": _3 }], "organic": _2, "origins": _2, "osaka": _2, "otsuka": _2, "ott": _2, "ovh": [1, { "nerdpol": _3 }], "page": [1, { "hlx": _3, "hlx3": _3, "translated": _3, "codeberg": _3, "pdns": _3, "plesk": _3, "prvcy": _3, "rocky": _3, "magnet": _3 }], "panasonic": _2, "paris": _2, "pars": _2, "partners": _2, "parts": _2, "party": _31, "pay": _2, "pccw": _2, "pet": _2, "pfizer": _2, "pharmacy": _2, "phd": _2, "philips": _2, "phone": _2, "photo": _2, "photography": _2, "photos": _37, "physio": _2, "pics": _2, "pictet": _2, "pictures": [1, { "1337": _3 }], "pid": _2, "pin": _2, "ping": _2, "pink": _2, "pioneer": _2, "pizza": [1, { "ngrok": _3 }], "place": _10, "play": _2, "playstation": _2, "plumbing": _2, "plus": _2, "pnc": _2, "pohl": _2, "poker": _2, "politie": _2, "porn": [1, { "indie": _3 }], "pramerica": _2, "praxi": _2, "press": _2, "prime": _2, "prod": _2, "productions": _2, "prof": _2, "progressive": _2, "promo": _2, "properties": _2, "property": _2, "protection": _2, "pru": _2, "prudential": _2, "pub": _38, "pwc": _2, "qpon": _2, "quebec": _2, "quest": _2, "racing": _2, "radio": _2, "read": _2, "realestate": _2, "realtor": _2, "realty": _2, "recipes": _2, "red": _2, "redstone": _2, "redumbrella": _2, "rehab": _2, "reise": _2, "reisen": _2, "reit": _2, "reliance": _2, "ren": _2, "rent": _2, "rentals": _2, "repair": _2, "report": _2, "republican": _2, "rest": _2, "restaurant": _2, "review": _31, "reviews": _2, "rexroth": _2, "rich": _2, "richardli": _2, "ricoh": _2, "ril": _2, "rio": _2, "rip": [1, { "clan": _3 }], "rocher": _2, "rocks": [1, { "myddns": _3, "lima-city": _3, "webspace": _3 }], "rodeo": _2, "rogers": _2, "room": _2, "rsvp": _2, "rugby": _2, "ruhr": _2, "run": [1, { "hs": _3, "development": _3, "ravendb": _3, "servers": _3, "build": _5, "code": _5, "database": _5, "migration": _5, "onporter": _3, "repl": _3, "wix": _3 }], "rwe": _2, "ryukyu": _2, "saarland": _2, "safe": _2, "safety": _2, "sakura": _2, "sale": _2, "salon": _2, "samsclub": _2, "samsung": _2, "sandvik": _2, "sandvikcoromant": _2, "sanofi": _2, "sap": _2, "sarl": _2, "sas": _2, "save": _2, "saxo": _2, "sbi": _2, "sbs": _2, "sca": _2, "scb": _2, "schaeffler": _2, "schmidt": _2, "scholarships": _2, "school": _2, "schule": _2, "schwarz": _2, "science": _31, "scot": [1, { "edu": _3, "gov": [2, { "service": _3 }] }], "search": _2, "seat": _2, "secure": _2, "security": _2, "seek": _2, "select": _2, "sener": _2, "services": [1, { "loginline": _3 }], "seven": _2, "sew": _2, "sex": _2, "sexy": _2, "sfr": _2, "shangrila": _2, "sharp": _2, "shaw": _2, "shell": _2, "shia": _2, "shiksha": _2, "shoes": _2, "shop": [1, { "base": _3, "hoplix": _3, "barsy": _3 }], "shopping": _2, "shouji": _2, "show": _2, "showtime": _2, "silk": _2, "sina": _2, "singles": _2, "site": [1, { "cloudera": _5, "cyon": _3, "fnwk": _3, "folionetwork": _3, "fastvps": _3, "jele": _3, "lelux": _3, "loginline": _3, "barsy": _3, "mintere": _3, "omniwe": _3, "opensocial": _3, "platformsh": _5, "tst": _5, "byen": _3, "srht": _3, "novecore": _3 }], "ski": _2, "skin": _2, "sky": _2, "skype": _2, "sling": _2, "smart": _2, "smile": _2, "sncf": _2, "soccer": _2, "social": _2, "softbank": _2, "software": _2, "sohu": _2, "solar": _2, "solutions": [1, { "diher": _5 }], "song": _2, "sony": _2, "soy": _2, "spa": _2, "space": [1, { "myfast": _3, "uber": _3, "xs4all": _3 }], "sport": _2, "spot": _2, "srl": _2, "stada": _2, "staples": _2, "star": _2, "statebank": _2, "statefarm": _2, "stc": _2, "stcgroup": _2, "stockholm": _2, "storage": _2, "store": [1, { "sellfy": _3, "shopware": _3, "storebase": _3 }], "stream": _2, "studio": _2, "study": _2, "style": _2, "sucks": _2, "supplies": _2, "supply": _2, "support": _38, "surf": _2, "surgery": _2, "suzuki": _2, "swatch": _2, "swiss": _2, "sydney": _2, "systems": [1, { "knightpoint": _3 }], "tab": _2, "taipei": _2, "talk": _2, "taobao": _2, "target": _2, "tatamotors": _2, "tatar": _2, "tattoo": _2, "tax": _2, "taxi": _2, "tci": _2, "tdk": _2, "team": [1, { "discourse": _3, "jelastic": _3 }], "tech": _2, "technology": _10, "temasek": _2, "tennis": _2, "teva": _2, "thd": _2, "theater": _2, "theatre": _2, "tiaa": _2, "tickets": _2, "tienda": _2, "tips": _2, "tires": _2, "tirol": _2, "tjmaxx": _2, "tjx": _2, "tkmaxx": _2, "tmall": _2, "today": [1, { "prequalifyme": _3 }], "tokyo": _2, "tools": _2, "top": [1, { "now-dns": _3, "ntdll": _3 }], "toray": _2, "toshiba": _2, "total": _2, "tours": _2, "town": _2, "toyota": _2, "toys": _2, "trade": _31, "trading": _2, "training": _2, "travel": _2, "travelers": _2, "travelersinsurance": _2, "trust": _2, "trv": _2, "tube": _2, "tui": _2, "tunes": _2, "tushu": _2, "tvs": _2, "ubank": _2, "ubs": _2, "unicom": _2, "university": _2, "uno": _2, "uol": _2, "ups": _2, "vacations": _2, "vana": _2, "vanguard": _2, "vegas": _2, "ventures": _2, "verisign": _2, "versicherung": _2, "vet": _2, "viajes": _2, "video": _2, "vig": _2, "viking": _2, "villas": _2, "vin": _2, "vip": _2, "virgin": _2, "visa": _2, "vision": _2, "viva": _2, "vivo": _2, "vlaanderen": _2, "vodka": _2, "volkswagen": _2, "volvo": _2, "vote": _2, "voting": _2, "voto": _2, "voyage": _2, "wales": _2, "walmart": _2, "walter": _2, "wang": _2, "wanggou": _2, "watch": _2, "watches": _2, "weather": _2, "weatherchannel": _2, "webcam": _2, "weber": _2, "website": _37, "wedding": _2, "weibo": _2, "weir": _2, "whoswho": _2, "wien": _2, "wiki": _37, "williamhill": _2, "win": _2, "windows": _2, "wine": _2, "winners": _2, "wme": _2, "wolterskluwer": _2, "woodside": _2, "work": _2, "works": _2, "world": _2, "wow": _2, "wtc": _2, "wtf": _2, "xbox": _2, "xerox": _2, "xfinity": _2, "xihuan": _2, "xin": _2, "xn--11b4c3d": _2, "": _2, "xn--1ck2e1b": _2, "": _2, "xn--1qqw23a": _2, "": _2, "xn--30rr7y": _2, "": _2, "xn--3bst00m": _2, "": _2, "xn--3ds443g": _2, "": _2, "xn--3pxu8k": _2, "": _2, "xn--42c2d9a": _2, "": _2, "xn--45q11c": _2, "": _2, "xn--4gbrim": _2, "": _2, "xn--55qw42g": _2, "": _2, "xn--55qx5d": _2, "": _2, "xn--5su34j936bgsg": _2, "": _2, "xn--5tzm5g": _2, "": _2, "xn--6frz82g": _2, "": _2, "xn--6qq986b3xl": _2, "": _2, "xn--80adxhks": _2, "": _2, "xn--80aqecdr1a": _2, "": _2, "xn--80asehdb": _2, "": _2, "xn--80aswg": _2, "": _2, "xn--8y0a063a": _2, "": _2, "xn--9dbq2a": _2, "": _2, "xn--9et52u": _2, "": _2, "xn--9krt00a": _2, "": _2, "xn--b4w605ferd": _2, "": _2, "xn--bck1b9a5dre4c": _2, "": _2, "xn--c1avg": _2, "": _2, "xn--c2br7g": _2, "": _2, "xn--cck2b3b": _2, "": _2, "xn--cckwcxetd": _2, "": _2, "xn--cg4bki": _2, "": _2, "xn--czr694b": _2, "": _2, "xn--czrs0t": _2, "": _2, "xn--czru2d": _2, "": _2, "xn--d1acj3b": _2, "": _2, "xn--eckvdtc9d": _2, "": _2, "xn--efvy88h": _2, "": _2, "xn--fct429k": _2, "": _2, "xn--fhbei": _2, "": _2, "xn--fiq228c5hs": _2, "": _2, "xn--fiq64b": _2, "": _2, "xn--fjq720a": _2, "": _2, "xn--flw351e": _2, "": _2, "xn--fzys8d69uvgm": _2, "": _2, "xn--g2xx48c": _2, "": _2, "xn--gckr3f0f": _2, "": _2, "xn--gk3at1e": _2, "": _2, "xn--hxt814e": _2, "": _2, "xn--i1b6b1a6a2e": _2, "": _2, "xn--imr513n": _2, "": _2, "xn--io0a7i": _2, "": _2, "xn--j1aef": _2, "": _2, "xn--jlq480n2rg": _2, "": _2, "xn--jvr189m": _2, "": _2, "xn--kcrx77d1x4a": _2, "": _2, "xn--kput3i": _2, "": _2, "xn--mgba3a3ejt": _2, "": _2, "xn--mgba7c0bbn0a": _2, "": _2, "xn--mgbaakc7dvf": _2, "": _2, "xn--mgbab2bd": _2, "": _2, "xn--mgbca7dzdo": _2, "": _2, "xn--mgbi4ecexp": _2, "": _2, "xn--mgbt3dhd": _2, "": _2, "xn--mk1bu44c": _2, "": _2, "xn--mxtq1m": _2, "": _2, "xn--ngbc5azd": _2, "": _2, "xn--ngbe9e0a": _2, "": _2, "xn--ngbrx": _2, "": _2, "xn--nqv7f": _2, "": _2, "xn--nqv7fs00ema": _2, "": _2, "xn--nyqy26a": _2, "": _2, "xn--otu796d": _2, "": _2, "xn--p1acf": [1, { "xn--90amc": _3, "xn--j1aef": _3, "xn--j1ael8b": _3, "xn--h1ahn": _3, "xn--j1adp": _3, "xn--c1avg": _3, "xn--80aaa0cvac": _3, "xn--h1aliz": _3, "xn--90a1af": _3, "xn--41a": _3 }], "": [1, { "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3, "": _3 }], "xn--pssy2u": _2, "": _2, "xn--q9jyb4c": _2, "": _2, "xn--qcka1pmc": _2, "": _2, "xn--rhqv96g": _2, "": _2, "xn--rovu88b": _2, "": _2, "xn--ses554g": _2, "": _2, "xn--t60b56a": _2, "": _2, "xn--tckwe": _2, "": _2, "xn--tiq49xqyj": _2, "": _2, "xn--unup4y": _2, "": _2, "xn--vermgensberater-ctb": _2, "vermgensberater": _2, "xn--vermgensberatung-pwb": _2, "vermgensberatung": _2, "xn--vhquv": _2, "": _2, "xn--vuq861b": _2, "": _2, "xn--w4r85el8fhu5dnra": _2, "": _2, "xn--w4rs40l": _2, "": _2, "xn--xhq521b": _2, "": _2, "xn--zfr164b": _2, "": _2, "xyz": [1, { "blogsite": _3, "localzone": _3, "crafting": _3, "zapto": _3, "telebit": _5 }], "yachts": _2, "yahoo": _2, "yamaxun": _2, "yandex": _2, "yodobashi": _2, "yoga": _2, "yokohama": _2, "you": _2, "youtube": _2, "yun": _2, "zappos": _2, "zara": _2, "zero": _2, "zip": _2, "zone": [1, { "cloud66": _3, "hs": _3, "triton": _5, "lima": _3 }], "zuerich": _2 }];
  return rules2;
}();

// node_modules/tldts/dist/es6/src/suffix-trie.js
function lookupInTrie(parts, trie, index, allowedMask) {
  let result = null;
  let node = trie;
  while (node !== void 0) {
    if ((node[0] & allowedMask) !== 0) {
      result = {
        index: index + 1,
        isIcann: node[0] === 1,
        isPrivate: node[0] === 2
      };
    }
    if (index === -1) {
      break;
    }
    const succ = node[1];
    node = Object.prototype.hasOwnProperty.call(succ, parts[index]) ? succ[parts[index]] : succ["*"];
    index -= 1;
  }
  return result;
}
function suffixLookup(hostname2, options, out) {
  var _a5;
  if (fast_path_default(hostname2, options, out)) {
    return;
  }
  const hostnameParts = hostname2.split(".");
  const allowedMask = (options.allowPrivateDomains ? 2 : 0) | (options.allowIcannDomains ? 1 : 0);
  const exceptionMatch = lookupInTrie(hostnameParts, exceptions, hostnameParts.length - 1, allowedMask);
  if (exceptionMatch !== null) {
    out.isIcann = exceptionMatch.isIcann;
    out.isPrivate = exceptionMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(exceptionMatch.index + 1).join(".");
    return;
  }
  const rulesMatch = lookupInTrie(hostnameParts, rules, hostnameParts.length - 1, allowedMask);
  if (rulesMatch !== null) {
    out.isIcann = rulesMatch.isIcann;
    out.isPrivate = rulesMatch.isPrivate;
    out.publicSuffix = hostnameParts.slice(rulesMatch.index).join(".");
    return;
  }
  out.isIcann = false;
  out.isPrivate = false;
  out.publicSuffix = (_a5 = hostnameParts[hostnameParts.length - 1]) !== null && _a5 !== void 0 ? _a5 : null;
}

// node_modules/tldts/dist/es6/index.js
var RESULT = getEmptyResult();
function parse(url, options = {}) {
  return parseImpl(url, 5, suffixLookup, options, getEmptyResult());
}

// node_modules/@dynamic-labs/utils/src/services/PlatformService/createBrowserPlatformService/createBrowserPlatformService.js
var createBrowserPlatformService = (window2) => ({
  getDisplayOrigin: () => window2.location.origin,
  getHost: () => window2.location.host,
  getHostname: () => window2.location.hostname,
  getOrigin: () => window2.location.origin,
  getTLD: (domain2) => {
    const data = parse(domain2 || window2.location.hostname, {
      allowPrivateDomains: true
    });
    return data.domain || void 0;
  },
  getUrl: () => new URL(window2.location.href),
  isNativeMobile: false,
  openURL: (url_1, ...args_1) => __awaiter3(void 0, [url_1, ...args_1], void 0, function* (url, target = "self", features = "") {
    if (target === "blank") {
      window2.open(url, "_blank", features);
    } else {
      window2.location.assign(url);
    }
  })
});

// node_modules/@dynamic-labs/utils/src/services/PlatformService/PlatformService.js
var _a;
var _PlatformService_implementation;
var PlatformService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a, _a, "f", _PlatformService_implementation)) {
      return createBrowserPlatformService(window);
    }
    return __classPrivateFieldGet(_a, _a, "f", _PlatformService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a, _a, implementation, "f", _PlatformService_implementation);
  }
  /**
   * Indicates if the current platform is a native mobile app
   * like react-native or flutter.
   */
  static get isNativeMobile() {
    return _a.implementation.isNativeMobile;
  }
  /**
   * Gets the origin of the current location.
   *
   * @example window.location.origin
   */
  static get getOrigin() {
    return _a.implementation.getOrigin;
  }
  /**
   * Gets the origin to be displayed in the UI.
   *
   * @example window.location.origin
   */
  static get getDisplayOrigin() {
    return _a.implementation.getDisplayOrigin;
  }
  /**
   * Gets the host of the current location.
   *
   * @example window.location.host
   */
  static get getHost() {
    return _a.implementation.getHost;
  }
  /**
   * Gets the hostname of the current location.
   *
   * @example window.location.hostname
   */
  static get getHostname() {
    return _a.implementation.getHostname;
  }
  /**
   * Gets the current URL.
   *
   * @example new URL(window.location.href)
   */
  static get getUrl() {
    return _a.implementation.getUrl;
  }
  static getTLD(domain2) {
    return _a.implementation.getTLD(domain2);
  }
  /**
   * Opens a URL. If possible, should avoid new windows.
   */
  static get openURL() {
    return _a.implementation.openURL;
  }
};
_a = PlatformService;
_PlatformService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/utils/src/getTLD/getTLD.js
var getTLD = () => PlatformService.getTLD();

// node_modules/@dynamic-labs/utils/src/isMobile/isMobile.js
var userAgentRegex1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ios|ipad|playbook|silk/i;
var userAgentRegex2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;
var isMobile = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return userAgentRegex1.test(navigator.userAgent) || userAgentRegex2.test(navigator.userAgent.substring(0, 4)) || isIPad(maxTouchPointsOverride) || isIPhone();
};
var isIPhone = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : /iPhone|ios/.test(navigator.userAgent);
var isIPhone8OrEarlier = () => typeof window === "undefined" || typeof navigator === "undefined" ? false : iPhoneLegacyRegex.some(({ regex }) => regex.test(navigator.userAgent));
var isIPad = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  const maxTouchPoints = maxTouchPointsOverride || navigator.maxTouchPoints;
  return /iPad/.test(navigator.userAgent) || /Mac/.test(navigator.userAgent) && maxTouchPoints === 5;
};
var isIOS = (maxTouchPointsOverride) => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return isIPhone() || isIPad(maxTouchPointsOverride);
};
var isAndroid = () => isMobile() && !isIOS();
var isLegacySafari = () => {
  if (typeof window === "undefined" || !window.CSS || typeof window.CSS.supports !== "function") {
    return false;
  }
  const cssValue = "aspect-ratio: 1 / 1";
  return !CSS.supports(cssValue);
};
var isSamsungBrowser = () => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  return navigator.userAgent.includes("SamsungBrowser");
};
var isSafariBrowser = () => {
  if (typeof window === "undefined" || typeof navigator === "undefined") {
    return false;
  }
  const { userAgent } = navigator;
  const isSafari = userAgent.includes("Safari") && !userAgent.includes("Chrome") && !userAgent.includes("Chromium");
  return isSafari;
};
var iPhoneLegacyRegex = [
  {
    model: "iPhone 5",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]12|5)$/
  },
  {
    model: "iPhone 5C",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?5[C,_]34)$/
  },
  {
    model: "iPhone 5S",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?6[C,_]12|5S)$/
  },
  {
    model: "iPhone 6 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]1|1C2%257enohPi|6PLUS)$/
  },
  {
    model: "iPhone 6",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?7[C,_]2|6)$/
  },
  {
    model: "iPhone 6s Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]2|6SPLUS)$/
  },
  {
    model: "iPhone 6s",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]1|iPhone[ /]6s|6S)$/
  },
  {
    model: "iPhone SE",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?8[C,_]4|SE)$/
  },
  {
    model: "iPhone 7",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]13|iphone7|7)$/
  },
  {
    model: "iPhone 7 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?9[C,_]24|7PLUS)$/
  },
  {
    model: "iPhone 8",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]14|8)$/
  },
  {
    model: "iPhone 8 Plus",
    regex: /(?:MDCR_|ICRU_|Apple-)?(?:iPh(?:one)?10[C,_]25|8PLUS)$/
  }
];
var getAndroidVersion = () => {
  if (typeof navigator === "undefined") {
    return;
  }
  const androidVersionMatch = navigator.userAgent.match(/Android (\d+(\.\d+)?)/);
  if (!androidVersionMatch) {
    return;
  }
  const androidVersion = parseFloat(androidVersionMatch[1]);
  return androidVersion;
};

// node_modules/@dynamic-labs/utils/src/handleMobileWalletRedirect/handleMobileWalletRedirect.js
var handleMobileWalletRedirect = ({ nativeLink, universalLink }) => {
  const url = encodeURIComponent(PlatformService.getUrl().href);
  const ref = encodeURIComponent(PlatformService.getOrigin());
  if (isSamsungBrowser()) {
    PlatformService.openURL(`${nativeLink}/${url}?ref=${ref}`);
  } else {
    PlatformService.openURL(`${universalLink}/${url}?ref=${ref}`);
  }
};

// node_modules/@dynamic-labs/utils/src/isString/isString.js
var isString = (value) => typeof value === "string";

// node_modules/@dynamic-labs/utils/src/parseChainId/parseChainId.js
var parseChainId = (chainId) => parseInt(chainId.toString());

// node_modules/@dynamic-labs/utils/src/parseIntSafe/parseIntSafe.js
var parseIntSafe = (value, radix = 10) => {
  try {
    const int = parseInt(String(value), radix);
    if (isNaN(int)) {
      logger2.error(`Error parsing ${value}`);
      return void 0;
    }
    return int;
  } catch (e) {
    logger2.error(`Error parsing ${value} to int: ${e}`);
  }
  return void 0;
};

// node_modules/@dynamic-labs/utils/src/parseNetworks/parseNetworks.js
var parseEvmNetworks = (networks) => {
  const clone2 = networks.slice();
  return clone2.map((network) => {
    network.chainId = parseChainId(network.chainId);
    network.networkId = parseChainId(network.networkId);
    return network;
  });
};

// node_modules/@dynamic-labs/utils/src/pipe/pipe.js
var pipe = (initialFunc) => {
  const funcs = [initialFunc];
  const executeFn = (input) => funcs.reduce((acc, func) => func(acc), input);
  const pipe3 = (newFunc) => {
    funcs.push(newFunc);
    return Object.assign((input) => executeFn(input), {
      pipe: pipe3
    });
  };
  return Object.assign(executeFn, { pipe: pipe3 });
};

// node_modules/@dynamic-labs/utils/src/sleep/sleep.js
function sleep(timeoutMs, valueToResolve) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(valueToResolve), timeoutMs);
  });
}

// node_modules/@dynamic-labs/utils/src/retryableFn/retryableFn.js
var FALLBACK_UNDEFINED = "FALLBACK_UNDEFINED";
var retryableFn = (fn_1, ...args_1) => __awaiter3(void 0, [fn_1, ...args_1], void 0, function* (fn, options = {}) {
  const { maxRetries = 3, currentRetry = 0, timeoutMs = 100, fallbackValue = new Error("Max retries reached"), retryStrategy = "timeout-only", retryIntervalMs = 0 } = options;
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => {
      reject(new Error("Timeout"));
    }, timeoutMs);
  });
  try {
    const result = yield Promise.race([fn(), timeoutPromise]);
    return result;
  } catch (err) {
    if (currentRetry >= maxRetries) {
      if (fallbackValue instanceof Error) {
        throw fallbackValue;
      } else if (fallbackValue === FALLBACK_UNDEFINED) {
        return void 0;
      }
      return fallbackValue;
    }
    const isTimeout = (err === null || err === void 0 ? void 0 : err.message) === "Timeout";
    const shouldRetry = retryStrategy === "timeout-and-rejection" || retryStrategy === "timeout-only" && isTimeout || retryStrategy === "rejection-only" && !isTimeout;
    if (!shouldRetry) {
      if (fallbackValue instanceof Error) {
        throw err;
      } else if (fallbackValue === FALLBACK_UNDEFINED) {
        return void 0;
      }
      return fallbackValue;
    }
    if (retryIntervalMs)
      yield sleep(retryIntervalMs);
    return retryableFn(fn, {
      currentRetry: currentRetry + 1,
      fallbackValue,
      maxRetries,
      retryIntervalMs,
      retryStrategy,
      timeoutMs
    });
  }
});

// node_modules/@dynamic-labs/utils/src/sanitizeName/sanitizeName.js
var sanitizeName = (name) => name.replace(/[^a-zA-Z0-9]/g, "").toLowerCase();

// node_modules/@dynamic-labs/utils/src/hexToString/hexToString.js
var hexToString = (hexString) => {
  const normalizedHexString = hexString.startsWith("0x") ? hexString.substring(2) : hexString;
  let text = "";
  const length = normalizedHexString.length - normalizedHexString.length % 2;
  for (let i = 0; i < length; i += 2) {
    const hexCode = normalizedHexString.substring(i, i + 2);
    const decimal = parseInt(hexCode, 16);
    text += String.fromCharCode(decimal);
  }
  return text;
};

// node_modules/@dynamic-labs/utils/src/isHex/isHex.js
var isHex = (str) => {
  if (typeof str !== "string") {
    throw new Error("Input must be a string");
  }
  const normalizedStr = str.startsWith("0x") ? str.substring(2) : str;
  const regex = /^[0-9a-fA-F]+$/;
  return regex.test(normalizedStr);
};

// node_modules/@dynamic-labs/utils/src/runSafe/runSafe.js
var runSafe = (callback) => __awaiter3(void 0, void 0, void 0, function* () {
  try {
    const resolved = yield callback();
    return [resolved, void 0];
  } catch (error40) {
    return [void 0, error40];
  }
});

// node_modules/@dynamic-labs/utils/src/template/template.js
var template = (templateText) => {
  return (data) => templateText.replace(/{{(\w+?)}}/g, (match, key) => key in data ? data[key] : match);
};

// node_modules/@dynamic-labs/utils/src/consts/phantomRedirect.js
var PHANTOM_REDIRECT_CONNECTION_TYPE_KEY = "phantom-redirect-connection-type";

// node_modules/@dynamic-labs/utils/src/services/PlatformEventsService/createBrowserPlatformEventsService/createBrowserPlatformEventsService.js
var createBrowserPlatformEventsService = (window2) => {
  const emitter = new eventemitter3_default();
  const mapPlatformEventsToRequestChannel = {
    appFocused: () => {
      window2.addEventListener("focus", () => {
        emitter.emit("appFocused");
      });
    }
  };
  Object.values(mapPlatformEventsToRequestChannel).forEach((handler) => handler());
  return emitter;
};

// node_modules/@dynamic-labs/utils/src/services/PlatformEventsService/PlatformEventsService.js
var _a2;
var _PlatformEventsService_implementation;
var PlatformEventsService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a2, _a2, "f", _PlatformEventsService_implementation)) {
      __classPrivateFieldSet(_a2, _a2, createBrowserPlatformEventsService(window), "f", _PlatformEventsService_implementation);
    }
    return __classPrivateFieldGet(_a2, _a2, "f", _PlatformEventsService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a2, _a2, implementation, "f", _PlatformEventsService_implementation);
  }
  static get on() {
    return _a2.implementation.on.bind(_a2.implementation);
  }
  static get off() {
    return _a2.implementation.off.bind(_a2.implementation);
  }
  static get once() {
    return _a2.implementation.once.bind(_a2.implementation);
  }
};
_a2 = PlatformEventsService;
_PlatformEventsService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/utils/src/services/FetchService/FetchService.js
var _a3;
var _FetchService_implementation;
var FetchService = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a3, _a3, "f", _FetchService_implementation)) {
      return { fetch: window.fetch.bind(window) };
    }
    return __classPrivateFieldGet(_a3, _a3, "f", _FetchService_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a3, _a3, implementation, "f", _FetchService_implementation);
  }
  static get fetch() {
    return _a3.implementation.fetch;
  }
};
_a3 = FetchService;
_FetchService_implementation = { value: void 0 };

// node_modules/@dynamic-labs/types/package.js
var version2 = "4.43.0";

// node_modules/@dynamic-labs/types/src/oauth/index.js
var SocialOAuthErrorCode;
(function(SocialOAuthErrorCode2) {
  SocialOAuthErrorCode2["ACCOUNT_ALREADY_LINKED"] = "account_already_linked";
  SocialOAuthErrorCode2["ACCOUNT_ALREADY_LINKED_TO_DIFFERENT_PROFILE"] = "account_already_linked_to_different_profile";
  SocialOAuthErrorCode2["INVALID_PROVIDER"] = "invalid_provider";
  SocialOAuthErrorCode2["NO_ACCOUNT_LINKED"] = "no_account_linked";
  SocialOAuthErrorCode2["NO_AUTH_CODE"] = "no_auth_code";
  SocialOAuthErrorCode2["NO_OAUTH_URL"] = "no_oauth_url";
  SocialOAuthErrorCode2["NO_PROVIDER"] = "no_provider";
  SocialOAuthErrorCode2["OAUTH_ERROR"] = "oauth_error";
  SocialOAuthErrorCode2["OAUTH_WINDOW_BLOCKED"] = "oauth_window_blocked";
  SocialOAuthErrorCode2["OAUTH_WINDOW_CLOSED"] = "oauth_window_closed";
  SocialOAuthErrorCode2["OAUTH_WINDOW_TIMEOUT"] = "oauth_window_timeout";
  SocialOAuthErrorCode2["PROVIDER_NOT_ENABLED"] = "provider_not_enabled";
  SocialOAuthErrorCode2["SESSION_TIMEOUT"] = "session_timeout";
  SocialOAuthErrorCode2["SIGNIN_ERROR"] = "signin_error";
  SocialOAuthErrorCode2["SOCIAL_LINKING_NOT_ENABLED"] = "social_linking_not_enabled";
  SocialOAuthErrorCode2["UNLINK_ERROR"] = "unlink_error";
  SocialOAuthErrorCode2["VERIFICATION_ERROR"] = "verification_error";
  SocialOAuthErrorCode2["GENERAL_ERROR"] = "general_error";
  SocialOAuthErrorCode2["USER_CANCELLED"] = "user_cancelled";
})(SocialOAuthErrorCode || (SocialOAuthErrorCode = {}));

// node_modules/@dynamic-labs/types/src/wallets/BaseWallet.js
var BaseWallet = class {
  constructor({ id, key, address, additionalAddresses = [], chain, isAuthenticated }) {
    this.id = id;
    this.key = key;
    this.address = address;
    this.additionalAddresses = additionalAddresses;
    this.chain = chain;
    this.isAuthenticated = isAuthenticated;
  }
};

// node_modules/@dynamic-labs/types/src/index.js
assertPackageVersion("@dynamic-labs/types", version2);

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/utils/loadAppleId/loadAppleId.js
var appleIdScriptSrc = "https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js";
var loadAppleId = () => new Promise((resolve, reject) => {
  const script = document.querySelector("script[data-apple-sdk]");
  if (script) {
    if (script.hasAttribute("data-loaded")) {
      resolve();
    } else {
      script.addEventListener("load", () => resolve());
      script.addEventListener("error", () => reject(new Error("Failed to load Apple SDK")));
    }
  } else {
    const script2 = document.createElement("script");
    script2.type = "text/javascript";
    script2.src = appleIdScriptSrc;
    script2.setAttribute("data-apple-sdk", "true");
    script2.onload = () => {
      script2 === null || script2 === void 0 ? void 0 : script2.setAttribute("data-loaded", "true");
      resolve();
    };
    script2.onerror = () => reject(new Error("Failed to load Apple SDK"));
    window.document.head.appendChild(script2);
  }
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/utils/connectWithAppleId/connectWithAppleId.js
var connectWithAppleId = (_a5) => __awaiter3(void 0, [_a5], void 0, function* ({ clientId, oauthLoginUrl, state }) {
  yield loadAppleId();
  AppleID.auth.init({
    clientId,
    redirectURI: oauthLoginUrl.searchParams.get("redirect_uri"),
    scope: "name email",
    state,
    usePopup: false
  });
  AppleID.auth.signIn();
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/createWindowOauth2Service/createWindowOauth2Service.js
var authWindowInterval;
var createWindowOauth2Service = () => ({
  getOauthCode: ({ apiProvider, provider, redirectUrl, setIsProcessing, state, oauthLoginUrl, initWebAuth, strategy }) => new Promise((resolve, _reject) => {
    if (provider === ProviderEnum.Apple && (isSafariBrowser() || isIOS() || strategy === "redirect")) {
      initWebAuth({
        redirectUrl: redirectUrl || window.location.href
      }).then(() => connectWithAppleId({
        clientId: apiProvider === null || apiProvider === void 0 ? void 0 : apiProvider.clientId,
        oauthLoginUrl,
        state
      }).catch(_reject));
      return;
    }
    if (strategy === "redirect" && provider !== ProviderEnum.Telegram) {
      initWebAuth({
        redirectUrl: redirectUrl || window.location.href
      }).then(() => {
        PlatformService.openURL(oauthLoginUrl.toString());
      });
      return;
    }
    const typedReject = (params) => _reject(params);
    clearInterval(authWindowInterval);
    const providersWaitingOauthMessage = {};
    const authWindow = window.open("", "_blank", "width=500,height=600");
    if (authWindow === null || typeof authWindow === "undefined") {
      typedReject({
        code: SocialOAuthErrorCode.OAUTH_WINDOW_BLOCKED,
        message: "Please allow popups and try again."
      });
      return;
    }
    const clearListeners = () => {
      window.removeEventListener("message", handleWindowMessage);
      providersWaitingOauthMessage[provider] = false;
    };
    const handleWindowMessage = (event) => __awaiter3(void 0, void 0, void 0, function* () {
      const message = event.data;
      const expectedOrigin = getExpectedOrigin(apiProvider);
      if (!expectedOrigin) {
        return;
      }
      if ((message === null || message === void 0 ? void 0 : message.type) === "origin_check" && authWindow) {
        logger2.debug("Origin check message received. Sending response now.", {
          data: message,
          expectedOrigin
        });
        authWindow.postMessage("origin_check_response", expectedOrigin);
        return;
      }
      const isTelegramCompletedMessage = (message === null || message === void 0 ? void 0 : message.type) === "telegram_completed";
      const isAuthorizationMessage = (message === null || message === void 0 ? void 0 : message.type) === "authorization_response";
      if (isAuthorizationMessage || isTelegramCompletedMessage) {
        logger2.debug("Message received", { data: message });
      }
      const isExpectedOrigin = event.origin === expectedOrigin;
      const isValidMessage = (isAuthorizationMessage && (message === null || message === void 0 ? void 0 : message.provider) === provider || isTelegramCompletedMessage) && isExpectedOrigin;
      if (!isValidMessage) {
        return;
      }
      setIsProcessing(true);
      if (!providersWaitingOauthMessage[provider]) {
        typedReject({
          code: SocialOAuthErrorCode.SESSION_TIMEOUT,
          message: `Connecting ${provider} account session timeout.`
        });
        return;
      }
      clearListeners();
      if (isTelegramCompletedMessage) {
        handleTelegramCompletionMessage(message, state);
        return;
      }
      handleAuthorizationMessage(message, provider, state);
    });
    const getExpectedOrigin = (apiProvider2) => {
      if (!(apiProvider2 === null || apiProvider2 === void 0 ? void 0 : apiProvider2.redirectUrl)) {
        return;
      }
      try {
        const redirectUri = new URL(apiProvider2.redirectUrl);
        return redirectUri.origin;
      } catch (e) {
        logger2.error("Failed to parse social provider redirect url", {
          error: e
        });
        return;
      }
    };
    const handleTelegramCompletionMessage = (message, state2) => {
      logger2.debug("Telegram completion message received", {
        data: message
      });
      const { code, state: authState } = message;
      if (state2 !== authState) {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: "Failed to connect telegram account: Invalid random state"
        });
        return;
      }
      resolve(code);
      setIsProcessing(false);
    };
    const handleAuthorizationMessage = (message, provider2, state2) => {
      const { code, error: error40, state: authState } = message;
      if (error40 && error40 !== "undefined") {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: `Failed to connect ${provider2} social account: ${error40}`
        });
        return;
      }
      if (state2 !== authState) {
        typedReject({
          code: SocialOAuthErrorCode.OAUTH_ERROR,
          message: `Failed to connect ${provider2} social account: Invalid random state`
        });
        return;
      }
      if (!code) {
        typedReject({
          code: SocialOAuthErrorCode.NO_AUTH_CODE,
          message: `Failed to connect ${provider2} social account: no authorization code`
        });
        return;
      }
      resolve(code);
      setIsProcessing(false);
    };
    if (!providersWaitingOauthMessage[provider]) {
      window.addEventListener("message", handleWindowMessage);
      providersWaitingOauthMessage[provider] = true;
    }
    initWebAuth().then(() => {
      authWindow === null || authWindow === void 0 ? void 0 : authWindow.location.assign(oauthLoginUrl);
      authWindowInterval = setInterval(() => {
        if (!(authWindow === null || authWindow === void 0 ? void 0 : authWindow.closed))
          return;
        clearInterval(authWindowInterval);
        setIsProcessing(false);
        if (providersWaitingOauthMessage[provider])
          typedReject({
            code: SocialOAuthErrorCode.USER_CANCELLED,
            message: "User cancelled connection"
          });
      }, 2e3);
    });
  })
});

// node_modules/@dynamic-labs/utils/src/services/Oauth2Service/Oauth2Service.js
var _a4;
var _Oauth2Service_implementation;
var Oauth2Service = class {
  static get implementation() {
    if (!__classPrivateFieldGet(_a4, _a4, "f", _Oauth2Service_implementation)) {
      return createWindowOauth2Service();
    }
    return __classPrivateFieldGet(_a4, _a4, "f", _Oauth2Service_implementation);
  }
  static set implementation(implementation) {
    __classPrivateFieldSet(_a4, _a4, implementation, "f", _Oauth2Service_implementation);
  }
  static get getOauthCode() {
    return _a4.implementation.getOauthCode;
  }
};
_a4 = Oauth2Service;
_Oauth2Service_implementation = { value: void 0 };
Oauth2Service.isGetOauthCodeError = (error40) => typeof error40 === "object" && "code" in error40 && Object.values(SocialOAuthErrorCode).includes(error40.code) && "message" in error40 && typeof error40.message === "string";

// node_modules/@dynamic-labs/utils/src/services/StorageService/createStorageService/createStorageService.js
var createStorageService = ({ storage }) => {
  const packValue = (value) => JSON.stringify(value);
  const unpackValue = (value) => JSON.parse(value);
  const getItem = (key) => {
    const value = storage.getItem(key);
    if (!value) {
      return void 0;
    }
    try {
      return unpackValue(value);
    } catch (error40) {
      logger2.error(`Error while parsing ${key} from local storage`, {
        value
      });
      removeItem(key);
      StorageService.events.emit("parseFailure", error40, key);
    }
    return void 0;
  };
  const setItem = (key, value) => {
    storage.setItem(key, packValue(value));
  };
  const removeItem = (key) => {
    storage.removeItem(key);
  };
  const getKeys = () => Object.keys(storage);
  return {
    getItem,
    getKeys,
    removeItem,
    setItem
  };
};

// node_modules/@dynamic-labs/utils/src/services/StorageService/StorageService.js
var StorageService = class _StorageService {
  static clearRegistry() {
    _StorageService.registry = {
      localStorage: void 0,
      secureStorage: void 0,
      sessionStorage: void 0
    };
  }
  static registerSourceStorage(source, implementation) {
    logger2.logVerboseTroubleshootingMessage("StorageService.registerSourceStorage", {
      implementation,
      source
    });
    _StorageService.registry[source] = implementation;
  }
  static getSourceStorage(source) {
    return _StorageService.registry[source];
  }
  static resolveStorage(options) {
    const priority = (options === null || options === void 0 ? void 0 : options.priority) || ["localStorage"];
    logger2.logVerboseTroubleshootingMessage("StorageService.resolveStorage", {
      options,
      priority
    });
    for (const source of priority) {
      const storage = _StorageService.getSourceStorage(source);
      if (storage) {
        return storage;
      }
    }
    if (priority.includes("localStorage")) {
      logger2.info("No available storage found based on the specified priority, defaulting to localStorage");
      return createStorageService({
        storage: localStorage
      });
    }
    if (priority.includes("sessionStorage")) {
      logger2.info("No available storage found based on the specified priority, defaulting to sessionStorage");
      return createStorageService({
        storage: sessionStorage
      });
    }
    logger2.logVerboseTroubleshootingMessage("No storage found  StorageService.registry:", _StorageService.registry);
    throw new Error("No available storage found based on the specified priority");
  }
  static getItem(key, options) {
    const storage = _StorageService.resolveStorage(options);
    return storage.getItem(key);
  }
  static setItem(key, value, options) {
    const storage = _StorageService.resolveStorage(options);
    storage.setItem(key, value);
  }
  static removeItem(key, options) {
    const storage = _StorageService.resolveStorage(options);
    storage.removeItem(key);
  }
  static getKeys(options) {
    return _StorageService.resolveStorage(options).getKeys();
  }
};
StorageService.registry = {
  localStorage: void 0,
  secureStorage: void 0,
  sessionStorage: void 0
};
StorageService.events = new eventemitter3_default();

// node_modules/@dynamic-labs/utils/src/services/StorageService/applyPostfixToStorageService/applyPostfixToStorageService.js
var applyPostfixToStorageService = ({ storage, postfix }) => {
  const getKeyWithPostfix = (key) => postfix ? `${key}_${postfix}` : key;
  return Object.assign(Object.assign({}, storage), { getItem: (key) => storage.getItem(getKeyWithPostfix(key)), removeItem: (key) => storage.removeItem(getKeyWithPostfix(key)), setItem: (key, data) => storage.setItem(getKeyWithPostfix(key), data) });
};

// node_modules/@dynamic-labs/utils/src/env/getEnvVarWithFallback.js
var getEnvVarWithFallback = (keys, defaultValue) => {
  if (typeof process === "undefined" || !process.env) {
    return defaultValue;
  }
  const keysToTry = Array.isArray(keys) ? keys : [keys];
  for (const key of keysToTry) {
    const value = process.env[key];
    if (value !== void 0) {
      return value;
    }
  }
  return defaultValue;
};

// node_modules/@dynamic-labs/utils/src/setupInsideIframe/utils/logger.js
var logger3 = new Logger("@dynamic-labs/iframe-setup");

// node_modules/@dynamic-labs/utils/src/index.js
assertPackageVersion("@dynamic-labs/utils", version);

// node_modules/@dynamic-labs/iconic/package.js
var version3 = "4.43.0";

// node_modules/@dynamic-labs/iconic/src/Iconic.js
var import_react = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/iconic/src/helpers/getIconicSpriteUrl.js
var DEFAULT_ICONIC_SPRITE_URL = "https://iconic.dynamic-static-assets.com/icons/sprite.svg";
var getIconicSpriteUrl = () => {
  var _a5, _b, _c;
  if (typeof process !== "undefined" && process.env) {
    return (_c = (_b = (_a5 = process.env["ICONIC_SPRITE_CDN_URL"]) !== null && _a5 !== void 0 ? _a5 : process.env["NEXT_PUBLIC_ICONIC_SPRITE_CDN_URL"]) !== null && _b !== void 0 ? _b : process.env["REACT_APP_ICONIC_SPRITE_CDN_URL"]) !== null && _c !== void 0 ? _c : DEFAULT_ICONIC_SPRITE_URL;
  }
  return DEFAULT_ICONIC_SPRITE_URL;
};

// node_modules/@dynamic-labs/iconic/src/Iconic.js
var ICONIC_SPRITE_URL = getIconicSpriteUrl();
var createIconic = (props) => {
  const Icon = Object.assign(Object.assign({}, props), { function: (props2) => {
    const url = `${ICONIC_SPRITE_URL}#${Icon.iconName}`;
    return (0, import_react.createElement)("img", Object.assign(Object.assign({ "data-testid": `iconic-${Icon.iconName}` }, props2), { alt: Icon.alt, src: url }));
  } });
  const IconicComponent = Icon.function.bind(Icon);
  Object.assign(IconicComponent, {
    iconName: Icon.iconName,
    sourcePath: Icon.sourcePath
  });
  return IconicComponent;
};

// node_modules/@dynamic-labs/iconic/src/icons/browsers/index.js
var BraveIcon = createIconic({
  alt: "Brave Browser",
  iconName: "brave",
  sourcePath: "icons/browsers/brave.svg"
});
var ChromeIcon = createIconic({
  alt: "Chrome Browser",
  iconName: "chrome",
  sourcePath: "icons/browsers/chrome.svg"
});
var EdgeIcon = createIconic({
  alt: "Edge Browser",
  iconName: "edge",
  sourcePath: "icons/browsers/edge.svg"
});
var FirefoxIcon = createIconic({
  alt: "Firefox Browser",
  iconName: "firefox",
  sourcePath: "icons/browsers/firefox.svg"
});
var OperaIcon = createIconic({
  alt: "Opera Browser",
  iconName: "opera",
  sourcePath: "icons/browsers/opera.svg"
});
var SafariIcon = createIconic({
  alt: "Opera Browser",
  iconName: "safari",
  sourcePath: "icons/browsers/safari.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/chains/index.js
var AleoIcon = createIconic({
  alt: "Aleo Chain",
  iconName: "aleo",
  sourcePath: "icons/chains/aleo.svg"
});
var AlgorandIcon = createIconic({
  alt: "Algorand Chain",
  iconName: "algorand",
  sourcePath: "icons/chains/algorand.svg"
});
var AptosIcon = createIconic({
  alt: "Aptos Chain",
  iconName: "aptos",
  sourcePath: "icons/chains/aptos.svg"
});
var ArbitrumIcon = createIconic({
  alt: "Arbitrum Chain",
  iconName: "arbitrum",
  sourcePath: "icons/chains/arbitrum.svg"
});
var AuroraIcon = createIconic({
  alt: "Aurora Chain",
  iconName: "aurora",
  sourcePath: "icons/chains/aurora.svg"
});
var AxelarIcon = createIconic({
  alt: "Axelar Chain",
  iconName: "axelar",
  sourcePath: "icons/chains/axelar.svg"
});
var BaseChainIcon = createIconic({
  alt: "Base Chain",
  iconName: "base",
  sourcePath: "icons/chains/base.svg"
});
var BerachainIcon = createIconic({
  alt: "Berachain Chain",
  iconName: "berachain",
  sourcePath: "icons/chains/berachain.svg"
});
var BitcoinIcon = createIconic({
  alt: "Bitcoin Chain",
  iconName: "bitcoin",
  sourcePath: "icons/chains/bitcoin.svg"
});
var BnbIcon = createIconic({
  alt: "BNB Chain",
  iconName: "bnb",
  sourcePath: "icons/chains/bnb.svg"
});
var CosmosIcon = createIconic({
  alt: "Cosmos Chain",
  iconName: "cosmos",
  sourcePath: "icons/chains/cosmos.svg"
});
var EclipseIcon = createIconic({
  alt: "Eclipse",
  iconName: "eclipse",
  sourcePath: "icons/chains/eclipse.svg"
});
var EthereumIcon = createIconic({
  alt: "Ethereum Chain",
  iconName: "ethereum",
  sourcePath: "icons/chains/ethereum.svg"
});
var FlowIcon = createIconic({
  alt: "Flow Chain",
  iconName: "flow",
  sourcePath: "icons/chains/flow.svg"
});
var GnosisIcon = createIconic({
  alt: "Gnosis Chain",
  iconName: "gnosis",
  sourcePath: "icons/chains/gnosis.svg"
});
var GoerliIcon = createIconic({
  alt: "Goerli Chain",
  iconName: "goerli",
  sourcePath: "icons/chains/goerli.svg"
});
var OptimismIcon = createIconic({
  alt: "Optimism Chain",
  iconName: "optimism",
  sourcePath: "icons/chains/optimism.svg"
});
var OsmosisIcon = createIconic({
  alt: "Osmosis Chain",
  iconName: "osmosis",
  sourcePath: "icons/chains/osmosis.svg"
});
var PalmIcon = createIconic({
  alt: "Palm Chain",
  iconName: "palm",
  sourcePath: "icons/chains/palm.svg"
});
var PolygonIcon = createIconic({
  alt: "Polygon Chain",
  iconName: "polygon",
  sourcePath: "icons/chains/polygon.svg"
});
var SeiIcon = createIconic({
  alt: "Sei Chain",
  iconName: "sei",
  sourcePath: "icons/chains/sei.svg"
});
var SolanaIcon = createIconic({
  alt: "Solana Chain",
  iconName: "solana",
  sourcePath: "icons/chains/solana.svg"
});
var SparkIcon = createIconic({
  alt: "Spark Chain",
  iconName: "spark",
  sourcePath: "icons/chains/spark.svg"
});
var StarknetIcon = createIconic({
  alt: "Starknet Chain",
  iconName: "starknet",
  sourcePath: "icons/chains/starknet.svg"
});
var StellarIcon = createIconic({
  alt: "Stellar Chain",
  iconName: "stellar",
  sourcePath: "icons/chains/stellar.svg"
});
var SuiIcon = createIconic({
  alt: "Sui Chain",
  iconName: "sui",
  sourcePath: "icons/chains/sui.svg"
});
var TonIcon = createIconic({
  alt: "Ton Chain",
  iconName: "ton",
  sourcePath: "icons/chains/ton.svg"
});
var TronIcon = createIconic({
  alt: "Tron Chain",
  iconName: "tron",
  sourcePath: "icons/chains/tron.svg"
});
var ZkSyncIcon = createIconic({
  alt: "zkSync Era Chain",
  iconName: "zkSync",
  sourcePath: "icons/chains/zkSync.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/onramps/index.js
var BanxaIcon = createIconic({
  alt: "Banxa",
  iconName: "banxa",
  sourcePath: "icons/onramps/banxa.svg"
});
var CoinbasePayIcon = createIconic({
  alt: "Coinbase Pay",
  iconName: "coinbase-pay",
  sourcePath: "icons/onramps/coinbase-pay.svg"
});
var CryptoDotComIcon = createIconic({
  alt: "Crypto.com",
  iconName: "crypto-dot-com",
  sourcePath: "icons/onramps/crypto-dot-com.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/social/index.js
var social_exports = {};
__export(social_exports, {
  AppleDarkSocialIcon: () => AppleDarkSocialIcon,
  AppleSocialIcon: () => AppleSocialIcon,
  BinanceSocialIcon: () => BinanceSocialIcon,
  BitbucketIcon: () => BitbucketIcon,
  CoinbaseSocialDarkIcon: () => CoinbaseSocialDarkIcon,
  CoinbaseSocialIcon: () => CoinbaseSocialIcon,
  DiscordIcon: () => DiscordIcon,
  EpicGamesDarkIcon: () => EpicGamesDarkIcon,
  EpicGamesIcon: () => EpicGamesIcon,
  FacebookIcon: () => FacebookIcon,
  FarcasterIcon: () => FarcasterIcon,
  GithubDarkIcon: () => GithubDarkIcon,
  GithubIcon: () => GithubIcon,
  GitlabIcon: () => GitlabIcon,
  GoogleIcon: () => GoogleIcon,
  HelpdeskIcon: () => HelpdeskIcon,
  InstagramIcon: () => InstagramIcon,
  KrakenDarkIcon: () => KrakenDarkIcon,
  KrakenIcon: () => KrakenIcon,
  LineIcon: () => LineIcon,
  LinkedinIcon: () => LinkedinIcon,
  MicrosoftIcon: () => MicrosoftIcon,
  OktaIcon: () => OktaIcon,
  OnePasswordDarkIcon: () => OnePasswordDarkIcon,
  OnePasswordIcon: () => OnePasswordIcon,
  ShopifyIcon: () => ShopifyIcon,
  SlackIcon: () => SlackIcon,
  SpotifyDarkIcon: () => SpotifyDarkIcon,
  SpotifyIcon: () => SpotifyIcon,
  SteamDarkIcon: () => SteamDarkIcon,
  SteamIcon: () => SteamIcon,
  TelegramIcon: () => TelegramIcon,
  TikTokDarkIcon: () => TikTokDarkIcon,
  TikTokIcon: () => TikTokIcon,
  TwitchDarkIcon: () => TwitchDarkIcon,
  TwitchIcon: () => TwitchIcon,
  TwitterDarkIcon: () => TwitterDarkIcon,
  TwitterIcon: () => TwitterIcon,
  YouTubeIcon: () => YouTubeIcon
});
var BitbucketIcon = createIconic({
  alt: "Bitbucket",
  iconName: "bitbucket",
  sourcePath: "icons/social/bitbucket.svg"
});
var DiscordIcon = createIconic({
  alt: "Discord",
  iconName: "discord",
  sourcePath: "icons/social/discord.svg"
});
var FacebookIcon = createIconic({
  alt: "Facebook",
  iconName: "facebook",
  sourcePath: "icons/social/facebook.svg"
});
var FarcasterIcon = createIconic({
  alt: "Farcaster",
  iconName: "farcaster",
  sourcePath: "icons/social/farcaster.svg"
});
var GithubIcon = createIconic({
  alt: "Github",
  iconName: "github",
  sourcePath: "icons/social/github.svg"
});
var GithubDarkIcon = createIconic({
  alt: "Github",
  iconName: "github-dark",
  sourcePath: "icons/social/github-dark.svg"
});
var GitlabIcon = createIconic({
  alt: "Gitlab",
  iconName: "gitlab",
  sourcePath: "icons/social/gitlab.svg"
});
var GoogleIcon = createIconic({
  alt: "Google",
  iconName: "google",
  sourcePath: "icons/social/google.svg"
});
var HelpdeskIcon = createIconic({
  alt: "Helpdesk",
  iconName: "helpdesk",
  sourcePath: "icons/social/helpdesk.svg"
});
var LinkedinIcon = createIconic({
  alt: "Linkedin",
  iconName: "linkedin",
  sourcePath: "icons/social/linkedin.svg"
});
var MicrosoftIcon = createIconic({
  alt: "Microsoft",
  iconName: "microsoft",
  sourcePath: "icons/social/microsoft.svg"
});
var SlackIcon = createIconic({
  alt: "Slack",
  iconName: "slack",
  sourcePath: "icons/social/slack.svg"
});
var TelegramIcon = createIconic({
  alt: "Telegram",
  iconName: "telegram",
  sourcePath: "icons/social/telegram.svg"
});
var TwitchIcon = createIconic({
  alt: "Twitch",
  iconName: "twitch",
  sourcePath: "icons/social/twitch.svg"
});
var TwitchDarkIcon = createIconic({
  alt: "Twitch",
  iconName: "twitch-dark",
  sourcePath: "icons/social/twitch-dark.svg"
});
var TwitterIcon = createIconic({
  alt: "Twitter",
  iconName: "twitter",
  sourcePath: "icons/social/twitter.svg"
});
var TwitterDarkIcon = createIconic({
  alt: "Twitter",
  iconName: "twitter-dark",
  sourcePath: "icons/social/twitter-dark.svg"
});
var AppleSocialIcon = createIconic({
  alt: "Apple",
  iconName: "apple",
  sourcePath: "icons/social/apple.svg"
});
var AppleDarkSocialIcon = createIconic({
  alt: "Apple",
  iconName: "apple-dark",
  sourcePath: "icons/social/apple-dark.svg"
});
var CoinbaseSocialIcon = createIconic({
  alt: "Coinbase",
  iconName: "coinbasesocial",
  sourcePath: "icons/social/coinbasesocial.svg"
});
var CoinbaseSocialDarkIcon = createIconic({
  alt: "Coinbase",
  iconName: "coinbasesocial-dark",
  sourcePath: "icons/social/coinbasesocial-dark.svg"
});
var InstagramIcon = createIconic({
  alt: "Instagram",
  iconName: "instagram",
  sourcePath: "icons/social/instagram.svg"
});
var YouTubeIcon = createIconic({
  alt: "YouTube",
  iconName: "youtube",
  sourcePath: "icons/social/youtube.svg"
});
var OnePasswordIcon = createIconic({
  alt: "onePassword",
  iconName: "one-password",
  sourcePath: "icons/social/onePassword.svg"
});
var OnePasswordDarkIcon = createIconic({
  alt: "onePassword-dark",
  iconName: "one-password-dark",
  sourcePath: "icons/social/onePassword-dark.svg"
});
var EpicGamesIcon = createIconic({
  alt: "epicGames",
  iconName: "epicgames",
  sourcePath: "icons/social/epicgames.svg"
});
var EpicGamesDarkIcon = createIconic({
  alt: "epicGames-dark",
  iconName: "epicgames-dark",
  sourcePath: "icons/social/epicgames-dark.svg"
});
var SpotifyIcon = createIconic({
  alt: "spotify",
  iconName: "spotify",
  sourcePath: "icons/social/spotify.svg"
});
var SpotifyDarkIcon = createIconic({
  alt: "spotify-dark",
  iconName: "spotify-dark",
  sourcePath: "icons/social/spotify-dark.svg"
});
var SteamIcon = createIconic({
  alt: "steam",
  iconName: "steam",
  sourcePath: "icons/social/steam.svg"
});
var SteamDarkIcon = createIconic({
  alt: "steam-dark",
  iconName: "steam-dark",
  sourcePath: "icons/social/steam-dark.svg"
});
var TikTokIcon = createIconic({
  alt: "tiktok",
  iconName: "tiktok",
  sourcePath: "icons/social/tiktok.svg"
});
var TikTokDarkIcon = createIconic({
  alt: "tiktok-dark",
  iconName: "tiktok-dark",
  sourcePath: "icons/social/tiktok-dark.svg"
});
var LineIcon = createIconic({
  alt: "line",
  iconName: "line",
  sourcePath: "icons/social/line.svg"
});
var ShopifyIcon = createIconic({
  alt: "shopify",
  iconName: "shopify",
  sourcePath: "icons/social/shopify.svg"
});
var KrakenIcon = createIconic({
  alt: "kraken",
  iconName: "kraken",
  sourcePath: "icons/social/kraken.svg"
});
var KrakenDarkIcon = createIconic({
  alt: "kraken-dark",
  iconName: "kraken-dark",
  sourcePath: "icons/social/kraken-dark.svg"
});
var BinanceSocialIcon = createIconic({
  alt: "binance",
  iconName: "binancesocial",
  sourcePath: "icons/social/binancesocial.svg"
});
var OktaIcon = createIconic({
  alt: "okta",
  iconName: "okta",
  sourcePath: "icons/social/okta.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/wallets/index.js
var OneInchIcon = createIconic({
  alt: "1inch Wallet",
  iconName: "1inch.svg",
  sourcePath: "icons/wallets/1inch.svg"
});
var ArgentXIcon = createIconic({
  alt: "Argent X Wallet",
  iconName: "argentx",
  sourcePath: "icons/wallets/argentx.svg"
});
var ArgentMobile = createIconic({
  alt: "Argent Mobile",
  iconName: "argentmobile",
  sourcePath: "icons/wallets/argent-mobile.svg"
});
var ArgentWebWallet = createIconic({
  alt: "Argent Web Wallet",
  iconName: "argentwebwallet",
  sourcePath: "icons/wallets/argent-web-wallet.svg"
});
var BackpackIcon = createIconic({
  alt: "Backpack Wallet",
  iconName: "backpack",
  sourcePath: "icons/wallets/backpack.svg"
});
var BinanceIcon = createIconic({
  alt: "Binance Wallet",
  iconName: "binance.svg",
  sourcePath: "icons/wallets/binance.svg"
});
var BitPayIcon = createIconic({
  alt: "BitPay Wallet",
  iconName: "bitpay.svg",
  sourcePath: "icons/wallets/bitpay.svg"
});
var BloctoIcon = createIconic({
  alt: "Blocto Wallet",
  iconName: "blocto",
  sourcePath: "icons/wallets/blocto.svg"
});
var BraavosIcon = createIconic({
  alt: "Braavos Wallet",
  iconName: "braavos",
  sourcePath: "icons/wallets/braavos.svg"
});
var ByBitIcon = createIconic({
  alt: "ByBit Wallet",
  iconName: "bybit",
  sourcePath: "icons/wallets/bybit.svg"
});
var Coin98Icon = createIconic({
  alt: "Coin98 Wallet",
  iconName: "coin98",
  sourcePath: "icons/wallets/coin98.svg"
});
var CoinbaseIcon = createIconic({
  alt: "Coinbase Wallet",
  iconName: "coinbase",
  sourcePath: "icons/wallets/coinbase.svg"
});
var CryptoIcon = createIconic({
  alt: "Crypto Wallet",
  iconName: "crypto.svg",
  sourcePath: "icons/wallets/crypto.svg"
});
var DapperIcon = createIconic({
  alt: "Dapper Wallet",
  iconName: "dapper",
  sourcePath: "icons/wallets/dapper.svg"
});
var DawnIcon = createIconic({
  alt: "Dawn Wallet",
  iconName: "dawn",
  sourcePath: "icons/wallets/dawn.svg"
});
var DefaultIcon = createIconic({
  alt: "Default Wallet",
  iconName: "defaultwallet",
  sourcePath: "icons/wallets/default.svg"
});
var EmailSignIcon = createIconic({
  alt: "Dapper Wallet",
  iconName: "emailsign.svg",
  sourcePath: "icons/wallets/emailsign.svg"
});
var SignInWithEmailIcon = createIconic({
  alt: "Sign in with Email",
  iconName: "signinwithemail",
  sourcePath: "icons/wallets/signinwithemail.svg"
});
var ExodusIcon = createIconic({
  alt: "Exodus Wallet",
  iconName: "exodus",
  sourcePath: "icons/wallets/exodus.svg"
});
var FireblocksIcon = createIconic({
  alt: "Fireblocks Wallet",
  iconName: "fireblocks",
  sourcePath: "icons/wallets/fireblocks.svg"
});
var FlowWalletIcon = createIconic({
  alt: "Flow Wallet",
  iconName: "flowwallet",
  sourcePath: "icons/wallets/flowwallet.svg"
});
var FordefiIcon = createIconic({
  alt: "Fordefi Wallet",
  iconName: "fordefi",
  sourcePath: "icons/wallets/fordefi.svg"
});
var FortmaticIcon = createIconic({
  alt: "Fortmatic Wallet",
  iconName: "fortmatic",
  sourcePath: "icons/wallets/fortmatic.svg"
});
var FrameIcon = createIconic({
  alt: "Frame Wallet",
  iconName: "frame",
  sourcePath: "icons/wallets/frame.svg"
});
var GamestopIcon = createIconic({
  alt: "Gamestop Wallet",
  iconName: "gamestop",
  sourcePath: "icons/wallets/gamestop.svg"
});
var GlowIcon = createIconic({
  alt: "Glow Wallet",
  iconName: "glow",
  sourcePath: "icons/wallets/glow.svg"
});
var ImTokenWallet = createIconic({
  alt: "ImToken Wallet",
  iconName: "imtoken.svg",
  sourcePath: "icons/wallets/imtoken.svg"
});
var InjectedWalletIcon = createIconic({
  alt: "Injected Wallet",
  iconName: "injectedwallet",
  sourcePath: "icons/wallets/injectedwallet.svg"
});
var KeplrIcon = createIconic({
  alt: "Keplr Wallet",
  iconName: "keplr",
  sourcePath: "icons/wallets/keplr.svg"
});
var LedgerIcon = createIconic({
  alt: "Ledger Wallet",
  iconName: "ledger",
  sourcePath: "icons/wallets/ledger.svg"
});
var LilicoIcon = createIconic({
  alt: "Lilico Wallet",
  iconName: "lilico",
  sourcePath: "icons/wallets/lilico.svg"
});
var LinenIcon = createIconic({
  alt: "Linen Wallet",
  iconName: "linen.svg",
  sourcePath: "icons/wallets/linen.svg"
});
var MaticIcon = createIconic({
  alt: "Matic Wallet",
  iconName: "matic",
  sourcePath: "icons/wallets/matic.svg"
});
var MetaMaskIcon = createIconic({
  alt: "MetaMask Wallet",
  iconName: "metamask",
  sourcePath: "icons/wallets/metamask.svg"
});
var MissingIcon = createIconic({
  alt: "Missing Wallet",
  iconName: "missing",
  sourcePath: "icons/wallets/missing.svg"
});
var MyalgoIcon = createIconic({
  alt: "MyAlgo Wallet",
  iconName: "myalgo",
  sourcePath: "icons/wallets/myalgo.svg"
});
var OmniIcon = createIconic({
  alt: "Omni Wallet",
  iconName: "omni",
  sourcePath: "icons/wallets/omni.svg"
});
var OpeanSeaIcon = createIconic({
  alt: "OpeanSea Wallet",
  iconName: "opeansea",
  sourcePath: "icons/wallets/opensea.svg"
});
var OylIcon = createIconic({
  alt: "Oyl Wallet",
  iconName: "oyl",
  sourcePath: "icons/wallets/oyl.svg"
});
var PasskeysWalletIcon = createIconic({
  alt: "Passkeys Wallet",
  iconName: "passkeys",
  sourcePath: "icons/wallets/passkeys.svg"
});
var PeraIcon = createIconic({
  alt: "Pera Wallet",
  iconName: "pera",
  sourcePath: "icons/wallets/pera.svg"
});
var PhantomIcon = createIconic({
  alt: "Phantom Wallet",
  iconName: "phantom",
  sourcePath: "icons/wallets/phantom.svg"
});
var RabbyIcon = createIconic({
  alt: "Rabby Wallet",
  iconName: "rabby",
  sourcePath: "icons/wallets/rabby.svg"
});
var RainbowIcon = createIconic({
  alt: "Rainbow Wallet",
  iconName: "rainbow",
  sourcePath: "icons/wallets/rainbow.svg"
});
var SafeIcon = createIconic({
  alt: "Safe Wallet",
  iconName: "safe",
  sourcePath: "icons/wallets/safe.svg"
});
var SequenceIcon = createIconic({
  alt: "Sequence Wallet",
  iconName: "sequence",
  sourcePath: "icons/wallets/sequence.svg"
});
var SlushIcon = createIconic({
  alt: "Slush  A Sui wallet",
  iconName: "slush",
  sourcePath: "icons/wallets/slush.svg"
});
var SolflareIcon = createIconic({
  alt: "Solflare Wallet",
  iconName: "solflare",
  sourcePath: "icons/wallets/solflare.svg"
});
var SpotIcon = createIconic({
  alt: "Spot Wallet",
  iconName: "spot",
  sourcePath: "icons/wallets/spot.svg"
});
var StrokeIcon = createIconic({
  alt: "Stroke Wallet",
  iconName: "stroke",
  sourcePath: "icons/wallets/stroke.svg"
});
var SuietIcon = createIconic({
  alt: "Suiet Wallet",
  iconName: "suiet",
  sourcePath: "icons/wallets/suiet.svg"
});
var TallyCashIcon = createIconic({
  alt: "Taho Wallet",
  iconName: "tallycash",
  sourcePath: "icons/wallets/tallycash.svg"
});
var TerraIcon = createIconic({
  alt: "Terra Wallet",
  iconName: "terra",
  sourcePath: "icons/wallets/terra.svg"
});
var TorusIcon = createIconic({
  alt: "Torus Wallet",
  iconName: "torus",
  sourcePath: "icons/wallets/torus.svg"
});
var TronLinkIcon = createIconic({
  alt: "TronLink Wallet",
  iconName: "tronlink",
  sourcePath: "icons/wallets/tronlink.svg"
});
var TrustIcon = createIconic({
  alt: "Trust Wallet",
  iconName: "trust",
  sourcePath: "icons/wallets/trust.svg"
});
var UnstoppableIcon = createIconic({
  alt: "Unstoppable Wallet",
  iconName: "unstoppable",
  sourcePath: "icons/wallets/unstoppable.svg"
});
var VenlyIcon = createIconic({
  alt: "Venly Wallet",
  iconName: "venly",
  sourcePath: "icons/wallets/venly.svg"
});
var WalletConnectIcon = createIconic({
  alt: "Wallet Connect Wallet",
  iconName: "walletconnect",
  sourcePath: "icons/wallets/walletconnect.svg"
});
var MagicLinkIcon = createIconic({
  alt: "Magic Link Wallet",
  iconName: "magiclink",
  sourcePath: "icons/wallets/magic-link.svg"
});
var TurnkeyIcon = createIconic({
  alt: "Turnkey",
  iconName: "turnkey",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var DynamicWaasIcon = createIconic({
  alt: "Dynamic Waas",
  iconName: "dynamicwaas",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var ZengoIcon = createIconic({
  alt: "Zengo Wallet",
  iconName: "zengo",
  sourcePath: "icons/wallets/zengo.svg"
});
var SuperbIcon = createIconic({
  alt: "Superb Wallet",
  iconName: "superb",
  sourcePath: "icons/wallets/superb.svg"
});
var ZeroDevIcon = createIconic({
  alt: "ZeroDev",
  iconName: "zerodev",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var SmartWalletIcon = createIconic({
  alt: "Smart Wallet",
  iconName: "smartwallet",
  sourcePath: "icons/wallets/smart-wallet.svg"
});
var MagicEdenIcon = createIconic({
  alt: "Magic Eden",
  iconName: "magiceden",
  sourcePath: "icons/wallets/magiceden.svg"
});
var XverseEdenIcon = createIconic({
  alt: "Xverse",
  iconName: "xverse",
  sourcePath: "icons/wallets/xverse.svg"
});
var UnisatIcon = createIconic({
  alt: "Unisat",
  iconName: "unisat",
  sourcePath: "icons/wallets/unisat.svg"
});
var LeatherIcon = createIconic({
  alt: "Leather",
  iconName: "leather",
  sourcePath: "icons/wallets/leather.svg"
});
var OkxIcon = createIconic({
  alt: "OKX",
  iconName: "okx",
  sourcePath: "icons/wallets/okx.svg"
});
var CoinbaseWaaSIcon = createIconic({
  alt: "Coinbase WaaS",
  iconName: "coinbasewaas",
  sourcePath: "icons/wallets/embedded-wallet.svg"
});
var MetaMaskStarknetIcon = createIconic({
  alt: "MetaMask Starknet Snap",
  iconName: "metamaskstarknetsnap",
  sourcePath: "icons/wallets/metamask-starknet.svg"
});
var NightlyIcon = createIconic({
  alt: "Nightly",
  iconName: "nightly",
  sourcePath: "icons/wallets/nightly.svg"
});
var OneKeyIcon = createIconic({
  alt: "OneKey",
  iconName: "onekey",
  sourcePath: "icons/wallets/onekey.svg"
});
var AmbireIcon = createIconic({
  alt: "Ambire",
  iconName: "ambire",
  sourcePath: "icons/wallets/ambire.svg"
});
var BitGetWalletIcon = createIconic({
  alt: "Bitget Wallet",
  iconName: "bitgetwallet",
  sourcePath: "icons/wallets/bitgetwallet.svg"
});
var MathWalletIcon = createIconic({
  alt: "Math Wallet",
  iconName: "coin98",
  sourcePath: "icons/wallets/coin98.svg"
});
var CloverWalletIcon = createIconic({
  alt: "Clover Wallet",
  iconName: "clover",
  sourcePath: "icons/wallets/clover.svg"
});
var UnknownWalletIcon = createIconic({
  alt: "Unknown Wallet",
  iconName: "unknown-wallet",
  sourcePath: "icons/wallets/unknown.svg"
});
var AbstractIcon = createIconic({
  alt: "Abstract",
  iconName: "abstract",
  sourcePath: "icons/wallets/abstract.svg"
});
var EdenOnlineIcon = createIconic({
  alt: "Eden Online",
  iconName: "edenonline",
  sourcePath: "icons/wallets/edenonline.svg"
});
var IntersendIcon = createIconic({
  alt: "Intersend",
  iconName: "intersend",
  sourcePath: "icons/wallets/intersend.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/mobile/index.js
var AppleIcon = createIconic({
  alt: "Apple",
  iconName: "apple",
  sourcePath: "icons/mobile/apple.svg"
});
var AndroidIcon = createIconic({
  alt: "Android",
  iconName: "android",
  sourcePath: "icons/mobile/android.svg"
});

// node_modules/@dynamic-labs/iconic/src/icons/misc/index.js
var CaptchaWaveIcon = createIconic({
  alt: "Captcha Wave",
  iconName: "captcha-wave",
  sourcePath: "icons/misc/captcha-wave.svg"
});
var UserProfileIcon = createIconic({
  alt: "User Profile",
  iconName: "user-profile",
  sourcePath: "icons/misc/user-profile.svg"
});
var ArrowSendIcon = createIconic({
  alt: "Arrow Send",
  iconName: "arrow-send",
  sourcePath: "icons/misc/arrow-send.svg"
});

// node_modules/@dynamic-labs/iconic/_virtual/_tslib.js
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}

// node_modules/@dynamic-labs/iconic/src/components/SocialIcon.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/iconic/src/logger.js
var logger4 = new Logger("iconic");

// node_modules/@dynamic-labs/iconic/src/components/getSocialIcon.js
var getSocialIcon = (name, variant = "light") => {
  const map = Object.fromEntries(Object.values(social_exports).map((icon2) => [icon2.iconName, icon2]));
  if (variant === "dark") {
    const darkIcon = map[`${name.toLowerCase()}-dark`];
    if (darkIcon)
      return darkIcon;
  }
  const icon = map[name.toLowerCase()];
  if (icon)
    return icon;
  throw new Error(`Icon ${name}, not found`);
};

// node_modules/@dynamic-labs/iconic/src/components/findSocialIcon.js
var findSocialIcon = (name, variant = "light") => {
  try {
    return getSocialIcon(name, variant);
  } catch (e) {
    logger4.error(e);
    return null;
  }
};

// node_modules/@dynamic-labs/iconic/src/components/SocialIcon.js
var SocialIcon = (_a5) => {
  var { name, variant } = _a5, props = __rest(_a5, ["name", "variant"]);
  const Icon = findSocialIcon(name, variant);
  if (!Icon)
    return null;
  return (0, import_react2.createElement)(Icon, props, null);
};

// node_modules/@dynamic-labs/iconic/src/index.js
assertPackageVersion("@dynamic-labs/iconic", version3);

// node_modules/@dynamic-labs/wallet-book/package.js
var version4 = "4.43.0";

// node_modules/@dynamic-labs/wallet-book/src/context/WalletBookContext.js
var import_react3 = __toESM(require_react(), 1);
var WalletBookContext = (0, import_react3.createContext)(void 0);
var useWalletBookContext = () => {
  const context = (0, import_react3.useContext)(WalletBookContext);
  if (context === void 0) {
    throw new Error("useWalletBookContext must be used within a WalletBookContextProvider");
  }
  return context;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletBookWallet.js
var getWalletBookWallet = (walletBook, walletKey, walletFallback) => {
  var _a5, _b, _c;
  if (!walletKey)
    throw new Error("Wallet key is required. Please pass in a wallet key to getWalletBookWallet");
  const walletData = (_b = (_a5 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) === null || _a5 === void 0 ? void 0 : _a5[walletKey]) !== null && _b !== void 0 ? _b : walletFallback;
  if (!walletData) {
    throw new Error(`Wallet ${walletKey} not found in wallet book (${Object.keys((_c = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _c !== void 0 ? _c : {}).length} wallets found)`);
  }
  return walletData;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/renderTemplate.js
var TEMPLATES = {
  androidUrl: "https://play.google.com/store/apps/details?id={{id}}",
  chromeUrl: "https://chrome.google.com/webstore/detail/{{id}}",
  edgeUrl: "https://microsoftedge.microsoft.com/addons/detail/{{id}}",
  firefoxUrl: "https://addons.mozilla.org/en-US/firefox/addon/{{id}}",
  iconicUrl: `${getIconicSpriteUrl()}#{{id}}`,
  iosUrl: "https://apps.apple.com/app/apple-store/{{id}}",
  walletConnectUrl: "https://registry.walletconnect.org/v2/logo/sm/{{id}}"
};
var renderTemplate = (templateName, data) => {
  if (!data)
    return void 0;
  return TEMPLATES[templateName].replace("{{id}}", data);
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getBrandIconUrl.js
var getBrandIconUrl = (brand) => {
  if (brand.spriteId) {
    return renderTemplate("iconicUrl", brand.spriteId);
  }
  return "";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/logger.js
var logger5 = new Logger("WalletBook");

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletIconUrl.js
var getDefaultWalletIconUrl = () => {
  try {
    return renderTemplate("iconicUrl", "defaultwallet");
  } catch (err) {
    logger5.error(err);
  }
  return "";
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletBookWallet.js
var findWalletBookWallet = (walletBook, walletKey) => {
  try {
    const walletData = getWalletBookWallet(walletBook, walletKey);
    return walletData;
  } catch (err) {
    return void 0;
  }
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletGroup.js
var getWalletGroup = (walletBook, key) => {
  const group = walletBook.groups[key];
  if (!group)
    throw new Error(`Group ${key} not found in wallet book`);
  return group;
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletGroup.js
var findWalletGroup = (walletBook, walletGroup) => {
  try {
    return getWalletGroup(walletBook, walletGroup);
  } catch (err) {
    logger5.error(err);
    return void 0;
  }
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletBookCdnUrl.js
var DEFAULT_WALLET_BOOK_CDN_URL = "https://dynamic-static-assets.com/wallet-book/v1/stable/wallet-book.json";
var getWalletBookCdnUrl = () => getEnvVarWithFallback([
  "WALLET_BOOK_CDN_URL",
  "NEXT_PUBLIC_WALLET_BOOK_CDN_URL",
  "REACT_APP_WALLET_BOOK_CDN_URL"
], DEFAULT_WALLET_BOOK_CDN_URL);

// node_modules/@dynamic-labs/wallet-book/src/helpers/findWalletGroupOverride.js
var findWalletGroupOverride = (walletBook, groupKey, walletKey) => {
  var _a5;
  const group = findWalletGroup(walletBook, groupKey);
  return (_a5 = group === null || group === void 0 ? void 0 : group.walletOverrides) === null || _a5 === void 0 ? void 0 : _a5[walletKey];
};

// node_modules/@dynamic-labs/wallet-book/src/helpers/isWalletBookPopulated.js
var isWalletBookPopulated = (walletBook) => {
  var _a5;
  return Object.keys((_a5 = walletBook === null || walletBook === void 0 ? void 0 : walletBook.wallets) !== null && _a5 !== void 0 ? _a5 : {}).length > 0;
};

// node_modules/@dynamic-labs/wallet-book/src/hooks/useWalletBookCdn.js
var import_react4 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/wallet-book/_virtual/_tslib.js
function __rest2(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter4(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/wallet-book/wallet-book-fallbacks.js
var groups = {
  argentx: {
    brand: {
      alt: "ArgentX",
      primaryColor: "#FF875B",
      spriteId: "argentx"
    },
    key: "argentx",
    name: "ArgentX"
  },
  backpack: {
    brand: {
      alt: "Backpack",
      spriteId: "backpack"
    },
    key: "backpack",
    name: "Backpack"
  },
  bitgetwallet: {
    brand: {
      alt: "Bitget Wallet",
      spriteId: "bitget"
    },
    key: "bitgetwallet",
    name: "Bitget"
  },
  blocto: {
    brand: {
      alt: "Blocto",
      primaryColor: "#5E678A",
      spriteId: "blocto"
    },
    key: "blocto",
    name: "Blocto"
  },
  brave: {
    brand: {
      alt: "Brave Browser",
      primaryColor: "#4B49C6",
      spriteId: "brave"
    },
    key: "brave",
    name: "Brave"
  },
  coin98: {
    brand: {
      alt: "Coin98 Wallet",
      primaryColor: "#CDA349",
      spriteId: "fc460647-ea95-447a-99f0-1bff8fa4be00"
    },
    key: "coin98",
    name: "Coin98"
  },
  coinbase: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    key: "coinbase",
    name: "Coinbase"
  },
  compasswallet: {
    brand: {
      alt: "Compass",
      primaryColor: "#4B49C6",
      spriteId: "1d7dea00-96be-4ce8-ca15-d14bddbb5000"
    },
    key: "compasswallet",
    name: "Compass"
  },
  exodus: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    key: "exodus",
    name: "Exodus"
  },
  fireblocks: {
    brand: {
      alt: "Fireblocks",
      spriteId: "fireblocks"
    },
    key: "fireblocks",
    name: "Fireblocks"
  },
  flowwallet: {
    brand: {
      alt: "Flow Wallet",
      primaryColor: "#2BE829",
      spriteId: "flowwallet"
    },
    key: "flowwallet",
    name: "Flow Wallet"
  },
  keplr: {
    brand: {
      alt: "Keplr",
      spriteId: "keplr"
    },
    key: "keplr",
    name: "Keplr"
  },
  magiceden: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    key: "magiceden",
    name: "Magic Eden"
  },
  mathwallet: {
    brand: {
      alt: "MathWallet Wallet",
      spriteId: "26a8f588-3231-4411-60ce-5bb6b805a700"
    },
    key: "mathwallet",
    name: "Math Wallet"
  },
  metamask: {
    brand: {
      alt: "MetaMask",
      primaryColor: "#E2761B",
      spriteId: "metamask"
    },
    key: "metamask",
    name: "MetaMask"
  },
  nightly: {
    brand: {
      alt: "Nightly Wallet",
      spriteId: "nightly"
    },
    key: "nightly",
    name: "Nightly"
  },
  okxwallet: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    key: "okxwallet",
    name: "OKX Wallet"
  },
  onekey: {
    brand: {
      alt: "OneKey Wallet",
      spriteId: "onekey"
    },
    key: "onekey",
    name: "OneKey"
  },
  phantom: {
    brand: {
      alt: "Phantom",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    key: "phantom",
    name: "Phantom"
  },
  tronlinkwallet: {
    brand: {
      alt: "TronLink Wallet",
      primaryColor: "#1677FF",
      spriteId: "tronlink"
    },
    key: "tronlink",
    name: "TronLink"
  },
  trust: {
    brand: {
      alt: "Trust Wallet",
      spriteId: "trust"
    },
    key: "trust",
    name: "Trust"
  },
  walletconnect: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    key: "walletconnect",
    name: "WalletConnect"
  },
  xverse: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    key: "xverse",
    name: "Xverse"
  }
};
var wallets = {
  metamask: {
    brand: {
      alt: "MetaMask Wallet",
      primaryColor: "#E8831D",
      spriteId: "metamask"
    },
    chainGroup: "metamask",
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:42161",
      "eip155:42170",
      "eip155:7777777",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453"
    ],
    desktop: {
      chromeId: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edgeId: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefoxId: "ether-metamask"
    },
    eip6963Config: {
      rdns: "io.metamask"
    },
    filterFromWalletConnect: true,
    group: "metamask",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isMetaMask",
            value: true
          },
          {
            flag: "isDawn",
            value: false
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isTrustWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isZerion",
            value: false
          },
          {
            flag: "isSuperb",
            value: false
          },
          {
            flag: "isRabby",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          },
          {
            flag: "isRainbow",
            value: false
          },
          {
            flag: "isAvalanche",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isZerion",
            value: false
          },
          {
            flag: "isOneKey",
            value: false
          },
          {
            flag: "isPhantom",
            value: false
          },
          {
            flag: "isCoin98",
            value: false
          },
          {
            flag: "isBinance",
            value: false
          }
        ]
      }
    ],
    mobile: {
      androidId: "io.metamask",
      inAppBrowser: "https://metamask.app.link/dapp",
      inAppBrowserV2: "https://metamask.app.link/dapp/{{dappURI}}",
      iosId: "id1438144202",
      native: "metamask://wc",
      universal: "https://metamask.app.link/wc"
    },
    name: "MetaMask",
    shortName: "MetaMask",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  coinbase: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    chainGroup: "coinbase",
    desktop: {
      chromeId: "hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    eip6963Config: {
      rdns: "com.coinbase.wallet"
    },
    group: "coinbase",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isCoinbaseWallet",
            value: true
          }
        ],
        windowLocations: [
          "coinbaseWalletExtension"
        ]
      }
    ],
    mobile: {
      androidId: "org.toshi",
      inAppBrowserV2: "https://go.cb-w.com/dapp?cb_url={{encodedDappURI}}",
      iosId: "id1278383455"
    },
    name: "Coinbase",
    shortName: "Coinbase Wallet"
  },
  coinbasesolana: {
    brand: {
      alt: "Coinbase Wallet",
      primaryColor: "#1648F9",
      spriteId: "coinbase"
    },
    chainGroup: "coinbase",
    desktop: {
      chromeId: "hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    group: "coinbase",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [],
        windowLocations: [
          "coinbaseSolana"
        ]
      }
    ],
    mobile: {
      androidId: "org.toshi",
      inAppBrowser: "https://go.cb-w.com/dapp?cb_url={{encodedDappURI}}",
      inAppBrowserV2: "https://go.cb-w.com/dapp?cb_url={{encodedDappURI}}",
      iosId: "id1278383455"
    },
    mobileExperience: "in-app-browser",
    name: "Coinbase",
    shortName: "Coinbase Wallet (Solana)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  phantom: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isGlow",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          }
        ],
        walletStandardLocators: [
          {
            locator: "features.phantom:.phantom",
            name: "Phantom"
          }
        ],
        windowLocations: [
          "phantom.solana"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    mobileExperience: "redirect",
    name: "Phantom"
  },
  phantombtc: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          }
        ],
        walletStandard: {
          features: [
            "bitcoin:connect"
          ],
          name: "Phantom"
        },
        windowLocations: [
          "phantom.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (Bitcoin)"
  },
  phantomevm: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          }
        ],
        windowLocations: [
          "phantom.ethereum"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    mobileExperience: "in-app-browser",
    name: "Phantom",
    shortName: "Phantom (EVM)"
  },
  phantomledger: {
    brand: {
      alt: "Phantom Wallet",
      primaryColor: "#4B49C6",
      spriteId: "phantom"
    },
    chainGroup: "phantom",
    desktop: {
      chromeId: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      firefoxId: "phantom-app"
    },
    group: "phantom",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isBraveWallet",
            value: false
          },
          {
            flag: "isExodus",
            value: false
          },
          {
            flag: "isMagicEden",
            value: false
          },
          {
            flag: "isGlow",
            value: false
          },
          {
            flag: "isOKExWallet",
            value: false
          },
          {
            flag: "isOkxWallet",
            value: false
          }
        ],
        walletStandardLocators: [
          {
            locator: "features.phantom:.phantom",
            name: "Phantom"
          }
        ],
        windowLocations: [
          "phantom.solana"
        ]
      }
    ],
    mobile: {
      androidId: "app.phantom",
      iosId: "id1598432977"
    },
    name: "Phantom",
    shortName: "Phantom (Ledger)"
  },
  walletconnect: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    chainGroup: "walletconnect",
    group: "walletconnect",
    mobile: {
      androidId: "enable-android",
      iosId: "id1438144202"
    },
    name: "WalletConnect",
    shortName: "WalletConnect"
  },
  walletconnectsol: {
    brand: {
      alt: "WalletConnect",
      primaryColor: "#3182CE",
      spriteId: "walletconnect"
    },
    chainGroup: "walletconnect",
    group: "walletconnect",
    mobile: {
      androidId: "enable-android",
      iosId: "id1438144202"
    },
    name: "WalletConnect"
  },
  argentx: {
    brand: {
      alt: "Argent X Wallet",
      primaryColor: "#FF875B",
      spriteId: "argentx"
    },
    desktop: {
      chromeId: "dlcobpjiigpikoobohmabehhmhfoodbb",
      edgeId: "ajcicjlkibolbeaaagejfhnofogocgcj",
      firefoxId: "argent-x"
    },
    name: "Ready Wallet (formerly Argent)",
    shortName: "Ready Wallet (formerly Argent)"
  },
  perawallet: {
    brand: {
      alt: "Pera Wallet",
      spriteId: "pera"
    },
    mobile: {
      androidId: "com.algorand.android",
      iosId: "id1459898525"
    },
    name: "Pera Wallet"
  },
  blocto: {
    brand: {
      alt: "Blocto Wallet",
      primaryColor: "#5E678A",
      spriteId: "blocto"
    },
    chainGroup: "blocto",
    group: "blocto",
    mobile: {
      androidId: "com.portto.blocto",
      iosId: "id1481181682"
    },
    name: "Blocto",
    shortName: "Blocto (Flow)"
  },
  solflare: {
    brand: {
      alt: "Solflare Wallet",
      primaryColor: "#FC7227",
      spriteId: "solflare"
    },
    chains: [
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "bhhhlbepdkbapadjdnnojkbgioiodbic"
    },
    filterFromWalletConnect: true,
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isSolflare",
            value: true
          }
        ],
        windowLocations: [
          "solflare"
        ]
      }
    ],
    mobile: {
      androidId: "com.solflare.mobile",
      iosId: "id1580902717"
    },
    name: "Solflare",
    walletConnect: {
      sdks: [
        "sign_v1"
      ]
    },
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  braavos: {
    brand: {
      alt: "Braavos Wallet",
      primaryColor: "#FABB38",
      spriteId: "braavos"
    },
    desktop: {
      chromeId: "jnlgamecbpmbajjfhmmmlhejkemejdma",
      edgeId: "hkkpjehhcnhgefhbdcgfkeegglpjchdc",
      firefoxId: "braavos-wallet"
    },
    injectedConfig: [
      {
        chain: "starknet",
        extensionLocators: [],
        windowLocations: [
          "braavos"
        ]
      }
    ],
    mobile: {
      androidId: "app.braavos.wallet",
      inAppBrowser: "https://link.braavos.app/dapp/{{encodedDappURI}}",
      inAppBrowserV2: "https://link.braavos.app/dapp/{{encodedDappURI}}",
      iosId: "id1636013523"
    },
    name: "Braavos"
  },
  trust: {
    brand: {
      alt: "Trust Wallet",
      primaryColor: "#0500FF",
      spriteId: "7677b54f-3486-46e2-4e37-bf8747814f00"
    },
    chainGroup: "trust",
    chains: [
      "cosmos:cosmoshub-4",
      "cosmos:kava-4",
      "cosmos:thorchain-mainnet-v1",
      "eip155:1",
      "eip155:10",
      "eip155:100",
      "eip155:108",
      "eip155:1101",
      "eip155:128",
      "eip155:137",
      "eip155:2020",
      "eip155:288",
      "eip155:321",
      "eip155:324",
      "eip155:361",
      "eip155:42161",
      "eip155:42220",
      "eip155:43114",
      "eip155:4689",
      "eip155:56",
      "eip155:56288",
      "eip155:59144",
      "eip155:60",
      "eip155:80084",
      "eip155:80085",
      "eip155:820",
      "eip155:88",
      "eip155:9001",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "egjidjbpglichdcondbcbdnbeeppgdph"
    },
    eip6963Config: {
      rdns: "com.trustwallet.app"
    },
    filterFromWalletConnect: true,
    group: "trust",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isTrustWallet",
            value: true
          }
        ],
        windowLocations: [
          "trustWallet"
        ]
      }
    ],
    mobile: {
      androidId: "com.wallet.crypto.trustapp",
      inAppBrowserV2: "https://link.trustwallet.com/open_url?url={{encodedDappURI}}",
      iosId: "id1288339409",
      native: "trust://wc",
      universal: "https://link.trustwallet.com/wc"
    },
    name: "Trust",
    shortName: "Trust",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  rainbow: {
    brand: {
      alt: "Rainbow Wallet",
      primaryColor: "#001e59",
      spriteId: "rainbow"
    },
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:137",
      "eip155:42161",
      "eip155:56",
      "eip155:7777777",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453"
    ],
    desktop: {
      chromeId: "opfgelmcmbiajamepnmloijbpoleiama",
      edgeId: "cpojfbodiccabbabgimdeohkkpjfpbnf",
      firefoxId: "rainbow-extension"
    },
    eip6963Config: {
      rdns: "me.rainbow"
    },
    filterFromWalletConnect: true,
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isRainbow",
            value: true
          }
        ],
        windowLocations: [
          "rainbow"
        ]
      }
    ],
    mobile: {
      androidId: "me.rainbow",
      inAppBrowserV2: "rainbow://dapp?url={{encodedDappURI}}",
      iosId: "id1457119021",
      native: "rainbow://wc",
      universal: "https://rnbwapp.com/wc"
    },
    name: "Rainbow",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  dapper: {
    brand: {
      alt: "Dapper Wallet",
      primaryColor: "#762FBE",
      spriteId: "dapper"
    },
    mobile: {
      android: "fake-to-get-dapper-to-appear",
      ios: "fake-to-get-dapper-to-appear"
    },
    name: "Dapper"
  },
  glow: {
    brand: {
      alt: "Glow Wallet",
      spriteId: "glow"
    },
    desktop: {
      chromeId: "ojbcfhjmpigfobfclfflafhblgemeidi",
      edgeId: "niihfokdlimbddhfmngnplgfcgpmlido",
      firefoxId: "glow-solana-wallet"
    },
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isGlow",
            value: true
          }
        ],
        windowLocations: [
          "glowSolana"
        ]
      }
    ],
    name: "Glow"
  },
  lilico: {
    brand: {
      alt: "Lilico Wallet",
      spriteId: "lilico"
    },
    desktop: {
      chromeId: "hpclkefagolihohboafpheddmmgdffjm"
    },
    filterFromWalletConnect: true,
    name: "Lilico"
  },
  flowwalletflow: {
    brand: {
      alt: "Flow Wallet",
      spriteId: "flowwallet"
    },
    chainGroup: "flowwallet",
    desktop: {
      chromeId: "hpclkefagolihohboafpheddmmgdffjm"
    },
    filterFromWalletConnect: true,
    group: "flowwallet",
    name: "Flow Wallet"
  },
  magicemailotp: {
    brand: {
      alt: "Magic Email OTP",
      spriteId: "magiclink"
    },
    name: "Magic Email OTP"
  },
  magiclink: {
    brand: {
      alt: "Magic Link",
      spriteId: "magiclink"
    },
    name: "Magic Link"
  },
  magicsocial: {
    brand: {
      alt: "Magic Social",
      spriteId: "magiclink"
    },
    name: "Magic Social"
  },
  magiceden: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    eip6963Config: {
      rdns: "io.magiceden.wallet"
    },
    filterFromWalletConnect: true,
    group: "magiceden",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isMagicEden",
            value: true
          }
        ],
        windowLocations: [
          "magicEden.ethereum"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      inAppBrowser: "magiceden://browser",
      inAppBrowserV2: "magiceden://browser/{{encodedDappURI}}",
      iosId: "id6478631482",
      native: "magiceden://wc",
      universal: "https://magiceden.io/browser"
    },
    name: "Magic Eden"
  },
  magicedenbtc: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    group: "magiceden",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Magic Eden"
        },
        windowLocations: [
          "magicEden.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      inAppBrowser: "magiceden://browser/{{encodedDappURI}}",
      inAppBrowserV2: "magiceden://browser/{{encodedDappURI}}",
      iosId: "id6478631482",
      universal: "https://magiceden.io/browser/{{encodedDappURI}}"
    },
    mobileExperience: "in-app-browser",
    name: "Magic Eden",
    shortName: "Magic Eden (Bitcoin)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  magicedensol: {
    brand: {
      alt: "Magic Eden",
      spriteId: "magiceden"
    },
    chainGroup: "magiceden",
    desktop: {
      chromeId: "mkpegjkblkkefacfnmkajcjmabijhclg"
    },
    group: "magiceden",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isMagicEden",
            value: true
          }
        ],
        windowLocations: [
          "magicEden.solana"
        ]
      }
    ],
    mobile: {
      androidId: "com.magiceden.wallet",
      inAppBrowser: "magiceden://browser/{{encodedDappURI}}",
      inAppBrowserV2: "magiceden://browser/{{encodedDappURI}}",
      iosId: "id6478631482",
      universal: "https://magiceden.io/browser/{{encodedDappURI}}"
    },
    name: "Magic Eden",
    shortName: "Magic Eden (Solana)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  exodus: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "4c16cad4-cac9-4643-6726-c696efaf5200"
    },
    chainGroup: "exodus",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56",
      "eip155:80084",
      "eip155:80085",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    filterFromWalletConnect: true,
    group: "exodus",
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc",
      universal: "https://exodus.com/m/wc"
    },
    name: "Exodus",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  exodusevm: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    chainGroup: "exodus",
    chains: [
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    eip6963Config: {
      rdns: "com.exodus.web3-wallet"
    },
    filterFromWalletConnect: true,
    group: "exodus",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isExodus",
            value: true
          }
        ]
      }
    ],
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc"
    },
    name: "Exodus",
    shortName: "Exodus Wallet (EVM)",
    walletConnect: {
      sdks: [
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  exodussol: {
    brand: {
      alt: "Exodus Wallet",
      spriteId: "exodus"
    },
    chainGroup: "exodus",
    chains: [
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "aholpfdialjgjfhomihkjbmgjidlcdno"
    },
    group: "exodus",
    injectedConfig: [
      {
        chain: "sol",
        extensionLocators: [
          {
            flag: "isPhantom",
            value: true
          },
          {
            flag: "isExodus",
            value: true
          }
        ],
        windowLocations: [
          "exodus.solana"
        ]
      }
    ],
    mobile: {
      androidId: "exodusmovement.exodus",
      iosId: "id1414384820",
      native: "exodus://wc"
    },
    name: "Exodus",
    shortName: "Exodus Wallet (Solana)",
    walletConnect: {
      sdks: [
        "sign_v2",
        "auth_v1"
      ]
    }
  },
  okxwallet: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    chains: [
      "bip122:000000000019d6689c085ae165831e93",
      "bip122:000000000933ea01ad0ee984209779ba",
      "eip155:1",
      "eip155:137",
      "eip155:43114",
      "eip155:56",
      "eip155:66",
      "eip155:80084",
      "eip155:80085",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp"
    ],
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    eip6963Config: {
      rdns: "com.okex.wallet"
    },
    filterFromWalletConnect: true,
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isOKExWallet",
            value: true
          },
          {
            flag: "isOkxWallet",
            value: true
          }
        ],
        windowLocations: [
          "okxwallet"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      inAppBrowserV2: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470",
      native: "okxwallet://main/wc"
    },
    name: "OKX Wallet",
    shortName: "OKX Wallet",
    walletConnect: {
      sdks: [
        "sign_v2"
      ]
    }
  },
  backpack: {
    brand: {
      alt: "Backpack",
      primaryColor: "#e43c3c",
      spriteId: "backpack"
    },
    chainGroup: "backpack",
    chains: [
      "eip155:1",
      "eip155:10",
      "eip155:10143",
      "eip155:137",
      "eip155:42161",
      "eip155:80084",
      "eip155:80085",
      "eip155:8453",
      "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
      "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
      "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
    ],
    desktop: {
      chromeId: "aflkmfhebedbjioipglgcbcmnbpgliof"
    },
    eip6963Config: {
      rdns: "app.backpack"
    },
    filterFromWalletConnect: true,
    group: "backpack",
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: [
          {
            flag: "isBackpack",
            value: true
          }
        ],
        windowLocations: []
      }
    ],
    mobile: {
      androidId: "app.backpack.mobile",
      iosId: "id6445964121",
      native: "backpack://wc"
    },
    name: "Backpack",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  okxwalletbtc: {
    brand: {
      alt: "OKX Wallet",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "okxwallet.bitcoin"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      inAppBrowserV2: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470"
    },
    mobileExperience: "in-app-browser",
    name: "OKX Wallet",
    shortName: "OKX Wallet (Bitcoin)",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  unisat: {
    brand: {
      alt: "UniSat",
      spriteId: "unisat"
    },
    desktop: {
      chromeId: "ppbibelpcjmhbdihakflkdcoccbgbkpo"
    },
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "unisat"
        ]
      }
    ],
    name: "UniSat"
  },
  unknown: {
    brand: {
      spriteId: "unknown-wallet"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1234567890"
    },
    name: "Unknown Wallet",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  xverse: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    chainGroup: "xverse",
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    group: "xverse",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Xverse",
          providerId: "XverseProviders.BitcoinProvider"
        },
        windowLocations: [
          "XverseProviders.BitcoinProvider"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      inAppBrowserV2: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    name: "Xverse",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  fallbackconnector: {
    brand: {
      spriteId: "unknown-wallet"
    },
    mobile: {
      androidId: "enable-android",
      iosId: "id1234567890"
    },
    name: "Fallback Connector",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  },
  oylwallet: {
    brand: {
      alt: "Oyl Wallet",
      spriteId: "oyl"
    },
    desktop: {
      chromeId: "ilolmnhjbbggkmopnemiphomhaojndmb"
    },
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "oyl"
        ]
      }
    ],
    name: "Oyl Wallet"
  },
  abstract: {
    brand: {
      alt: "Abstract",
      spriteId: "abstract"
    },
    chains: [
      "eip155:11124",
      "eip155:2741"
    ],
    desktop: {
      universal: "https://portal.abs.xyz/profile"
    },
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: []
      }
    ],
    name: "Abstract",
    walletConnect: {
      sdks: [
        "sign_v1",
        "sign_v2"
      ]
    }
  },
  edenonline: {
    brand: {
      alt: "Eden Online",
      spriteId: "edenonline"
    },
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: []
      }
    ],
    name: "Eden Online"
  },
  onekeybtc: {
    brand: {
      alt: "OneKey Wallet",
      spriteId: "onekey"
    },
    chainGroup: "onekey",
    desktop: {
      chromeId: "jnmbobjmhlngoefaiojfljckilhhlhcj"
    },
    group: "onekey",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "$onekey.btc"
        ]
      }
    ],
    mobile: {
      androidId: "so.onekey.app.wallet",
      iosId: "id1609559473"
    },
    mobileExperience: "in-app-browser",
    name: "OneKey"
  },
  intersend: {
    brand: {
      alt: "Intersend",
      spriteId: "intersend"
    },
    injectedConfig: [
      {
        chain: "evm",
        extensionLocators: []
      }
    ],
    name: "Intersend"
  },
  okxeclipse: {
    brand: {
      alt: "OKX Wallet",
      primaryColor: "#FABB38",
      spriteId: "okx"
    },
    chainGroup: "okxwallet",
    desktop: {
      chromeId: "mcohilncbfahbmgdjkbpemcciiolgcge"
    },
    group: "okxwallet",
    injectedConfig: [
      {
        chain: "eclipse",
        extensionLocators: [
          {
            flag: "isOKExWallet",
            value: true
          },
          {
            flag: "isOkxWallet",
            value: true
          }
        ],
        windowLocations: [
          "okxwallet.solana"
        ]
      }
    ],
    mobile: {
      androidId: "com.okinc.okex.gp",
      inAppBrowser: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      inAppBrowserV2: "okx://wallet/dapp/url?dappUrl={{encodedDappURI}}",
      iosId: "id1327268470"
    },
    name: "OKX Wallet"
  },
  dynamicwaas: {
    brand: {
      alt: "Dynamic Waas",
      primaryColor: "#4779ff",
      spriteId: "dynamicwaas"
    },
    name: "Dynamic Waas"
  },
  nightlyeclipse: {
    brand: {
      alt: "Nightly Wallet",
      spriteId: "nightly"
    },
    chainGroup: "nightly",
    desktop: {
      chromeId: "fiikommddbeccaoicoejoniammnalkfa",
      edgeId: "fiikommddbeccaoicoejoniammnalkfa",
      operaId: "fiikommddbeccaoicoejoniammnalkfa"
    },
    group: "nightly",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "eclipse",
        extensionLocators: [],
        walletStandard: {
          features: [
            "standard:connect",
            "standard:disconnect",
            "solana:signMessage",
            "solana:signTransaction",
            "solana:signAndSendTransaction"
          ],
          name: "Nightly"
        }
      }
    ],
    name: "Nightly"
  },
  bitgetwalletbtc: {
    brand: {
      alt: "Bitget Wallet",
      spriteId: "bitgetwallet"
    },
    chainGroup: "bitgetwallet",
    group: "bitgetwallet",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "bitkeep.unisat"
        ]
      }
    ],
    mobile: {
      androidId: "com.bitkeep.wallet",
      inAppBrowser: "https://bkcode.vip?action=dapp&url={{encodedDappURI}}",
      inAppBrowserV2: "https://bkcode.vip?action=dapp&url={{encodedDappURI}}",
      iosId: "id1395301115"
    },
    name: "Bitget Wallet"
  },
  backpackeclipse: {
    brand: {
      alt: "Backpack",
      primaryColor: "#e43c3c",
      spriteId: "backpack"
    },
    chainGroup: "backpack",
    desktop: {
      chromeId: "aflkmfhebedbjioipglgcbcmnbpgliof"
    },
    group: "backpack",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "eclipse",
        extensionLocators: [
          {
            flag: "isBackpack",
            value: true
          }
        ],
        windowLocations: [
          "backpack"
        ]
      }
    ],
    mobile: {
      androidId: "app.backpack.mobile",
      inAppBrowser: "backpack://ul/v1/browse/{{encodedDappURI}}",
      inAppBrowserV2: "backpack://ul/v1/browse/{{encodedDappURI}}",
      iosId: "id6445964121"
    },
    mobileExperience: "in-app-browser",
    name: "Backpack"
  },
  binancewalletbtc: {
    brand: {
      alt: "Binance Wallet",
      spriteId: "binance"
    },
    chainGroup: "binance",
    group: "binance",
    injectedConfig: [
      {
        chain: "btc",
        extensionLocators: [],
        windowLocations: [
          "binancew3w.bitcoin"
        ]
      }
    ],
    name: "Binance Wallet",
    shortName: "Binance"
  },
  xversestarknet: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    chainGroup: "xverse",
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    group: "xverse",
    injectedConfig: [
      {
        chain: "starknet",
        extensionLocators: [],
        windowLocations: [
          "xverse"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      inAppBrowserV2: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    name: "Xverse"
  },
  xversespark: {
    brand: {
      alt: "Xverse Wallet",
      spriteId: "xverse"
    },
    chainGroup: "xverse",
    desktop: {
      chromeId: "idnnbdplmphpflfnlkomgpfbpcgelopg"
    },
    group: "xverse",
    hardwareWallets: [
      "ledger"
    ],
    injectedConfig: [
      {
        chain: "spark",
        extensionLocators: [],
        walletStandard: {
          features: [
            "sats-connect:"
          ],
          name: "Xverse",
          providerId: "XverseProviders.SparkProvider"
        },
        windowLocations: [
          "XverseProviders.SparkProvider"
        ]
      }
    ],
    mobile: {
      androidId: "com.secretkeylabs.xverse",
      inAppBrowser: "xverse://browser?url={{encodedDappURI}}",
      inAppBrowserV2: "xverse://browser?url={{encodedDappURI}}",
      iosId: "id1552272513"
    },
    mobileExperience: "in-app-browser",
    name: "Xverse",
    walletLimitations: {
      browserExtension: {
        unsupportedMethods: [
          "getConnectedAccounts"
        ]
      }
    }
  }
};
var walletBookFallbacks = {
  groups,
  wallets
};

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse2,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version5
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    var _a5;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a5 = inst._zod).traits ?? (_a5.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer2(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a5;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a5 = inst._zod).deferred ?? (_a5.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a5, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a5 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a5.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  const set = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  var _a5;
  if (typeof navigator !== "undefined" && ((_a5 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a5.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  var _a5;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a5 = x.issues[i]) == null ? void 0 : _a5.continue) !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a5;
    (_a5 = iss).path ?? (_a5.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a5, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a5 = iss.inst) == null ? void 0 : _a5._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error40, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error40.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error40, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error41) => {
    for (const issue2 of error41.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error40);
  return fieldErrors;
}
function treeifyError(error40, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error41, path = []) => {
    var _a5, _b;
    for (const issue2 of error41.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a5 = curr.properties)[el] ?? (_a5[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error40);
  return result;
}
function toDotPath(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error40) {
  var _a5;
  const lines = [];
  const issues = [...error40.issues].sort((a, b) => a.path.length - b.path.length);
  for (const issue2 of issues) {
    lines.push(` ${issue2.message}`);
    if ((_a5 = issue2.path) == null ? void 0 : _a5.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
var parse2 = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version8) => {
  if (!version8)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version8}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a5;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a5 = inst._zod).onattach ?? (_a5.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a5;
    (_a5 = inst2._zod.bag).multipleOf ?? (_a5.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a5 = def.format) == null ? void 0 : _a5.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a5;
  $ZodCheck.init(inst, def);
  (_a5 = inst._zod.def).when ?? (_a5.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a5, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a5 = inst._zod).check ?? (_a5.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version5 = {
  major: 4,
  minor: 0,
  patch: 5
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a6;
  var _a5;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version5;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a5 = inst._zod).deferred ?? (_a5.deferred = []);
    (_a6 = inst._zod.deferred) == null ? void 0 : _a6.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a7;
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: (_a7 = r.error) == null ? void 0 : _a7.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => {
          var _a8;
          return r.success ? { value: r.data } : { issues: (_a8 = r.error) == null ? void 0 : _a8.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  var _a5;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a5 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a5.patterns) ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    var _a5;
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = (_a5 = o._zod.propValues) == null ? void 0 : _a5[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :   ${issue2.expected}    ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${issue2.expected}, daxil olan ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}

// node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "slo";
      }
      case "string": {
        return "etzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${issue2.expected}, obdreno ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}

// node_modules/zod/v4/locales/de.js
var error6 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error6()
  };
}

// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error7 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error7()
  };
}

// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${issue2.expected}, riceviis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error8()
  };
}

// node_modules/zod/v4/locales/es.js
var error9 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${issue2.expected}, recibido ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es_default() {
  return {
    localeError: error9()
  };
}

// node_modules/zod/v4/locales/fa.js
var error10 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected}  ${parsedType4(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function fa_default() {
  return {
    localeError: error10()
  };
}

// node_modules/zod/v4/locales/fi.js
var error11 = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error11()
  };
}

// node_modules/zod/v4/locales/fr.js
var error12 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} reu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error12()
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${issue2.expected}, reu ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error13()
  };
}

// node_modules/zod/v4/locales/he.js
var error14 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: " ",
    emoji: "'",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "  64",
    base64url: "  64  ",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :   "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :    ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function he_default() {
  return {
    localeError: error14()
  };
}

// node_modules/zod/v4/locales/hu.js
var error15 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szm";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tmb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${issue2.expected}, a kapott rtk ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error15()
  };
}

// node_modules/zod/v4/locales/id.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error16()
  };
}

// node_modules/zod/v4/locales/it.js
var error17 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error17()
  };
}

// node_modules/zod/v4/locales/ja.js
var error18 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `: ${issue2.expected}${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function ja_default() {
  return {
    localeError: error18()
  };
}

// node_modules/zod/v4/locales/kh.js
var error19 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  ${issue2.expected}  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function kh_default() {
  return {
    localeError: error19()
  };
}

// node_modules/zod/v4/locales/ko.js
var error20 = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},   ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "";
        if (sizing) {
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function ko_default() {
  return {
    localeError: error20()
  };
}

// node_modules/zod/v4/locales/mk.js
var error21 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function mk_default() {
  return {
    localeError: error21()
  };
}

// node_modules/zod/v4/locales/ms.js
var error22 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/nl.js
var error23 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error23()
  };
}

// node_modules/zod/v4/locales/no.js
var error24 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/ota.js
var error25 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${issue2.expected}, alnan ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error25()
  };
}

// node_modules/zod/v4/locales/ps.js
var error26 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected} ,  ${parsedType4(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return ` `;
    }
  };
};
function ps_default() {
  return {
    localeError: error26()
  };
}

// node_modules/zod/v4/locales/pl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error27()
  };
}

// node_modules/zod/v4/locales/pt.js
var error28 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${issue2.expected}, recebido ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error28()
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error29 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ru_default() {
  return {
    localeError: error29()
  };
}

// node_modules/zod/v4/locales/sl.js
var error30 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${issue2.expected}, prejeto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error30()
  };
}

// node_modules/zod/v4/locales/sv.js
var error31 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${issue2.expected}, fick ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error31()
  };
}

// node_modules/zod/v4/locales/ta.js
var error32 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " " : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta_default() {
  return {
    localeError: error32()
  };
}

// node_modules/zod/v4/locales/th.js
var error33 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `:  ${issue2.expected}  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function th_default() {
  return {
    localeError: error33()
  };
}

// node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error34 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${issue2.expected}, alnan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error34()
  };
}

// node_modules/zod/v4/locales/ua.js
var error35 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ua_default() {
  return {
    localeError: error35()
  };
}

// node_modules/zod/v4/locales/ur.js
var error36 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  : ${issue2.expected}   ${parsedType4(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur_default() {
  return {
    localeError: error36()
  };
}

// node_modules/zod/v4/locales/vi.js
var error37 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${issue2.expected}, nhn c ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi_default() {
  return {
    localeError: error37()
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error38 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "(NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error38()
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error39 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return ``;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/function.js
var $ZodFunction = class {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse2(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse2(this._def.output, output, void 0, { callee: impl }) : output;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, void 0, { callee: impl }) : output;
    };
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
};
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params == null ? void 0 : params.input) ? _tuple($ZodTuple, params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: (params == null ? void 0 : params.output) ?? _unknown($ZodUnknown)
  });
}

// node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry;
    this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
    this.override = (params == null ? void 0 : params.override) ?? (() => {
    });
    this.io = (params == null ? void 0 : params.io) ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a6, _b, _c;
    var _a5;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = (_b = (_a6 = schema._zod).toJSONSchema) == null ? void 0 : _b.call(_a6);
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (((_c = def.catchall) == null ? void 0 : _c._zod.def.type) === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file.minLength = minimum;
            if (maximum !== void 0)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a5 = result.schema).default ?? (_a5.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    var _a5, _b, _c, _d, _e, _f;
    const params = {
      cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
      reused: (_params == null ? void 0 : _params.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (_params == null ? void 0 : _params.external) ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      var _a6;
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = (_a6 = params.external.registry.get(entry[0])) == null ? void 0 : _a6.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${(_a5 = seen.cycle) == null ? void 0 : _a5.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = (_b = params.external.registry.get(entry[0])) == null ? void 0 : _b.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = (_c = this.metadataRegistry.get(entry[0])) == null ? void 0 : _c.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if ((_d = params.external) == null ? void 0 : _d.uri) {
      const id = (_e = params.external.registry.get(schema)) == null ? void 0 : _e.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = ((_f = params.external) == null ? void 0 : _f.defs) ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params == null ? void 0 : _params.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/mini/schemas.js
var ZodMiniType = $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
});
var ZodMiniString = $constructor("ZodMiniString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodMiniType.init(inst, def);
});
function string2(params) {
  return _string(ZodMiniString, params);
}
var ZodMiniStringFormat = $constructor("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  ZodMiniString.init(inst, def);
});
var ZodMiniEmail = $constructor("ZodMiniEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniGUID = $constructor("ZodMiniGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniUUID = $constructor("ZodMiniUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniURL = $constructor("ZodMiniURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniEmoji = $constructor("ZodMiniEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNanoID = $constructor("ZodMiniNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID = $constructor("ZodMiniCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID2 = $constructor("ZodMiniCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniULID = $constructor("ZodMiniULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniXID = $constructor("ZodMiniXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniKSUID = $constructor("ZodMiniKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv4 = $constructor("ZodMiniIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv6 = $constructor("ZodMiniIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv4 = $constructor("ZodMiniCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv6 = $constructor("ZodMiniCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64 = $constructor("ZodMiniBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64URL = $constructor("ZodMiniBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniE164 = $constructor("ZodMiniE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniJWT = $constructor("ZodMiniJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCustomStringFormat = $constructor("ZodMiniCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNumber = $constructor("ZodMiniNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodMiniType.init(inst, def);
});
function number2(params) {
  return _number(ZodMiniNumber, params);
}
var ZodMiniNumberFormat = $constructor("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodMiniNumber.init(inst, def);
});
var ZodMiniBoolean = $constructor("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodMiniType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodMiniBoolean, params);
}
var ZodMiniBigInt = $constructor("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniBigIntFormat = $constructor("ZodMiniBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodMiniBigInt.init(inst, def);
});
var ZodMiniSymbol = $constructor("ZodMiniSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUndefined = $constructor("ZodMiniUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNull = $constructor("ZodMiniNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniAny = $constructor("ZodMiniAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUnknown = $constructor("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNever = $constructor("ZodMiniNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniVoid = $constructor("ZodMiniVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDate = $constructor("ZodMiniDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodMiniType.init(inst, def);
});
function date2(params) {
  return _date(ZodMiniDate, params);
}
var ZodMiniArray = $constructor("ZodMiniArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodMiniType.init(inst, def);
});
function array(element, params) {
  return new ZodMiniArray({
    type: "array",
    element,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniObject = $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodMiniObject(def);
}
var ZodMiniUnion = $constructor("ZodMiniUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDiscriminatedUnion = $constructor("ZodMiniDiscriminatedUnion", (inst, def) => {
  $ZodDiscriminatedUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniIntersection = $constructor("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTuple = $constructor("ZodMiniTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniRecord = $constructor("ZodMiniRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodMiniType.init(inst, def);
});
function record(keyType, valueType, params) {
  return new ZodMiniRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniMap = $constructor("ZodMiniMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSet = $constructor("ZodMiniSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniEnum = $constructor("ZodMiniEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodMiniEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniLiteral = $constructor("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniFile = $constructor("ZodMiniFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTransform = $constructor("ZodMiniTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodMiniType.init(inst, def);
});
function transform(fn) {
  return new ZodMiniTransform({
    type: "transform",
    transform: fn
  });
}
var ZodMiniOptional = $constructor("ZodMiniOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
function optional(innerType) {
  return new ZodMiniOptional({
    type: "optional",
    innerType
  });
}
var ZodMiniNullable = $constructor("ZodMiniNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodMiniType.init(inst, def);
});
function nullable(innerType) {
  return new ZodMiniNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodMiniDefault = $constructor("ZodMiniDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _default2(innerType, defaultValue) {
  return new ZodMiniDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodMiniPrefault = $constructor("ZodMiniPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNonOptional = $constructor("ZodMiniNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSuccess = $constructor("ZodMiniSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCatch = $constructor("ZodMiniCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNaN = $constructor("ZodMiniNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPipe = $constructor("ZodMiniPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodMiniType.init(inst, def);
});
function pipe2(in_, out) {
  return new ZodMiniPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodMiniReadonly = $constructor("ZodMiniReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTemplateLiteral = $constructor("ZodMiniTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniLazy = $constructor("ZodMiniLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPromise = $constructor("ZodMiniPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCustom = $constructor("ZodMiniCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodMiniType.init(inst, def);
});
function custom(fn, _params) {
  return _custom(ZodMiniCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodMiniCustom, fn, _params);
}

// node_modules/zod/v4/mini/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  date: () => date3,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodMiniISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodMiniISODateTime, params);
}
var ZodMiniISODate = $constructor("$ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function date3(params) {
  return _isoDate(ZodMiniISODate, params);
}
var ZodMiniISOTime = $constructor("$ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodMiniISOTime, params);
}
var ZodMiniISODuration = $constructor("$ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodMiniISODuration, params);
}

// node_modules/zod/v4/mini/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint2,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodMiniString, params);
}
function number3(params) {
  return _coercedNumber(ZodMiniNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodMiniBoolean, params);
}
function bigint2(params) {
  return _coercedBigint(ZodMiniBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodMiniDate, params);
}

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/nonEmptyString.js
var nonEmptyString = optional(pipe2(transform((val) => val ? val : void 0), optional(string2())));

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/filterEmptyObject.js
var filterEmptyObject = (val) => val && Object.values(val).some((x) => Boolean(x)) ? val : void 0;

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/nonEmptyStringArray.js
var nonEmptyStringArray = optional(pipe2(transform((val) => Array.isArray(val) && val.length > 0 ? val : void 0), optional(array(string2()))));

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformAndroidId.js
var transformAndroidId = (url) => {
  if (!(url === null || url === void 0 ? void 0 : url.match(/^https?:\/\//)))
    return url;
  if (!url)
    return;
  try {
    const urlObject = new URL(url);
    const id = urlObject.searchParams.get("id");
    if (id) {
      return id;
    }
  } catch (_a5) {
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformChromeExtensionId.js
var transformChromeExtensionId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(/^[a-z]{32}$/))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("chrome.google.com/webstore/detail/")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.split("/").at(-1);
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformEdgeExtensionId.js
var transformEdgeExtensionId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(/^[a-z]{32}$/))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("microsoftedge.microsoft.com/addons/detail/")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.split("/").at(-1);
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformFirefoxExtensionId.js
var transformFirefoxExtensionId = (url) => {
  if (!(url === null || url === void 0 ? void 0 : url.match(/^https?:\/\//)))
    return url;
  if (url === null || url === void 0 ? void 0 : url.includes("addons.mozilla.org")) {
    try {
      const urlObject = new URL(url);
      return urlObject.pathname.replace(/\/$/, "").split("/").at(-1);
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/utils/transformIosId.js
var idRegex = /^id[0-9]{1,36}$/;
var transformIosId = (url) => {
  if (url === null || url === void 0 ? void 0 : url.match(idRegex))
    return url;
  if (url === null || url === void 0 ? void 0 : url.match(/^https:\/\/[a-zA-Z0-9-]+\.apple\.com/)) {
    try {
      const urlObject = new URL(url);
      const expectedId = urlObject.pathname.replace(/\/$/, "").split("/").at(-1);
      if (expectedId === null || expectedId === void 0 ? void 0 : expectedId.match(idRegex)) {
        return expectedId;
      }
    } catch (_a5) {
    }
  }
  return;
};

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletSchema.js
var injectedConfigSchema = object({
  chain: string2(),
  extensionLocators: array(object({
    flag: string2(),
    value: _default2(optional(boolean2()), true)
  })),
  /**
   * Allows declaring which interface, if any, this wallet's implementation follows
   * ex. Leather with https://btckit.org/
   */
  providerInterface: optional(string2()),
  /**
   * Allows declaring that this wallet is discoverable through the the Wallet Standard
   * See https://github.com/wallet-standard/wallet-standard
   * Also allows ignoring wallets that don't support the provided features
   */
  walletStandard: optional(object({
    features: array(string2()),
    name: string2(),
    providerId: optional(string2())
  })),
  walletStandardLocators: optional(array(object({ locator: string2(), name: string2() }))),
  windowLocations: optional(array(string2())).check(refine((val) => {
    if (!val)
      return true;
    if (!val.some((v) => ["ethereum", "ethereum.providers"].includes(v)))
      return true;
    return false;
  }, {
    message: "windowLocations cannot include ethereum or ethereum.providers as they are included by default",
    path: ["config"]
  }))
});
var brandSchema = object({
  alt: nonEmptyString,
  primaryColor: nonEmptyString,
  spriteId: nonEmptyString
});
var walletSchema = pipe2(pipe2(transform((val) => val), object({
  brand: optional(brandSchema),
  chainGroup: optional(string2()),
  chains: optional(array(string2())),
  desktop: optional(pipe2(object({
    chromeId: optional(pipe2(nonEmptyString, transform(transformChromeExtensionId))),
    edgeId: optional(pipe2(nonEmptyString, transform(transformEdgeExtensionId))),
    firefoxId: optional(pipe2(nonEmptyString, transform(transformFirefoxExtensionId))),
    native: nonEmptyString,
    operaId: nonEmptyString,
    safariId: nonEmptyString,
    universal: nonEmptyString
  }), transform(filterEmptyObject))),
  eip6963Config: optional(object({ rdns: string2() })),
  filterFromWalletConnect: optional(boolean2()),
  group: optional(string2()),
  /**
   * Indicates which hardware wallets are enabled for this wallet
   */
  hardwareWallets: optional(array(string2())),
  injectedConfig: optional(array(injectedConfigSchema)),
  mobile: optional(pipe2(optional(object({
    android: nullish2(string2()),
    androidId: optional(pipe2(nonEmptyString, transform(transformAndroidId))),
    /**
     * @deprecated Use inAppBrowserV2 instead for EVM wallet deep linking
     */
    inAppBrowser: nullish2(string2()),
    inAppBrowserV2: nullish2(string2()),
    ios: nullish2(string2()),
    iosId: optional(pipe2(nonEmptyString, transform(transformIosId))),
    native: nonEmptyString,
    universal: nonEmptyString
  })), transform(filterEmptyObject))),
  mobileExperience: optional(_enum2(["in-app-browser", "redirect"])),
  name: string2(),
  shortName: nonEmptyString,
  showOnlyIfInstalled: optional(boolean2()),
  switchNetworkOnlyFromWallet: optional(boolean2()),
  walletConnect: optional(pipe2(optional(object({
    sdks: nonEmptyStringArray
  })), transform(filterEmptyObject))),
  walletGroup: optional(string2()),
  /**
   * Indicates which connector methods/events are not supported, keyed by wallet type
   */
  walletLimitations: optional(object({
    browserExtension: optional(object({
      unsupportedEvents: optional(array(string2())),
      unsupportedMethods: optional(array(string2()))
    })),
    mobile: optional(object({
      unsupportedEvents: optional(array(string2())),
      unsupportedMethods: optional(array(string2()))
    }))
  }))
})), transform((val) => {
  var _a5, _b, _c, _d, _e, _f;
  if (val.group) {
    val.chainGroup = val.group;
  }
  if (((_a5 = val.mobile) === null || _a5 === void 0 ? void 0 : _a5.iosId) || ((_b = val.mobile) === null || _b === void 0 ? void 0 : _b.ios) === null) {
    (_c = val.mobile) === null || _c === void 0 ? true : delete _c.ios;
  }
  if (((_d = val.mobile) === null || _d === void 0 ? void 0 : _d.androidId) || ((_e = val.mobile) === null || _e === void 0 ? void 0 : _e.android) === null) {
    (_f = val.mobile) === null || _f === void 0 ? true : delete _f.android;
  }
  return val;
}));

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletGroup.js
var WalletOverrideEntrySchema = object({
  brand: optional(brandSchema),
  name: nonEmptyString
});
var walletGroupSchema = object({
  brand: optional(object({
    alt: nonEmptyString,
    primaryColor: nonEmptyString,
    spriteId: nonEmptyString
  })),
  key: string2(),
  name: string2(),
  walletOverrides: optional(record(string2(), WalletOverrideEntrySchema))
});

// node_modules/@dynamic-labs/wallet-book/src/schemas/walletBookSchema.js
record(string2(), walletSchema);
var walletBookSchema = pipe2(transform((val) => val), object({
  groups: record(string2(), walletGroupSchema),
  wallets: record(string2(), walletSchema)
}));
record(string2(), walletGroupSchema);

// node_modules/@dynamic-labs/wallet-book/src/hooks/fetchWalletBook/fetchWalletBook.js
var walletBookCache = { current: {} };
var walletBookEmitter = new eventemitter3_default();
var fetchWalletBook = () => __awaiter4(void 0, void 0, void 0, function* () {
  const url = getWalletBookCdnUrl();
  const fn = () => __awaiter4(void 0, void 0, void 0, function* () {
    const res = yield fetch(url, { mode: "cors" });
    if (!res.ok) {
      throw new Error(`Failed to fetch wallet book data from ${url} with status code ${res.status}`);
    }
    const json = yield res.json();
    try {
      const parsedData = walletBookSchema.parse(json);
      return parsedData;
    } catch (e) {
      logger5.error("Error parsing wallet book data", e, json);
      throw e;
    }
  });
  walletBookCache.current = yield retryableFn(fn, {
    fallbackValue: walletBookSchema.parse(walletBookFallbacks),
    maxRetries: 3,
    retryStrategy: "timeout-and-rejection",
    timeoutMs: 3e4
  });
  walletBookEmitter.emit("walletBookLoaded", walletBookCache.current);
});

// node_modules/@dynamic-labs/wallet-book/src/hooks/useWalletBookCdn.js
fetchWalletBook();
var useWalletBookCdn = () => {
  const [walletBookState, setWalletBookState] = (0, import_react4.useState)(walletBookCache.current);
  (0, import_react4.useEffect)(() => {
    walletBookEmitter.on("walletBookLoaded", setWalletBookState);
    setWalletBookState(walletBookCache.current);
    return () => {
      walletBookEmitter.off("walletBookLoaded", setWalletBookState);
    };
  }, []);
  return walletBookState;
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletIcon.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/@dynamic-labs/wallet-book/src/helpers/getWalletIconData.js
var getWalletIconData = (walletBook, walletKey, isGroup) => {
  if (!walletKey) {
    return {
      walletIconAlt: "",
      walletIconUrl: ""
    };
  }
  try {
    const walletData = isGroup ? findWalletGroup(walletBook, walletKey) : getWalletBookWallet(walletBook, walletKey);
    const iconData = walletData === null || walletData === void 0 ? void 0 : walletData.brand;
    if (iconData) {
      return {
        walletIconAlt: iconData.alt,
        walletIconUrl: getBrandIconUrl(iconData)
      };
    }
  } catch (err) {
    logger5.debug(err);
  }
  return {
    walletIconAlt: "",
    walletIconUrl: ""
  };
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletIcon.js
var WalletBookWalletIcon = (_a5) => {
  var { walletKey, isGroup, children } = _a5, props = __rest2(_a5, ["walletKey", "isGroup", "children"]);
  const { walletBook } = useWalletBookContext();
  const [imgError, setImgError] = (0, import_react5.useState)(false);
  const { walletIconUrl, walletIconAlt } = getWalletIconData(walletBook, walletKey, isGroup);
  const defaultWalletIconUrl = getDefaultWalletIconUrl();
  if (!walletIconUrl) {
    return (0, import_react5.createElement)(import_react5.Fragment, {}, children);
  }
  const onError = () => {
    setImgError(true);
  };
  return (0, import_react5.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: walletIconAlt, key: walletKey, onError, src: imgError ? defaultWalletIconUrl : walletIconUrl }), children);
};
var WalletIcon = (_a5) => {
  var { icon, walletKey, isGroup, children } = _a5, props = __rest2(_a5, ["icon", "walletKey", "isGroup", "children"]);
  if (!icon) {
    return (0, import_react5.createElement)(WalletBookWalletIcon, Object.assign({
      children,
      isGroup,
      walletKey
    }, props));
  }
  return (0, import_react5.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: walletKey, key: walletKey, src: icon }), children);
};

// node_modules/@dynamic-labs/wallet-book/src/components/WalletBookContextProvider.js
var import_react6 = __toESM(require_react(), 1);
var WalletBookContextProvider = ({ walletBook, children }) => (0, import_react6.createElement)(WalletBookContext.Provider, {
  value: { walletBook }
}, children);

// node_modules/@dynamic-labs/wallet-book/src/components/BrandIcon.js
var import_react7 = __toESM(require_react(), 1);
var BrandIcon = (_a5) => {
  var { brand, walletKey } = _a5, props = __rest2(_a5, ["brand", "walletKey"]);
  const [imgError, setImgError] = (0, import_react7.useState)(false);
  const walletIconUrl = getBrandIconUrl(brand);
  const defaultWalletIconUrl = getDefaultWalletIconUrl();
  if (!walletIconUrl) {
    return (0, import_react7.createElement)(import_react7.Fragment, {});
  }
  const onError = () => {
    setImgError(true);
  };
  return (0, import_react7.createElement)("img", Object.assign(Object.assign({ "data-testid": `wallet-icon-${walletKey}` }, props), { alt: brand.alt, onError, src: imgError ? defaultWalletIconUrl : walletIconUrl }));
};

// node_modules/@dynamic-labs/wallet-book/src/index.js
assertPackageVersion("@dynamic-labs/wallet-book", version4);

// node_modules/@dynamic-labs/wallet-connector-core/package.js
var version6 = "4.43.0";

// node_modules/@dynamic-labs/wallet-connector-core/src/events/walletConnectorEvents.js
var walletConnectorEvents = new eventemitter3_default();

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/logger.js
var logger6 = new Logger("WalletConnector");

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/ProviderLookup/ProviderLookup.js
var ProviderLookup = (installedProviders, extensionLocators) => {
  if (extensionLocators.length === 0) {
    return void 0;
  }
  return installedProviders.find((provider) => {
    const extensionLocatorMatch = extensionLocators.every((condition) => {
      const flagValue = (provider === null || provider === void 0 ? void 0 : provider[condition.flag]) || false;
      return flagValue === condition.value;
    });
    return extensionLocatorMatch === true;
  });
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getChainInfo/getChainInfo.js
var createChainInfo = (blockchainName, name, symbol, displayName) => ({
  blockchainName,
  displayName: displayName !== null && displayName !== void 0 ? displayName : blockchainName,
  name,
  symbol
});
var chainsInfo = [
  createChainInfo("Algorand", "algorand", "ALGO"),
  createChainInfo("Aptos", "aptos", "APTOS"),
  createChainInfo("Bitcoin", "bitcoin", "BTC"),
  createChainInfo("Cosmos", "cosmos", "COSMOS"),
  createChainInfo("Eclipse", "eclipse", "ECLIPSE"),
  createChainInfo("Ethereum", "evm", "ETH", "EVM"),
  createChainInfo("Flow", "flow", "FLOW"),
  createChainInfo("Solana", "solana", "SOL"),
  createChainInfo("Spark", "spark", "SPARK"),
  createChainInfo("Starknet", "starknet", "ETH"),
  createChainInfo("Sui", "sui", "SUI"),
  createChainInfo("Tron", "tron", "TRON")
];
var chainOverrides = {
  algo: "algorand",
  bip122: "bitcoin",
  btc: "bitcoin",
  eip155: "evm",
  eth: "evm",
  sol: "solana",
  stark: "starknet",
  sui: "sui"
};
var chainInfoOverrides;
var setChainInfoOverrides = (overrides) => {
  chainInfoOverrides = overrides;
};
var getChainInfo = (chain) => {
  var _a5;
  const lowerCasedChain = chain.toLowerCase();
  const normalizedChain = (_a5 = chainOverrides[lowerCasedChain]) !== null && _a5 !== void 0 ? _a5 : lowerCasedChain;
  const chainInfo = chainsInfo.find((info) => info.name === normalizedChain || info.symbol.toLocaleLowerCase() === normalizedChain);
  if (!chainInfo) {
    return;
  }
  return chainInfo;
};
var getChainInfoWithOverrides = (chain) => {
  var _a5, _b;
  const chainInfo = getChainInfo(chain);
  if (!chainInfo) {
    return;
  }
  const overrides = chainInfoOverrides === null || chainInfoOverrides === void 0 ? void 0 : chainInfoOverrides[chainInfo.name];
  const chainInfoClone = Object.assign({}, chainInfo);
  if (overrides) {
    chainInfoClone.blockchainName = (_a5 = overrides.displayName) !== null && _a5 !== void 0 ? _a5 : chainInfo.blockchainName;
    chainInfoClone.displayName = (_b = overrides.displayName) !== null && _b !== void 0 ? _b : chainInfo.displayName;
  }
  return chainInfoClone;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmailOTPWalletConnector/isEmailOTPWalletConnector.js
var isEmailOTPWalletConnector = (walletConnector) => Boolean(walletConnector.verifyOneTimePassword);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmailWalletConnector/isEmailWalletConnector.js
var isEmailWalletConnector = (walletConnector) => Boolean(walletConnector.clearEmail);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isTurnkeyWalletConnector/isTurnkeyWalletConnector.js
var isTurnkeyWalletConnector = (walletConnector) => {
  const turnkeyWalletConnector = walletConnector;
  return Boolean(turnkeyWalletConnector && turnkeyWalletConnector.key === "turnkeyhd" && typeof turnkeyWalletConnector.getWebAuthnAttestation === "function" && typeof turnkeyWalletConnector.getAuthenticatorHandler === "function" && typeof turnkeyWalletConnector.getExportHandler === "function" && typeof turnkeyWalletConnector.isSessionKeyCompatible === "function" && typeof turnkeyWalletConnector.createOrRestoreSession === "function");
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/shouldLowercaseAddress.js
var shouldLowercaseAddress = (chain) => (
  // these are standard from CAIP-2: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md
  // see also: https://github.com/ChainAgnostic/namespaces
  // note: no standard namespace currently exists for flow
  ["eip155", "flow", "evm", "eth", "avax", "matic"].includes(chain.toLowerCase())
);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSameAddress/utils/normalizeAddress/normalizeAddress.js
var normalizeAddress = (rawAddress, chain) => {
  let address = rawAddress;
  if (address === null || address === void 0 ? void 0 : address.startsWith("0x")) {
    address = address.slice(2);
  }
  address = shouldLowercaseAddress(chain) ? address === null || address === void 0 ? void 0 : address.toLowerCase() : address;
  return address;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSameAddress/isSameAddress.js
var isSameAddress = (left, right, chain) => normalizeAddress(left, chain) === normalizeAddress(right, chain);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSocialWalletConnector/isSocialWalletConnector.js
var isSocialWalletConnector = (walletConnector) => Boolean(walletConnector.canConnectViaSocial);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletConnectorByKey.js
var filterWalletsByKey = (wallets2, keys) => keys.flatMap((key) => wallets2.find((w) => walletHasKey(w, key))).filter(isWalletConnector);
var walletHasKey = (wallet, key) => wallet.key === key;
var isWalletConnector = (item) => Boolean(item);
var getWalletConnectorByKey = (wallets2, key) => filterWalletsByKey(wallets2, [key]).length > 0 ? filterWalletsByKey(wallets2, [key])[0] : null;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/walletConnectDeepLinks/walletConnectDeepLinks.js
var getConnectionDeepLink = (uri, deepLinks, preference) => {
  if (isAndroid()) {
    return uri;
  }
  const deepLink = getRegularDeepLink(uri, deepLinks, preference);
  if (!deepLink) {
    return `${deepLink}?uri=${encodeURIComponent(uri)}`;
  }
  const deepLinkUrl = new URL(deepLink);
  const deepLinkParams = new URLSearchParams(deepLinkUrl.search);
  deepLinkParams.set("uri", uri);
  deepLinkUrl.search = deepLinkParams.toString();
  return deepLinkUrl.toString();
};
var getRegularDeepLink = (uri, deepLinks, preference) => {
  var _a5, _b, _c, _d;
  if (isAndroid()) {
    return uri.split("?")[0];
  }
  const index = isMobile() ? "mobile" : "desktop";
  let origin;
  if (preference === "native") {
    origin = ((_a5 = deepLinks[index]) === null || _a5 === void 0 ? void 0 : _a5.native) || ((_b = deepLinks[index]) === null || _b === void 0 ? void 0 : _b.universal);
  } else {
    origin = ((_c = deepLinks[index]) === null || _c === void 0 ? void 0 : _c.universal) || ((_d = deepLinks[index]) === null || _d === void 0 ? void 0 : _d.native);
  }
  return origin || "";
};
var getDeepLink = ({ mode, uri = "", deepLinks, preference }) => {
  if (!deepLinks) {
    return "";
  }
  switch (mode) {
    case "connection":
      return getConnectionDeepLink(uri, deepLinks, preference);
    case "regular":
      return getRegularDeepLink(uri, deepLinks, preference);
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/walletConnectDeepLinks/performPlatformSpecificConnectionMethod.js
var performPlatformSpecificConnectionMethod = (uri, deepLinks, opts, preference) => {
  var _a5, _b, _c;
  const deepLink = getDeepLink({
    deepLinks,
    mode: "connection",
    preference,
    uri
  });
  if (isMobile()) {
    PlatformService.openURL(deepLink);
  } else {
    if ((_a5 = deepLinks === null || deepLinks === void 0 ? void 0 : deepLinks.desktop) === null || _a5 === void 0 ? void 0 : _a5.native) {
      (_b = opts.onDesktopUri) === null || _b === void 0 ? void 0 : _b.call(opts, deepLink);
    }
    (_c = opts.onDisplayUri) === null || _c === void 0 ? void 0 : _c.call(opts, uri);
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isEmbeddedConnector/isEmbeddedConnector.js
var isEmbeddedConnector = (connector) => Boolean(connector.isEmbeddedWallet);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isMagicConnector/isMagicConnector.js
var isMagicConnector = (connector) => ["magicemailotp", "magicsocial"].includes(connector.key);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isBloctoConnector/isBloctoConnector.js
var isBloctoConnector = (connector) => ["bloctoemail", "bloctoevm", "Blocto"].includes(connector.key);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isPasskeyWalletConnector/isPasskeyWalletConnector.js
var isPasskeyWalletConnector = (walletConnector) => Boolean(walletConnector.getWebAuthnAttestation);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isAccountAbstractionConnector/isAccountAbstractionConnector.js
var isAccountAbstractionConnector = (walletConnector) => walletConnector !== void 0 && walletConnector !== null && typeof walletConnector === "object" && "canSponsorTransactionGas" in walletConnector;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isBitcoinConnector/isBitcoinConnector.js
var isBitcoinConnector = (connector) => Boolean(connector === null || connector === void 0 ? void 0 : connector.sendBitcoin);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isHardwareWalletConnector/isHardwareWalletConnector.js
var isHardwareWalletConnector = (connector) => "canConnectWithHardwareWallet" in connector;

// node_modules/@dynamic-labs/wallet-connector-core/_virtual/_tslib.js
function __rest3(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter5(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isHex/isHex.js
var isHex2 = (value) => {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return /^0x[0-9a-fA-F]*$/.test(value);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/eventListenerHandlers.js
var eventListenerHandlers = (walletConnector) => {
  const handleAccountChange = (accounts) => __awaiter5(void 0, void 0, void 0, function* () {
    logger6.debug(`${walletConnector.name} - accountChange`, accounts);
    if (accounts.length === 0) {
      walletConnector.emit("disconnect");
      return;
    }
    walletConnector.emit("accountChange", { accounts });
  });
  const handleChainChange = (chain) => __awaiter5(void 0, void 0, void 0, function* () {
    logger6.debug(`${walletConnector.name} - chainChange`, chain);
    const chainStr = isHex2(chain) ? parseInt(chain, 16).toString() : chain.toString();
    walletConnector.emit("chainChange", {
      chain: chainStr
    });
  });
  const handleDisconnect = (error40) => __awaiter5(void 0, void 0, void 0, function* () {
    logger6.debug(`${walletConnector.name} - disconnect`, error40);
    if ((error40 === null || error40 === void 0 ? void 0 : error40.code) === 1013) {
      return;
    }
    walletConnector.emit("disconnect");
  });
  return {
    handleAccountChange,
    handleChainChange,
    handleDisconnect
  };
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isPhantomRedirectConnector/isPhantomRedirectConnector.js
var isPhantomRedirectConnector = (connector) => connector.key === "phantom" && connector.extractSignature !== void 0;

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getRpcUrlForChain/getRpcUrlForChain.js
var getRpcUrlForChain = ({ networks, chainId }) => {
  var _a5;
  const network = networks.find((network2) => network2.chainId === chainId);
  if (!network) {
    return void 0;
  }
  return ((_a5 = network.privateCustomerRpcUrls) === null || _a5 === void 0 ? void 0 : _a5[0]) || network.rpcUrls[0];
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isWalletConnectConnector/isWalletConnectConnector.js
var isWalletConnectConnector = (connector) => Boolean(connector === null || connector === void 0 ? void 0 : connector.isWalletConnect);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSendBalanceWalletConnector/isSendBalanceWalletConnector.js
var isSendBalanceWalletConnector = (walletConnector) => {
  var _a5;
  return "createUiTransaction" in walletConnector && typeof walletConnector.createUiTransaction === "function" && walletConnector.isAvailable && !((_a5 = walletConnector.isSendBalanceUnsupported) === null || _a5 === void 0 ? void 0 : _a5.call(walletConnector));
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSessionKeyCompatible/isSessionKeyCompatibleWalletConnector/isSessionKeyCompatibleWalletConnector.js
var isSessionKeyCompatibleWalletConnector = (walletConnector) => {
  const connector = walletConnector;
  return Boolean(typeof (connector === null || connector === void 0 ? void 0 : connector.isSessionKeyCompatible) === "function" && connector.isSessionKeyCompatible());
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isSessionKeyCompatible/isSessionKeyCompatibleWallet/isSessionKeyCompatibleWallet.js
var isSessionKeyCompatibleWallet = (wallet) => isSessionKeyCompatibleWalletConnector(wallet.connector);

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getMobileExperience/getMobileExperience.js
var getMobileExperience = ({ mobileExperienceProp, walletBook, walletKey, walletConnector }) => {
  logger6.logVerboseTroubleshootingMessage("[getMobileExperience]", {
    mobileExperienceProp,
    walletKey
  });
  if (mobileExperienceProp) {
    if (typeof mobileExperienceProp === "string") {
      return mobileExperienceProp;
    } else if (mobileExperienceProp[walletKey]) {
      return mobileExperienceProp[walletKey];
    } else if (mobileExperienceProp.default) {
      return mobileExperienceProp.default;
    }
  }
  const walletBookRecord = findWalletBookWallet(walletBook, walletKey);
  logger6.logVerboseTroubleshootingMessage("[getMobileExperience]", {
    isWalletConnect: walletConnector.isWalletConnect,
    walletBookRecord
  });
  if (walletBookRecord === null || walletBookRecord === void 0 ? void 0 : walletBookRecord.mobileExperience) {
    return walletBookRecord.mobileExperience;
  }
  if (walletKey === "metamask") {
    return "redirect";
  }
  if (walletConnector.isWalletConnect) {
    return "redirect";
  }
  return "in-app-browser";
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getDeepLinks/getDeepLinks.js
var getMobileDeepLinks = (mobile) => {
  if (!mobile) {
    return;
  }
  return {
    native: mobile.native,
    universal: mobile.universal
  };
};
var getDesktopDeepLinks = (desktop) => {
  if (!desktop) {
    return;
  }
  return {
    native: desktop.native,
    universal: desktop.universal
  };
};
var getDeepLinks = ({ mobile, desktop }) => {
  const mobileDeepLinks = getMobileDeepLinks(mobile);
  const desktopDeepLinks = getDesktopDeepLinks(desktop);
  if (!mobileDeepLinks && !desktopDeepLinks) {
    return;
  }
  return {
    desktop: desktopDeepLinks,
    mobile: mobileDeepLinks
  };
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getDownloadLinks/getDownloadLinks.js
var getMobileDownloadLinks = (mobile) => {
  if (!mobile) {
    return;
  }
  return {
    androidId: mobile.androidId,
    iosId: mobile.iosId
  };
};
var getDesktopDownloadLinks = (desktop) => {
  if (!desktop) {
    return;
  }
  return {
    chromeId: desktop.chromeId,
    edgeId: desktop.edgeId,
    firefoxId: desktop.firefoxId,
    operaId: desktop.operaId,
    safariId: desktop.safariId
  };
};
var getDownloadLinks = (wallet) => {
  const mobileLinks = getMobileDownloadLinks(wallet.mobile);
  const desktopLinks = getDesktopDownloadLinks(wallet.desktop);
  if (!mobileLinks && !desktopLinks) {
    return;
  }
  return Object.assign(Object.assign({}, mobileLinks), desktopLinks);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getIconUrl/getIconUrl.js
var getIconUrl = (spriteId) => {
  if (!spriteId) {
    return renderTemplate("iconicUrl", "defaultwallet");
  }
  return renderTemplate("iconicUrl", spriteId);
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getValidHexColor/getValidHexColor.js
var getValidHexColor = (color) => {
  if (!color) {
    return;
  }
  const hexColorRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
  return hexColorRegex.test(color) ? color : void 0;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getWalletLimitations/getWalletLimitations.js
var getWalletLimitations = (walletLimitations) => {
  if (!(walletLimitations === null || walletLimitations === void 0 ? void 0 : walletLimitations.browserExtension)) {
    return;
  }
  const { unsupportedEvents, unsupportedMethods } = walletLimitations.browserExtension;
  return {
    desktop: {
      unsupportedEvents,
      unsupportedMethods
    }
  };
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletMetadataFromWalletBook/getWalletMetadataFromWalletBook.js
var getWalletMetadataFromWalletBook = ({ walletKey, walletBookWallet, walletBook, walletFallback }) => {
  var _a5, _b, _c, _d, _e, _f, _g, _h, _j;
  if (!isWalletBookPopulated(walletBook) && !walletFallback) {
    logger6.warn("Wallet book is required");
    return;
  }
  try {
    const wallet = walletBookWallet !== null && walletBookWallet !== void 0 ? walletBookWallet : getWalletBookWallet(walletBook, walletKey, walletFallback);
    if (!wallet) {
      logger6.warn("Wallet not found in wallet book");
      return;
    }
    return {
      brandColor: getValidHexColor((_a5 = wallet === null || wallet === void 0 ? void 0 : wallet.brand) === null || _a5 === void 0 ? void 0 : _a5.primaryColor),
      deepLinks: getDeepLinks({
        desktop: wallet === null || wallet === void 0 ? void 0 : wallet.desktop,
        mobile: wallet === null || wallet === void 0 ? void 0 : wallet.mobile
      }),
      downloadLinks: getDownloadLinks(wallet),
      groupKey: (_b = wallet === null || wallet === void 0 ? void 0 : wallet.chainGroup) !== null && _b !== void 0 ? _b : wallet === null || wallet === void 0 ? void 0 : wallet.walletGroup,
      icon: (_d = getIconUrl((_c = wallet === null || wallet === void 0 ? void 0 : wallet.brand) === null || _c === void 0 ? void 0 : _c.spriteId)) !== null && _d !== void 0 ? _d : "",
      id: walletKey,
      inAppBrowserUrl: (_h = (_f = (_e = wallet.mobile) === null || _e === void 0 ? void 0 : _e.inAppBrowserV2) !== null && _f !== void 0 ? _f : (_g = wallet.mobile) === null || _g === void 0 ? void 0 : _g.inAppBrowser) !== null && _h !== void 0 ? _h : void 0,
      name: wallet.name,
      rdns: (_j = wallet.eip6963Config) === null || _j === void 0 ? void 0 : _j.rdns,
      supportedHardwareWallets: wallet.hardwareWallets,
      walletLimitations: getWalletLimitations(wallet.walletLimitations)
    };
  } catch (e) {
    logger6.warn("Error getting wallet metadata from wallet book", {
      error: e
    });
    return;
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isConnectorMethodSupported/isConnectorMethodSupported.js
var isConnectorMethodSupported = (connector, method, platform) => {
  var _a5, _b, _c;
  return !((_c = (_b = (_a5 = connector.metadata.walletLimitations) === null || _a5 === void 0 ? void 0 : _a5[platform]) === null || _b === void 0 ? void 0 : _b.unsupportedMethods) === null || _c === void 0 ? void 0 : _c.includes(method));
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isConnectorEventSupported/isConnectorEventSupported.js
var isConnectorEventSupported = (connector, event, platform) => {
  var _a5, _b, _c;
  return !((_c = (_b = (_a5 = connector.metadata.walletLimitations) === null || _a5 === void 0 ? void 0 : _a5[platform]) === null || _b === void 0 ? void 0 : _b.unsupportedEvents) === null || _c === void 0 ? void 0 : _c.includes(event));
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletLinks/getWalletLinks.js
var getWalletLinks = (downloadLinks) => {
  var _a5, _b, _c, _d, _e, _f, _g, _h;
  const links = {
    android: "",
    brave: "",
    chrome: "",
    edge: "",
    firefox: "",
    ios: ""
  };
  if (!downloadLinks) {
    return links;
  }
  links.brave = (_a5 = renderTemplate("chromeUrl", downloadLinks.chromeId)) !== null && _a5 !== void 0 ? _a5 : "";
  links.chrome = (_b = renderTemplate("chromeUrl", downloadLinks.chromeId)) !== null && _b !== void 0 ? _b : "";
  links.edge = (_c = renderTemplate("edgeUrl", downloadLinks.edgeId)) !== null && _c !== void 0 ? _c : "";
  links.firefox = (_d = renderTemplate("firefoxUrl", downloadLinks.firefoxId)) !== null && _d !== void 0 ? _d : "";
  links.ios = (_f = (_e = renderTemplate("iosUrl", downloadLinks.iosId)) !== null && _e !== void 0 ? _e : downloadLinks.iosUrl) !== null && _f !== void 0 ? _f : "";
  links.android = (_h = (_g = renderTemplate("androidUrl", downloadLinks.androidId)) !== null && _g !== void 0 ? _g : downloadLinks.androidUrl) !== null && _h !== void 0 ? _h : "";
  return links;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/isDynamicWaasConnector/isDynamicWaasConnector.js
var isDynamicWaasConnector = (walletConnector) => {
  const dynamicWaasConnector = walletConnector;
  return Boolean(dynamicWaasConnector && dynamicWaasConnector.key === "dynamicwaas");
};

// node_modules/@dynamic-labs/wallet-connector-core/src/utils/getWalletProvider/getWalletProvider.js
var getWalletProvider = (connector) => {
  if (connector.isEmbeddedWallet) {
    return WalletProviderEnum.EmbeddedWallet;
  }
  if (connector.canConnectViaCustodialService) {
    return WalletProviderEnum.CustodialService;
  }
  if (connector.isInstalledOnBrowser()) {
    return WalletProviderEnum.BrowserExtension;
  }
  return isMobile() ? WalletProviderEnum.DeepLink : WalletProviderEnum.QrCode;
};

// node_modules/@dynamic-labs/wallet-connector-core/src/Wallet/Wallet.js
var Wallet = class extends BaseWallet {
  constructor(_a5) {
    var { connector } = _a5, props = __rest3(_a5, ["connector"]);
    super(props);
    this._connector = connector;
  }
  /**
   * Gets the wallet connector.
   */
  get connector() {
    return this._connector;
  }
  /**
   * Retrieves the balance of the wallet.
   * @returns A promise that resolves to the balance of the wallet as a string,
   * or undefined if the balance cannot be retrieved.
   */
  getBalance() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.getBalance(this.address);
    });
  }
  /**
   * Retrieves the name service data associated with the wallet.
   * @returns A promise that resolves to the name service data of the wallet,
   * or undefined if the data cannot be retrieved.
   */
  getNameService() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.getNameService(this.address);
    });
  }
  /**
   * Retrieves the network that the wallet is connected to.
   * @returns A promise that resolves to the network value as a string or number,
   * or undefined if the network cannot be retrieved.
   */
  getNetwork() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.getNetwork(true);
    });
  }
  /**
   * If the wallet is connected.
   * @returns A promise that resolves to true the wallet is connected or false if it's not connected.
   */
  isConnected() {
    return __awaiter5(this, void 0, void 0, function* () {
      try {
        const connectedAccounts = yield this._connector.getConnectedAccounts();
        return connectedAccounts.map((address) => normalizeAddress(address, this.chain)).includes(normalizeAddress(this.address, this.chain));
      } catch (error40) {
        logger6.error("[Wallet] isConnected - Error detecting if wallet is connected", error40);
        return false;
      }
    });
  }
  /**
   * Proves ownership of the wallet by signing a message.
   * @param messageToSign - The message to sign.
   * @returns A promise that resolves to the signature of the message as a string,
   *  or undefined if the message cannot be signed.
   */
  proveOwnership(messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.proveOwnership(this.address, messageToSign);
    });
  }
  /**
   * Signs a message using the wallet.
   * @param messageToSign - The message to sign.
   * @returns A promise that resolves to the signature of the message as a string,
   * or undefined if the message cannot be signed.
   */
  signMessage(messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.sync();
      return this._connector.signMessage(messageToSign, {
        address: this.address
      });
    });
  }
  /**
   * Switches the network that the wallet is connected to.
   * @param networkChainId - The chain id of the network to switch to.
   * @returns A promise that resolves when the network is switched.
   */
  switchNetwork(networkChainId) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.switchNetwork({
        networkChainId
      });
    });
  }
  /**
   * Synchronizes the wallet with the connector.
   * @returns A promise that resolves when the wallet is connected and active.
   */
  sync() {
    return __awaiter5(this, void 0, void 0, function* () {
      return this._connector.validateActiveWallet(this.address);
    });
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/WalletBookSingleton/WalletBookSingleton.js
var WalletBookSingleton = class _WalletBookSingleton {
  constructor(walletBook) {
    this.walletBook = walletBook;
  }
  static getOrCreate(walletBook) {
    var _a5;
    if (!((_a5 = _WalletBookSingleton.instance) === null || _a5 === void 0 ? void 0 : _a5.walletBook)) {
      _WalletBookSingleton.instance = new _WalletBookSingleton(walletBook);
    }
    return _WalletBookSingleton.instance;
  }
  static reset() {
    _WalletBookSingleton.instance = void 0;
  }
};

// node_modules/@dynamic-labs/wallet-connector-core/src/WalletConnectorBase/WalletConnectorBase.js
var _WalletConnectorBase_registeredExtensions;
var WalletConnectorBase = class _WalletConnectorBase extends eventemitter3_default {
  createWallet(props) {
    const wallet = new this.ChainWallet(props);
    return wallet;
  }
  /**
   * We store the constructor props so that we can use them later on
   * in getMobileOrInstalledWallet which may fall back to a different class
   * but will need the original constructor props.
   * @param props - constructor props
   */
  constructor(props) {
    super();
    this.chainRpcProviders = void 0;
    this.isGlobalTransaction = false;
    _WalletConnectorBase_registeredExtensions.set(this, []);
    this.didSetup = false;
    this.requiresNonDynamicEmailOtp = false;
    this.canConnectViaCustodialService = false;
    this.canConnectViaQrCode = false;
    this.canConnectViaSocial = false;
    this.canHandleMultipleConnections = true;
    this.isAvailable = true;
    this.isEmbeddedWallet = false;
    this.isWalletConnect = false;
    this.overrideKey = void 0;
    this.providerResources = void 0;
    this.switchNetworkOnlyFromWallet = void 0;
    this.isInitialized = true;
    this.constructorProps = props;
    this._walletBookInstance = WalletBookSingleton.getOrCreate(props.walletBook);
    this._metadata = props.metadata;
    this.walletConnectorEventsEmitter = this.constructorProps.walletConnectorEventsEmitter || walletConnectorEvents;
    if (this.walletBook === void 0) {
      throw new Error("WalletConnectorBase was not called with super(props) and is missing wallet-book");
    }
  }
  extend(extension, settings) {
    if (__classPrivateFieldGet2(this, _WalletConnectorBase_registeredExtensions, "f").includes(extension.name)) {
      throw new Error(`You can only register a single extension of: ${extension.name}`);
    }
    if (extension.name === "global-wallet-extension") {
      if (!this.isEmbeddedWallet || !this.supportedChains.includes("EVM"))
        return;
    }
    __classPrivateFieldGet2(this, _WalletConnectorBase_registeredExtensions, "f").push(extension.name);
    extension.extend(this, settings !== null && settings !== void 0 ? settings : {});
  }
  /**
   * Add the event listeners for the wallet and connect
   * with event emitter.
   */
  initEventListener() {
    if (this.didSetup)
      return;
    this.didSetup = true;
    this.setupEventListeners();
  }
  get walletBook() {
    return this._walletBookInstance.walletBook;
  }
  filter() {
    return true;
  }
  get mobileExperience() {
    return getMobileExperience({
      mobileExperienceProp: this.constructorProps.mobileExperience,
      walletBook: this.walletBook,
      walletConnector: this,
      walletKey: this.key
    });
  }
  /**
   * Prompt the user to choose accounts to connect (see behavior in MM)
   * @default Promise<[]>
   */
  chooseAccountsToConnect() {
    return Promise.resolve([]);
  }
  connect() {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.getAddress();
    });
  }
  /**
   * Generic function to close the wallet connection
   *
   * Originally implemented for WalletConnect, but it is used
   * for anything that needs to be "logged out" or cleaned up.
   *
   * Remember to call teardownEventListeners() in the implementation.
   *
   * @default Promise<undefined>
   */
  endSession() {
    return Promise.resolve();
  }
  /**
   * Gets the public address of the wallet
   *
   * @default Promise<undefined>
   */
  getAddress(opts) {
    return Promise.resolve(void 0);
  }
  /**
   * Parses a public address to ensure it follows a correct format.
   *
   * For instance, with EVM wallets, this might ensure it follows the EIP 55 format.
   *
   * @default string
   */
  parseAddress(address) {
    return address;
  }
  /**
   * Whether this wallet connector is targeting a testnet.
   * So far only supported for EVM connectors.
   *
   * @default Promise<false>
   */
  isTestnet() {
    return Promise.resolve(false);
  }
  /**
   * Gets the additional addresses of the wallet, given the main address
   *
   * @default Promise<[]>
   */
  getAdditionalAddresses(mainAddress) {
    return Promise.resolve([]);
  }
  /**
   * Sets the additional addresses of the wallet, given the main address
   *
   * @default Promise<void>
   */
  setAdditionalAddresses(mainAddress, additionalAddresses) {
    return Promise.resolve();
  }
  /**
   * Gets the balance of the wallet
   *
   * @default Promise<undefined>
   */
  getBalance(address) {
    return Promise.resolve(void 0);
  }
  /**
   * Get the address silently
   *
   * This is used to check which accounts are already connected and
   * should silently attempt to reconnect. If the user refreshes their
   * page and gets disconnected, there's likely an issue with the
   * implementation of this method.
   *
   * @default Promise<[]>
   */
  getConnectedAccounts() {
    return Promise.resolve([]);
  }
  /**
   * Gets the deep link of the wallet
   *
   * @default undefined
   */
  getDeepLink() {
    return void 0;
  }
  getNetwork() {
    return Promise.resolve(void 0);
  }
  /**
   * Gets current network of connected wallet
   *
   * @default Promise<undefined>
   */
  getNameService(address) {
    return Promise.resolve(void 0);
  }
  getPublicClient() {
    return Promise.resolve(void 0);
  }
  getSession() {
    return __awaiter5(this, void 0, void 0, function* () {
      return Promise.resolve();
    });
  }
  getSigner() {
    return Promise.resolve(void 0);
  }
  getWalletClient(chainId) {
    return void 0;
  }
  /**
   * Initialize the wallet connector with any async operations
   *
   * @default Promise<void>
   */
  init() {
    return Promise.resolve();
  }
  /**
   * Check if the wallet is installed on the browser
   *
   * @default false
   */
  isInstalledOnBrowser() {
    return false;
  }
  /**
   * Override key or the normalized wallet name if needed
   */
  get key() {
    return this.overrideKey || this.name.replace(/\W/g, "").toLowerCase();
  }
  get metadata() {
    var _a5;
    if (!this._metadata) {
      this._metadata = getWalletMetadataFromWalletBook({
        walletBook: this.walletBook,
        walletKey: this.key
      });
    }
    return (_a5 = this._metadata) !== null && _a5 !== void 0 ? _a5 : { icon: "", id: this.key, name: this.name };
  }
  /**
   * Whether the wallet connector should fall back to a different wallet connector
   * This is called after the object is instantiated, so it can't be a static property
   * and will return the appropriate instance of the wallet connector
   * @returns WalletConnector
   * @default this
   */
  getMobileOrInstalledWallet() {
    return this;
  }
  /**
   * In most cases this is an alias for `signMessage`
   *
   * @default Promise<undefined>
   */
  proveOwnership(address, messageToSign) {
    return __awaiter5(this, void 0, void 0, function* () {
      yield this.validateActiveWallet(address);
      return this.signMessage(messageToSign);
    });
  }
  /**
   * Set up event listeners for the wallet
   *
   * @default void
   */
  setupEventListeners() {
    return;
  }
  /**
   * Sign a message
   *
   * @default Promise<undefined>
   */
  signMessage(messageToSign, options) {
    return Promise.resolve(void 0);
  }
  /**
   * Returns the array of block explorer URLs available for the current network
   */
  getBlockExplorerUrlsForCurrentNetwork() {
    return __awaiter5(this, void 0, void 0, function* () {
      return [];
    });
  }
  /**
   * Whether the wallet supports network switching
   *
   * @default false
   */
  supportsNetworkSwitching() {
    return false;
  }
  switchNetwork({ networkName, networkChainId }) {
    return Promise.resolve(void 0);
  }
  /**
   * Tear down event listeners for the wallet
   * @default void
   */
  teardownEventListeners() {
    return;
  }
  /**
   * Receive the user verified credentials
   */
  setVerifiedCredentials(verifiedCredentials) {
    return;
  }
  /**
   * Whether the wallet allow for getting the address in the
   * current chain.
   * This is used for multi chain wallets.
   * @default true
   */
  canGetChainAddress() {
    return true;
  }
  /**
   * Prompts the user to make expected wallet active
   *
   * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
   * @returns {Promise<void>} A promise that resolves when the active address matches the expected address,
   * otherwise rejects with an error.
   */
  handleWalletNotActive(_a5) {
    return __awaiter5(this, arguments, void 0, function* ({ activeAddress, expectedAddress, reconnectedAddress }) {
      logger6.debug("validateActiveWallet - wallet is not active", {
        activeAddress,
        expectedAddress,
        reconnectedAddress
      });
      const currentActiveAddress = activeAddress || reconnectedAddress || "";
      const walletUiUtils = this.constructorProps.walletUiUtils;
      if (!walletUiUtils) {
        throw new WalletAddressMismatchError(`Wallet ${expectedAddress !== null && expectedAddress !== void 0 ? expectedAddress : ""} is not currently active in ${this.name || this.key}.`, {
          activeAddress: currentActiveAddress,
          expectedAddress,
          walletName: this.name || this.key
        });
      }
      return walletUiUtils.syncWallet({
        activeAddress: currentActiveAddress,
        expectedAddress,
        walletConnector: this
      });
    });
  }
  /**
   * Validates if the address is connected and active in the wallet app
   *
   * @throws {WalletAddressMismatchError} If the active address does not match the expected address.
   * @returns {Promise<void>} A promise that resolves if the active address matches the expected address,
   * otherwise rejects with an error.
   */
  validateActiveWallet(expectedAddress) {
    return __awaiter5(this, void 0, void 0, function* () {
      logger6.debug("validateActiveWallet - validating wallet", expectedAddress);
      const canFetchConnectedAccounts = isConnectorMethodSupported(this, "getConnectedAccounts", "desktop");
      logger6.debug("validateActiveWallet - getting connected accounts", {
        canFetchConnectedAccounts
      });
      const [activeAddress] = canFetchConnectedAccounts ? yield this.getConnectedAccounts() : [];
      const isWalletActive = activeAddress && isSameAddress(activeAddress, expectedAddress, this.connectedChain);
      if (isWalletActive) {
        logger6.debug("validateActiveWallet - wallet is active");
        return;
      }
      logger6.debug("validateActiveWallet - trying to reconnect wallet...");
      const getReconnectedAddress = () => __awaiter5(this, void 0, void 0, function* () {
        if (!this.canHandleMultipleConnections || !this.canGetChainAddress()) {
          return void 0;
        }
        return this.getAddress().catch((err) => {
          logger6.debug("validateActiveWallet - error getting address", err);
          return void 0;
        });
      });
      const reconnectedAddress = yield getReconnectedAddress();
      if (reconnectedAddress && isSameAddress(reconnectedAddress, expectedAddress, this.connectedChain)) {
        logger6.debug("validateActiveWallet - wallet reconnected successfuly");
        return;
      }
      return this.handleWalletNotActive({
        activeAddress,
        expectedAddress,
        reconnectedAddress
      });
    });
  }
  /**
   * Get the enabled networks for the wallet.
   *
   * These are normally set in the opts prop of the wallet connector constructor. The
   * network values are passed from project settings and can require an update to
   * [getWalletConnectorConstructorOptions] for new chains.
   *
   * @returns {GenericNetwork[]} The enabled networks
   */
  getEnabledNetworks() {
    return [];
  }
  /**
   * Retry the deeplink connection for mobile wallets
   * @default Promise<void>
   */
  retryDeeplinkConnection() {
    return;
  }
  /**
   * Check if retryDeeplinkConnection has been implemented by a subclass
   */
  hasRetryDeeplinkConnection() {
    return this.retryDeeplinkConnection !== _WalletConnectorBase.prototype.retryDeeplinkConnection;
  }
  /**
   * Open the inAppBrowser if required
   * @returns True if the inAppBrowser was opened, false otherwise.
   */
  openInAppBrowserIfRequired() {
    var _a5;
    if (this.isInstalledOnBrowser() || !isMobile() || !((_a5 = this.metadata) === null || _a5 === void 0 ? void 0 : _a5.inAppBrowserUrl) || this.mobileExperience === "redirect") {
      return false;
    }
    const inAppBrowserCompiledTemplate = template(this.metadata.inAppBrowserUrl);
    const { href } = PlatformService.getUrl();
    const deepLink = inAppBrowserCompiledTemplate({
      encodedDappURI: encodeURIComponent(href)
    });
    PlatformService.openURL(deepLink);
    return true;
  }
};
_WalletConnectorBase_registeredExtensions = /* @__PURE__ */ new WeakMap();

// node_modules/@dynamic-labs/wallet-connector-core/src/index.js
assertPackageVersion("@dynamic-labs/wallet-connector-core", version6);

// node_modules/@dynamic-labs/rpc-providers/package.js
var version7 = "4.43.0";

// node_modules/@dynamic-labs/rpc-providers/src/RpcProviders.js
var ProviderChain;
(function(ProviderChain2) {
  ProviderChain2["ECLIPSE"] = "eclipse";
  ProviderChain2["EVM"] = "evm";
  ProviderChain2["SOLANA"] = "solana";
  ProviderChain2["STARKNET"] = "starknet";
  ProviderChain2["SUI"] = "sui";
})(ProviderChain || (ProviderChain = {}));

// node_modules/@dynamic-labs/rpc-providers/_virtual/_tslib.js
function __awaiter6(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/@dynamic-labs/rpc-providers/src/ChainRpcProviders.js
var ChainRpcProvidersClass = class _ChainRpcProvidersClass {
  static get client() {
    if (!_ChainRpcProvidersClass.instance) {
      _ChainRpcProvidersClass.instance = new _ChainRpcProvidersClass();
    }
    return _ChainRpcProvidersClass.instance;
  }
  constructor() {
    this.getProvidersMethods = {};
  }
  static getProviders(configurations) {
    Object.values(ProviderChain).forEach((chain) => {
      var _a5, _b;
      if (!_ChainRpcProvidersClass.providers[chain]) {
        const providers = (_b = (_a5 = _ChainRpcProvidersClass.client.getProvidersMethods)[chain]) === null || _b === void 0 ? void 0 : _b.call(_a5, configurations);
        if (providers) {
          Object.assign(_ChainRpcProvidersClass.providers, {
            [chain]: providers
          });
        }
      }
    });
    return _ChainRpcProvidersClass.providers;
  }
  static registerChainProviders(providerChain, fn) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!_ChainRpcProvidersClass.client.getProvidersMethods[providerChain]) {
        Object.assign(_ChainRpcProvidersClass.client.getProvidersMethods, {
          [providerChain]: fn
        });
      }
    });
  }
};
ChainRpcProvidersClass.providers = {};
ChainRpcProvidersClass.wipeInstance = () => {
  ChainRpcProvidersClass.instance = void 0;
  ChainRpcProvidersClass.providers = {};
};
var ChainRpcProviders = ChainRpcProvidersClass;

// node_modules/@dynamic-labs/rpc-providers/src/index.js
assertPackageVersion("@dynamic-labs/rpc-providers", version7);

// node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js
function browserSupportsWebAuthn() {
  return _browserSupportsWebAuthnInternals.stubThis((globalThis == null ? void 0 : globalThis.PublicKeyCredential) !== void 0 && typeof globalThis.PublicKeyCredential === "function");
}
var _browserSupportsWebAuthnInternals = {
  stubThis: (value) => value
};

// node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js
function bufferToBase64URLString(buffer) {
  const bytes = new Uint8Array(buffer);
  let str = "";
  for (const charCode of bytes) {
    str += String.fromCharCode(charCode);
  }
  const base64String = btoa(str);
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

// node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js
function base64URLStringToBuffer(base64URLString) {
  const base642 = base64URLString.replace(/-/g, "+").replace(/_/g, "/");
  const padLength = (4 - base642.length % 4) % 4;
  const padded = base642.padEnd(base642.length + padLength, "=");
  const binary = atob(padded);
  const buffer = new ArrayBuffer(binary.length);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}

// node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js
function toPublicKeyCredentialDescriptor(descriptor) {
  const { id } = descriptor;
  return {
    ...descriptor,
    id: base64URLStringToBuffer(id),
    /**
     * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer
     * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports
     * are fine to pass to WebAuthn since browsers will recognize the new value.
     */
    transports: descriptor.transports
  };
}

// node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js
function isValidDomain(hostname2) {
  return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname2 === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname2)
  );
}

// node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js
var WebAuthnError = class extends Error {
  constructor({ message, code, cause, name }) {
    super(message, { cause });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = name ?? cause.name;
    this.code = code;
  }
};

// node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js
function identifyRegistrationError({ error: error40, options }) {
  var _a5, _b, _c;
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error40.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error40
      });
    }
  } else if (error40.name === "ConstraintError") {
    if (((_a5 = publicKey.authenticatorSelection) == null ? void 0 : _a5.requireResidentKey) === true) {
      return new WebAuthnError({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: error40
      });
    } else if (
      // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
      options.mediation === "conditional" && ((_b = publicKey.authenticatorSelection) == null ? void 0 : _b.userVerification) === "required"
    ) {
      return new WebAuthnError({
        message: "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: error40
      });
    } else if (((_c = publicKey.authenticatorSelection) == null ? void 0 : _c.userVerification) === "required") {
      return new WebAuthnError({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: error40
      });
    }
  } else if (error40.name === "InvalidStateError") {
    return new WebAuthnError({
      message: "The authenticator was previously registered",
      code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
      cause: error40
    });
  } else if (error40.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error40.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error40
    });
  } else if (error40.name === "NotSupportedError") {
    const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === "public-key");
    if (validPubKeyCredParams.length === 0) {
      return new WebAuthnError({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: error40
      });
    }
    return new WebAuthnError({
      message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
      code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
      cause: error40
    });
  } else if (error40.name === "SecurityError") {
    const effectiveDomain = globalThis.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${globalThis.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error40
      });
    } else if (publicKey.rp.id !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error40
      });
    }
  } else if (error40.name === "TypeError") {
    if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
      return new WebAuthnError({
        message: "User ID was not between 1 and 64 characters",
        code: "ERROR_INVALID_USER_ID_LENGTH",
        cause: error40
      });
    }
  } else if (error40.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new credential",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error40
    });
  }
  return error40;
}

// node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js
var BaseWebAuthnAbortService = class {
  constructor() {
    Object.defineProperty(this, "controller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  createNewAbortSignal() {
    if (this.controller) {
      const abortError = new Error("Cancelling existing WebAuthn API call for new one");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
    }
    const newController = new AbortController();
    this.controller = newController;
    return newController.signal;
  }
  cancelCeremony() {
    if (this.controller) {
      const abortError = new Error("Manually cancelling existing WebAuthn API call");
      abortError.name = "AbortError";
      this.controller.abort(abortError);
      this.controller = void 0;
    }
  }
};
var WebAuthnAbortService = new BaseWebAuthnAbortService();

// node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js
var attachments = ["cross-platform", "platform"];
function toAuthenticatorAttachment(attachment) {
  if (!attachment) {
    return;
  }
  if (attachments.indexOf(attachment) < 0) {
    return;
  }
  return attachment;
}

// node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js
async function startRegistration(options) {
  var _a5;
  if (!options.optionsJSON && options.challenge) {
    console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
    options = { optionsJSON: options };
  }
  const { optionsJSON, useAutoRegister = false } = options;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  const publicKey = {
    ...optionsJSON,
    challenge: base64URLStringToBuffer(optionsJSON.challenge),
    user: {
      ...optionsJSON.user,
      id: base64URLStringToBuffer(optionsJSON.user.id)
    },
    excludeCredentials: (_a5 = optionsJSON.excludeCredentials) == null ? void 0 : _a5.map(toPublicKeyCredentialDescriptor)
  };
  const createOptions = {};
  if (useAutoRegister) {
    createOptions.mediation = "conditional";
  }
  createOptions.publicKey = publicKey;
  createOptions.signal = WebAuthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.create(createOptions);
  } catch (err) {
    throw identifyRegistrationError({ error: err, options: createOptions });
  }
  if (!credential) {
    throw new Error("Registration was not completed");
  }
  const { id, rawId, response, type } = credential;
  let transports = void 0;
  if (typeof response.getTransports === "function") {
    transports = response.getTransports();
  }
  let responsePublicKeyAlgorithm = void 0;
  if (typeof response.getPublicKeyAlgorithm === "function") {
    try {
      responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();
    } catch (error40) {
      warnOnBrokenImplementation("getPublicKeyAlgorithm()", error40);
    }
  }
  let responsePublicKey = void 0;
  if (typeof response.getPublicKey === "function") {
    try {
      const _publicKey = response.getPublicKey();
      if (_publicKey !== null) {
        responsePublicKey = bufferToBase64URLString(_publicKey);
      }
    } catch (error40) {
      warnOnBrokenImplementation("getPublicKey()", error40);
    }
  }
  let responseAuthenticatorData;
  if (typeof response.getAuthenticatorData === "function") {
    try {
      responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());
    } catch (error40) {
      warnOnBrokenImplementation("getAuthenticatorData()", error40);
    }
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      attestationObject: bufferToBase64URLString(response.attestationObject),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      transports,
      publicKeyAlgorithm: responsePublicKeyAlgorithm,
      publicKey: responsePublicKey,
      authenticatorData: responseAuthenticatorData
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
  };
}
function warnOnBrokenImplementation(methodName, cause) {
  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.
`, cause);
}

// node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js
function browserSupportsWebAuthnAutofill() {
  if (!browserSupportsWebAuthn()) {
    return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
  }
  const globalPublicKeyCredential = globalThis.PublicKeyCredential;
  if ((globalPublicKeyCredential == null ? void 0 : globalPublicKeyCredential.isConditionalMediationAvailable) === void 0) {
    return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
  }
  return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());
}
var _browserSupportsWebAuthnAutofillInternals = {
  stubThis: (value) => value
};

// node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js
function identifyAuthenticationError({ error: error40, options }) {
  const { publicKey } = options;
  if (!publicKey) {
    throw Error("options was missing required publicKey property");
  }
  if (error40.name === "AbortError") {
    if (options.signal instanceof AbortSignal) {
      return new WebAuthnError({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: error40
      });
    }
  } else if (error40.name === "NotAllowedError") {
    return new WebAuthnError({
      message: error40.message,
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: error40
    });
  } else if (error40.name === "SecurityError") {
    const effectiveDomain = globalThis.location.hostname;
    if (!isValidDomain(effectiveDomain)) {
      return new WebAuthnError({
        message: `${globalThis.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: error40
      });
    } else if (publicKey.rpId !== effectiveDomain) {
      return new WebAuthnError({
        message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
        code: "ERROR_INVALID_RP_ID",
        cause: error40
      });
    }
  } else if (error40.name === "UnknownError") {
    return new WebAuthnError({
      message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
      code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
      cause: error40
    });
  }
  return error40;
}

// node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js
async function startAuthentication(options) {
  var _a5, _b;
  if (!options.optionsJSON && options.challenge) {
    console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.");
    options = { optionsJSON: options };
  }
  const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true } = options;
  if (!browserSupportsWebAuthn()) {
    throw new Error("WebAuthn is not supported in this browser");
  }
  let allowCredentials;
  if (((_a5 = optionsJSON.allowCredentials) == null ? void 0 : _a5.length) !== 0) {
    allowCredentials = (_b = optionsJSON.allowCredentials) == null ? void 0 : _b.map(toPublicKeyCredentialDescriptor);
  }
  const publicKey = {
    ...optionsJSON,
    challenge: base64URLStringToBuffer(optionsJSON.challenge),
    allowCredentials
  };
  const getOptions = {};
  if (useBrowserAutofill) {
    if (!await browserSupportsWebAuthnAutofill()) {
      throw Error("Browser does not support WebAuthn autofill");
    }
    const eligibleInputs = document.querySelectorAll("input[autocomplete$='webauthn']");
    if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {
      throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');
    }
    getOptions.mediation = "conditional";
    publicKey.allowCredentials = [];
  }
  getOptions.publicKey = publicKey;
  getOptions.signal = WebAuthnAbortService.createNewAbortSignal();
  let credential;
  try {
    credential = await navigator.credentials.get(getOptions);
  } catch (err) {
    throw identifyAuthenticationError({ error: err, options: getOptions });
  }
  if (!credential) {
    throw new Error("Authentication was not completed");
  }
  const { id, rawId, response, type } = credential;
  let userHandle = void 0;
  if (response.userHandle) {
    userHandle = bufferToBase64URLString(response.userHandle);
  }
  return {
    id,
    rawId: bufferToBase64URLString(rawId),
    response: {
      authenticatorData: bufferToBase64URLString(response.authenticatorData),
      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),
      signature: bufferToBase64URLString(response.signature),
      userHandle
    },
    type,
    clientExtensionResults: credential.getClientExtensionResults(),
    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)
  };
}

export {
  LogLevel,
  Logger,
  assertPackageVersion,
  require_buffer,
  ceil,
  DeferredPromise,
  listenToEip6963Events,
  Eip6963ProviderSingleton,
  CustomError,
  DynamicError,
  AccessBlockedError,
  AccountExistsError,
  ChainalysisError,
  CustomFieldNotUniqueError,
  EmailAlreadyExistsError,
  EmailVerificationError,
  EmbeddedWalletException,
  EmbeddedWalletExistsError,
  ErrorCode,
  GateBlockedError,
  GetAddressCancelledError,
  InsufficientFundsError,
  InvalidEmbeddedWalletSessionKeyError,
  InvalidPhoneNumberError,
  InvalidPrimaryWalletOrConnectorError,
  MergeAccountsConfirmationError,
  MetaMaskError,
  MissingEnvironmentIdError,
  MissingPublicAddressError,
  NoAccessError,
  RequestChannelNotHandledError,
  ResponseError,
  SandboxMaximumThresholdReachedError,
  SmsVerificationError,
  SocialAccountAlreadyExistsError,
  TooManyEmailVerificationsError,
  TransactionGasCannotBeSponsoredError,
  UserHasAccountWithEmailError,
  UsernameAlreadyExistsError,
  UserRejectedRequestError,
  UserRejectedTransactionError,
  VerificationDataCollectionError,
  WalletNotDeployedError,
  WalletUsedError,
  createEventTimeline,
  formatNumberText,
  getProvidersFromWindow,
  PlatformService,
  getTLD,
  isMobile,
  isIPhone,
  isIPhone8OrEarlier,
  isIPad,
  isIOS,
  isAndroid,
  isLegacySafari,
  isSamsungBrowser,
  getAndroidVersion,
  handleMobileWalletRedirect,
  isString,
  parseIntSafe,
  parseEvmNetworks,
  pipe,
  sleep,
  FALLBACK_UNDEFINED,
  retryableFn,
  sanitizeName,
  hexToString,
  isHex,
  runSafe,
  template,
  tracing,
  PHANTOM_REDIRECT_CONNECTION_TYPE_KEY,
  PlatformEventsService,
  FetchService,
  Configuration,
  ExchangeKeyEnum,
  AuthModeEnum,
  AuthStorageEnum,
  AuthenticatorTransportProtocol,
  JwtVerifiedCredentialFormatEnum,
  ProviderEnum,
  WalletAddressType,
  EmbeddedWalletVersionEnum,
  HardwareWalletEnum,
  WalletProviderEnum,
  MfaBackupCodeAcknowledgement,
  CustomFieldType,
  KycFieldType,
  ChainEnum,
  EmbeddedWalletChainEnum,
  EmbeddedWalletProviderEnum,
  EnvironmentEnum,
  OnrampProviders,
  MFAAction,
  MFADeviceType,
  NextViewEnum,
  SignInProviderEnum,
  SocialSignInProviderEnum,
  SdkViewSectionType,
  SdkViewType,
  UnprocessableEntityErrorCode,
  UserFieldsCheckEnum,
  VerifyRequestFromJSON,
  SDKApi,
  DynamicJwtFromJSON,
  SocialOAuthErrorCode,
  Oauth2Service,
  createStorageService,
  StorageService,
  applyPostfixToStorageService,
  getEnvVarWithFallback,
  walletConnectorEvents,
  logger6 as logger,
  ProviderLookup,
  setChainInfoOverrides,
  getChainInfo,
  getChainInfoWithOverrides,
  isEmailOTPWalletConnector,
  isEmailWalletConnector,
  isTurnkeyWalletConnector,
  isSameAddress,
  isSocialWalletConnector,
  getWalletConnectorByKey,
  getDeepLink,
  performPlatformSpecificConnectionMethod,
  isEmbeddedConnector,
  isMagicConnector,
  isBloctoConnector,
  isPasskeyWalletConnector,
  isAccountAbstractionConnector,
  isBitcoinConnector,
  isHardwareWalletConnector,
  eventListenerHandlers,
  isPhantomRedirectConnector,
  getRpcUrlForChain,
  isWalletConnectConnector,
  isSendBalanceWalletConnector,
  isSessionKeyCompatibleWalletConnector,
  isSessionKeyCompatibleWallet,
  useWalletBookContext,
  getIconicSpriteUrl,
  BraveIcon,
  ChromeIcon,
  EdgeIcon,
  FirefoxIcon,
  OperaIcon,
  SafariIcon,
  AlgorandIcon,
  AptosIcon,
  BitcoinIcon,
  CosmosIcon,
  EclipseIcon,
  EthereumIcon,
  FlowIcon,
  SolanaIcon,
  SparkIcon,
  StarknetIcon,
  SuiIcon,
  TronIcon,
  DiscordIcon,
  HelpdeskIcon,
  SlackIcon,
  TwitterIcon,
  SignInWithEmailIcon,
  WalletConnectIcon,
  AppleIcon,
  AndroidIcon,
  CaptchaWaveIcon,
  UserProfileIcon,
  findSocialIcon,
  SocialIcon,
  findWalletBookWallet,
  getWalletBookCdnUrl,
  findWalletGroupOverride,
  isWalletBookPopulated,
  string2 as string,
  number2 as number,
  date2 as date,
  array,
  object,
  record,
  _enum2 as _enum,
  optional,
  nullable,
  custom,
  useWalletBookCdn,
  WalletIcon,
  WalletBookContextProvider,
  BrandIcon,
  isConnectorEventSupported,
  getWalletLinks,
  isDynamicWaasConnector,
  getWalletProvider,
  Wallet,
  WalletConnectorBase,
  ProviderChain,
  ChainRpcProviders,
  bufferToBase64URLString,
  browserSupportsWebAuthn,
  startRegistration,
  startAuthentication
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
//# sourceMappingURL=chunk-QVA33I52.js.map
